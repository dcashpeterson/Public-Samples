"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var SPKillSwitch_1 = tslib_1.__importDefault(require("./SPKillSwitch"));
// This character is allowed to go unencoded in a URL and commonly represents "NOT" logic in boolean algebra
// Reference: http://www.faqs.org/rfcs/rfc1738.html
var DISABLED_FLIGHT_PREFIX = '!';
// Debug flight id. This flight is only enabled for internal Microsoft tenants like the eDog tenant. This flight
// is used for debug level testing and should not be enabled for PROD customer tenants due security reasons.
// Enabling this flight on PROD customer tenants can deem them vulnerable to script injection.
var SPFX_DEBUG_FLIGHT_ID = 205;
// Debug flight id. This flight is only enabled for internal Microsoft tenants like the eDog tenant. This flight
// is used for debug level testing and should not be enabled for PROD customer tenants due security reasons.
// Enabling this flight on PROD customer tenants can deem them vulnerable to script injection. This flight is
// intended to be used as a replacement for the SPFX_DEBUG_FLIGHT_ID flight.
var CLIENT_DEBUG_FEATURE_OVERRIDES_FLIGHT_ID = 60763;
/**
 * NOT FOR USE BY THIRD PARTY DEVELOPERS
 *
 * This class supports Microsoft's internal deployment workflow.
 * For more information, see https://microsoft.sharepoint.com/teams/odsp/_layouts/OneNote.aspx
 * ?id=/teams/odsp/Shared%20Documents/MI-6%20Team/MI-6%20Team/Global/SPO%20Flighting
 *
 * @privateRemarks
 * SPFlight is currently being reexported by sp-client-base.  For GA, this will be sorted out by
 * VSO 278235 which will move this class back into sp-client-base (sp-core-library).
 *
 * @internal
 */
var SPFlight = /** @class */ (function () {
    function SPFlight() {
    }
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    SPFlight.initialize = function (flights) {
        this._isInitialized = true;
        this._enabledFlightsMap = flights || [];
        this._forceEnabledFlights = [];
        this._forceDisabledFlights = [];
    };
    Object.defineProperty(SPFlight, "isDebugFlightEnabled", {
        /**
         * Return true if the debug flight is enabled.
         */
        get: function () {
            return (SPFlight.isEnabled(SPFX_DEBUG_FLIGHT_ID) ||
                SPFlight.isEnabled(CLIENT_DEBUG_FEATURE_OVERRIDES_FLIGHT_ID) ||
                (SPKillSwitch_1.default.isActivated('f5a6830a-99fa-4cc4-8361-62d32a5805f3'
                /* DO NOT GRADUATE THIS KILLSWITCH.  It is for turning on debugging on secure broker in SPDF */
                ) &&
                    window.location.host.toLowerCase() === 'securebroker.sharepointonline.com'));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    SPFlight.setDebugFlights = function (debugFlights) {
        if (!this._isInitialized) {
            throw new Error("Flights are not initialized. Can't set debug flights.");
        }
        // If allowQueryFlights then parse the 'debugFlights' query string parameter for any flights to enable for
        // the session. 'debugFlights' is expected to be a comma separated list. We store the flights as given
        // to avoid needing to do any bitmask conversions during translation and just check the
        // feature ID directly.
        if (debugFlights && debugFlights.length > 0) {
            try {
                var debugFlightStrings = debugFlights.split(',');
                this._forceEnabledFlights = debugFlightStrings
                    .filter(function (value) { return value[0] !== DISABLED_FLIGHT_PREFIX; })
                    .map(function (value) {
                    return parseInt(value, 10);
                })
                    .filter(function (value) { return !isNaN(value); });
                this._forceDisabledFlights = debugFlightStrings
                    .filter(function (value) { return value[0] === DISABLED_FLIGHT_PREFIX; })
                    .map(function (value) {
                    return parseInt(value.slice(1), 10);
                })
                    .filter(function (value) { return !isNaN(value); });
                // eslint-disable-next-line no-console
                console.log("Debug flights are enabled.");
                if (this._forceEnabledFlights.length > 0) {
                    // eslint-disable-next-line no-console
                    console.log("Enabled flights: ".concat(this._forceEnabledFlights.join(', ')));
                }
                if (this._forceDisabledFlights.length > 0) {
                    // eslint-disable-next-line no-console
                    console.log("Disabled flights: ".concat(this._forceDisabledFlights.join(', ')));
                }
            }
            catch (error) {
                // If an exception is thrown, we'll log the error and clear debug flights
                this._forceEnabledFlights = [];
                this._forceDisabledFlights = [];
                // eslint-disable-next-line no-console
                console.log("Error parsing debugFlights query string parameter: ".concat(error));
            }
        }
        this._validateDebugFlights();
    };
    /**
     * NOT FOR USE BY THIRD PARTY DEVELOPERS
     *
     * This function will determine if a flight is enabled in the global list.
     */
    SPFlight.isEnabled = function (flight) {
        if (!this._isInitialized && !DEPRECATED_UNIT_TEST) {
            throw new Error("Flights are not initialized. Flight requested: ".concat(flight));
        }
        if (!flight || flight < 0) {
            return false;
        }
        // Debug flights override existing flight information
        if (this._forceEnabledFlights.indexOf(flight) !== -1) {
            return true;
        }
        if (this._forceDisabledFlights.indexOf(flight) !== -1) {
            return false;
        }
        if (flight >= 60000) {
            // 1. Flights currently process 2 different range sets 1. [0 - 2000]
            // and 2. [60000 - 89999] that are bit encoded as a bitarray.
            // 2. A. Flights from 0 - 2000 are encoded in bit array position
            // 0 - 2000.
            // 2. B. Flights from 60000 onwards are encoded in bit array position
            // 2001 onwards. (As the preceding range has taken up slots 0 - 2000)
            // 3. The bit array is integer encoded and sent as a javascript
            // snippet to the client page.
            // 4. This SPFlight class needs to determine the current position of
            // the flight based on the flightId in the javascript integer snippet.
            // 5. Here since all flights eventually are a single stream of bits
            // from 0 onwards. We must map the new flight range to get the right
            // index position. So RangeSet 1 [0 - 2000] flightIds maps to [0 - 2000]
            // indices in the bit array while RangeSet 2 [60000+=] flightIds
            // maps to [2001+=] indices in the bit array. So 2000 here
            // is used to indicate the previous indices which are already
            // occupied by flightIds [0 - 2000]. 1 is because arrays are 0 index
            // counters. So if the bit array count is 2000 there are actually
            // 2001 flights evauluated.
            flight = flight - 60000 + 2000 + 1; // This gets the correct flights
            // index position for flights greater than 60000.
        }
        // Determines which set of bitMasks should be used to determine if a flight is enabled.
        var enabledFlightsIndex = flight >> 5;
        if (enabledFlightsIndex < 0 || enabledFlightsIndex >= this._enabledFlightsMap.length) {
            return false;
        }
        // Masks the flight number and determines if the flight is turned on within that mask.
        // eslint-disable-next-line no-bitwise
        var bitMask = 1 << (flight & 31);
        // eslint-disable-next-line no-bitwise
        return (this._enabledFlightsMap[enabledFlightsIndex] & bitMask) !== 0;
    };
    SPFlight._validateDebugFlights = function () {
        var debugFlightsSet = new Set(this._forceEnabledFlights.concat(this._forceDisabledFlights));
        // If size is smaller than the sum of its parts, it means that there is a duplicate number in both arrays
        if (debugFlightsSet.size < this._forceEnabledFlights.length + this._forceDisabledFlights.length) {
            throw new Error('There are flights that are forced to be both enabled and disabled');
        }
    };
    SPFlight._isInitialized = false;
    /**
     * List of SharePoint flight feature IDs that are forced to be enabled
     * through the debugFlights query string parameter.
     */
    SPFlight._forceEnabledFlights = [];
    /**
     * List of SharePoint flight feature IDs that are forced to be disabled
     * through the debugFlights query string parameter.
     */
    SPFlight._forceDisabledFlights = [];
    /**
     * Array of bits (indexed by flight number, where 1 means that flight is enabled).
     */
    SPFlight._enabledFlightsMap = [];
    return SPFlight;
}());
exports.default = SPFlight;
//# sourceMappingURL=SPFlight.js.map