"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isElementFocusableChildOf = exports.getFocusableDescendants = exports.getFirstFocusableChild = exports.isElementFocusable = exports.getFocusableChildren = exports.isKey = exports.KeyCodes = void 0;
var KeyCodes;
(function (KeyCodes) {
    KeyCodes[KeyCodes["Enter"] = 13] = "Enter";
    KeyCodes[KeyCodes["Escape"] = 27] = "Escape";
    KeyCodes[KeyCodes["Tab"] = 9] = "Tab";
    KeyCodes[KeyCodes["F10"] = 121] = "F10";
    KeyCodes[KeyCodes["P"] = 80] = "P";
})(KeyCodes = exports.KeyCodes || (exports.KeyCodes = {}));
function isKey(keyCode, e, allowAlt, allowCtrl, allowShift) {
    if (allowAlt === void 0) { allowAlt = false; }
    if (allowCtrl === void 0) { allowCtrl = false; }
    if (allowShift === void 0) { allowShift = false; }
    return (e.keyCode === keyCode &&
        ((allowAlt && e.altKey) || (!allowAlt && !e.altKey)) &&
        ((allowCtrl && e.ctrlKey) || (!allowCtrl && !e.ctrlKey)) &&
        ((allowShift && e.shiftKey) || (!allowShift && !e.shiftKey)));
}
exports.isKey = isKey;
function getFocusableChildren(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var children = [];
    for (var _i = 0, _a = getFocusableDescendants(elem, ignoreTabIndex); _i < _a.length; _i++) {
        var descendant = _a[_i];
        if (isElementFocusableChildOf(descendant, elem)) {
            children.push(descendant);
        }
    }
    return children;
}
exports.getFocusableChildren = getFocusableChildren;
function isElementFocusable(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var tagName = elem.tagName.toLowerCase();
    if (elem && !elem.hidden && elem.offsetParent && window.getComputedStyle(elem).display !== 'none') {
        var hasTabIndex = elem.hasAttribute('tabindex');
        // If TabIndex exists, then we can assume elem.getAttribute is not null
        var tabindex = hasTabIndex ? parseInt(elem.getAttribute('tabindex'), 10) : NaN;
        if (!ignoreTabIndex && hasTabIndex && tabindex < 0) {
            return false;
        }
        if ((tagName === 'a' && !!elem.href) || elem.isContentEditable) {
            return true;
        }
        if ((tagName === 'button' || tagName === 'input' || tagName === 'select' || tagName === 'textarea') &&
            !elem.disabled) {
            return true;
        }
        /**
         * There are few cases like office-ui-fabric-react's dropdown control, which do not
         * use the conventional HTML elements to create dropdown. Instead they are using a
         * data attribute 'is-focusable' and making it focusable. Hence to respect those elements
         * added this check. Check this only when the 'ignoreTabIndex' is true, this is because when
         * user doesn't want to ignore tabindexes then tabindex will get preference over this attribute.
         */
        if (ignoreTabIndex && elem.getAttribute('data-is-focusable') === 'true') {
            return true;
        }
        if (!ignoreTabIndex && hasTabIndex && tabindex > -1) {
            return true;
        }
    }
    return false;
}
exports.isElementFocusable = isElementFocusable;
function queryFocusableSelector(elem) {
    var selector = "button,input,textarea,select,a[href]:not([href='']),[tabindex],[contenteditable='true'], [data-is-focusable='true']";
    var nodes = elem.querySelectorAll(selector);
    return Array.prototype.slice.call(nodes);
}
function getFirstFocusableChild(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var elements = queryFocusableSelector(elem);
    var focusableElements = elements.filter(function (element) {
        return isElementFocusable(element, ignoreTabIndex);
    });
    // If the first focusable node is a radio input, we focus on the first checked one.
    // If there is no checked radio input, the first radio input will be focused.
    var firstFocusableElement = focusableElements[0];
    if (firstFocusableElement instanceof HTMLInputElement && firstFocusableElement.type === 'radio') {
        var results = focusableElements.filter(function (element) {
            return element instanceof HTMLInputElement && element.name === firstFocusableElement.name && element.checked;
        });
        return results[0] || firstFocusableElement;
    }
    return firstFocusableElement;
}
exports.getFirstFocusableChild = getFirstFocusableChild;
function getFocusableDescendants(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var descendants = [];
    var nodes = queryFocusableSelector(elem);
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (isElementFocusable(node, ignoreTabIndex)) {
            descendants.push(node);
        }
    }
    return descendants;
}
exports.getFocusableDescendants = getFocusableDescendants;
function isElementFocusableChildOf(elem, ancestor) {
    var parent = elem.parentElement;
    while (parent && parent.tagName !== 'BODY') {
        if (parent.isEqualNode(ancestor)) {
            return true;
        }
        if (isElementFocusable(parent)) {
            break;
        }
        parent = parent.parentElement;
    }
    return false;
}
exports.isElementFocusableChildOf = isElementFocusableChildOf;
//# sourceMappingURL=CanvasA11y.js.map