"use strict";
/**
 * file uploadFilesTots
 * Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Uploads a list of files to an Azure Blob Service instance
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureUploader = void 0;
const storage_blob_1 = require("@azure/storage-blob");
const node_core_library_1 = require("@rushstack/node-core-library");
const mime = __importStar(require("mime"));
const devDeployUtilities_1 = require("./devDeployUtilities");
const ALREADY_EXISTS_STATUS_CODE = 409;
/**
 * @internal
 */
class AzureUploader {
    constructor(options) {
        const sasOptions = options;
        const keyOptions = options;
        const storageAccountUrl = (0, devDeployUtilities_1.getStorageAccountUrl)(options.storageAccountName);
        let blobServiceClient;
        if (sasOptions.sas && keyOptions.storageKey) {
            throw new Error('Either a SAS or a storage key must be provided, but not both.');
        }
        else if (sasOptions.sas) {
            blobServiceClient = storage_blob_1.BlobServiceClient.fromConnectionString(`BlobEndpoint=${storageAccountUrl};SharedAccessSignature=${sasOptions.sas}`);
        }
        else if (keyOptions.storageKey) {
            const keyCredential = new storage_blob_1.StorageSharedKeyCredential(options.storageAccountName, keyOptions.storageKey);
            blobServiceClient = new storage_blob_1.BlobServiceClient(storageAccountUrl, keyCredential);
        }
        else {
            throw new Error('Either a SAS or a storage key must be provided.');
        }
        this._containerClient = blobServiceClient.getContainerClient(options.containerName);
    }
    /**
     * Upload file to Azure
     */
    async uploadFileToAzureAsync(terminal, localFilename, serverFilename, blobHeaders) {
        // Manually set contentType, otherwise it will be 'application/octet-stream'
        blobHeaders = {
            ...blobHeaders,
            // Use server file name in case of writing the same blob to different file paths
            blobContentType: mime.getType(serverFilename) || undefined
        };
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.uploadFile(localFilename, { blobHTTPHeaders: blobHeaders });
            terminal === null || terminal === void 0 ? void 0 : terminal.writeLine(`Uploaded file: ${serverFilename}`);
        }
        catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal === null || terminal === void 0 ? void 0 : terminal.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload file "${serverFilename}" from "${localFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    async uploadToAzureAsync(terminal, contents, serverFilename, blobMetadata) {
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.upload(contents, contents.length, { metadata: blobMetadata });
            terminal.writeLine(`Uploaded file: ${serverFilename}`);
        }
        catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload data to "${serverFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    /**
     * Upload files to Azure
     */
    async uploadFilesToAzureAsync(terminal, files, maxParallelism = AzureUploader.DEFAULT_AZURE_MAX_PARALLELISM, maxRetries = AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES, retryDelayMs = AzureUploader.DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS, onFileUploaded) {
        terminal.writeLine(`Uploading ${files.length} files to Azure...`);
        const childTerminal = onFileUploaded ? undefined : terminal;
        await node_core_library_1.Async.forEachAsync(files, async (file) => {
            await node_core_library_1.Async.runWithRetriesAsync({
                action: () => this.uploadFileToAzureAsync(childTerminal, file.localPath, file.azurePath, file.blobHeaders),
                maxRetries,
                retryDelayMs
            });
            onFileUploaded === null || onFileUploaded === void 0 ? void 0 : onFileUploaded(file.azurePath);
        }, { concurrency: maxParallelism });
        terminal.writeLine(`Finished uploading.`);
    }
    async ensureContainerExistsAsync(terminal) {
        try {
            await this._containerClient.create({ access: 'blob' });
            terminal.writeLine(`Created container: ${this._containerClient.containerName}`);
        }
        catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                return;
            }
            throw new Error(`Unable to create container ${e} ${e.statusCode} ${e.code}`);
        }
    }
    _getBlockBlobClient(serverFilename) {
        const blobClient = this._containerClient.getBlobClient(serverFilename);
        const blockBlobClient = blobClient.getBlockBlobClient();
        return blockBlobClient;
    }
}
exports.AzureUploader = AzureUploader;
AzureUploader.DEFAULT_AZURE_MAX_PARALLELISM = 20;
AzureUploader.DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS = 5000;
AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES = 10;
//# sourceMappingURL=AzureUploader.js.map