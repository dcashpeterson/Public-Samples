"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsalMonitor = void 0;
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var AadKillSwitches_1 = require("../../AadKillSwitches");
/**
 * Class used to wrap _QosMonitor.
 *
 * This class provides the same interface as _QosMonitor and adds no additional
 * functionality, but can be optionally configured to skip logging.
 *
 * Since the MSAL Token Providers may wish to skip logging for any given
 * request, this wrapper can be used in place of _QosMonitor. This simplifies
 * logging since you no longer need to check if the monitor is defined or if
 * you need to skip logging before writing the monitor.
 *
 * To skip logging, set the optional constructor parameter (shouldSkipLogging)
 * to true.
 *
 * @internal
 */
/* tslint:disable:no-any */
var MsalMonitor = /** @class */ (function () {
    function MsalMonitor(scenarioName, shouldSkipLogging) {
        if (shouldSkipLogging === void 0) { shouldSkipLogging = false; }
        this._shouldSkipLogging = shouldSkipLogging;
        if (!shouldSkipLogging) {
            this._qosMonitor = new sp_diagnostics_1._QosMonitor(scenarioName);
        }
    }
    /**
     * Same as calling _QosMonitor.writeSuccess().
     *
     * If shouldSkipLogging is set to true, this method will do nothing.
     */
    MsalMonitor.prototype.writeSuccess = function (extraData) {
        var _a;
        if (this._shouldSkipLogging) {
            return;
        }
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            this._updatePageEndVisibility(extraData);
        }
        (_a = this._qosMonitor) === null || _a === void 0 ? void 0 : _a.writeSuccess(extraData);
    };
    /**
     * Same as calling _QosMonitor.writeExpectedFailure().
     *
     * If shouldSkipLogging is set to true, this method will do nothing.
     */
    MsalMonitor.prototype.writeExpectedFailure = function (tagNameSuffix, error, extraData) {
        var _a;
        if (this._shouldSkipLogging) {
            return;
        }
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            this._updatePageEndVisibility(extraData);
        }
        (_a = this._qosMonitor) === null || _a === void 0 ? void 0 : _a.writeExpectedFailure(tagNameSuffix, error, extraData);
    };
    /**
     * Same as calling _QosMonitor.writeUnexpectedFailure().
     *
     * If shouldSkipLogging is set to true, this method will do nothing.
     */
    MsalMonitor.prototype.writeUnexpectedFailure = function (tagNameSuffix, error, extraData) {
        var _a, _b;
        if (this._shouldSkipLogging) {
            return;
        }
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            this._updatePageEndVisibility(extraData);
        }
        var browserInfo = sp_core_library_1._BrowserDetection.getBrowserInformation();
        if ((browserInfo === null || browserInfo === void 0 ? void 0 : browserInfo.browser) === sp_core_library_1._Browser.IE) {
            (_a = this._qosMonitor) === null || _a === void 0 ? void 0 : _a.writeExpectedFailure(tagNameSuffix, error, extraData);
        }
        else {
            (_b = this._qosMonitor) === null || _b === void 0 ? void 0 : _b.writeUnexpectedFailure(tagNameSuffix, error, extraData);
        }
    };
    MsalMonitor.prototype._updatePageEndVisibility = function (extraData) {
        if (extraData) {
            extraData.isPageVisibleEnd = document.visibilityState === 'visible';
        }
    };
    return MsalMonitor;
}());
exports.MsalMonitor = MsalMonitor;
/* tslint:enable:no-any */
//# sourceMappingURL=MsalMonitor.js.map