"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var ReactDOM = tslib_1.__importStar(require("react-dom"));
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var Strings_resx_1 = tslib_1.__importDefault(require("../loc/Strings.resx"));
var PropertyPaneController_module_scss_1 = tslib_1.__importDefault(require("./PropertyPaneController.module.scss"));
var Flights_1 = require("../common/Flights");
var KillSwitches_1 = require("../common/KillSwitches");
var MultiColumnHelper_1 = require("../utils/MultiColumnHelper");
/**
 * Property pane animation timeout (in milliseconds).
 */
var ANIMATION_TIMEOUT = 400;
/**
 * Property pane configuration complete timeout for Reactive components (in milliseconds).
 */
var CONFIGURATION_COMPLETE_TIMEOUT = 5000;
/**
 * Property pane container id.
 */
var PROPERTY_PANE_CONTAINER_ID = 'spPropertyPaneContainer';
/**
 * Property pane container id.
 */
var PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID = 'spPropertyPaneContainerNoFlexbox';
/**
 * Class which manages all the interactions between property pane and the property pane consumers, such as web parts.
 *
 * @internal
 */
var PropertyPaneController = /** @class */ (function () {
    /**
     * Instantiates the PropertyPaneController object.
     *
     * NOTE: [TODO] When the killswitch 'ConsumePropertyPaneControllerFromServiceScope'
     * is graduated remove this constructor and make the _constructor as the constructor
     * and still keep it as private.
     */
    function PropertyPaneController() {
        /*
         * Property pane controller log source
         */
        this._logSource = sp_diagnostics_1._LogSource.create('PropertyPaneController');
        /**
         * Dictionary of all the registered property pane consumers.
         */
        this._consumers = new Map();
        /**
         * The set of listeners for propertyPane field changes
         */
        this._onPropertyPaneFieldChangeListeners = new Map();
        this._constructor();
    }
    /**
     * Adds a specified callback for property pane field changed events.
     * @param instanceId - the specified instanceId
     * @param callback - the specified callback function
     * @returns returns a function to unregister the callback function
     */
    PropertyPaneController.prototype.registerOnPropertyPaneFieldChangedListener = function (instanceId, callback) {
        var _this = this;
        var currentListeners = this._onPropertyPaneFieldChangeListeners.get(instanceId) || new Set();
        currentListeners.add(callback);
        this._onPropertyPaneFieldChangeListeners.set(instanceId, currentListeners);
        return function () {
            // clean up the listeners for the specified instanceId
            currentListeners.delete(callback);
            // clean up the map if there are no more listeners for the specified instanceId
            if (currentListeners.size === 0) {
                _this._onPropertyPaneFieldChangeListeners.delete(instanceId);
            }
        };
    };
    /**
     * Registers a property pane consumer with the property pane controller.
     *
     * @param instanceId - Instance id of the consumer.
     * @param consumer - Property pane consume to be registered.
     */
    PropertyPaneController.prototype.registerConsumer = function (instanceId, consumer) {
        sp_core_library_1.Validate.isNonemptyString(instanceId, 'instanceId');
        sp_core_library_1.Validate.isNotNullOrUndefined(consumer, 'consumer');
        this._consumers.set(instanceId, consumer);
    };
    /**
     * Returns true if the passed in instance Id, is a registered consumer.
     * @param instanceId - Instance id of the consumer.
     */
    PropertyPaneController.prototype.isConsumerRegistered = function (instanceId) {
        return this._consumers.has(instanceId);
    };
    Object.defineProperty(PropertyPaneController.prototype, "currentlyConfiguredConsumerId", {
        /**
         * Get the currently configured consumer's instance Id
         */
        get: function () {
            return this._currentlyConfiguredConsumerId;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * API to request an action to be performed on the property pane. This helps in configuring a SharePoint component.
     * The inbuilt property pane is used for the configuration, with the below conditions:
     *
     *   - propertyPaneAction is Open and then open the property pane.
     *   - propertyPaneAction is Close and then close the property pane.
     *   - propertyPaneAction is Toggle and the property pane is closed: in this case we open the property pane and
     *       start the configuration process.
     *       Example - This happens when web part configure button is clicked.
     *   - propertyPaneAction is Toggle and the property pane is open: in this case, if the incoming consumer id
     *       is different than the one being currently configured, we keep the property pane open
     *       and change the active consumer being configured.
     *   - propertyPaneAction is Default and the property pane is closed: do nothing
     *   - propertyPaneAction is Default and the property pane is opened: change the property pane to display the
     *       settings of the newly selected consumer.
     *       Example - This happens when the user navigates between property pane consumers (ex: web parts).
     *
     * @param toBeConfiguredConsumerId - instance id of the consumer.
     * @param propertyPaneAction - indicates in what state the property pane should be.
     * @param renderedByWebPart - is the property pane rendered by a web part and not by Canvas or any other source.
     * @param context - additional data passed by the consumer, to be sent back to the same webpart
     */
    PropertyPaneController.prototype.requestAction = function (toBeConfiguredConsumerId, propertyPaneAction, renderedByWebPart, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    context) {
        if (propertyPaneAction === void 0) { propertyPaneAction = 'Default'; }
        /**
         * It's a no operation scenario if a consumer is asking to refresh the property pane contents by invoking
         * refreshPropertyPane api, while some other consumer is being configured.
         */
        var noOp = renderedByWebPart &&
            propertyPaneAction === 'Refresh' &&
            toBeConfiguredConsumerId !== this._currentlyConfiguredConsumerId;
        if (!noOp) {
            // 'id' can be 'undefined'. It happens when user selects RTE.
            // When 'id' is 'undefined' then 'wp' will be 'undefined'. In that case we render the empty property pane.
            var toBeConfiguredConsumer = this._tryGetConsumer(toBeConfiguredConsumerId);
            this._setPropertyPaneDOMElements();
            /**
             * A variable indicating, if the property pane will open or not. The flag is set to true when the pane is NOT
             * open and the requested propertyPaneAction is either Open or Toggle.
             */
            var paneWillOpen = !this._isOpen && (propertyPaneAction === 'Open' || propertyPaneAction === 'Toggle');
            var activeComponentChanged = false;
            /**
             * Fire the 'ActiveWebPartChanged' event when the configuring consumer changes on the property pane.
             */
            if (toBeConfiguredConsumerId &&
                this._currentlyConfiguredConsumerId &&
                (toBeConfiguredConsumerId !== this._currentlyConfiguredConsumerId || paneWillOpen)) {
                activeComponentChanged = true;
                /**
                 * Premptively asking consumer(if exists, consumer can be undefined for canvas toolbox hint.)
                 * to load async resources for its property pane before the data
                 * is requested via _getPropertyPaneData call.
                 * We make this call when the active webpart has changed and the property pane is shown.
                 */
                if (toBeConfiguredConsumer && (this._isOpen || paneWillOpen)) {
                    toBeConfiguredConsumer._loadPropertyPaneResources();
                }
                this._fireConfigurationEvent(toBeConfiguredConsumerId, 'ActiveWebPartChanged');
            }
            if (propertyPaneAction !== 'Refresh') {
                /**
                 * When shifting from internal item edit to the overall component edit, canvas sends in Toggle
                 * as the propertyPaneAction. However, to keep the property pane open and shift to the overall
                 * component configuration we will ignore the incoming propertypanestate and just refreshes it.
                 */
                if (propertyPaneAction === 'Toggle') {
                    var internalToOverallComponentEdit = !!this._isPaneRenderedByWebPart !== !!renderedByWebPart;
                    if (!activeComponentChanged && internalToOverallComponentEdit) {
                        propertyPaneAction = 'Refresh';
                    }
                }
                /**
                 * Update the '_isPaneRenderedByWebPart' variable only in the NON 'Refresh' scenarios.
                 * On 'Refresh' we have decided NOT to update the '_isPaneRenderedByWebPart'.
                 */
                this._isPaneRenderedByWebPart = !!renderedByWebPart;
            }
            this._executeAction(toBeConfiguredConsumer, toBeConfiguredConsumerId, propertyPaneAction, context);
            this._currentlyConfiguredConsumerId = toBeConfiguredConsumerId;
        }
        else if (propertyPaneAction === 'Refresh' && !(0, KillSwitches_1.isActivateActionOnRefreshKSActivated)()) {
            this._executeAction(this._tryGetConsumer(toBeConfiguredConsumerId), toBeConfiguredConsumerId, propertyPaneAction, context);
        }
        else {
            sp_diagnostics_1._TraceLogger.logVerbose(this._logSource, sp_core_library_1.Text.format(Strings_resx_1.default.NoOpOnRefreshPropertyPaneText, toBeConfiguredConsumerId));
        }
    };
    /**
     * Returns true if the property pane is rendered by a consumer,example web part, RTE etc.,
     * and not by the host, example canvas.
     * A component becomes consumer if it implements IPropertyPaneConsumer.
     */
    PropertyPaneController.prototype.isRenderedByConsumer = function () {
        return !!this._isPaneRenderedByWebPart;
    };
    /**
     * Returns true if the property pane is open.
     */
    PropertyPaneController.prototype.isOpen = function () {
        return !!this._isOpen;
    };
    /**
     * Empty out the property pane when the web part being configured is deleted from the page.
     *
     * @param id - Instance id of the consumer.
     */
    PropertyPaneController.prototype.onConsumerDelete = function (id) {
        sp_core_library_1.Validate.isNonemptyString(id, 'id');
        if (id === this._currentlyConfiguredConsumerId) {
            if (this._isOpen) {
                this._renderPropertyPane(undefined, true);
            }
            this._currentlyConfiguredConsumerId = undefined;
        }
        // Remove consumer from map on dispose to prevent memory leak.
        this._consumers.delete(id);
    };
    /**
     * Allows the property panes title to be overridden.
     *
     * @param topControl - React element to be rendered at the top of the property pane.
     * @param title - Title of the property pane.
     *
     * @internal
     */
    PropertyPaneController.prototype._setAppPagePropertyPaneTopData = function (topControl, title) {
        this._topControl = topControl;
        this._title = title;
    };
    /**
     * Causes the property pane to be rendered narrowly (320px vs 340px).
     *
     * @internal
     */
    PropertyPaneController.prototype._setPropertyPaneToNarrowRender = function (narrow) {
        this._narrowRender = narrow;
    };
    /**
     * Method to get a consumer instance.
     */
    PropertyPaneController.prototype.getConsumer = function (id) {
        return this._tryGetConsumer(id);
    };
    Object.defineProperty(PropertyPaneController.prototype, "propertyPaneHost", {
        /**
         *  Gets _propertyPaneHost property.
         */
        get: function () {
            return this._propertyPaneHost;
        },
        set: function (host) {
            this._propertyPaneHost = host;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Instantiates the PropertyPaneController object.
     *
     * The constructor is private since this service should always be constructed
     * via the ServiceScope key.
     *
     * NOTE: When the killswitch 'ConsumePropertyPaneControllerFromServiceScope'
     * is graduated, this method will become the actual constructor.
     */
    PropertyPaneController.prototype._constructor = function () {
        this._propertyPaneContainerId =
            sp_core_library_1.Environment.type !== sp_core_library_1.EnvironmentType.ClassicSharePoint
                ? PROPERTY_PANE_CONTAINER_ID
                : PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID;
        // method bindings
        this._onPropertyPaneFieldChanged = this._onPropertyPaneFieldChanged.bind(this);
        this._onConfigurationEvent = this._onConfigurationEvent.bind(this);
        this._fireConfigurationEvent = this._fireConfigurationEvent.bind(this);
    };
    /**
     * Executes the request action on the property pane if appropriate.
     *
     * @param toBeConfiguredConsumer - component to be configured.
     * @param toBeConfiguredConsumerInstanceId - Instance id of the component to be configured.
     * @param propertyPaneAction - Action to be executed on the property pane.
     */
    PropertyPaneController.prototype._executeAction = function (toBeConfiguredConsumer, toBeConfiguredConsumerInstanceId, propertyPaneAction, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    context) {
        switch (propertyPaneAction) {
            case 'Open':
            case 'OpenDetails':
                /**
                 * Inside the '_renderPropertyPane' the value of the variable '_isOpen' could be modified.
                 * Hence, to keep the before state of it, introducing 'paneOpenBeforeRender'.
                 */
                var paneOpenBeforeRender = !!this._isOpen;
                if ((0, KillSwitches_1.isPropertyPaneHostKSActivated)() ||
                    !this._propertyPaneHost ||
                    this._propertyPaneHost.canOpen(toBeConfiguredConsumerInstanceId)) {
                    this._renderPropertyPane(toBeConfiguredConsumer, true, true, propertyPaneAction === 'OpenDetails', context);
                    this._showPropertyPane();
                    /**
                     * returns early so that the post toggle events are not fired since the property pane is
                     * not being rendered
                     */
                }
                else {
                    sp_diagnostics_1._TraceLogger.logVerbose(this._logSource, sp_core_library_1.Text.format('Early Return on _executeAction OpenDetails due to Content Panel {0}', toBeConfiguredConsumer));
                    return;
                }
                /**
                 * If pane is 'open' before '_renderPropertyPane' is called that means property pane did not toggle.
                 * Hence no events were fired. So fire the events explicitly.
                 */
                if (paneOpenBeforeRender) {
                    this._fireNoToggleConfigurationEvents(toBeConfiguredConsumerInstanceId);
                }
                else {
                    this._firePostToggleConfigurationEvents();
                }
                break;
            // Property pane should close.
            case 'Close':
                if (this._isOpen) {
                    this._hidePropertyPane();
                    this._firePostToggleConfigurationEvents();
                }
                break;
            // Property pane should toggle i.e., if it's open, close it else open it.
            case 'Toggle':
                if (this._isOpen) {
                    this._hidePropertyPane();
                }
                else {
                    if ((0, KillSwitches_1.isPropertyPaneHostKSActivated)() ||
                        !this._propertyPaneHost ||
                        this._propertyPaneHost.canOpen(toBeConfiguredConsumerInstanceId)) {
                        this._renderPropertyPane(toBeConfiguredConsumer, true, true);
                        this._showPropertyPane();
                        /**
                         * returns early so that the post toggle events are not fired since the property pane is
                         * not being rendered
                         */
                    }
                    else {
                        sp_diagnostics_1._TraceLogger.logVerbose(this._logSource, sp_core_library_1.Text.format('Early Return on _executeAction Toggle due to Content Panel {0}', toBeConfiguredConsumer));
                        return;
                    }
                }
                // Fire the post toggle events.
                this._firePostToggleConfigurationEvents();
                break;
            // Keep the property pane open if it's already open, else no-op.
            case 'Default':
                if (this._isOpen) {
                    // New component triggered the 'openPropertyPane' and the property pane is open, so will keep it open.
                    // This results in NO toggle. So fire the events specific to this condition.
                    this._fireNoToggleConfigurationEvents(toBeConfiguredConsumerInstanceId);
                    /*
                    Commenting out this block since the original code always evaluated to true. There's a work item where
                    we should diverge the logic at some point. Leaving this here for record keeping.
          
                    // If current opened property pane is the right property pane, no need to force reset.
                    // Otherwise, the componentDidUpdate in PropertyPane.tsx will have never been entered, which will lead to
                    // _isPropertyPaneReplaced in PropertyPane.tsx keeping true.
                    // The logic inside PropertyPane.tsx is strong enough to decide whether it need to reset whole property pane.
                    if (this._isCurrentlyConfiguredPropertyPaneReactive) {
                      this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                    } else {
                      // @todo: (SPPPLAT VSO# Task 236141:Implement Non-Reactive property pane in full).
                      // For now we are rendering the property pane, but ideally we have to check if the
                      // property pane is in dirty state and act accordingly.
                      this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                    }
                    */
                    this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                }
                break;
            /**
             * Refresh the contents of the property pane if the property pane is open for the requesting component.
             *  - This condition is prechecked in 'requestPropertyPaneAction' method.
             */
            case 'Refresh':
                if (!(0, KillSwitches_1.isActivateActionOnRefreshKSActivated)()) {
                    var onChangeListeners = this._onPropertyPaneFieldChangeListeners.get(toBeConfiguredConsumerInstanceId);
                    Array.from(onChangeListeners || []).forEach(function (cb) { return cb(); });
                }
                if (this._isOpen) {
                    this._renderPropertyPane(toBeConfiguredConsumer, true, false);
                }
                break;
            /**
             * Unmount property pane and reset _isOpen to false.
             */
            case 'Unmount':
                this._hidePropertyPane();
                this._firePostToggleConfigurationEvents();
                break;
        }
    };
    /**
     * A private method to show the property pane.
     *
     * This method will also set the value of the '_isOpen' value appropriately.
     */
    PropertyPaneController.prototype._showPropertyPane = function () {
        if (this._pageContentElement) {
            this._pageContentElement.classList.add(PropertyPaneController_module_scss_1.default.shrinkContent);
        }
        else {
            /**
             * This is a temporary fix.
             * todo: (SPPPLAT VSO: Bug 237945:Fix the property pane rendering on the classic page)
             */
            this._propertyPaneContainer.style.top = '50px';
            this._propertyPaneContainer.style.zIndex = '999';
        }
        if (this._workbenchCommandBarElement) {
            this._workbenchCommandBarElement.classList.add(PropertyPaneController_module_scss_1.default.shrinkContent);
        }
        this._propertyPaneContainer.classList.add(this._narrowRender ? PropertyPaneController_module_scss_1.default.showPaneNarrow : PropertyPaneController_module_scss_1.default.showPane);
        this._propertyPaneContainer.dataset.automationId = 'showPane';
        this._isOpen = true;
    };
    /**
     * A private method to hide the property pane.
     *
     * This method will also set the value of the '_isOpen' value appropriately.
     */
    PropertyPaneController.prototype._hidePropertyPane = function () {
        var clearPropertyPaneReference = false;
        if (this._pageContentElement) {
            this._pageContentElement.classList.remove(PropertyPaneController_module_scss_1.default.shrinkContent);
            if (this._propertyPaneElement) {
                // eslint-disable-next-line @microsoft/spfx/pair-react-dom-render-unmount
                ReactDOM.unmountComponentAtNode(this._propertyPaneElement);
                clearPropertyPaneReference = true;
            }
        }
        else if (this._propertyPaneElement) {
            /**
             * If there is no page content element, then it means that it is a classic page. So unmounting
             * the property pane node, because for some reason property pane is not respecting PropertyPaneContainer
             * styles.
             *
             * This is a temporary fix.
             * todo: (SPPPLAT VSO: Bug 237945:Fix the property pane rendering on the classic page)
             */
            // eslint-disable-next-line @microsoft/spfx/pair-react-dom-render-unmount
            ReactDOM.unmountComponentAtNode(this._propertyPaneElement);
            clearPropertyPaneReference = true;
        }
        if (clearPropertyPaneReference) {
            this._propertyPaneElement = undefined;
        }
        if (this._workbenchCommandBarElement) {
            this._workbenchCommandBarElement.classList.remove(PropertyPaneController_module_scss_1.default.shrinkContent);
        }
        this._propertyPaneContainer.classList.remove(this._narrowRender ? PropertyPaneController_module_scss_1.default.showPaneNarrow : PropertyPaneController_module_scss_1.default.showPane);
        if ((0, Flights_1.isCardDesignerPlusPlusFlight2Enabled)() && this._isPropertyPaneExpandedClassActive()) {
            this._propertyPaneContainer.classList.remove(PropertyPaneController_module_scss_1.default.spPropertyPaneContainerExpanded);
        }
        this._propertyPaneContainer.dataset.automationId = 'hidePane';
        this._isOpen = false;
    };
    /**
     * Renders the property pane.
     *
     * @param currentConsumer - Current component for which the property pane is to be displayed.
     * @param recreatePropertyPane - Indicates whether property pane should be recreated or not.
     * @param reset - Indicating whether property pane state should be reset or not.
     * @param isDetails - Indicating whether this is rendered in openDetails scenario
     * @param context - additional data passed by the consumer, to be sent back to the same webpart
     */
    PropertyPaneController.prototype._renderPropertyPane = function (currentConsumer, recreatePropertyPane, reset, isDetails, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    context) {
        var _this = this;
        var qosMonitor = new sp_diagnostics_1._QosMonitor('PropertyPaneController.renderPropertyPane');
        if (currentConsumer) {
            currentConsumer
                ._getPropertyPaneData(isDetails, context)
                .then(function (data) {
                // load the property pane only when the resolved promise is of the current webpart.
                // else no-op
                if (_this._currentlyConfiguredConsumerId === data.webPartId) {
                    /**
                     * Posting a message to the current window indicating that the property pane will open.
                     * This is used by the clientsidewebpartmanager to close isolated property pane, if open.
                     *
                     * todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
                     * todo(SPPPLAT PBI #687467): Refactor IframedWebPartContoller
                     */
                    window.postMessage('Property pane will open', window.location.origin);
                    _this._buildAndLoadPropertyPane(data, reset);
                }
            })
                .catch(function (error) {
                sp_diagnostics_1._TraceLogger.logErrorData({
                    source: _this._logSource,
                    error: error
                });
                qosMonitor.writeUnexpectedFailure('UnhandledError', error);
                throw error;
            });
        }
        else {
            // if !currentWebpart
            this._currentPropertyPaneData = this._getEmptyPropertyPaneData();
            this._loadPropertyPaneComponent(recreatePropertyPane);
        }
    };
    /**
     * Builds the data required to load the property pane and then loads the property pane component.
     *
     * @param propertyPaneData - property pane data for currently active consumer.
     * @param reset - Indicating whether property pane state should be reset or not.
     */
    PropertyPaneController.prototype._buildAndLoadPropertyPane = function (propertyPaneData, reset) {
        var _this = this;
        this._currentPropertyPaneData = propertyPaneData;
        propertyPaneData.onPropertyPaneFieldChanged = this._onPropertyPaneFieldChanged;
        propertyPaneData.onConfigurationEvent = this._onConfigurationEvent;
        propertyPaneData.render = function () {
            _this._reRender();
        };
        propertyPaneData.shouldResetState = reset;
        if ((0, Flights_1.isCardDesignerPlusPlusFlight2Enabled)()) {
            var shouldExpand = this._isPropertyPaneExpanded();
            var isExpandedClassAdded = this._isPropertyPaneExpandedClassActive();
            if (shouldExpand && !isExpandedClassAdded) {
                this._propertyPaneContainer.classList.add(PropertyPaneController_module_scss_1.default.spPropertyPaneContainerExpanded);
            }
            else if (!shouldExpand && isExpandedClassAdded) {
                this._propertyPaneContainer.classList.remove(PropertyPaneController_module_scss_1.default.spPropertyPaneContainerExpanded);
            }
        }
        if (propertyPaneData.configuration && propertyPaneData.configuration.showLoadingIndicator) {
            // Reason behind calculating delay like this is, we want to respect
            // the value provided by the consumer's author, including 0(otherwise its a falsy value.)
            var delay = propertyPaneData.configuration.loadingIndicatorDelayTime === undefined
                ? 500
                : propertyPaneData.configuration.loadingIndicatorDelayTime;
            setTimeout(function () {
                if (propertyPaneData.configuration.showLoadingIndicator) {
                    /**
                     * Reloading the property pane component if showOverlaySpinner is true after the
                     * overlaySpinnerDelayTime (if specified) or 500 ms.
                     */
                    _this._loadPropertyPaneComponent(true);
                }
            }, delay);
        }
        else {
            this._loadPropertyPaneComponent(true);
        }
    };
    /**
     * Method to load the property pane component into the propertypanecontainer element using the
     * currentPropertyPaneData.
     *
     * @param recreatePropertyPane - Indicating whether property pane should be recreated or not.
     */
    PropertyPaneController.prototype._loadPropertyPaneComponent = function (recreatePropertyPane) {
        var _this = this;
        var qosMonitor = new sp_diagnostics_1._QosMonitor('PropertyPaneController.loadPropertyPaneComponent');
        // Load the property pane asynchronously in a separate bundle.
        Promise.resolve().then(function () { return tslib_1.__importStar(require(/* webpackChunkName: 'property-pane-component' */ '../propertyPane/PropertyPane')); }).then(function (propertyPane) {
            // Only if this flag is true, re-insert the property pane element into the DOM.
            var insertIntoDom = false;
            if (recreatePropertyPane) {
                // Recreating the property pane. This will enable the property pane to be in a valid state.
                if (!_this._propertyPaneElement) {
                    _this._propertyPaneElement = document.createElement('div');
                    insertIntoDom = true;
                }
            }
            if (_this._propertyPaneElement) {
                _this._propertyPaneElement.className = _this._currentPropertyPaneData.webPartId;
                if (_this._title) {
                    _this._currentPropertyPaneData.title = _this._title;
                }
                var el = React.createElement(propertyPane.default, {
                    data: _this._currentPropertyPaneData,
                    renderNarrow: _this._narrowRender
                }, _this._topControl);
                // eslint-disable-next-line @microsoft/spfx/pair-react-dom-render-unmount
                ReactDOM.render(el, _this._propertyPaneElement);
            }
            // If the consumer app provides a container div, the property pane will slide-in/out.
            // Else, the property pane will be a popup and overlay over the content area.
            // Further, if not required, do not re-insert the element into dom.
            if (_this._propertyPaneContainer) {
                if (insertIntoDom) {
                    _this._clearPropertyPaneContainer();
                    if (_this._propertyPaneElement) {
                        _this._propertyPaneContainer.appendChild(_this._propertyPaneElement);
                    }
                }
            }
            else {
                if (insertIntoDom && document.body.lastChild && _this._propertyPaneElement) {
                    document.body.insertBefore(_this._propertyPaneElement, document.body.lastChild.nextSibling);
                }
            }
        })
            .catch(function (error) {
            sp_diagnostics_1._TraceLogger.logErrorData({
                source: _this._logSource,
                error: error
            });
            qosMonitor.writeUnexpectedFailure('UnhandledError', error);
        });
    };
    /**
     * Allow the property pane to re-render itself. Used when navigating pages.
     */
    PropertyPaneController.prototype._reRender = function () {
        var consumer = this._tryGetConsumer(this._currentPropertyPaneData.webPartId);
        if (consumer) {
            this._renderPropertyPane(consumer);
        }
    };
    /**
     * Property pane field change event handler.
     *
     * @param propertyName - Name of the property pane field changed.
     * @param newValue - New value.
     *  This value could be undefined/empty in the case of custom field.
     */
    PropertyPaneController.prototype._onPropertyPaneFieldChanged = function (propertyName, newValue, fieldType) {
        if (!this._currentPropertyPaneData.webPartId) {
            throw new Error('onPropertyPaneFieldChanged event is not expected when no consumer is being configured');
        }
        var consumer = this._tryGetConsumer(this._currentPropertyPaneData.webPartId);
        if (consumer) {
            consumer._onPropertyPaneFieldChanged(propertyName, newValue, fieldType);
            if ((0, Flights_1.isTopActionsEnabled)()) {
                var onChangeListeners = this._onPropertyPaneFieldChangeListeners.get(this._currentPropertyPaneData.webPartId);
                Array.from(onChangeListeners || []).forEach(function (cb) { return cb(); });
            }
            // Resetting the boolean value.
            this._renderPropertyPane(consumer);
        }
        if (this._isCurrentlyConfiguredPropertyPaneReactive()) {
            this._resetConfigurationCompleteTimeout();
        }
    };
    /**
     * Callback to handle the configuration events that originate in the property pane.
     *
     * @example
     * PropertyPaneClosed, PropertyPaneApplyClicked etc.,
     */
    PropertyPaneController.prototype._onConfigurationEvent = function (configurationEvent) {
        switch (configurationEvent) {
            /**
             * For the event 'PropertyPaneClosed' we need to fire both the 'PropertyPaneClosed' and
             * 'PropertyPaneConfigurationComplete' events to the consumer.
             * '_togglePropertyPanePosition' internally fires both the events.
             */
            case 'Closed':
                this._hidePropertyPane();
                this._firePostToggleConfigurationEvents();
                break;
            /**
             * For these events we need to fire two events:
             *  - 'PropertyPaneConfigurationComplete' and
             *  - Whatever the event the caller has passed in 'configurationEvent'.
             */
            case 'ApplyClicked':
            case 'LostFocus':
                this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, configurationEvent);
                this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 'ConfigurationComplete');
                break;
        }
    };
    /**
     * Method to fire the configuration events post toggling the property pane.
     * If toggling opened the property pane then fire both the 'PropertyPaneOpened' and 'PropertyPaneConfigurationStart'
     * events after the ANIMATION_TIMEOUT is elapsed.
     * Else if the toggling resulted in closing the property pane then fire 'PropertyPaneConfigurationComplete' event
     * and then after ANIMATION_TIMEOUT is elapsed fire 'PropertyPaneClosed' event.
     */
    PropertyPaneController.prototype._firePostToggleConfigurationEvents = function () {
        var _this = this;
        // @todo: this is a temporary fix to let the host (e.g. Canvas) know that the property pane has completed
        // animating. The current property pane animation is 367ms and hence the 400ms timeout. The correct fix is
        // to hookup to the animation end event.
        if (this._isOpen) {
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 'Opened');
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 'ConfigurationStart');
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 *
                 * @example
                 * Modern pages use this message to re-size it's header.'
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, ANIMATION_TIMEOUT);
        }
        else {
            this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 'ConfigurationComplete');
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredConsumerId, 'Closed');
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 *
                 * @example
                 * Modern pages use this message to re-size it's header.'
                 *
                 * todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, ANIMATION_TIMEOUT);
        }
    };
    /**
     * Method to fire the configuration events when the property pane did not toggle.
     * Fire the 'ConfigurationComplete' event on the current consumer and
     * then 'ConfigurationStart' for the new consumer.
     *
     * @param id - Id of the consumer to be configured.
     */
    PropertyPaneController.prototype._fireNoToggleConfigurationEvents = function (id) {
        // Firing events for the current consumer.
        this._fireConfigurationEvent(this._currentlyConfiguredConsumerId, 'ConfigurationComplete');
        // Firing events for the new consumer.
        this._fireConfigurationEvent(id, 'ConfigurationStart');
    };
    /**
     * Method to fire the configuration event to the host and the consumer.
     *
     * @param componentId - Id of the consumer to which the event needs to be sent.
     * @param configurationEvent - Kind of configuration event to fire.
     */
    PropertyPaneController.prototype._fireConfigurationEvent = function (componentId, configurationEvent) {
        this._clearConfigurationCompleteTimeout();
        // Up to IWebPartGetter to handle an undefined string.
        var consumer = this._tryGetConsumer(componentId);
        if (consumer) {
            var eventArgs = {
                componentId: componentId,
                configurationEvent: configurationEvent
            };
            sp_core_library_1._SPEventManager.instance.raiseEvent('propertyPaneEvent', eventArgs);
            // Raise the event to the consumer.
            consumer._onPropertyPaneLifeCycleEvent(configurationEvent);
        }
    };
    /**
     * Private method to set the property pane related DOM elements, which are used in slide in slide out effect.
     */
    PropertyPaneController.prototype._setPropertyPaneDOMElements = function () {
        var workbenchElement = document.getElementById('workbenchPageContent');
        // @todo: (SPPPLAT VSO#222337) - Refactor Workbench page layout
        if (workbenchElement) {
            this._pageContentElement = workbenchElement;
            this._workbenchCommandBarElement = document.getElementById('workbenchCommandBar');
        }
        else {
            this._pageContentElement = document.getElementById('spPageChromeAppDiv');
        }
        // All modern apps should have the spPageChromeAppDiv. If not, then we should treat like the Classic page scenario.
        // i.e.the container div should be hanging off the root node. And we should create it only the first time.
        if (!this._pageContentElement) {
            if (!this._propertyPaneContainer) {
                this._propertyPaneContainer = document.createElement('div');
                this._propertyPaneContainer.id = this._propertyPaneContainerId;
                this._propertyPaneContainer.className = this._propertyPaneContainerId;
                document.body.appendChild(this._propertyPaneContainer);
            }
        }
        else {
            // We know it will always exist in the Classic Page scenario.
            this._propertyPaneContainer =
                document.getElementById(this._propertyPaneContainerId) ||
                    // classic page or when flexbox killswitch is on
                    document.getElementById(PROPERTY_PANE_CONTAINER_NOFLEXBOX_ID);
        }
    };
    /**
     * Removes all the children of the property pane container.
     */
    PropertyPaneController.prototype._clearPropertyPaneContainer = function () {
        while (this._propertyPaneContainer && this._propertyPaneContainer.firstChild) {
            this._propertyPaneContainer.removeChild(this._propertyPaneContainer.firstChild);
        }
    };
    /**
     * Reset configuration completion timeout.
     */
    PropertyPaneController.prototype._resetConfigurationCompleteTimeout = function () {
        this._clearConfigurationCompleteTimeout();
        this._configurationCompletionTimeout = window.setTimeout(this._fireConfigurationEvent, CONFIGURATION_COMPLETE_TIMEOUT, this._currentlyConfiguredConsumerId, 'ConfigurationComplete');
    };
    /**
     * Clear configuration completion timeout.
     */
    PropertyPaneController.prototype._clearConfigurationCompleteTimeout = function () {
        if (this._configurationCompletionTimeout) {
            window.clearTimeout(this._configurationCompletionTimeout);
            this._configurationCompletionTimeout = undefined;
        }
    };
    /**
     * Method to check whether the currently configured property pane is reactive or not.
     */
    PropertyPaneController.prototype._isCurrentlyConfiguredPropertyPaneReactive = function () {
        if (this._currentlyConfiguredConsumerId) {
            var consumer = this._tryGetConsumer(this._currentlyConfiguredConsumerId);
            var isReactive = this._currentPropertyPaneData
                ? this._currentPropertyPaneData.isReactive
                : consumer && !consumer._isPropertyPaneReactive();
            return !!isReactive;
        }
        return false;
    };
    /**
     * Method to get a consumer instance.
     */
    PropertyPaneController.prototype._tryGetConsumer = function (id) {
        return this._consumers.get(id);
    };
    /**
     * Returns the property pane data which has only 'onClose' defined. This is used when we have to display
     * empty property pane, when there is nothing to configure.
     */
    PropertyPaneController.prototype._getEmptyPropertyPaneData = function () {
        return {
            webPartId: undefined,
            title: undefined,
            shouldResetState: true,
            onPropertyPaneFieldChanged: undefined,
            onConfigurationEvent: this._onConfigurationEvent,
            onRendered: undefined,
            properties: undefined,
            configuration: {
                pages: []
            },
            dynamicConfiguration: undefined
        };
    };
    PropertyPaneController.prototype._isPropertyPaneExpanded = function () {
        return (this._currentPropertyPaneData && (0, MultiColumnHelper_1.isPropertyPaneMultiColumn)(this._currentPropertyPaneData.configuration));
    };
    PropertyPaneController.prototype._isPropertyPaneExpandedClassActive = function () {
        return this._propertyPaneContainer.classList.contains(PropertyPaneController_module_scss_1.default.spPropertyPaneContainerExpanded);
    };
    return PropertyPaneController;
}());
exports.default = PropertyPaneController;
//# sourceMappingURL=PropertyPaneController.js.map