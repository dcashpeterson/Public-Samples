{"version":3,"file":"DependencyAnalyzer.js","sourceRoot":"","sources":["../src/DependencyAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\n\nimport { Path } from './Path';\nimport { PackletAnalyzer } from './PackletAnalyzer';\n\nenum RefFileKind {\n  Import,\n  ReferenceFile,\n  TypeReferenceDirective\n}\n\n// TypeScript compiler internal:\n// Version range: >= 3.6.0, <= 4.2.0\n// https://github.com/microsoft/TypeScript/blob/5ecdcef4cecfcdc86bd681b377636422447507d7/src/compiler/program.ts#L541\ninterface RefFile {\n  // The absolute path of the module that was imported.\n  // (Normalized to an all lowercase ts.Path string.)\n  referencedFileName: string;\n  // The kind of reference.\n  kind: RefFileKind;\n  // An index indicating the order in which items occur in a compound expression\n  index: number;\n\n  // The absolute path of the source file containing the import statement.\n  // (Normalized to an all lowercase ts.Path string.)\n  file: string;\n}\n\n// TypeScript compiler internal:\n// Version range: > 4.2.0\n// https://github.com/microsoft/TypeScript/blob/2eca17d7c1a3fb2b077f3a910d5019d74b6f07a0/src/compiler/types.ts#L3693\nenum FileIncludeKind {\n  RootFile,\n  SourceFromProjectReference,\n  OutputFromProjectReference,\n  Import,\n  ReferenceFile,\n  TypeReferenceDirective,\n  LibFile,\n  LibReferenceDirective,\n  AutomaticTypeDirectiveFile\n}\n\n// TypeScript compiler internal:\n// Version range: > 4.2.0\n// https://github.com/microsoft/TypeScript/blob/2eca17d7c1a3fb2b077f3a910d5019d74b6f07a0/src/compiler/types.ts#L3748\ntype FileIncludeReason = {\n  kind: FileIncludeKind;\n  file: string | undefined;\n};\n\ninterface ITsProgramInternals extends ts.Program {\n  // TypeScript compiler internal:\n  // Version range: >= 3.6.0, <= 4.2.0\n  // https://github.com/microsoft/TypeScript/blob/5ecdcef4cecfcdc86bd681b377636422447507d7/src/compiler/types.ts#L3723\n  getRefFileMap?: () => Map<string, RefFile[]> | undefined;\n\n  // TypeScript compiler internal:\n  // Version range: > 4.2.0\n  // https://github.com/microsoft/TypeScript/blob/2eca17d7c1a3fb2b077f3a910d5019d74b6f07a0/src/compiler/types.ts#L3871\n  getFileIncludeReasons?: () => Map<string, FileIncludeReason[]>;\n}\n\n/**\n * Represents a packlet that imports another packlet.\n */\nexport interface IPackletImport {\n  /**\n   * The name of the packlet being imported.\n   */\n  packletName: string;\n\n  /**\n   * The absolute path of the file that imports the packlet.\n   */\n  fromFilePath: string;\n}\n\n/**\n * Used to build a linked list of imports that represent a circular dependency.\n */\ninterface IImportListNode extends IPackletImport {\n  /**\n   * The previous link in the linked list.\n   */\n  previousNode: IImportListNode | undefined;\n}\n\nexport class DependencyAnalyzer {\n  /**\n   * @param packletName - the packlet to be checked next in our traversal\n   * @param startingPackletName - the packlet that we started with; if the traversal reaches this packlet,\n   *   then a circular dependency has been detected\n   * @param refFileMap - the compiler's `refFileMap` data structure describing import relationships\n   * @param fileIncludeReasonsMap - the compiler's data structure describing import relationships\n   * @param program - the compiler's `ts.Program` object\n   * @param packletsFolderPath - the absolute path of the \"src/packlets\" folder.\n   * @param visitedPacklets - the set of packlets that have already been visited in this traversal\n   * @param previousNode - a linked list of import statements that brought us to this step in the traversal\n   */\n  private static _walkImports(\n    packletName: string,\n    startingPackletName: string,\n    refFileMap: Map<string, RefFile[]> | undefined,\n    fileIncludeReasonsMap: Map<string, FileIncludeReason[]> | undefined,\n    program: ts.Program,\n    packletsFolderPath: string,\n    visitedPacklets: Set<string>,\n    previousNode: IImportListNode | undefined\n  ): IImportListNode | undefined {\n    visitedPacklets.add(packletName);\n\n    const packletEntryPoint: string = Path.join(packletsFolderPath, packletName, 'index');\n\n    const tsSourceFile: ts.SourceFile | undefined =\n      program.getSourceFile(packletEntryPoint + '.ts') || program.getSourceFile(packletEntryPoint + '.tsx');\n    if (!tsSourceFile) {\n      return undefined;\n    }\n\n    const referencingFilePaths: string[] = [];\n\n    if (refFileMap) {\n      // TypeScript version range: >= 3.6.0, <= 4.2.0\n      const refFiles: RefFile[] | undefined = refFileMap.get((tsSourceFile as any).path as any);\n      if (refFiles) {\n        for (const refFile of refFiles) {\n          if (refFile.kind === RefFileKind.Import) {\n            referencingFilePaths.push(refFile.file);\n          }\n        }\n      }\n    } else if (fileIncludeReasonsMap) {\n      // Typescript version range: > 4.2.0\n      const fileIncludeReasons: FileIncludeReason[] | undefined = fileIncludeReasonsMap.get(\n        (tsSourceFile as any).path as any\n      );\n      if (fileIncludeReasons) {\n        for (const fileIncludeReason of fileIncludeReasons) {\n          if (fileIncludeReason.kind === FileIncludeKind.Import) {\n            if (fileIncludeReason.file) {\n              referencingFilePaths.push(fileIncludeReason.file);\n            }\n          }\n        }\n      }\n    }\n\n    for (const referencingFilePath of referencingFilePaths) {\n      // Is it a reference to a packlet?\n      if (Path.isUnder(referencingFilePath, packletsFolderPath)) {\n        const referencingRelativePath: string = Path.relative(packletsFolderPath, referencingFilePath);\n        const referencingPathParts: string[] = referencingRelativePath.split(/[\\/\\\\]+/);\n        const referencingPackletName: string = referencingPathParts[0];\n\n        // Did we return to where we started from?\n        if (referencingPackletName === startingPackletName) {\n          // Ignore the degenerate case where the starting node imports itself,\n          // since @rushstack/packlets/mechanics will already report that.\n          if (previousNode) {\n            // Make a new linked list node to record this step of the traversal\n            const importListNode: IImportListNode = {\n              previousNode: previousNode,\n              fromFilePath: referencingFilePath,\n              packletName: packletName\n            };\n\n            // The traversal has returned to the packlet that we started from;\n            // this means we have detected a circular dependency\n            return importListNode;\n          }\n        }\n\n        // Have we already analyzed this packlet?\n        if (!visitedPacklets.has(referencingPackletName)) {\n          // Make a new linked list node to record this step of the traversal\n          const importListNode: IImportListNode = {\n            previousNode: previousNode,\n            fromFilePath: referencingFilePath,\n            packletName: packletName\n          };\n\n          const result: IImportListNode | undefined = DependencyAnalyzer._walkImports(\n            referencingPackletName,\n            startingPackletName,\n            refFileMap,\n            fileIncludeReasonsMap,\n            program,\n            packletsFolderPath,\n            visitedPacklets,\n            importListNode\n          );\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * For the specified packlet, trace all modules that import it, looking for a circular dependency\n   * between packlets.  If found, an array is returned describing the import statements that cause\n   * the problem.\n   *\n   * @remarks\n   * For example, suppose we have files like this:\n   *\n   * ```\n   * src/packlets/logging/index.ts\n   * src/packlets/logging/Logger.ts --> imports \"../data-model\"\n   * src/packlets/data-model/index.ts\n   * src/packlets/data-model/DataModel.ts --> imports \"../logging\"\n   * ```\n   *\n   * The returned array would be:\n   * ```ts\n   * [\n   *   { packletName: \"logging\",    fromFilePath: \"/path/to/src/packlets/data-model/DataModel.ts\" },\n   *   { packletName: \"data-model\", fromFilePath: \"/path/to/src/packlets/logging/Logger.ts\" },\n   * ]\n   * ```\n   *\n   * If there is more than one circular dependency chain, only the first one that is encountered\n   * will be returned.\n   */\n  public static checkEntryPointForCircularImport(\n    packletName: string,\n    packletAnalyzer: PackletAnalyzer,\n    program: ts.Program\n  ): IPackletImport[] | undefined {\n    const programInternals: ITsProgramInternals = program;\n\n    let refFileMap: Map<string, RefFile[]> | undefined;\n    let fileIncludeReasonsMap: Map<string, FileIncludeReason[]> | undefined;\n\n    if (programInternals.getRefFileMap) {\n      // TypeScript version range: >= 3.6.0, <= 4.2.0\n      refFileMap = programInternals.getRefFileMap();\n    } else if (programInternals.getFileIncludeReasons) {\n      // Typescript version range: > 4.2.0\n      fileIncludeReasonsMap = programInternals.getFileIncludeReasons();\n    } else {\n      // If you encounter this error, please report a bug\n      throw new Error(\n        'Your TypeScript compiler version is not supported; please upgrade @rushstack/eslint-plugin-packlets' +\n          ' or report a GitHub issue'\n      );\n    }\n\n    const visitedPacklets: Set<string> = new Set();\n\n    const listNode: IImportListNode | undefined = DependencyAnalyzer._walkImports(\n      packletName,\n      packletName,\n      refFileMap,\n      fileIncludeReasonsMap,\n      program,\n      packletAnalyzer.packletsFolderPath!,\n      visitedPacklets,\n      undefined // previousNode\n    );\n\n    if (listNode) {\n      // Convert the linked list to an array\n      const packletImports: IPackletImport[] = [];\n      for (let current: IImportListNode | undefined = listNode; current; current = current.previousNode) {\n        packletImports.push({ fromFilePath: current.fromFilePath, packletName: current.packletName });\n      }\n      return packletImports;\n    }\n\n    return undefined;\n  }\n}\n"]}