{"version":3,"file":"LocFileParser.js","sourceRoot":"","sources":["../src/LocFileParser.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,yDAAsD;AACtD,yDAAsD;AACtD,mDAA4E;AAoB5E,MAAM,UAAU,GAAkC,IAAI,GAAG,EAA4B,CAAC;AAEtF,SAAgB,sBAAsB,CAAC,QAAgB;IACrD,IAAI,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,MAAM,CAAC;KACf;SAAM,IAAI,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;QAChD,OAAO,UAAU,CAAC;KACnB;SAAM,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;QACvC,OAAO,SAAS,CAAC;KAClB;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,uCAAuC,QAAQ,EAAE,CAAC,CAAC;KACpE;AACH,CAAC;AAVD,wDAUC;AAED;;GAEG;AACH,SAAgB,YAAY,CAAC,OAA6B;IACxD,MAAM,EAAE,MAAM,GAAG,sBAAsB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,GAAG,OAAO,CAAC;IAEtE,MAAM,YAAY,GAAW,GAAG,OAAO,CAAC,QAAQ,IAAI,MAAM,IAAI,OAAO,CAAC,wBAAwB,IAAI,MAAM,EAAE,CAAC;IAC3G,MAAM,eAAe,GAAiC,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACnF,IAAI,eAAe,EAAE;QACnB,IACE,eAAe,CAAC,OAAO,KAAK,OAAO,CAAC,OAAO;YAC3C,eAAe,CAAC,YAAY,KAAK,OAAO,CAAC,YAAY,EACrD;YACA,OAAO,eAAe,CAAC,UAAU,CAAC;SACnC;KACF;IAED,IAAI,UAA6B,CAAC;IAClC,QAAQ,MAAM,EAAE;QACd,KAAK,MAAM,CAAC,CAAC;YACX,UAAU,GAAG,IAAA,qBAAS,EAAC,OAAO,CAAC,CAAC;YAChC,MAAM;SACP;QAED,KAAK,UAAU,CAAC,CAAC;YACf,UAAU,GAAG,IAAA,2BAAY,EAAC,OAAO,CAAC,CAAC;YACnC,MAAM;SACP;QAED,KAAK,SAAS,CAAC,CAAC;YACd,UAAU,GAAG,IAAA,2BAAY,EAAC,OAAO,CAAC,CAAC;YACnC,MAAM;SACP;QAED,OAAO,CAAC,CAAC;YACP,MAAM,IAAI,KAAK,CAAC,uBAAuB,MAAM,EAAE,CAAC,CAAC;SAClD;KACF;IAED,UAAU,CAAC,GAAG,CAAC,YAAY,EAAE;QAC3B,OAAO,EAAE,OAAO,CAAC,OAAO;QACxB,UAAU;QACV,YAAY,EAAE,OAAO,CAAC,YAAY;KACnC,CAAC,CAAC;IAEH,OAAO,UAAU,CAAC;AACpB,CAAC;AA3CD,oCA2CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { IgnoreStringFunction, ILocalizationFile, IParseFileOptions } from './interfaces';\nimport { parseLocJson } from './parsers/parseLocJson';\nimport { parseResJson } from './parsers/parseResJson';\nimport { type IParseResxOptionsBase, parseResx } from './parsers/parseResx';\n\n/**\n * @public\n */\nexport type ParserKind = 'resx' | 'loc.json' | 'resjson';\n\n/**\n * @public\n */\nexport interface IParseLocFileOptions extends IParseFileOptions, IParseResxOptionsBase {\n  parser?: ParserKind;\n}\n\ninterface IParseCacheEntry {\n  content: string;\n  parsedFile: ILocalizationFile;\n  ignoreString: IgnoreStringFunction | undefined;\n}\n\nconst parseCache: Map<string, IParseCacheEntry> = new Map<string, IParseCacheEntry>();\n\nexport function selectParserByFilePath(filePath: string): ParserKind {\n  if (/\\.resx$/i.test(filePath)) {\n    return 'resx';\n  } else if (/\\.(resx|loc)\\.json$/i.test(filePath)) {\n    return 'loc.json';\n  } else if (/\\.resjson$/i.test(filePath)) {\n    return 'resjson';\n  } else {\n    throw new Error(`Unsupported file extension in file: ${filePath}`);\n  }\n}\n\n/**\n * @public\n */\nexport function parseLocFile(options: IParseLocFileOptions): ILocalizationFile {\n  const { parser = selectParserByFilePath(options.filePath) } = options;\n\n  const fileCacheKey: string = `${options.filePath}?${parser}&${options.resxNewlineNormalization || 'none'}`;\n  const parseCacheEntry: IParseCacheEntry | undefined = parseCache.get(fileCacheKey);\n  if (parseCacheEntry) {\n    if (\n      parseCacheEntry.content === options.content &&\n      parseCacheEntry.ignoreString === options.ignoreString\n    ) {\n      return parseCacheEntry.parsedFile;\n    }\n  }\n\n  let parsedFile: ILocalizationFile;\n  switch (parser) {\n    case 'resx': {\n      parsedFile = parseResx(options);\n      break;\n    }\n\n    case 'loc.json': {\n      parsedFile = parseLocJson(options);\n      break;\n    }\n\n    case 'resjson': {\n      parsedFile = parseResJson(options);\n      break;\n    }\n\n    default: {\n      throw new Error(`Unsupported parser: ${parser}`);\n    }\n  }\n\n  parseCache.set(fileCacheKey, {\n    content: options.content,\n    parsedFile,\n    ignoreString: options.ignoreString\n  });\n\n  return parsedFile;\n}\n"]}