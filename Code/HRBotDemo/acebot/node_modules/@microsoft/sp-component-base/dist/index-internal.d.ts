/**
 * SharePoint Framework support for building client-side components
 *
 * @remarks
 * This package supports development of client-side components (e.g. web parts,
 * client-side extensions, and applications) built using the SharePoint Framework.
 * It defines the base classes and interfaces for functionality that is
 * common across all client-side component types.
 *
 * @packagedocumentation
 */

import { AadHttpClientFactory } from '@microsoft/sp-http';
import { AadTokenProviderFactory } from '@microsoft/sp-http';
import { DynamicDataReference } from '@microsoft/sp-dynamic-data';
import { Guid } from '@microsoft/sp-core-library';
import { HttpClient } from '@microsoft/sp-http';
import type { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import type { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';
import { IDisposable } from '@microsoft/sp-core-library';
import { IDynamicDataCallables } from '@microsoft/sp-dynamic-data';
import { IDynamicDataSource } from '@microsoft/sp-dynamic-data';
import { IDynamicDataSourceMetadata } from '@microsoft/sp-dynamic-data';
import type { IFontStyles } from '@fluentui/react';
import { IPalette } from '@fluentui/react';
import type { IPartialTheme } from '@fluentui/react';
import type { IRawStyle } from '@fluentui/react';
import { ISemanticColors } from '@fluentui/react';
import { ISemanticTextColors } from '@fluentui/react';
import type { ISPEventObserver } from '@microsoft/sp-core-library';
import { MSGraphClientFactory } from '@microsoft/sp-http';
import { PageContext } from '@microsoft/sp-page-context';
import { ServiceKey } from '@microsoft/sp-core-library';
import { ServiceScope } from '@microsoft/sp-core-library';
import { SPEvent } from '@microsoft/sp-core-library';
import { SPEventArgs } from '@microsoft/sp-core-library';
import { SPHttpClient } from '@microsoft/sp-http';

/**
 * The base class for client-side components such as BaseClientSideWebPart or BaseExtension.
 *
 * @public
 */
export declare abstract class BaseComponent implements ISPEventObserver {
    /**
     * Use the context object to access common services and state associated with the component.
     *
     * @remarks
     *
     * Child classes are expected to override this field by redeclaring it with a specialized type.
     * It is meant to be a read-only property; the type cannot be declared as read-only in the base class
     * (because it is initialized outside the constructor), but child classes should redeclare
     * it as readonly.
     *
     * @privateRemarks
     *
     * This is a workaround for a missing compiler feature.  If the compiler issue is resolved,
     * then we can convert "context" to an ordinary property getter.
     * https://github.com/Microsoft/TypeScript/issues/338
     */
    protected context?: BaseComponentContext;
    /* Excluded from this release type: _isWebPartAndContainsDynamicDataSource */
    private _isDisposed;
    /* Excluded from this release type: _dynamicDataSourceId */
    /* Excluded from this release type: __constructor */
    /**
     * Disposes the component.
     *
     * @remarks
     * Third-party code generally does not need to call this method; it's invoked
     * automatically when the lifecycle ends for a web part or extension.  To perform
     * custom cleanup when your component is disposed, override the {@link BaseComponent.onDispose}
     * method.
     */
    dispose(): void;
    /* Excluded from this release type: _containsDynamicDataSource */
    /* Excluded from this release type: _containsDynamicDataSource */
    /**
     * Returns true if the component has been already disposed.
     */
    get isDisposed(): boolean;
    /**
     * Provides access to the manifest for the client-side component.
     * virtual
     * @remarks
     * Child classes can override this with more specialized manifest types.
     */
    get manifest(): IClientSideComponentManifest;
    /**
     * This event method is called at the end of the component's lifecycle.
     * It provides an opportunity to release any associated resources, cancel any
     * outstanding requests, etc.
     * virtual
     */
    protected onDispose(): void;
    /**
     * A unique identifier for the instance of the component.
     *
     * @remarks
     * A component implementation can be loaded multiple times on the page.
     * For example, if the component is a charting web part, multiple instances of this web part
     * could be added to the SharePoint canvas.  The instanceId uniquely identifies each
     * of these instances.
     */
    get instanceId(): string;
    /**
     * Returns the component identifier as defined in the component's associated manifest.
     *
     * @remarks
     * Each client-side component has an associated manifest that is used by the sp-loader to load its scripts,
     * and which may include additional metadata about the component.  The manifest is uniquely identified using
     * a text string containing a lower case GUID value.
     */
    get componentId(): string;
    /* Excluded from this release type: _initializeContext */
    /* Excluded from this release type: onProvideServices */
}

/**
 * The base class for context objects for client-side components.
 *
 * @remarks
 * A "context" object is a collection of well-known services and other
 * objects that are likely to be needed by business logic that interacts with a
 * associated component.  Each component type has its own specialized subclass
 * of BaseComponentContext, e.g. WebPartContext for web parts, ExtensionContext for
 * client-side extensions, and so on.
 *
 * @privateRemarks
 *
 * NOTE: The context object is a convenience that avoids the overhead of
 * properly factoring the dependencies for every class in a project.
 * If lots of members are added to the context without discipline, it can
 * easily devolve into a poor engineering practice (where "everything depends
 * on everything else").  Think carefully before adding more objects to the context object.
 * Is it really a core scenario?  Is it unnecessarily coupling your package to another
 * package?  Is there a better place to put the object?
 *
 * Only add data properties or well-defined classes with ubiquitous applicability.
 * Never add loose functions, callbacks, or settable properties to the context.
 *
 * @public
 */
export declare abstract class BaseComponentContext implements IDisposable {
    /**
     * Manifest for the client-side component.
     */
    readonly manifest: IClientSideComponentManifest;
    private _serviceScope;
    private _instanceId;
    private _pageContext;
    private _dynamicDataProvider;
    private _dynamicDataSourceManager;
    private _isDisposed;
    private _httpClient;
    private _spHttpClient;
    private _aadClientFactory;
    private _aadTokenFactory;
    private _msGraphClientFactory;
    private _isServedFromLocalhost;
    /* Excluded from this release type: __constructor */
    /**
     * Returns true if the context is disposed.
     */
    get isDisposed(): boolean;
    /**
     * Disposes the base component context.
     */
    dispose(): void;
    /**
     * The associated {@link @microsoft/sp-core-library#ServiceScope} for this component.
     * @remarks
     * A child service scope is created for each client-side component.
     */
    get serviceScope(): ServiceScope;
    /**
     * {@inheritDoc BaseComponent.instanceId}
     */
    get instanceId(): string;
    /**
     * The page context provides standard definitions for common SharePoint objects
     * that need to be shared between the client-side application, web parts, and other
     * components.
     */
    get pageContext(): PageContext;
    /* Excluded from this release type: _initializeDynamicData */
    /**
     * Returns the Dynamic Data Provider associated with the component.
     */
    get dynamicDataProvider(): DynamicDataProvider;
    /**
     * Returns the Dynamic Data Source Manager associated with the component.
     */
    get dynamicDataSourceManager(): DynamicDataSourceManager;
    /**
     * The instance of AadHttpClientFactory created for this instance of component
     */
    get aadHttpClientFactory(): AadHttpClientFactory;
    /**
     * The instance of AadTokenProviderFactory created for this instance of component
     */
    get aadTokenProviderFactory(): AadTokenProviderFactory;
    /**
     * The instance of MSGraphClientFactory created for this instance of component
     */
    get msGraphClientFactory(): MSGraphClientFactory;
    /**
     * The instance of HttpClient created for this instance of component
     */
    get httpClient(): HttpClient;
    /**
     * The instance of SpHttpClient created for this instance of component
     */
    get spHttpClient(): SPHttpClient;
    /**
     * Returns true if the solution is being served from localhost
     */
    get isServedFromLocalhost(): boolean;
}

/* Excluded from this release type: _CacheMissReason */

/**
 * The Dynamic Data Provider allows components to consume Dynamic Data.
 * It allows components to request Dynamic Data sources and register/unregister to those.
 *
 * @public
 */
export declare class DynamicDataProvider implements IDisposable {
    /* Excluded from this release type: _jsonPathArrayRegex */
    private _dynamicDataManager;
    private _component;
    private _isDisposed;
    private _isInitialized;
    private _isSourcesChangedEventListenerAdded;
    /**
     * Set of pending registrations.
     */
    private _pendingRegistrations;
    /* Excluded from this release type: _initialize */
    /**
     * Disposes the Dynamic Data Provider.
     */
    dispose(): void;
    /**
     * Returns true if the Dynamic Data Provider is disposed.
     */
    get isDisposed(): boolean;
    /* Excluded from this release type: _isProviderInitialized */
    /* Excluded from this release type: _dynamicDataSourceId */
    /**
     * Registers a callback for updates when a Dynamic Data source is changed.
     * This happens when any property is updated within the source.
     *
     * @privateRemarks
     * We register the source, only if the source is available else defer the registration
     * to when the availableSources change.
     *
     * @param sourceId - Id of the Dynamic Data Source.
     * @param callback - Function to execute when the source updates its data.
     */
    registerSourceChanged(sourceId: string, callback: () => void): void;
    /**
     * Unregisters a callback for updates when a Dynamic Data source is changed.
     *
     * @param sourceId - Id of the Dynamic Data Source.
     * @param callback - Function to remove from the registration. Must be the same it was registered with.
     */
    unregisterSourceChanged(sourceId: string, callback: () => void): void;
    /**
     * Registers a callback for updates when a property is changed in a Dynamic Data source.
     *
     * @privateRemarks
     * We register the source, only if the source is available else defer the registration
     * to when the availableSources change.
     *
     * @param sourceId - Id of the Dynamic Data Source.
     * @param propertyId - Id of the property of the source.
     * @param callback - Function to execute when the source updates its data.
     */
    registerPropertyChanged(sourceId: string, propertyId: string, callback: () => void): void;
    /**
     * Unregisters a callback for updates when a property is changed in a Dynamic Data source.
     *
     * @privateRemarks
     * If the sourceId is present in _registeredSourcesForPropertyChanged then
     *    it removes from sourceID from the set _registeredSourcesForPropertyChanged and
     *    invokes unregisterPropertyChanged event on the DynamicDataManager
     *
     * else if the sourceId is present in _pendingSourcesForPropertyChanged then
     *    it just removes the sourceId from the set _pendingSourcesForPropertyChanged
     *
     * @param sourceId - Id of the Dynamic Data Source.
     * @param propertyId - Id of the property of the source.
     * @param callback - Function to remove from the registration. Must be the same it was registered with.
     */
    unregisterPropertyChanged(sourceId: string, propertyId: string, callback: () => void): void;
    /**
     * Registers a callback to an event that raises when the list of available Dynamic Data Sources is updated.
     *
     * @param callback - Function to execute when the sources are updated.
     */
    registerAvailableSourcesChanged(callback: () => void): void;
    /**
     * Unregisters a callback to an event that raises when the list of available Dynamic Data Sources is updated.
     *
     * @privateRemarks
     * This api is used by the consumer of the dynamic data.
     *
     * @param callback - Function to remove from the registration. Must be the same it was registered with.
     */
    unregisterAvailableSourcesChanged(callback: () => void): void;
    /**
     * Returns a list with all available Dynamic Data Sources.
     *
     * @returns Read-only array with all available sources.
     */
    getAvailableSources(): ReadonlyArray<IDynamicDataSource>;
    /* Excluded from this release type: getAvailableSourcesByComponentId */
    /**
     * Returns a Dynamic Data Source, by its id.
     * If the source is not present, it returns undefined.
     *
     * @param id - Id of the Dynamic Data Source.
     */
    tryGetSource(id: string): IDynamicDataSource | undefined;
    /* Excluded from this release type: _getData */
    private _onSourcesChanged;
    private _assertNotDisposed;
    private _assertInitialized;
    /**
     * Adds the registration to the pending registrations if not already added.
     * Also adds a listener to the _DynamicDataManager's sourcesChangedEvent.
     */
    private _addPendingRegistration;
    /**
     * Removes the pending registration and then, if there are no more pending registrations
     * remove the 'sourcesChangedEvent' listener.
     */
    private _removePendingRegistration;
    /**
     * Returns true if the incoming source is already added to the _pendingRegistrations Map.
     *
     * @param incomingRegistration - registration to be checked.
     */
    private _isRegistrationPending;
    /**
     * Logs a feature event with any extra data from the producer of the event.
     * @param logFeature - Name of the feature to log.
     * @param contextualProps - Contextual log properties of the feature event.
     */
    private _logFeatureEntry;
}

/**
 * The Dynamic Data Source Manager is responsible for:
 *  - Constructing the dynamic data source
 *  - Allowing initialization of the dynamic data source by a component
 *  - Allowing data source to update its metadata and notify when data has been updated.
 *
 * @public
 */
export declare class DynamicDataSourceManager implements IDisposable {
    private _dynamicDataManager;
    private _component;
    private _callableFunctions;
    private _src;
    private _isDisposed;
    private _isInitialized;
    private _logSource;
    /* Excluded from this release type: _initialize */
    /**
     * Disposes the resources held by the Dynamic Data source.
     */
    dispose(): void;
    /**
     * Returns true if the DynamicDataSourceManager is disposed.
     */
    get isDisposed(): boolean;
    /* Excluded from this release type: _source */
    /**
     * Initializes the Dynamic Data Source for the component.
     *
     * @param callableFunctions - Set of methods that are exposed through the Dynamic Data Source
     */
    initializeSource(callableFunctions: IDynamicDataCallables): void;
    /**
     * Notifies that this source has updated its properties.
     *
     * When invoked, it enables to broadcast the notification to all the consumers who have
     * registered to this notification from this source.
     */
    notifySourceChanged(): void;
    /**
     * Notifies that this source has updated a specific property.
     *
     * When invoked, it enables to broadcast the notification to all the consumers who have
     * registered to this notification from this source.
     *
     * @param propertyId - Id of the updated property in the source.
     */
    notifyPropertyChanged(propertyId: string): void;
    /**
     * Updates the metadata of the Dynamic Data Source.
     * It allows to update fields like title or description.
     * Auto-generated fields like alias, componentId or instanceId cannot be updated.
     *
     * @param metadata - Partial of the metadata.
     */
    updateMetadata(metadata: Partial<IDynamicDataSourceMetadata>): void;
    /**
     * Returns the Id of the current DataSource.
     * If the component did not initialize as a dynamic data source, then it returns an empty string.
     */
    get sourceId(): string;
    private _buildSource;
    /**
     * This is the allowedEvents() that the DynamicDataSource actually exposes.
     * It does a copy of the data to ensure the consumer doesn't modify the source.
     */
    private _allowedEvents;
    /**
     * This is the sendEvent() that the consumer invokes to send an event to the source, with data.
     * @param eventName - Name of the event
     * @param data - Associated data
     */
    private _sendEvent;
    /**
     * This is the getPropertyDefinitions() that the DynamicDataSource actually exposes.
     * It does a copy of the data to ensure the consumer doesn't modify the source.
     * This assumes that the component has dynamic data and has a controller.
     */
    private _getPropertyDefinitions;
    /**
     * This is the getPropertyValue() that the DynamicDataSource actually exposes.
     * It does a copy of the data to ensure the consumer doesn't modify the source.
     * This assumes that the component has the source initialized.
     * If there is no value returned, it checks whether the propertyId is incorrect or the value is actually undefined.
     *
     * @remarks
     * If the property value associated with the property id, is an array then the
     * propertyId will have [*] notation appended at the end to support valid JSON Path notation.
     * Hence when reading the property id, we account for that and extract the name accordingly.
     */
    private _getPropertyValue;
    /**
     * Returns the real time value of the property.
     */
    private _getPropertyDefinitionsAsync;
    /**
     * Returns the real time value of the property.
     * @param propertyId - property id for which the value is requested.
     */
    private _getPropertyValueAsync;
    /**
     * This is the allowedEvents() that the DynamicDataSource actually exposes.
     * It does a copy of the data to ensure the consumer doesn't modify the source.
     */
    private _allowedEventsAsync;
    /**
     * This is the getPropertyValueSchema() that the DynamicDataSource actually exposes.
     * It does a copy of the data to ensure the consumer doesn't modify the source.
     * If the source doesn't provide the annotated value, then it falls back to whatever
     * 'getPropertyValue' returns as the sample value and metadata would be undefined.
     *
     * @remarks
     * If the property value associated with the property id, is an array then the
     * propertyId will have [*] notation appended at the end to support valid JSON Path notation.
     * Hence when reading the property id, we account for that and extract the name accordingly.
     *
     * @param propertyId - property id for which the schema is requested.
     */
    private _getAnnotatedPropertyValue;
    /**
     * Returns the annotated value of the property.
     * @param propertyId - property id for which the value is requested.
     */
    private _getAnnotatedPropertyValueAsync;
    private _buildMetadata;
    /**
     * Asserts if the event is a valid event on the source.
     *
     * Its an invalid event in two cases:
     *  1. When '_allowedEvent()' api returns undefined
     *  2. When the event name is not one of the allowed events on the source.
     *
     * @param eventName - Name of the event.
     */
    private _assertValidEvent;
    private _assertNotDisposed;
    private _assertInitialized;
    private _assertSourceExists;
    /**
     * Logs a feature event.
     * @param logFeature - Name of the feature to log.
     * @param contextualProps - Contextual log properties of the feature event.
     */
    private _logFeatureEntry;
}

/**
 * Serializable object that simplifies usage of a DynamicProperty.
 *
 * @remarks
 * This is built for usage in web part properties, and modified through the property pane.
 * Can be initialized with a default callback.
 * Web parts initialize with the render method so if the 3rd party developer does nothing, a change in the
 * DynamicProperty will re-render the web part automatically.
 *
 * @public
 */
export declare class DynamicProperty<TValue> implements IDisposable {
    /* Excluded from this release type: _TYPE_NAME */
    private static readonly _arrayRegex;
    private _reference;
    private _value;
    private _hasValue;
    private _sourceId;
    private _provider?;
    private _isDisposed;
    /**
     * Set to store all callback assigned in order to unregister them when the object gets disposed.
     */
    private _callbacks?;
    /**
     * Default callback. Can be undefined if another callback has been set up.
     */
    private _defaultCallback;
    /**
     * Collection of callbacks that should be registered if/when the DynamicProperty source gets registered.
     * This gets emptied when the source exists.
     */
    private _pendingCallbacks?;
    private _onSourcesChanged?;
    /**
     * Create a new DynamicProperty object.
     * @param provider - DynamicDataProvider.
     * @param callback - Optional. Default callback to be registered for updates in the DynamicDataSource.
     */
    constructor(provider: DynamicDataProvider, callback?: () => void);
    /**
     * Sets the value of the DynamicProperty to be a reference to a DynamicDynamicSource
     * and property.  The reference is of the form `<source>:<property>:<path>`.
     * @param reference - Id of the DynamicDataSource and property.
     */
    setReference(reference: string): void;
    /**
     * Sets a static value in the DynamicProperty.
     * @param value - Value for the DynamicProperty.
     */
    setValue(value: TValue): void;
    /**
     * {@inheritDoc @microsoft/sp-core-library#IDisposable.isDisposed}
     */
    get isDisposed(): boolean;
    /**
     * {@inheritDoc @microsoft/sp-core-library#IDisposable.dispose}
     */
    dispose(): void;
    /* Excluded from this release type: toJSON */
    /**
     * DynamicDataReference string that the DynamicProperty object points to.
     * The reference is of the form `<source>:<property>:<path>`.
     *
     * @remarks
     * If the DynamicProperty is set up with static data, this returns undefined.
     */
    get reference(): string | undefined;
    /* Excluded from this release type: value */
    /**
     * Returns the value of the object.
     *
     * @remarks
     * If the value is an array, then the first element of the array is returned;
     * otherwise, the value itself is returned.
     *
     * NOTE: This api will never return an array.  To retrieve an array value,
     * use the {@link DynamicProperty.tryGetValues} API.
     *
     * @returns the value associated with the dynamic property or
     * undefined if the source or the data doesn't exist.
     */
    tryGetValue(): TValue | undefined;
    /**
     * Returns the value of the object.
     *
     * @remarks
     * If the value is NOT an array, then an array is returned with the value being the single entry;
     * otherwise, the value itself is returned.  If the property is undefined or cannot be found,
     * an empty array will be returned.
     *
     * NOTE: This api will always return an array and it assumes that the array is homogeneous.
     * To retrieve a non-array value, use the {@link DynamicProperty.tryGetValue} API.
     *
     * @returns the value associated with the dynamic property or
     * an empty array if the source or the data doesn't exist.
     */
    tryGetValues(): TValue[];
    /**
     * Returns the DynamicDataSource that the DynamicProperty object refers to.
     * Returns undefined if the source doesn't exist.
     */
    tryGetSource(): IDynamicDataSource | undefined;
    /**
     * Registers a callback function for updates on the associated DynamicDataSource.
     * @param callback - Callback function to register.
     */
    register(callback: () => void): void;
    /**
     * Unregisters a callback function for updates on the associated DynamicDataSource.
     * The callback function must be the same it was registered with.
     * @param callback - Callback function to unregister.
     */
    unregister(callback: () => void): void;
    /**
     * Returns true if the object has a default callback.
     */
    hasDefaultCallback(): boolean;
    /**
     * Removes the registration for the default callback.
     *
     * @remarks
     * This can be useful for advanced users who only want their custom callbacks.
     */
    removeDefaultCallback(): void;
    /* Excluded from this release type: _getSourceId */
    /* Excluded from this release type: _getProperty */
    /* Excluded from this release type: _getPropertyPath */
    /* Excluded from this release type: _cloneDeep */
    /**
     * Returns the property name of the DynamicDataSource that the DynamicProperty points to.
     *
     * @remarks
     * Removes the array notation from the property name, if any, before it is being registered.
     * This is to avoid any mismatch between the strings passed by the source when it notifies
     * a property change, as the source doesn't pass any array notation with the property name.
     * Array notation is only for internal representation, for a property whose value is an array type.
     */
    private _getPropertyToRegister;
    /**
     * Callback when the DynamicDataSources list changes.
     * It registers the pending callbacks into the DynamicDataProvidere.
     */
    private _onSourcesChangedCallback;
    private _getData;
}

/* Excluded from this release type: _ensureIsolatedDomainUrl */

/* Excluded from this release type: _IComponentContextParameters */

/* Excluded from this release type: _IComponentPosition */

/**
 * This is the structure used for map values for component properties metadata.
 *
 * @public
 */
export declare interface IComponentPropertyMetadata {
    /**
     * Indicates whether the property should be serialized as HTML.
     *
     * @remarks
     * This flag instructs framework to store the value as HTML, so that SharePoint can perform the following
     * services on it:
     *
     * - normalizing HTML encodings
     *
     * - stripping unsafe HTML tags (i.e. for usage with Element.innerHTML)
     *
     * - search indexing
     *
     * - SharePoint link fix-up
     *
     * Only enable this flag for HTML content where these modifications are acceptable. If non-HTML content is
     * provided, SharePoint framework might make modifications to convert it to HTML valid. For plain text content
     * that simply needs to be exposed to the search index (without any rewriting), use the `isSearchablePlainText`
     * flag instead.
     */
    isHtmlString?: boolean;
    /**
     * Indicates if the property contains plain text that should be search-indexed by SharePoint.
     *
     * @remarks
     * This flag instructs the framework to store the property in a representation that supports search indexing.
     * The content will be treated as plain text; SharePoint will not modify the string in any way, and
     * special HTML characters may be stored encoded and appear in search results. If your string contains
     * HTML markup, use the isHtmlString setting instead.
     *
     * Security note: For security reasons, never assign a plain text string to `Element.innerHTML`.
     */
    isSearchablePlainText?: boolean;
    /**
     * Indicates if the property contains a link. This allows SharePoint server to treat the value as such and
     * perform services like search indexing, link fix-up, loading from CDN, etc.
     */
    isLink?: boolean;
    /**
     * Indicates if the property contains a link. This allows SharePoint server to treat the value as such and
     * perform services like link fix-up, search indexing, loading from CDN, etc.
     */
    isImageSource?: boolean;
    /* Excluded from this release type: isComponentDependency */
    /**
     * Indicates if the framework should persist the property on the server.
     *
     * @remarks
     * Use this for properties that are only important in run-time, and do not need to persist on the server.
     * This can reduce the size of the serialized data of the component and optimize the component load time.
     * The property value will be removed from the serialized data sent to the server, but this has no effect on
     * the run-time property bag. The property value will still be available in the `onBeforeSerialize()` method,
     * and the value will not be cleared from the run-time property bag. The initial render of your component should
     * not depend on the value of the property. Setting a default value for the property can be done in `onInit()` method.
     *
     * Note that if the property path refers to a property that has a complex object as the value, the whole object
     * will be removed from the persisted data.
     */
    shouldNotPersist?: boolean;
    /* Excluded from this release type: customMetadata */
}

export { IFontStyles }

export { IPalette }

export { IRawStyle }

/**
 * {@inheritdoc IFontStyles}
 *
 * @public
 */
export declare interface IReadonlyFontStyles extends Readonly<IFontStyles> {
}

/**
 * @public
 */
export declare type IReadonlyRawStyle = Readonly<IRawStyle>;

/**
 * Immutable ITheme.
 *
 * @public
 */
export declare interface IReadonlyTheme extends Readonly<ITheme> {
}

export { ISemanticColors }

export { ISemanticTextColors }

/**
 * Contains collections of data that can be processed by server side services like search index and link fixup
 *
 * @public
 */
export declare interface ISerializedServerProcessedData {
    /**
     * A key-value map where keys are string identifiers and values are rich text with HTML format.
     *
     * @remarks
     * SharePoint servers treat the values as HTML content and run services like safety checks, search index
     * and link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myRichDescription': '<div>Some standard <b>HTML content</b><a href='http://somelink'>A Link</a></div>'
     *   'anotherRichText': <div class='aClass'><span style='color:red'>Some red text</div>
     * }
     * ```
     *
     */
    htmlStrings?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are strings that should be search indexed.
     *
     * @remarks
     * The values are HTML-encoded before being sent to the server. The encoded values are visible to the search
     * indexer, but are not treated as valid HTML. So, other services such as link fixup will not run on them.
     *
     * Example:
     * ```
     * {
     *  'justSomeText': 'This is some plain text',
     *  'anotherText': 'Can have <any> characters here: "<>&\''
     * }
     * ```
     */
    searchablePlainTexts?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are links.
     *
     * @remarks
     * SharePoint servers treat the values as links and run services like link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myWebURL': 'http://contoso.com'
     *   'myFileLink': 'https://res.contoso.com/file.docx'
     * }
     * ```
     */
    links?: {
        [key: string]: string;
    };
    /**
     * A key-value map where keys are string identifiers and values are image sources.
     *
     * @remarks
     * SharePoint servers treat the values as image sources and run services like search index and link fixup on them.
     *
     * Example:
     * ```
     * {
     *   'myImage1': 'http://res.contoso.com/path/to/file'
     *   'myImage2': 'https://res.contoso.com/someName.jpg'
     * }
     * ```
     */
    imageSources?: {
        [key: string]: string;
    };
    /* Excluded from this release type: componentDependencies */
    /* Excluded from this release type: customMetadata */
}

/**
 * Collection of theme values, which can be used to programatically style components.
 *
 * @public
 */
export declare interface ITheme extends IPartialTheme {
}

/* Excluded from this release type: _IWebPartLoadData */

/* Excluded from this release type: _LegacyThirdPartyFabricCoreLoader */

/* Excluded from this release type: _PropertyMetadataProcessor */

/* Excluded from this release type: ServerProcessedDataType */

/* Excluded from this release type: _ShimmerFactory */

/**
 * The object passed when the IThemeProvider.themeChangedEvent is raised.
 *
 * @public
 */
export declare class ThemeChangedEventArgs extends SPEventArgs {
    /**
     * The new theme. If the value is undefined, then the theme was cleared.
     */
    readonly theme: ITheme | undefined;
}

/**
 * The ThemeProvider class provides the capability to get different themes from the Framework. Themes can be provided
 * in different contexts, e.g. Canvas sections may provide a variant of the global theme in some contexts.
 *
 * @public
 */
export declare class ThemeProvider {
    /**
     * The service key for ThemeProvider.
     */
    static readonly serviceKey: ServiceKey<ThemeProvider>;
    private static readonly _themeChangedEventNameLiteral;
    /**
     * Used to register a unique event for each ThemeProvider instance by appending
     * the instance count to themeChangedEventNameLiteral.
     */
    private static _instanceCount;
    /**
     * Raised when the theme changes with the new theme as an argument.
     *
     * @eventproperty
     */
    readonly themeChangedEvent: SPEvent<ThemeChangedEventArgs>;
    private readonly _id;
    private _theme;
    /**
     * Construct a new instance of the ThemeProvider class.
     *
     * @param serviceScope - The current service scope.
     * @param theme - Theme to provide.
     */
    constructor(serviceScope: ServiceScope, theme?: ITheme);
    private get _themeChangedEventName();
    /* Excluded from this release type: _clearTheme */
    /* Excluded from this release type: _setTheme */
    /**
     * If set, get the current scoped theme.
     */
    tryGetTheme(): IReadonlyTheme | undefined;
    private _raiseEvent;
}

/* Excluded from this release type: _WebPartLoadDataCollector */

export { }
