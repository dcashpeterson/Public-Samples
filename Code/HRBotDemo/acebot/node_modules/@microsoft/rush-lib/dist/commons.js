"use strict";
exports.id = "commons";
exports.ids = ["commons"];
exports.modules = {

/***/ 589083:
/*!*********************************************************!*\
  !*** ./lib-esnext/api/ApprovedPackagesConfiguration.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApprovedPackagesConfiguration": () => (/* binding */ ApprovedPackagesConfiguration),
/* harmony export */   "ApprovedPackagesItem": () => (/* binding */ ApprovedPackagesItem)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_JsonSchemaUrls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logic/JsonSchemaUrls */ 866717);
/* harmony import */ var _schemas_approved_packages_schema_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../schemas/approved-packages.schema.json */ 405603);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * An item returned by ApprovedPackagesConfiguration
 * @public
 */
class ApprovedPackagesItem {
    /**
     * @internal
     */
    constructor(packageName) {
        /**
         * The project categories that are allowed to use this package.
         */
        this.allowedCategories = new Set();
        this.packageName = packageName;
    }
}
/**
 * This represents the JSON file specified via the "approvedPackagesFile" option in rush.json.
 * @public
 */
class ApprovedPackagesConfiguration {
    constructor(jsonFilename) {
        this.items = [];
        this._itemsByName = new Map();
        this._jsonFilename = jsonFilename;
        this.clear();
    }
    /**
     * Clears all the settings, returning to an empty state.
     */
    clear() {
        this._itemsByName.clear();
        this._loadedJson = {
            // Ensure this comes first in the key ordering
            $schema: '',
            packages: []
        };
    }
    getItemByName(packageName) {
        return this._itemsByName.get(packageName);
    }
    addOrUpdatePackage(packageName, reviewCategory) {
        let changed = false;
        let item = this._itemsByName.get(packageName);
        if (!item) {
            item = new ApprovedPackagesItem(packageName);
            this._addItem(item);
            changed = true;
        }
        if (reviewCategory && !item.allowedCategories.has(reviewCategory)) {
            item.allowedCategories.add(reviewCategory);
            changed = true;
        }
        return changed;
    }
    /**
     * If the file exists, calls loadFromFile().
     */
    tryLoadFromFile(approvedPackagesPolicyEnabled) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(this._jsonFilename)) {
            return false;
        }
        this.loadFromFile();
        if (!approvedPackagesPolicyEnabled) {
            // eslint-disable-next-line no-console
            console.log(`Warning: Ignoring "${path__WEBPACK_IMPORTED_MODULE_0__.basename(this._jsonFilename)}" because the` +
                ` "approvedPackagesPolicy" setting was not specified in rush.json`);
        }
        return false;
    }
    /**
     * Loads the configuration data from the filename that was passed to the constructor.
     */
    loadFromFile() {
        const approvedPackagesJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.loadAndValidate(this._jsonFilename, ApprovedPackagesConfiguration._jsonSchema);
        this.clear();
        for (const browserPackage of approvedPackagesJson.packages) {
            this._addItemJson(browserPackage, this._jsonFilename);
        }
    }
    /**
     * Loads the configuration data to the filename that was passed to the constructor.
     */
    saveToFile() {
        // Update the JSON structure that we already loaded, preserving any existing state
        // (which passed schema validation).
        // eslint-disable-next-line dot-notation
        this._loadedJson['$schema'] = _logic_JsonSchemaUrls__WEBPACK_IMPORTED_MODULE_2__.JsonSchemaUrls.approvedPackages;
        this._loadedJson.packages = [];
        this.items.sort((a, b) => {
            return a.packageName.localeCompare(b.packageName);
        });
        for (const item of this.items) {
            // Sort the items from the set.
            const allowedCategories = Array.from(item.allowedCategories);
            allowedCategories.sort();
            const itemJson = {
                name: item.packageName,
                allowedCategories: allowedCategories
            };
            this._loadedJson.packages.push(itemJson);
        }
        // Save the file
        let body = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.stringify(this._loadedJson);
        // Unindent the allowedCategories array to improve readability
        body = body.replace(/("allowedCategories": +\[)([^\]]+)/g, (substring, ...args) => {
            return args[0] + args[1].replace(/\s+/g, ' ');
        });
        // Add a header
        body = '// DO NOT ADD COMMENTS IN THIS FILE.  They will be lost when the Rush tool resaves it.\n' + body;
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.writeFile(this._jsonFilename, body, {
            convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.NewlineKind.CrLf
        });
    }
    /**
     * Helper function only used by the constructor when loading the file.
     */
    _addItemJson(itemJson, jsonFilename) {
        if (this._itemsByName.has(itemJson.name)) {
            throw new Error(`Error loading package review file ${jsonFilename}:\n` +
                ` the name "${itemJson.name}" appears more than once`);
        }
        const item = new ApprovedPackagesItem(itemJson.name);
        if (itemJson.allowedCategories) {
            for (const allowedCategory of itemJson.allowedCategories) {
                item.allowedCategories.add(allowedCategory);
            }
        }
        this._addItem(item);
    }
    /**
     * Helper function that adds an already created ApprovedPackagesItem to the
     * list and set.
     */
    _addItem(item) {
        if (this._itemsByName.has(item.packageName)) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Duplicate key');
        }
        this.items.push(item);
        this._itemsByName.set(item.packageName, item);
    }
}
ApprovedPackagesConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonSchema.fromLoadedObject(_schemas_approved_packages_schema_json__WEBPACK_IMPORTED_MODULE_3__);

//# sourceMappingURL=ApprovedPackagesConfiguration.js.map

/***/ }),

/***/ 986096:
/*!**************************************************!*\
  !*** ./lib-esnext/api/ApprovedPackagesPolicy.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApprovedPackagesPolicy": () => (/* binding */ ApprovedPackagesPolicy)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ApprovedPackagesConfiguration */ 589083);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * This is a helper object for RushConfiguration.
 * It exposes the "approvedPackagesPolicy" feature from rush.json.
 * @public
 */
class ApprovedPackagesPolicy {
    /** @internal */
    constructor(rushConfiguration, rushConfigurationJson) {
        const approvedPackagesPolicy = rushConfigurationJson.approvedPackagesPolicy || {};
        this.enabled = !!rushConfigurationJson.approvedPackagesPolicy;
        this.ignoredNpmScopes = new Set(approvedPackagesPolicy.ignoredNpmScopes);
        this.reviewCategories = new Set(approvedPackagesPolicy.reviewCategories);
        if (this.enabled) {
            if (!this.reviewCategories.size) {
                throw new Error(`The "approvedPackagesPolicy" feature is enabled rush.json, but the reviewCategories` +
                    ` list is not configured.`);
            }
        }
        // Load browser-approved-packages.json
        const browserApprovedPackagesPath = path__WEBPACK_IMPORTED_MODULE_0__.join(rushConfiguration.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.browserApprovedPackagesFilename);
        this.browserApprovedPackages = new _ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_2__.ApprovedPackagesConfiguration(browserApprovedPackagesPath);
        this.browserApprovedPackages.tryLoadFromFile(this.enabled);
        // Load nonbrowser-approved-packages.json
        const nonbrowserApprovedPackagesPath = path__WEBPACK_IMPORTED_MODULE_0__.join(rushConfiguration.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.nonbrowserApprovedPackagesFilename);
        this.nonbrowserApprovedPackages = new _ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_2__.ApprovedPackagesConfiguration(nonbrowserApprovedPackagesPath);
        this.nonbrowserApprovedPackages.tryLoadFromFile(this.enabled);
    }
}
//# sourceMappingURL=ApprovedPackagesPolicy.js.map

/***/ }),

/***/ 541976:
/*!***************************************************!*\
  !*** ./lib-esnext/api/BuildCacheConfiguration.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BuildCacheConfiguration": () => (/* binding */ BuildCacheConfiguration)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_buildCache_FileSystemBuildCacheProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logic/buildCache/FileSystemBuildCacheProvider */ 339043);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _RushUserConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RushUserConfiguration */ 354981);
/* harmony import */ var _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EnvironmentConfiguration */ 382806);
/* harmony import */ var _logic_buildCache_CacheEntryId__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../logic/buildCache/CacheEntryId */ 574471);
/* harmony import */ var _schemas_build_cache_schema_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../schemas/build-cache.schema.json */ 168442);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.








/**
 * Use this class to load and save the "common/config/rush/build-cache.json" config file.
 * This file provides configuration options for cached project build output.
 * @beta
 */
class BuildCacheConfiguration {
    constructor({ getCacheEntryId, buildCacheJson, rushUserConfiguration, rushConfiguration, cloudCacheProvider }) {
        var _a;
        this.buildCacheEnabled = (_a = _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.buildCacheEnabled) !== null && _a !== void 0 ? _a : buildCacheJson.buildCacheEnabled;
        this.cacheWriteEnabled =
            !!this.buildCacheEnabled && _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.buildCacheWriteAllowed !== false;
        this.getCacheEntryId = getCacheEntryId;
        this.localCacheProvider = new _logic_buildCache_FileSystemBuildCacheProvider__WEBPACK_IMPORTED_MODULE_3__.FileSystemBuildCacheProvider({
            rushUserConfiguration: rushUserConfiguration,
            rushConfiguration: rushConfiguration
        });
        this.cloudCacheProvider = cloudCacheProvider;
    }
    /**
     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {
        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(jsonFilePath)) {
            return undefined;
        }
        return await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);
    }
    /**
     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.
     */
    static async loadAndRequireEnabledAsync(terminal, rushConfiguration, rushSession) {
        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(jsonFilePath)) {
            terminal.writeErrorLine(`The build cache feature is not enabled. This config file is missing:\n` + jsonFilePath);
            terminal.writeLine(`\nThe Rush website documentation has instructions for enabling the build cache.`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        const buildCacheConfiguration = await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);
        if (!buildCacheConfiguration.buildCacheEnabled) {
            terminal.writeErrorLine(`The build cache feature is not enabled. You can enable it by editing this config file:\n` +
                jsonFilePath);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        return buildCacheConfiguration;
    }
    /**
     * Gets the absolute path to the build-cache.json file in the specified rush workspace.
     */
    static getBuildCacheConfigFilePath(rushConfiguration) {
        return path__WEBPACK_IMPORTED_MODULE_0__.resolve(rushConfiguration.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.buildCacheFilename);
    }
    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {
        const buildCacheJson = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.loadAndValidateAsync(jsonFilePath, BuildCacheConfiguration._jsonSchema);
        const rushUserConfiguration = await _RushUserConfiguration__WEBPACK_IMPORTED_MODULE_5__.RushUserConfiguration.initializeAsync();
        let getCacheEntryId;
        try {
            getCacheEntryId = _logic_buildCache_CacheEntryId__WEBPACK_IMPORTED_MODULE_6__.CacheEntryId.parsePattern(buildCacheJson.cacheEntryNamePattern);
        }
        catch (e) {
            terminal.writeErrorLine(`Error parsing cache entry name pattern "${buildCacheJson.cacheEntryNamePattern}": ${e}`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        let cloudCacheProvider;
        // Don't configure a cloud cache provider if local-only
        if (buildCacheJson.cacheProvider !== 'local-only') {
            const cloudCacheProviderFactory = rushSession.getCloudBuildCacheProviderFactory(buildCacheJson.cacheProvider);
            if (!cloudCacheProviderFactory) {
                throw new Error(`Unexpected cache provider: ${buildCacheJson.cacheProvider}`);
            }
            cloudCacheProvider = await cloudCacheProviderFactory(buildCacheJson);
        }
        return new BuildCacheConfiguration({
            buildCacheJson,
            getCacheEntryId,
            rushConfiguration,
            rushUserConfiguration,
            rushSession,
            cloudCacheProvider
        });
    }
}
BuildCacheConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonSchema.fromLoadedObject(_schemas_build_cache_schema_json__WEBPACK_IMPORTED_MODULE_7__);

//# sourceMappingURL=BuildCacheConfiguration.js.map

/***/ }),

/***/ 202137:
/*!**************************************!*\
  !*** ./lib-esnext/api/ChangeFile.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeFile": () => (/* binding */ ChangeFile)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_Git__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logic/Git */ 668229);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * This class represents a single change file.
 */
class ChangeFile {
    /**
     * @internal
     */
    constructor(changeFileData, rushConfiguration) {
        if (!changeFileData) {
            throw new Error(`changeFileData does not have a value`);
        }
        if (!rushConfiguration) {
            throw new Error(`rushConfiguration does not have a value`);
        }
        this._changeFileData = changeFileData;
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Adds a change entry into the change file
     * @param data - change information
     */
    addChange(data) {
        this._changeFileData.changes.push(data);
    }
    /**
     * Gets all the change entries about the specified package from the change file.
     * @param packageName - package name
     */
    getChanges(packageName) {
        const changes = [];
        for (const info of this._changeFileData.changes) {
            if (info.packageName === packageName) {
                changes.push(info);
            }
        }
        return changes;
    }
    /**
     * Writes the change file to disk in sync mode.
     * Returns the file path.
     * @returns the path to the file that was written (based on generatePath())
     */
    writeSync() {
        const filePath = this.generatePath();
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.save(this._changeFileData, filePath, {
            ensureFolderExists: true
        });
        return filePath;
    }
    /**
     * Generates a file path for storing the change file to disk.
     * Note that this value may change if called twice in a row,
     * as it is partially based on the current date/time.
     */
    generatePath() {
        let branch = undefined;
        const git = new _logic_Git__WEBPACK_IMPORTED_MODULE_2__.Git(this._rushConfiguration);
        const repoInfo = git.getGitInfo();
        branch = repoInfo && repoInfo.branch;
        if (!branch) {
            // eslint-disable-next-line no-console
            console.log('Could not automatically detect git branch name, using timestamp instead.');
        }
        // example filename: yourbranchname_2017-05-01-20-20.json
        const filename = branch
            ? this._escapeFilename(`${branch}_${this._getTimestamp()}.json`)
            : `${this._getTimestamp()}.json`;
        const filePath = path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.changesFolder, ...this._changeFileData.packageName.split('/'), filename);
        return filePath;
    }
    /**
     * Gets the current time, formatted as YYYY-MM-DD-HH-MM
     * Optionally will include seconds
     */
    _getTimestamp(useSeconds = false) {
        // Create a date string with the current time
        // dateString === "2016-10-19T22:47:49.606Z"
        const dateString = new Date().toJSON();
        // Parse out 2 capture groups, the date and the time
        const dateParseRegex = /([0-9]{4}-[0-9]{2}-[0-9]{2}).*([0-9]{2}:[0-9]{2}:[0-9]{2})/;
        // matches[1] === "2016-10-19"
        // matches[2] === "22:47:49"
        const matches = dateString.match(dateParseRegex);
        if (matches) {
            // formattedDate === "2016-10-19"
            const formattedDate = matches[1];
            let formattedTime;
            if (useSeconds) {
                // formattedTime === "22-47-49"
                formattedTime = matches[2].replace(':', '-');
            }
            else {
                // formattedTime === "22-47"
                const timeParts = matches[2].split(':');
                formattedTime = `${timeParts[0]}-${timeParts[1]}`;
            }
            return `${formattedDate}-${formattedTime}`;
        }
        return undefined;
    }
    _escapeFilename(filename, replacer = '-') {
        // Removes / ? < > \ : * | ", really anything that isn't a letter, number, '.' '_' or '-'
        const badCharacters = /[^a-zA-Z0-9._-]/g;
        return filename.replace(badCharacters, replacer);
    }
}
//# sourceMappingURL=ChangeFile.js.map

/***/ }),

/***/ 780924:
/*!********************************************!*\
  !*** ./lib-esnext/api/ChangeManagement.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeType": () => (/* binding */ ChangeType)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Represents all of the types of change requests.
 */
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["none"] = 0] = "none";
    ChangeType[ChangeType["dependency"] = 1] = "dependency";
    ChangeType[ChangeType["hotfix"] = 2] = "hotfix";
    ChangeType[ChangeType["patch"] = 3] = "patch";
    ChangeType[ChangeType["minor"] = 4] = "minor";
    ChangeType[ChangeType["major"] = 5] = "major";
})(ChangeType || (ChangeType = {}));
//# sourceMappingURL=ChangeManagement.js.map

/***/ }),

/***/ 714304:
/*!*****************************************!*\
  !*** ./lib-esnext/api/ChangeManager.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeManager": () => (/* binding */ ChangeManager)
/* harmony export */ });
/* harmony import */ var _ChangeFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChangeFile */ 202137);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * A class that helps with programmatically interacting with Rush's change files.
 * @public
 */
class ChangeManager {
    /**
     * Creates a change file that has a 'none' type.
     * @param rushConfiguration - The rush configuration we are working with
     * @param projectName - The name of the project for which to create a change file
     * @param emailAddress - The email address which should be associated with this change
     * @returns the path to the file that was created, or undefined if no file was written
     */
    static createEmptyChangeFiles(rushConfiguration, projectName, emailAddress) {
        const projectInfo = rushConfiguration.getProjectByName(projectName);
        if (projectInfo && projectInfo.shouldPublish) {
            const changefile = {
                // eslint-disable-line @typescript-eslint/no-explicit-any
                changes: [
                    {
                        comment: '',
                        packageName: projectName,
                        type: 'none'
                    }
                ],
                packageName: projectName,
                email: emailAddress
            };
            return new _ChangeFile__WEBPACK_IMPORTED_MODULE_0__.ChangeFile(changefile, rushConfiguration).writeSync();
        }
        return undefined;
    }
}
//# sourceMappingURL=ChangeManager.js.map

/***/ }),

/***/ 13111:
/*!************************************************!*\
  !*** ./lib-esnext/api/CobuildConfiguration.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CobuildConfiguration": () => (/* binding */ CobuildConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ 825828);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EnvironmentConfiguration */ 382806);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _schemas_cobuild_schema_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../schemas/cobuild.schema.json */ 222518);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * Use this class to load and save the "common/config/rush/cobuild.json" config file.
 * This file provides configuration options for the Rush Cobuild feature.
 * @beta
 */
class CobuildConfiguration {
    constructor(options) {
        var _a;
        const { cobuildJson, cobuildLockProviderFactory } = options;
        this.cobuildContextId = _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.cobuildContextId;
        this.cobuildFeatureEnabled = this.cobuildContextId ? cobuildJson.cobuildFeatureEnabled : false;
        this.cobuildRunnerId = _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.cobuildRunnerId || (0,uuid__WEBPACK_IMPORTED_MODULE_1__.v4)();
        this.cobuildLeafProjectLogOnlyAllowed =
            (_a = _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.cobuildLeafProjectLogOnlyAllowed) !== null && _a !== void 0 ? _a : false;
        this._cobuildLockProviderFactory = cobuildLockProviderFactory;
        this._cobuildJson = cobuildJson;
    }
    /**
     * Attempts to load the cobuild.json data from the standard file path `common/config/rush/cobuild.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {
        const jsonFilePath = CobuildConfiguration.getCobuildConfigFilePath(rushConfiguration);
        try {
            return await CobuildConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);
        }
        catch (err) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(err)) {
                throw err;
            }
        }
    }
    static getCobuildConfigFilePath(rushConfiguration) {
        return `${rushConfiguration.commonRushConfigFolder}/${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.cobuildFilename}`;
    }
    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {
        let cobuildJson;
        try {
            cobuildJson = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidateAsync(jsonFilePath, CobuildConfiguration._jsonSchema);
        }
        catch (e) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(e)) {
                return undefined;
            }
            throw e;
        }
        if (!(cobuildJson === null || cobuildJson === void 0 ? void 0 : cobuildJson.cobuildFeatureEnabled)) {
            return undefined;
        }
        const cobuildLockProviderFactory = rushSession.getCobuildLockProviderFactory(cobuildJson.cobuildLockProvider);
        if (!cobuildLockProviderFactory) {
            throw new Error(`Unexpected cobuild lock provider: ${cobuildJson.cobuildLockProvider}`);
        }
        return new CobuildConfiguration({
            cobuildJson,
            rushConfiguration,
            rushSession,
            cobuildLockProviderFactory
        });
    }
    async createLockProviderAsync(terminal) {
        if (this.cobuildFeatureEnabled) {
            terminal.writeLine(`Running cobuild (runner ${this.cobuildContextId}/${this.cobuildRunnerId})`);
            const cobuildLockProvider = await this._cobuildLockProviderFactory(this._cobuildJson);
            this._cobuildLockProvider = cobuildLockProvider;
            await this._cobuildLockProvider.connectAsync();
        }
    }
    async destroyLockProviderAsync() {
        var _a;
        if (this.cobuildFeatureEnabled) {
            await ((_a = this._cobuildLockProvider) === null || _a === void 0 ? void 0 : _a.disconnectAsync());
        }
    }
    getCobuildLockProvider() {
        if (!this._cobuildLockProvider) {
            throw new Error(`Cobuild lock provider has not been created`);
        }
        return this._cobuildLockProvider;
    }
}
CobuildConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_cobuild_schema_json__WEBPACK_IMPORTED_MODULE_4__);

//# sourceMappingURL=CobuildConfiguration.js.map

/***/ }),

/***/ 563114:
/*!****************************************************!*\
  !*** ./lib-esnext/api/CommandLineConfiguration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommandLineConfiguration": () => (/* binding */ CommandLineConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _schemas_command_line_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../schemas/command-line.schema.json */ 703450);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



const DEFAULT_BUILD_COMMAND_JSON = {
    commandKind: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bulkCommandKind,
    name: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName,
    summary: "Build all projects that haven't been built, or have changed since they were last built.",
    description: 'This command is similar to "rush rebuild", except that "rush build" performs' +
        ' an incremental build. In other words, it only builds projects whose source files have changed' +
        ' since the last successful build. The analysis requires a Git working tree, and only considers' +
        ' source files that are tracked by Git and whose path is under the project folder. (For more details' +
        ' about this algorithm, see the documentation for the "package-deps-hash" NPM package.) The incremental' +
        ' build state is tracked in a per-project folder called ".rush/temp" which should NOT be added to Git. The' +
        ' build command is tracked by the "arguments" field in the "package-deps_build.json" file contained' +
        ' therein; a full rebuild is forced whenever the command has changed (e.g. "--production" or not).',
    safeForSimultaneousRushProcesses: false,
    enableParallelism: true,
    incremental: true
};
const DEFAULT_REBUILD_COMMAND_JSON = {
    commandKind: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bulkCommandKind,
    name: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.rebuildCommandName,
    summary: 'Clean and rebuild the entire set of projects.',
    description: 'This command assumes that the package.json file for each project contains' +
        ' a "scripts" entry for "npm run build" that performs a full clean build.' +
        ' Rush invokes this script to build each project that is registered in rush.json.' +
        ' Projects are built in parallel where possible, but always respecting the dependency' +
        ' graph for locally linked projects.  The number of simultaneous processes will be' +
        ' based on the number of machine cores unless overridden by the --parallelism flag.' +
        ' (For an incremental build, see "rush build" instead of "rush rebuild".)',
    safeForSimultaneousRushProcesses: false,
    enableParallelism: true,
    incremental: false
};
/**
 * Custom Commands and Options for the Rush Command Line
 */
class CommandLineConfiguration {
    /**
     * Use CommandLineConfiguration.loadFromFile()
     *
     * @internal
     */
    constructor(commandLineJson, options = {}) {
        var _a, _b, _c;
        this.commands = new Map();
        this.phases = new Map();
        this.parameters = [];
        /**
         * These path will be prepended to the PATH environment variable
         */
        this.additionalPathFolders = [];
        /**
         * A map of bulk command names to their corresponding synthetic phase identifiers
         */
        this._syntheticPhasesByTranslatedBulkCommandName = new Map();
        const phasesJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.phases;
        if (phasesJson) {
            const phaseNameRegexp = new RegExp(`^${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`);
            for (const phase of phasesJson) {
                if (this.phases.has(phase.name)) {
                    throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, the phase "${phase.name}" is specified ` +
                        'more than once.');
                }
                if (!phase.name.match(phaseNameRegexp)) {
                    throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, the phase "${phase.name}"'s name ` +
                        'is not a valid phase name. Phase names must begin with the ' +
                        `required prefix "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phaseNamePrefix}" followed by a name containing ` +
                        'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +
                        'must not end with a hyphen.');
                }
                if (phase.ignoreMissingScript !== undefined && phase.missingScriptBehavior !== undefined) {
                    throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, the phase "${phase.name}"'s defines ` +
                        'both "ignoreMissingScript" and "missingScriptBehavior". If using the "missingScriptBehavior", ' +
                        `remove "ignoreMissingScript", since it subsumes the functionality.`);
                }
                // This is a completely fresh object. Avoid use of the `...` operator in its construction
                // to guarantee monomorphism.
                const processedPhase = {
                    name: phase.name,
                    isSynthetic: false,
                    logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(phase.name),
                    associatedParameters: new Set(),
                    dependencies: {
                        self: new Set(),
                        upstream: new Set()
                    },
                    missingScriptBehavior: (_a = phase.missingScriptBehavior) !== null && _a !== void 0 ? _a : (phase.ignoreMissingScript ? 'log' : 'error'),
                    allowWarningsOnSuccess: !!phase.allowWarningsOnSuccess
                };
                this.phases.set(phase.name, processedPhase);
            }
            // Resolve phase names to the underlying objects
            for (const rawPhase of phasesJson) {
                // The named phase not existing was already handled in the loop above
                const phase = this.phases.get(rawPhase.name);
                const selfDependencies = (_b = rawPhase.dependencies) === null || _b === void 0 ? void 0 : _b.self;
                const upstreamDependencies = (_c = rawPhase.dependencies) === null || _c === void 0 ? void 0 : _c.upstream;
                if (selfDependencies) {
                    for (const dependencyName of selfDependencies) {
                        const dependency = this.phases.get(dependencyName);
                        if (!dependency) {
                            throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, in the phase "${phase.name}", the self ` +
                                `dependency phase "${dependencyName}" does not exist.`);
                        }
                        phase.dependencies.self.add(dependency);
                    }
                }
                if (upstreamDependencies) {
                    for (const dependencyName of upstreamDependencies) {
                        const dependency = this.phases.get(dependencyName);
                        if (!dependency) {
                            throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, in the phase "${phase.name}", ` +
                                `the upstream dependency phase "${dependencyName}" does not exist.`);
                        }
                        phase.dependencies.upstream.add(dependency);
                    }
                }
            }
            // Do the recursive stuff after the dependencies have been converted
            const safePhases = new Set();
            const cycleDetector = new Set();
            for (const phase of this.phases.values()) {
                this._checkForPhaseSelfCycles(phase, cycleDetector, safePhases);
            }
        }
        const commandsJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands;
        let buildCommandPhases;
        let buildCommandOriginalPhases;
        if (commandsJson) {
            for (const command of commandsJson) {
                if (this.commands.has(command.name)) {
                    throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, the command "${command.name}" is specified ` +
                        'more than once.');
                }
                let normalizedCommand;
                switch (command.commandKind) {
                    case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phasedCommandKind: {
                        const originalPhases = new Set();
                        const commandPhases = new Set();
                        const watchPhases = new Set();
                        normalizedCommand = Object.assign(Object.assign({}, command), { isSynthetic: false, associatedParameters: new Set(), originalPhases, phases: commandPhases, watchPhases, alwaysWatch: false, alwaysInstall: undefined });
                        for (const phaseName of command.phases) {
                            const phase = this.phases.get(phaseName);
                            if (!phase) {
                                throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, in the "phases" property of the ` +
                                    `"${normalizedCommand.name}" command, the phase "${phaseName}" does not exist.`);
                            }
                            originalPhases.add(phase);
                            commandPhases.add(phase);
                        }
                        // Apply implicit phase dependency expansion
                        // The equivalent of the "--to" operator used for projects
                        // Appending to the set while iterating it accomplishes a full breadth-first search
                        for (const phase of commandPhases) {
                            for (const dependency of phase.dependencies.self) {
                                commandPhases.add(dependency);
                            }
                            for (const dependency of phase.dependencies.upstream) {
                                commandPhases.add(dependency);
                            }
                        }
                        const { watchOptions, installOptions } = command;
                        if (watchOptions) {
                            normalizedCommand.alwaysWatch = watchOptions.alwaysWatch;
                            normalizedCommand.watchDebounceMs = watchOptions.debounceMs;
                            // No implicit phase dependency expansion for watch mode.
                            for (const phaseName of watchOptions.watchPhases) {
                                const phase = this.phases.get(phaseName);
                                if (!phase) {
                                    throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, in the "watchPhases" property of the ` +
                                        `"${normalizedCommand.name}" command, the phase "${phaseName}" does not exist.`);
                                }
                                watchPhases.add(phase);
                            }
                        }
                        if (installOptions) {
                            normalizedCommand.alwaysInstall = installOptions.alwaysInstall;
                        }
                        break;
                    }
                    case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.globalCommandKind: {
                        normalizedCommand = Object.assign(Object.assign({}, command), { associatedParameters: new Set() });
                        break;
                    }
                    case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bulkCommandKind: {
                        // Translate the bulk command into a phased command
                        normalizedCommand = this._translateBulkCommandToPhasedCommand(command);
                        break;
                    }
                }
                if (normalizedCommand.name === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName ||
                    normalizedCommand.name === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.rebuildCommandName) {
                    if (normalizedCommand.commandKind === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.globalCommandKind) {
                        throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a command "${normalizedCommand.name}" using ` +
                            `the command kind "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.globalCommandKind}". This command can only be designated as a command ` +
                            `kind "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bulkCommandKind}" or "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phasedCommandKind}".`);
                    }
                    else if (command.safeForSimultaneousRushProcesses) {
                        throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a command "${normalizedCommand.name}" using ` +
                            `"safeForSimultaneousRushProcesses=true". This configuration is not supported for "${normalizedCommand.name}".`);
                    }
                    else if (normalizedCommand.name === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName) {
                        // Record the build command phases in case we need to construct a synthetic "rebuild" command
                        buildCommandPhases = normalizedCommand.phases;
                        buildCommandOriginalPhases = normalizedCommand.originalPhases;
                    }
                }
                this.commands.set(normalizedCommand.name, normalizedCommand);
            }
        }
        if (!options.doNotIncludeDefaultBuildCommands) {
            let buildCommand = this.commands.get(_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName);
            if (!buildCommand) {
                // If the build command was not specified in the config file, add the default build command
                buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);
                buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;
                buildCommandPhases = buildCommand.phases;
                buildCommandOriginalPhases = buildCommand.originalPhases;
                this.commands.set(buildCommand.name, buildCommand);
            }
            if (!this.commands.has(_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.rebuildCommandName)) {
                // If a rebuild command was not specified in the config file, add the default rebuild command
                if (!buildCommandPhases || !buildCommandOriginalPhases) {
                    throw new Error(`Phases for the "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName}" were not found.`);
                }
                const rebuildCommand = Object.assign(Object.assign({}, DEFAULT_REBUILD_COMMAND_JSON), { commandKind: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phasedCommandKind, isSynthetic: true, phases: buildCommandPhases, disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache, associatedParameters: buildCommand.associatedParameters, originalPhases: buildCommandOriginalPhases, watchPhases: new Set(), alwaysWatch: false, alwaysInstall: undefined });
                this.commands.set(rebuildCommand.name, rebuildCommand);
            }
        }
        const parametersJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.parameters;
        if (parametersJson) {
            for (const parameter of parametersJson) {
                const normalizedParameter = Object.assign(Object.assign({}, parameter), { associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [], associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : [] });
                this.parameters.push(normalizedParameter);
                // Do some basic validation
                switch (normalizedParameter.parameterKind) {
                    case 'choice': {
                        const alternativeNames = normalizedParameter.alternatives.map((x) => x.name);
                        if (normalizedParameter.defaultValue &&
                            alternativeNames.indexOf(normalizedParameter.defaultValue) < 0) {
                            throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, the parameter "${normalizedParameter.longName}",` +
                                ` specifies a default value "${normalizedParameter.defaultValue}"` +
                                ` which is not one of the defined alternatives: "${alternativeNames.toString()}"`);
                        }
                        break;
                    }
                }
                let parameterHasAssociatedCommands = false;
                if (normalizedParameter.associatedCommands) {
                    for (const associatedCommandName of normalizedParameter.associatedCommands) {
                        const syntheticPhase = this._syntheticPhasesByTranslatedBulkCommandName.get(associatedCommandName);
                        if (syntheticPhase) {
                            // If this parameter was associated with a bulk command, include the association
                            // with the synthetic phase
                            normalizedParameter.associatedPhases.push(syntheticPhase.name);
                        }
                        const associatedCommand = this.commands.get(associatedCommandName);
                        if (!associatedCommand) {
                            throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                `that is associated with a command "${associatedCommandName}" that does not exist or does ` +
                                'not support custom parameters.');
                        }
                        else {
                            associatedCommand.associatedParameters.add(normalizedParameter);
                            parameterHasAssociatedCommands = true;
                        }
                    }
                }
                if (normalizedParameter.associatedPhases) {
                    for (const associatedPhaseName of normalizedParameter.associatedPhases) {
                        const associatedPhase = this.phases.get(associatedPhaseName);
                        if (!associatedPhase) {
                            throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                `that is associated with a phase "${associatedPhaseName}" that does not exist.`);
                        }
                    }
                }
                if (!parameterHasAssociatedCommands) {
                    throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}"` +
                        ` that lists no associated commands.`);
                }
                // In the presence of plugins, there is utility to defining parameters that are associated with a phased
                // command but no phases. Don't enforce that a parameter is associated with at least one phase.
            }
        }
    }
    /**
     * Performs a depth-first search to detect cycles in the directed graph of phase "self" dependencies.
     *
     * @param phase The phase node currently being checked
     * @param phasesInPath The current path from the start node to `phase`
     * @param cycleFreePhases Phases that have already been fully walked and confirmed to not be in any cycles
     */
    _checkForPhaseSelfCycles(phase, phasesInPath, cycleFreePhases) {
        if (cycleFreePhases.has(phase)) {
            // phase is known to not be reachable from itself, i.e. not in a cycle. Skip.
            return;
        }
        for (const dependency of phase.dependencies.self) {
            if (phasesInPath.has(dependency)) {
                throw new Error(`In ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename}, there exists a cycle within the ` +
                    `set of ${dependency.name} dependencies: ${Array.from(phasesInPath, (phaseInPath) => phaseInPath.name).join(', ')}`);
            }
            else {
                phasesInPath.add(dependency);
                this._checkForPhaseSelfCycles(dependency, phasesInPath, cycleFreePhases);
                phasesInPath.delete(dependency);
            }
        }
        // phase is not reachable from itself, mark for skipping
        cycleFreePhases.add(phase);
    }
    /**
     * Load the command-line.json configuration file from the specified path. Note that this
     * does not include the default build settings. This option is intended to be used to load
     * command-line.json files from plugins. To load a common/config/rush/command-line.json file,
     * use {@see loadFromFileOrDefault} instead.
     *
     * If the file does not exist, this function returns `undefined`
     */
    static tryLoadFromFile(jsonFilePath) {
        let commandLineJson;
        try {
            commandLineJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(jsonFilePath, CommandLineConfiguration._jsonSchema);
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        if (commandLineJson) {
            return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: true });
        }
        else {
            return undefined;
        }
    }
    /**
     * Loads the configuration from the specified file and applies any omitted default build
     * settings.  If the file does not exist, then a default instance is returned.
     * If the file contains errors, then an exception is thrown.
     */
    static loadFromFileOrDefault(jsonFilePath) {
        let commandLineJson = undefined;
        if (jsonFilePath) {
            try {
                commandLineJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.load(jsonFilePath);
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(e)) {
                    throw e;
                }
            }
            // merge commands specified in command-line.json and default (re)build settings
            // Ensure both build commands are included and preserve any other commands specified
            if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands) {
                for (let i = 0; i < commandLineJson.commands.length; i++) {
                    const command = commandLineJson.commands[i];
                    // Determine if we have a set of default parameters
                    let commandDefaultDefinition = {};
                    switch (command.commandKind) {
                        case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.phasedCommandKind:
                        case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bulkCommandKind: {
                            switch (command.name) {
                                case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.buildCommandName: {
                                    commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;
                                    break;
                                }
                                case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.rebuildCommandName: {
                                    commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    // Merge the default parameters into the repo-specified parameters
                    commandLineJson.commands[i] = Object.assign(Object.assign({}, commandDefaultDefinition), command);
                }
                CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilePath);
            }
        }
        return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: false });
    }
    prependAdditionalPathFolder(pathFolder) {
        this.additionalPathFolders.unshift(pathFolder);
    }
    /**
     * This function replaces colons (":") with underscores ("_").
     *
     * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.
     * Replacing colons with underscores produces a filesystem-safe name.
     */
    _normalizeNameForLogFilenameIdentifiers(name) {
        return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe
    }
    _translateBulkCommandToPhasedCommand(command) {
        const phaseName = command.name;
        const phase = {
            name: phaseName,
            isSynthetic: true,
            logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(command.name),
            associatedParameters: new Set(),
            dependencies: {
                self: new Set(),
                upstream: new Set()
            },
            missingScriptBehavior: command.ignoreMissingScript ? 'log' : 'error',
            allowWarningsOnSuccess: !!command.allowWarningsInSuccessfulBuild,
            shellCommand: command.shellCommand
        };
        if (!command.ignoreDependencyOrder) {
            phase.dependencies.upstream.add(phase);
        }
        this.phases.set(phaseName, phase);
        this._syntheticPhasesByTranslatedBulkCommandName.set(command.name, phase);
        const phases = new Set([phase]);
        const translatedCommand = Object.assign(Object.assign({}, command), { commandKind: 'phased', isSynthetic: true, associatedParameters: new Set(), phases, originalPhases: phases, 
            // Bulk commands used the same phases for watch as for regular execution. Preserve behavior.
            watchPhases: command.watchForChanges ? phases : new Set(), alwaysWatch: !!command.watchForChanges, alwaysInstall: undefined });
        return translatedCommand;
    }
}
CommandLineConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_command_line_schema_json__WEBPACK_IMPORTED_MODULE_2__);

//# sourceMappingURL=CommandLineConfiguration.js.map

/***/ }),

/***/ 989216:
/*!*******************************************************!*\
  !*** ./lib-esnext/api/CommonVersionsConfiguration.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommonVersionsConfiguration": () => (/* binding */ CommonVersionsConfiguration)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _PackageNameParsers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PackageNameParsers */ 644443);
/* harmony import */ var _logic_JsonSchemaUrls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logic/JsonSchemaUrls */ 866717);
/* harmony import */ var _schemas_common_versions_schema_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../schemas/common-versions.schema.json */ 355174);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






/**
 * Use this class to load and save the "common/config/rush/common-versions.json" config file.
 * This config file stores dependency version information that affects all projects in the repo.
 * @public
 */
class CommonVersionsConfiguration {
    constructor(commonVersionsJson, filePath) {
        this._modified = false;
        this._preferredVersions = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.ProtectableMap({
            onSet: this._onSetPreferredVersions.bind(this)
        });
        this.preferredVersions = this._preferredVersions.protectedView;
        if (commonVersionsJson && commonVersionsJson.implicitlyPreferredVersions !== undefined) {
            this.implicitlyPreferredVersions = commonVersionsJson.implicitlyPreferredVersions;
        }
        else {
            this.implicitlyPreferredVersions = undefined;
        }
        this._allowedAlternativeVersions = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.ProtectableMap({
            onSet: this._onSetAllowedAlternativeVersions.bind(this)
        });
        this.allowedAlternativeVersions = this._allowedAlternativeVersions.protectedView;
        if (commonVersionsJson) {
            try {
                CommonVersionsConfiguration._deserializeTable(this.preferredVersions, commonVersionsJson.preferredVersions);
                CommonVersionsConfiguration._deserializeTable(this.allowedAlternativeVersions, commonVersionsJson.allowedAlternativeVersions);
            }
            catch (e) {
                throw new Error(`Error loading "${path__WEBPACK_IMPORTED_MODULE_1__.basename(filePath)}": ${e.message}`);
            }
        }
        this.filePath = filePath;
    }
    /**
     * Loads the common-versions.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     */
    static loadFromFile(jsonFilename) {
        let commonVersionsJson = undefined;
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(jsonFilename)) {
            commonVersionsJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.loadAndValidate(jsonFilename, CommonVersionsConfiguration._jsonSchema);
        }
        return new CommonVersionsConfiguration(commonVersionsJson, jsonFilename);
    }
    static _deserializeTable(map, object) {
        if (object) {
            for (const [key, value] of Object.entries(object)) {
                map.set(key, value);
            }
        }
    }
    static _serializeTable(map) {
        const table = {};
        const keys = [...map.keys()];
        keys.sort();
        for (const key of keys) {
            table[key] = map.get(key);
        }
        return table;
    }
    /**
     * Get a sha1 hash of the preferred versions.
     */
    getPreferredVersionsHash() {
        // Sort so that the hash is stable
        const orderedPreferredVersions = new Map(this._preferredVersions.protectedView);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Sort.sortMapKeys(orderedPreferredVersions);
        // JSON.stringify does not support maps, so we need to convert to an object first
        const preferredVersionsObj = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.MapExtensions.toObject(orderedPreferredVersions);
        return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(JSON.stringify(preferredVersionsObj)).digest('hex');
    }
    /**
     * Writes the "common-versions.json" file to disk, using the filename that was passed to loadFromFile().
     */
    save() {
        if (this._modified) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.save(this._serialize(), this.filePath, { updateExistingFile: true });
            this._modified = false;
            return true;
        }
        return false;
    }
    /**
     * Returns preferredVersions.
     */
    getAllPreferredVersions() {
        const allPreferredVersions = new Map();
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.MapExtensions.mergeFromMap(allPreferredVersions, this.preferredVersions);
        return allPreferredVersions;
    }
    _onSetPreferredVersions(source, key, value) {
        _PackageNameParsers__WEBPACK_IMPORTED_MODULE_3__.PackageNameParsers.permissive.validate(key);
        this._modified = true;
        return value;
    }
    _onSetAllowedAlternativeVersions(source, key, value) {
        _PackageNameParsers__WEBPACK_IMPORTED_MODULE_3__.PackageNameParsers.permissive.validate(key);
        this._modified = true;
        return value;
    }
    _serialize() {
        const result = {
            $schema: _logic_JsonSchemaUrls__WEBPACK_IMPORTED_MODULE_4__.JsonSchemaUrls.commonVersions
        };
        if (this._preferredVersions.size) {
            result.preferredVersions = CommonVersionsConfiguration._serializeTable(this.preferredVersions);
        }
        if (this._allowedAlternativeVersions.size) {
            result.allowedAlternativeVersions = CommonVersionsConfiguration._serializeTable(this.allowedAlternativeVersions);
        }
        return result;
    }
}
CommonVersionsConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonSchema.fromLoadedObject(_schemas_common_versions_schema_json__WEBPACK_IMPORTED_MODULE_5__);

//# sourceMappingURL=CommonVersionsConfiguration.js.map

/***/ }),

/***/ 268756:
/*!***************************************************!*\
  !*** ./lib-esnext/api/CustomTipsConfiguration.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomTipId": () => (/* binding */ CustomTipId),
/* harmony export */   "CustomTipSeverity": () => (/* binding */ CustomTipSeverity),
/* harmony export */   "CustomTipType": () => (/* binding */ CustomTipType),
/* harmony export */   "CustomTipsConfiguration": () => (/* binding */ CustomTipsConfiguration),
/* harmony export */   "PNPM_CUSTOM_TIPS": () => (/* binding */ PNPM_CUSTOM_TIPS),
/* harmony export */   "RUSH_CUSTOM_TIPS": () => (/* binding */ RUSH_CUSTOM_TIPS)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _schemas_custom_tips_schema_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../schemas/custom-tips.schema.json */ 501107);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * An identifier representing a Rush message that can be customized by
 * defining a custom tip in `common/config/rush/custom-tips.json`.
 * @remarks
 * Custom tip ids always start with the `TIP_` prefix.
 *
 * @privateRemarks
 * Events from the Rush process should with "TIP_RUSH_".
 * Events from a PNPM subprocess should start with "TIP_PNPM_".
 *
 * @beta
 */
var CustomTipId;
(function (CustomTipId) {
    CustomTipId["TIP_RUSH_INCONSISTENT_VERSIONS"] = "TIP_RUSH_INCONSISTENT_VERSIONS";
    CustomTipId["TIP_PNPM_UNEXPECTED_STORE"] = "TIP_PNPM_UNEXPECTED_STORE";
    CustomTipId["TIP_PNPM_NO_MATCHING_VERSION"] = "TIP_PNPM_NO_MATCHING_VERSION";
    CustomTipId["TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE"] = "TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE";
    CustomTipId["TIP_PNPM_PEER_DEP_ISSUES"] = "TIP_PNPM_PEER_DEP_ISSUES";
    CustomTipId["TIP_PNPM_OUTDATED_LOCKFILE"] = "TIP_PNPM_OUTDATED_LOCKFILE";
    CustomTipId["TIP_PNPM_TARBALL_INTEGRITY"] = "TIP_PNPM_TARBALL_INTEGRITY";
    CustomTipId["TIP_PNPM_MISMATCHED_RELEASE_CHANNEL"] = "TIP_PNPM_MISMATCHED_RELEASE_CHANNEL";
    CustomTipId["TIP_PNPM_INVALID_NODE_VERSION"] = "TIP_PNPM_INVALID_NODE_VERSION";
})(CustomTipId || (CustomTipId = {}));
/**
 * The severity of a custom tip.
 * It determines the printing severity ("Error" = red, "Warning" = yellow, "Info" = normal).
 *
 * @beta
 */
var CustomTipSeverity;
(function (CustomTipSeverity) {
    CustomTipSeverity["Warning"] = "Warning";
    CustomTipSeverity["Error"] = "Error";
    CustomTipSeverity["Info"] = "Info";
})(CustomTipSeverity || (CustomTipSeverity = {}));
/**
 * The type of the custom tip.
 *
 * @remarks
 * There might be types like `git` in the future.
 *
 * @beta
 */
var CustomTipType;
(function (CustomTipType) {
    CustomTipType["rush"] = "rush";
    CustomTipType["pnpm"] = "pnpm";
})(CustomTipType || (CustomTipType = {}));
const RUSH_CUSTOM_TIPS = {
    [CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS]: {
        tipId: CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.rush
    }
};
const PNPM_CUSTOM_TIPS = {
    [CustomTipId.TIP_PNPM_UNEXPECTED_STORE]: {
        tipId: CustomTipId.TIP_PNPM_UNEXPECTED_STORE,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            return str.includes('ERR_PNPM_UNEXPECTED_STORE');
        }
    },
    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION]: {
        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            // Example message: (do notice the difference between this one and the TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE)
            // Error Message: ERR_PNPM_NO_MATCHING_VERSION No matching version found for @babel/types@^7.22.5
            // The latest release of @babel/types is "7.22.4".
            // Other releases are:
            // * esm: 7.21.4-esm.4
            return str.includes('No matching version found for') && str.includes('The latest release of');
        }
    },
    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE]: {
        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            return str.includes('ERR_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE');
        }
    },
    [CustomTipId.TIP_PNPM_PEER_DEP_ISSUES]: {
        tipId: CustomTipId.TIP_PNPM_PEER_DEP_ISSUES,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            return str.includes('ERR_PNPM_PEER_DEP_ISSUES');
        }
    },
    [CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE]: {
        tipId: CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            // Todo: verify this
            return str.includes('ERR_PNPM_OUTDATED_LOCKFILE');
        }
    },
    [CustomTipId.TIP_PNPM_TARBALL_INTEGRITY]: {
        tipId: CustomTipId.TIP_PNPM_TARBALL_INTEGRITY,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            // Todo: verify this
            return str.includes('ERR_PNPM_TARBALL_INTEGRITY');
        }
    },
    [CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL]: {
        tipId: CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            // Todo: verify this
            return str.includes('ERR_PNPM_MISMATCHED_RELEASE_CHANNEL');
        }
    },
    [CustomTipId.TIP_PNPM_INVALID_NODE_VERSION]: {
        tipId: CustomTipId.TIP_PNPM_INVALID_NODE_VERSION,
        severity: CustomTipSeverity.Error,
        type: CustomTipType.pnpm,
        isMatch: (str) => {
            // Todo: verify this
            return str.includes('ERR_PNPM_INVALID_NODE_VERSION');
        }
    }
};
/**
 * Used to access the `common/config/rush/custom-tips.json` config file,
 * which allows repo maintainers to configure extra details to be printed alongside
 * certain Rush messages.
 * @beta
 */
class CustomTipsConfiguration {
    constructor(configFilePath) {
        const providedCustomTips = new Map();
        let configuration;
        try {
            configuration = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.loadAndValidate(configFilePath, CustomTipsConfiguration._jsonSchema);
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        const customTips = configuration === null || configuration === void 0 ? void 0 : configuration.customTips;
        if (customTips) {
            for (const tipItem of customTips) {
                if (!(tipItem.tipId in CustomTipId)) {
                    throw new Error(`The ${path__WEBPACK_IMPORTED_MODULE_0__.basename(configFilePath)} configuration` +
                        ` references an unknown ID "${tipItem.tipId}"`);
                }
                if (providedCustomTips.has(tipItem.tipId)) {
                    throw new Error(`The ${path__WEBPACK_IMPORTED_MODULE_0__.basename(configFilePath)} configuration` +
                        ` specifies a duplicate definition for "${tipItem.tipId}"`);
                }
                else {
                    providedCustomTips.set(tipItem.tipId, tipItem);
                }
            }
        }
        this.providedCustomTipsByTipId = providedCustomTips;
    }
    /**
     * If custom-tips.json defines a tip for the specified tipId,
     * display the tip on the terminal.
     *
     * @remarks
     * The severity of the tip is defined in ${@link CustomTipsConfiguration.customTipRegistry}.
     * If you want to change the severity specifically for this call, use other API like {@link CustomTipsConfiguration._showErrorTip}.
     *
     * @internal
     */
    _showTip(terminal, tipId) {
        const severityOfOriginalMessage = CustomTipsConfiguration.customTipRegistry[tipId].severity;
        this._writeMessageWithPipes(terminal, severityOfOriginalMessage, tipId);
    }
    /**
     * If custom-tips.json defines a tip for the specified tipId,
     * display the tip on the terminal.
     * @internal
     */
    _showInfoTip(terminal, tipId) {
        this._writeMessageWithPipes(terminal, CustomTipSeverity.Info, tipId);
    }
    /**
     * If custom-tips.json defines a tip for the specified tipId,
     * display the tip on the terminal.
     * @internal
     */
    _showWarningTip(terminal, tipId) {
        this._writeMessageWithPipes(terminal, CustomTipSeverity.Warning, tipId);
    }
    /**
     * If custom-tips.json defines a tip for the specified tipId,
     * display the tip on the terminal.
     * @internal
     */
    _showErrorTip(terminal, tipId) {
        this._writeMessageWithPipes(terminal, CustomTipSeverity.Error, tipId);
    }
    _writeMessageWithPipes(terminal, severity, tipId) {
        const customTipJsonItem = this.providedCustomTipsByTipId.get(tipId);
        if (customTipJsonItem) {
            let writeFunction;
            switch (severity) {
                case CustomTipSeverity.Error:
                    writeFunction = terminal.writeErrorLine.bind(terminal);
                    break;
                case CustomTipSeverity.Warning:
                    writeFunction = terminal.writeWarningLine.bind(terminal);
                    break;
                default:
                    writeFunction = terminal.writeLine.bind(terminal);
                    break;
            }
            writeFunction(`| Custom Tip (${tipId})`);
            writeFunction('|');
            const message = customTipJsonItem.message;
            const wrappedAndIndentedMessage = _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(message, undefined, '| ');
            writeFunction(wrappedAndIndentedMessage);
            terminal.writeLine();
        }
    }
}
CustomTipsConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonSchema.fromLoadedObject(_schemas_custom_tips_schema_json__WEBPACK_IMPORTED_MODULE_3__);
/**
 * A registry mapping custom tip IDs to their corresponding metadata.
 *
 * @remarks
 * This registry is used to look up metadata for custom tips based on their IDs. The metadata includes
 * information such as the severity level, the type of tip, and an optional matching function.
 *
 * Each key in the registry corresponds to a `CustomTipIdEnum` value, and each value is an object
 * implementing the `ICustomTipInfo` interface.
 *
 * @example
 * ```typescript
 * const tipInfo = CustomTipsConfiguration.customTipRegistry[CustomTipIdEnum.TIP_RUSH_INCONSISTENT_VERSIONS];
 * console.log(tipInfo.severity);  // Output: CustomTipSeverity.Error
 * ```
 *
 * See {@link CustomTipId} for the list of custom tip IDs.
 * See {@link ICustomTipInfo} for the structure of the metadata.
 */
CustomTipsConfiguration.customTipRegistry = Object.assign(Object.assign({}, RUSH_CUSTOM_TIPS), PNPM_CUSTOM_TIPS);

//# sourceMappingURL=CustomTipsConfiguration.js.map

/***/ }),

/***/ 382806:
/*!****************************************************!*\
  !*** ./lib-esnext/api/EnvironmentConfiguration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnvironmentConfiguration": () => (/* binding */ EnvironmentConfiguration),
/* harmony export */   "EnvironmentVariableNames": () => (/* binding */ EnvironmentVariableNames)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! true-case-path */ 477156);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(true_case_path__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * Names of environment variables used by Rush.
 * @beta
 */
// eslint-disable-next-line @typescript-eslint/typedef
const EnvironmentVariableNames = {
    /**
     * This variable overrides the temporary folder used by Rush.
     * The default value is "common/temp" under the repository root.
     *
     * @remarks This environment variable is not compatible with workspace installs. If attempting
     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.
     */
    RUSH_TEMP_FOLDER: 'RUSH_TEMP_FOLDER',
    /**
     * This variable overrides the version of Rush that will be installed by
     * the version selector.  The default value is determined by the "rushVersion"
     * field from rush.json.
     */
    RUSH_PREVIEW_VERSION: 'RUSH_PREVIEW_VERSION',
    /**
     * If this variable is set to "1", Rush will not fail the build when running a version
     * of Node that does not match the criteria specified in the "nodeSupportedVersionRange"
     * field from rush.json.
     */
    RUSH_ALLOW_UNSUPPORTED_NODEJS: 'RUSH_ALLOW_UNSUPPORTED_NODEJS',
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: 'RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD',
    /**
     * This variable selects a specific installation variant for Rush to use when installing
     * and linking package dependencies.
     * For more information, see the command-line help for the `--variant` parameter
     * and this article:  https://rushjs.io/pages/advanced/installation_variants/
     */
    RUSH_VARIANT: 'RUSH_VARIANT',
    /**
     * Specifies the maximum number of concurrent processes to launch during a build.
     * For more information, see the command-line help for the `--parallelism` parameter for "rush build".
     */
    RUSH_PARALLELISM: 'RUSH_PARALLELISM',
    /**
     * If this variable is set to "1", Rush will create symlinks with absolute paths instead
     * of relative paths. This can be necessary when a repository is moved during a build or
     * if parts of a repository are moved into a sandbox.
     */
    RUSH_ABSOLUTE_SYMLINKS: 'RUSH_ABSOLUTE_SYMLINKS',
    /**
     * When using PNPM as the package manager, this variable can be used to configure the path that
     * PNPM will use as the store directory.
     *
     * If a relative path is used, then the store path will be resolved relative to the process's
     * current working directory.  An absolute path is recommended.
     */
    RUSH_PNPM_STORE_PATH: 'RUSH_PNPM_STORE_PATH',
    /**
     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM
     * validates the integrity of the PNPM store during installation. The value of this environment variable must be
     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.
     */
    RUSH_PNPM_VERIFY_STORE_INTEGRITY: 'RUSH_PNPM_VERIFY_STORE_INTEGRITY',
    /**
     * This environment variable can be used to specify the `--target-folder` parameter
     * for the "rush deploy" command.
     */
    RUSH_DEPLOY_TARGET_FOLDER: 'RUSH_DEPLOY_TARGET_FOLDER',
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows
     * group policy forbids executing scripts installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    RUSH_GLOBAL_FOLDER: 'RUSH_GLOBAL_FOLDER',
    /**
     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.
     *
     * @remarks
     * Setting this environment variable overrides whatever credential has been saved in the
     * local cloud cache credentials using `rush update-cloud-credentials`.
     *
     *
     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query
     * parameters.
     *
     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview
     */
    RUSH_BUILD_CACHE_CREDENTIAL: 'RUSH_BUILD_CACHE_CREDENTIAL',
    /**
     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`
     * configuration file.
     *
     * @remarks
     * Specify `1` to enable the build cache or `0` to disable it.
     *
     * If there is no build cache configured, then this environment variable is ignored.
     */
    RUSH_BUILD_CACHE_ENABLED: 'RUSH_BUILD_CACHE_ENABLED',
    /**
     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this
     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then
     * this environment variable is ignored.
     */
    RUSH_BUILD_CACHE_WRITE_ALLOWED: 'RUSH_BUILD_CACHE_WRITE_ALLOWED',
    /**
     * Setting this environment variable opts into running with cobuilds. The context id should be the same across
     * multiple VMs, but changed when it is a new round of cobuilds.
     *
     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.
     *
     * @remarks
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    RUSH_COBUILD_CONTEXT_ID: 'RUSH_COBUILD_CONTEXT_ID',
    /**
     * Explicitly specifies a name for each participating cobuild runner.
     *
     * Setting this environment variable opts into running with cobuilds.
     *
     * @remarks
     * This environment variable is optional, if it is not provided, a random id is used.
     *
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    RUSH_COBUILD_RUNNER_ID: 'RUSH_COBUILD_RUNNER_ID',
    /**
     * If this variable is set to "1", When getting distributed builds, Rush will automatically handle the leaf project
     * with build cache "disabled" by writing to the cache in a special "log files only mode". This is useful when you
     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.
     */
    RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: 'RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED',
    /**
     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.
     */
    RUSH_GIT_BINARY_PATH: 'RUSH_GIT_BINARY_PATH',
    /**
     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.
     */
    RUSH_TAR_BINARY_PATH: 'RUSH_TAR_BINARY_PATH',
    /**
     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.
     * Will be set upon loading Rush.
     */
    RUSH_LIB_PATH: '_RUSH_LIB_PATH',
    /**
     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or
     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned
     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.
     *
     * @remarks
     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers
     * assign when they execute lifecycle scripts.
     */
    RUSH_INVOKED_FOLDER: 'RUSH_INVOKED_FOLDER'
};
/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 * @beta
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
class EnvironmentConfiguration {
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushTempFolderOverride;
    }
    /**
     * If "1", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._absoluteSymlinks;
    }
    /**
     * If this environment variable is set to "1", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowUnsupportedNodeVersion;
    }
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    static get allowWarningsInSuccessfulBuild() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;
    }
    /**
     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'
     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}
     */
    static get pnpmStorePathOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._pnpmStorePathOverride;
    }
    /**
     * If specified, enables or disables integrity verification of the pnpm store during install.
     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}
     */
    static get pnpmVerifyStoreIntegrity() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._pnpmVerifyStoreIntegrity;
    }
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}
     */
    static get rushGlobalFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushGlobalFolderOverride;
    }
    /**
     * Provides a credential for reading from and writing to a remote build cache, if configured.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}
     */
    static get buildCacheCredential() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheCredential;
    }
    /**
     * If set, enables or disables the cloud build cache feature.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}
     */
    static get buildCacheEnabled() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheEnabled;
    }
    /**
     * If set, enables or disables writing to the cloud build cache.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}
     */
    static get buildCacheWriteAllowed() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheWriteAllowed;
    }
    /**
     * Provides a determined cobuild context id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}
     */
    static get cobuildContextId() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildContextId;
    }
    /**
     * Provides a determined cobuild runner id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}
     */
    static get cobuildRunnerId() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildRunnerId;
    }
    /**
     * If set, enables or disables the cobuild leaf project log only feature.
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}
     */
    static get cobuildLeafProjectLogOnlyAllowed() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed;
    }
    /**
     * Allows the git binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}
     */
    static get gitBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._gitBinaryPath;
    }
    /**
     * Allows the tar binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}
     */
    static get tarBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._tarBinaryPath;
    }
    /**
     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before
     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`
     * is even installed). Thus we need to read this environment variable differently from all the others.
     * @internal
     */
    static _getRushGlobalFolderOverride(processEnv) {
        const value = processEnv[EnvironmentVariableNames.RUSH_GLOBAL_FOLDER];
        if (value) {
            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);
            return normalizedValue;
        }
    }
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static validate(options = {}) {
        var _a, _b, _c;
        EnvironmentConfiguration.reset();
        const unknownEnvVariables = [];
        for (const envVarName in process.env) {
            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {
                const value = process.env[envVarName];
                // Environment variables are only case-insensitive on Windows
                const normalizedEnvVarName = os__WEBPACK_IMPORTED_MODULE_0__.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;
                switch (normalizedEnvVarName) {
                    case EnvironmentVariableNames.RUSH_TEMP_FOLDER: {
                        EnvironmentConfiguration._rushTempFolderOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS: {
                        EnvironmentConfiguration._absoluteSymlinks =
                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS, value)) !== null && _a !== void 0 ? _a : false;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS: {
                        if (value === 'true' || value === 'false') {
                            // Small, undocumented acceptance of old "true" and "false" values for
                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.
                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';
                        }
                        else {
                            EnvironmentConfiguration._allowUnsupportedNodeVersion =
                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS, value)) !== null && _b !== void 0 ? _b : false;
                        }
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: {
                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =
                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD, value)) !== null && _c !== void 0 ? _c : false;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PNPM_STORE_PATH: {
                        EnvironmentConfiguration._pnpmStorePathOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY: {
                        EnvironmentConfiguration._pnpmVerifyStoreIntegrity =
                            value === '1' ? true : value === '0' ? false : undefined;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_GLOBAL_FOLDER: {
                        // Handled specially below
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL: {
                        EnvironmentConfiguration._buildCacheCredential = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED: {
                        EnvironmentConfiguration._buildCacheEnabled =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED: {
                        EnvironmentConfiguration._buildCacheWriteAllowed =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID: {
                        EnvironmentConfiguration._cobuildContextId = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID: {
                        EnvironmentConfiguration._cobuildRunnerId = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: {
                        EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_GIT_BINARY_PATH: {
                        EnvironmentConfiguration._gitBinaryPath = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_TAR_BINARY_PATH: {
                        EnvironmentConfiguration._tarBinaryPath = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PARALLELISM:
                    case EnvironmentVariableNames.RUSH_PREVIEW_VERSION:
                    case EnvironmentVariableNames.RUSH_VARIANT:
                    case EnvironmentVariableNames.RUSH_DEPLOY_TARGET_FOLDER:
                        // Handled by @microsoft/rush front end
                        break;
                    case EnvironmentVariableNames.RUSH_INVOKED_FOLDER:
                    case EnvironmentVariableNames.RUSH_LIB_PATH:
                        // Assigned by Rush itself
                        break;
                    default:
                        unknownEnvVariables.push(envVarName);
                        break;
                }
            }
        }
        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.
        if (unknownEnvVariables.length > 0) {
            throw new Error('The following environment variables were found with the "RUSH_" prefix, but they are not ' +
                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);
        }
        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().
        EnvironmentConfiguration._rushGlobalFolderOverride =
            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        EnvironmentConfiguration._hasBeenValidated = true;
    }
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset() {
        EnvironmentConfiguration._rushTempFolderOverride = undefined;
        EnvironmentConfiguration._hasBeenValidated = false;
    }
    static _ensureValidated() {
        if (!EnvironmentConfiguration._hasBeenValidated) {
            EnvironmentConfiguration.validate();
        }
    }
    static parseBooleanEnvironmentVariable(name, value) {
        if (value === '' || value === undefined) {
            return undefined;
        }
        else if (value === '0') {
            return false;
        }
        else if (value === '1') {
            return true;
        }
        else {
            throw new Error(`Invalid value "${value}" for the environment variable ${name}. Valid choices are 0 or 1.`);
        }
    }
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: `C:\Folder1\folder2\`
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    static _normalizeDeepestParentFolderPath(folderPath) {
        folderPath = path__WEBPACK_IMPORTED_MODULE_1__.normalize(folderPath);
        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path__WEBPACK_IMPORTED_MODULE_1__.sep;
        const parsedPath = path__WEBPACK_IMPORTED_MODULE_1__.parse(folderPath);
        const pathRoot = parsedPath.root;
        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);
        const pathParts = [...pathWithoutRoot.split(path__WEBPACK_IMPORTED_MODULE_1__.sep), parsedPath.name].filter((part) => !!part);
        // Starting with all path sections, and eliminating one from the end during each loop iteration,
        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset
        // of the path that exists and we've now gotten the correct casing.
        //
        // Once we've found a parent folder that exists, append the path sections that didn't exist.
        for (let i = pathParts.length; i >= 0; i--) {
            const constructedPath = path__WEBPACK_IMPORTED_MODULE_1__.join(pathRoot, ...pathParts.slice(0, i));
            try {
                const normalizedConstructedPath = (0,true_case_path__WEBPACK_IMPORTED_MODULE_2__.trueCasePathSync)(constructedPath);
                const result = path__WEBPACK_IMPORTED_MODULE_1__.join(normalizedConstructedPath, ...pathParts.slice(i));
                if (endsWithSlash) {
                    return `${result}${path__WEBPACK_IMPORTED_MODULE_1__.sep}`;
                }
                else {
                    return result;
                }
            }
            catch (e) {
                // This path doesn't exist, continue to the next subpath
            }
        }
        return undefined;
    }
}
EnvironmentConfiguration._hasBeenValidated = false;
EnvironmentConfiguration._absoluteSymlinks = false;
EnvironmentConfiguration._allowUnsupportedNodeVersion = false;
EnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;

//# sourceMappingURL=EnvironmentConfiguration.js.map

/***/ }),

/***/ 519005:
/*!**************************************!*\
  !*** ./lib-esnext/api/EventHooks.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "EventHooks": () => (/* binding */ EventHooks)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Events happen during Rush runs.
 * @beta
 */
var Event;
(function (Event) {
    /**
     * Pre Rush install event
     */
    Event[Event["preRushInstall"] = 1] = "preRushInstall";
    /**
     * Post Rush install event
     */
    Event[Event["postRushInstall"] = 2] = "postRushInstall";
    /**
     * Pre Rush build event
     */
    Event[Event["preRushBuild"] = 3] = "preRushBuild";
    /**
     * Post Rush build event
     */
    Event[Event["postRushBuild"] = 4] = "postRushBuild";
})(Event || (Event = {}));
/**
 * This class represents Rush event hooks configured for this repo.
 * Hooks are customized script actions that Rush executes when specific events occur.
 * The actions are expressed as a command-line that is executed using the operating system shell.
 * @beta
 */
class EventHooks {
    /**
     * @internal
     */
    constructor(eventHooksJson) {
        this._hooks = new Map();
        for (const [name, eventHooks] of Object.entries(eventHooksJson)) {
            const eventName = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Enum.tryGetValueByKey(Event, name);
            if (eventName) {
                this._hooks.set(eventName, [...eventHooks] || []);
            }
        }
    }
    /**
     * Return all the scripts associated with the specified event.
     * @param event - Rush event
     */
    get(event) {
        return this._hooks.get(event) || [];
    }
}
//# sourceMappingURL=EventHooks.js.map

/***/ }),

/***/ 259205:
/*!****************************************************!*\
  !*** ./lib-esnext/api/ExperimentsConfiguration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExperimentsConfiguration": () => (/* binding */ ExperimentsConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _schemas_experiments_schema_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../schemas/experiments.schema.json */ 329717);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Use this class to load the "common/config/rush/experiments.json" config file.
 * This file allows repo maintainers to enable and disable experimental Rush features.
 * @public
 */
class ExperimentsConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this.configuration = {};
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(this._jsonFileName)) {
            this.configuration = {};
        }
        else {
            this.configuration = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(this._jsonFileName, ExperimentsConfiguration._jsonSchema);
        }
    }
}
ExperimentsConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_experiments_schema_json__WEBPACK_IMPORTED_MODULE_1__);

//# sourceMappingURL=ExperimentsConfiguration.js.map

/***/ }),

/***/ 919846:
/*!*******************************************!*\
  !*** ./lib-esnext/api/LastInstallFlag.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LAST_INSTALL_FLAG_FILE_NAME": () => (/* binding */ LAST_INSTALL_FLAG_FILE_NAME),
/* harmony export */   "LastInstallFlag": () => (/* binding */ LastInstallFlag),
/* harmony export */   "LastInstallFlagFactory": () => (/* binding */ LastInstallFlagFactory)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



const LAST_INSTALL_FLAG_FILE_NAME = 'last-install.flag';
/**
 * A helper class for managing last-install flags, which are persistent and
 * indicate that something installed in the folder was successfully completed.
 * It also compares state, so that if something like the Node.js version has changed,
 * it can invalidate the last install.
 * @internal
 */
class LastInstallFlag {
    /**
     * Creates a new LastInstall flag
     * @param folderPath - the folder that this flag is managing
     * @param state - optional, the state that should be managed or compared
     */
    constructor(folderPath, state = {}) {
        this.path = path__WEBPACK_IMPORTED_MODULE_0__.join(folderPath, this.flagName);
        this._state = state;
    }
    /**
     * Returns true if the file exists and the contents match the current state.
     */
    isValid(options) {
        return this._isValid(false, options);
    }
    /**
     * Same as isValid(), but with an additional check:  If the current state is not equal to the previous
     * state, and an the current state causes an error, then throw an exception with a friendly message.
     *
     * @internal
     */
    checkValidAndReportStoreIssues(options) {
        return this._isValid(true, options);
    }
    _isValid(checkValidAndReportStoreIssues, { rushVerb = 'update', statePropertiesToIgnore } = {}) {
        let oldState;
        try {
            oldState = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.load(this.path);
        }
        catch (err) {
            return false;
        }
        const newState = Object.assign({}, this._state);
        if (statePropertiesToIgnore) {
            for (const optionToIgnore of statePropertiesToIgnore) {
                delete newState[optionToIgnore];
                delete oldState[optionToIgnore];
            }
        }
        if (!(0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_2__.objectsAreDeepEqual)(oldState, newState)) {
            if (checkValidAndReportStoreIssues) {
                const pkgManager = newState.packageManager;
                if (pkgManager === 'pnpm') {
                    if (
                    // Only throw an error if the package manager hasn't changed from PNPM
                    oldState.packageManager === pkgManager) {
                        const normalizedOldStorePath = oldState.storePath
                            ? _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Path.convertToPlatformDefault(oldState.storePath)
                            : '<global>';
                        const normalizedNewStorePath = newState.storePath
                            ? _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Path.convertToPlatformDefault(newState.storePath)
                            : '<global>';
                        if (
                        // Throw if the store path changed
                        normalizedOldStorePath !== normalizedNewStorePath) {
                            throw new Error('Current PNPM store path does not match the last one used. This may cause inconsistency in your builds.\n\n' +
                                `If you wish to install with the new store path, please run "rush ${rushVerb} --purge"\n\n` +
                                `Old Path: ${normalizedOldStorePath}\n` +
                                `New Path: ${normalizedNewStorePath}`);
                        }
                    }
                }
            }
            return false;
        }
        return true;
    }
    /**
     * Writes the flag file to disk with the current state
     */
    create() {
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.save(this._state, this.path, {
            ensureFolderExists: true
        });
    }
    /**
     * Removes the flag file
     */
    clear() {
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.deleteFile(this.path);
    }
    /**
     * Returns the name of the flag file
     */
    get flagName() {
        return LAST_INSTALL_FLAG_FILE_NAME;
    }
}
/**
 * A helper class for LastInstallFlag
 *
 * @internal
 */
class LastInstallFlagFactory {
    /**
     * Gets the LastInstall flag and sets the current state. This state is used to compare
     * against the last-known-good state tracked by the LastInstall flag.
     * @param rushConfiguration - the configuration of the Rush repo to get the install
     * state from
     *
     * @internal
     */
    static getCommonTempFlag(rushConfiguration, extraState = {}) {
        const currentState = Object.assign({ node: process.versions.node, packageManager: rushConfiguration.packageManager, packageManagerVersion: rushConfiguration.packageManagerToolVersion, rushJsonFolder: rushConfiguration.rushJsonFolder }, extraState);
        if (currentState.packageManager === 'pnpm' && rushConfiguration.pnpmOptions) {
            currentState.storePath = rushConfiguration.pnpmOptions.pnpmStorePath;
            if (rushConfiguration.pnpmOptions.useWorkspaces) {
                currentState.workspaces = rushConfiguration.pnpmOptions.useWorkspaces;
            }
        }
        return new LastInstallFlag(rushConfiguration.commonTempFolder, currentState);
    }
}
//# sourceMappingURL=LastInstallFlag.js.map

/***/ }),

/***/ 986208:
/*!****************************************!*\
  !*** ./lib-esnext/api/LastLinkFlag.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LAST_LINK_FLAG_FILE_NAME": () => (/* binding */ LAST_LINK_FLAG_FILE_NAME),
/* harmony export */   "LastLinkFlag": () => (/* binding */ LastLinkFlag),
/* harmony export */   "LastLinkFlagFactory": () => (/* binding */ LastLinkFlagFactory)
/* harmony export */ });
/* harmony import */ var _LastInstallFlag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LastInstallFlag */ 919846);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


const LAST_LINK_FLAG_FILE_NAME = 'last-link.flag';
/**
 * A helper class for managing the last-link flag, which is persistent and
 * indicates that linking was completed successfully.
 * @internal
 */
class LastLinkFlag extends _LastInstallFlag__WEBPACK_IMPORTED_MODULE_1__.LastInstallFlag {
    /**
     * @override
     */
    isValid() {
        let oldState;
        try {
            oldState = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.load(this.path);
        }
        catch (err) {
            // Swallow error
        }
        return !!oldState;
    }
    /**
     * @override
     */
    checkValidAndReportStoreIssues() {
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Not implemented');
    }
    /**
     * Returns the name of the flag file
     *
     * @override
     */
    get flagName() {
        return LAST_LINK_FLAG_FILE_NAME;
    }
}
/**
 * A helper class for LastLinkFlag
 *
 * @internal
 */
class LastLinkFlagFactory {
    /**
     * Gets the LastLink flag and sets the current state. This state is used to compare
     * against the last-known-good state tracked by the LastLink flag.
     * @param rushConfiguration - the configuration of the Rush repo to get the install
     * state from
     *
     * @internal
     */
    static getCommonTempFlag(rushConfiguration) {
        return new LastLinkFlag(rushConfiguration.commonTempFolder, {});
    }
}
//# sourceMappingURL=LastLinkFlag.js.map

/***/ }),

/***/ 73666:
/*!*********************************************!*\
  !*** ./lib-esnext/api/PackageJsonEditor.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyType": () => (/* binding */ DependencyType),
/* harmony export */   "PackageJsonDependency": () => (/* binding */ PackageJsonDependency),
/* harmony export */   "PackageJsonEditor": () => (/* binding */ PackageJsonEditor)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * @public
 */
var DependencyType;
(function (DependencyType) {
    DependencyType["Regular"] = "dependencies";
    DependencyType["Dev"] = "devDependencies";
    DependencyType["Optional"] = "optionalDependencies";
    DependencyType["Peer"] = "peerDependencies";
    DependencyType["YarnResolutions"] = "resolutions";
})(DependencyType || (DependencyType = {}));
/**
 * @public
 */
class PackageJsonDependency {
    constructor(name, version, type, onChange) {
        this.name = name;
        this._version = version;
        this.dependencyType = type;
        this._onChange = onChange;
    }
    get version() {
        return this._version;
    }
    setVersion(newVersion) {
        if (!semver__WEBPACK_IMPORTED_MODULE_0__.valid(newVersion) && !semver__WEBPACK_IMPORTED_MODULE_0__.validRange(newVersion)) {
            throw new Error(`Cannot set version to invalid value: "${newVersion}"`);
        }
        this._version = newVersion;
        this._onChange();
    }
}
/**
 * @public
 */
class PackageJsonEditor {
    /**
     * @internal
     */
    constructor(filepath, data) {
        this.filePath = filepath;
        this._sourceData = data;
        this._modified = false;
        this._dependencies = new Map();
        this._devDependencies = new Map();
        this._resolutions = new Map();
        const dependencies = data.dependencies || {};
        const optionalDependencies = data.optionalDependencies || {};
        const peerDependencies = data.peerDependencies || {};
        const devDependencies = data.devDependencies || {};
        const resolutions = data.resolutions || {};
        const _onChange = this._onChange.bind(this);
        try {
            Object.keys(dependencies || {}).forEach((packageName) => {
                if (Object.prototype.hasOwnProperty.call(optionalDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both ` +
                        `"dependencies" and "optionalDependencies"`);
                }
                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both "dependencies" and "peerDependencies"`);
                }
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, dependencies[packageName], DependencyType.Regular, _onChange));
            });
            Object.keys(optionalDependencies || {}).forEach((packageName) => {
                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both ` +
                        `"optionalDependencies" and "peerDependencies"`);
                }
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, optionalDependencies[packageName], DependencyType.Optional, _onChange));
            });
            Object.keys(peerDependencies || {}).forEach((packageName) => {
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, peerDependencies[packageName], DependencyType.Peer, _onChange));
            });
            Object.keys(devDependencies || {}).forEach((packageName) => {
                this._devDependencies.set(packageName, new PackageJsonDependency(packageName, devDependencies[packageName], DependencyType.Dev, _onChange));
            });
            Object.keys(resolutions || {}).forEach((packageName) => {
                this._resolutions.set(packageName, new PackageJsonDependency(packageName, resolutions[packageName], DependencyType.YarnResolutions, _onChange));
            });
            // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortMapKeys(this._dependencies);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortMapKeys(this._devDependencies);
        }
        catch (e) {
            throw new Error(`Error loading "${filepath}": ${e.message}`);
        }
    }
    static load(filePath) {
        return new PackageJsonEditor(filePath, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.load(filePath));
    }
    static fromObject(object, filename) {
        return new PackageJsonEditor(filename, object);
    }
    get name() {
        return this._sourceData.name;
    }
    get version() {
        return this._sourceData.version;
    }
    /**
     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.
     */
    get dependencyList() {
        return [...this._dependencies.values()];
    }
    /**
     * The list of dependencies of type DependencyType.Dev.
     */
    get devDependencyList() {
        return [...this._devDependencies.values()];
    }
    /**
     * This field is a Yarn-specific feature that allows overriding of package resolution.
     *
     * @remarks
     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md
     * | 0000-selective-versions-resolutions.md RFC} for details.
     */
    get resolutionsList() {
        return [...this._resolutions.values()];
    }
    tryGetDependency(packageName) {
        return this._dependencies.get(packageName);
    }
    tryGetDevDependency(packageName) {
        return this._devDependencies.get(packageName);
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        const dependency = new PackageJsonDependency(packageName, newVersion, dependencyType, this._onChange.bind(this));
        // Rush collapses everything that isn't a devDependency into the dependencies
        // field, so we need to set the value depending on dependency type
        switch (dependencyType) {
            case DependencyType.Regular:
            case DependencyType.Optional:
            case DependencyType.Peer:
                this._dependencies.set(packageName, dependency);
                break;
            case DependencyType.Dev:
                this._devDependencies.set(packageName, dependency);
                break;
            case DependencyType.YarnResolutions:
                this._resolutions.set(packageName, dependency);
                break;
            default:
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Unsupported DependencyType');
        }
        this._modified = true;
    }
    removeDependency(packageName, dependencyType) {
        switch (dependencyType) {
            case DependencyType.Regular:
            case DependencyType.Optional:
            case DependencyType.Peer:
                this._dependencies.delete(packageName);
                break;
            case DependencyType.Dev:
                this._devDependencies.delete(packageName);
                break;
            case DependencyType.YarnResolutions:
                this._resolutions.delete(packageName);
                break;
            default:
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Unsupported DependencyType');
        }
        this._modified = true;
    }
    saveIfModified() {
        if (this._modified) {
            this._modified = false;
            this._sourceData = this._normalize(this._sourceData);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.save(this._sourceData, this.filePath, { updateExistingFile: true });
            return true;
        }
        return false;
    }
    /**
     * Get the normalized package.json that represents the current state of the
     * PackageJsonEditor. This method does not save any changes that were made to the
     * package.json, but instead returns the object representation of what would be saved
     * if saveIfModified() is called.
     */
    saveToObject() {
        // Only normalize if we need to
        const sourceData = this._modified ? this._normalize(this._sourceData) : this._sourceData;
        // Provide a clone to avoid reference back to the original data object
        return (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_2__.cloneDeep)(sourceData);
    }
    _onChange() {
        this._modified = true;
    }
    /**
     * Create a normalized shallow copy of the provided package.json without modifying the
     * original. If the result of this method is being returned via a public facing method,
     * it will still need to be deep-cloned to avoid propogating changes back to the
     * original dataset.
     */
    _normalize(source) {
        const normalizedData = Object.assign({}, source);
        delete normalizedData.dependencies;
        delete normalizedData.optionalDependencies;
        delete normalizedData.peerDependencies;
        delete normalizedData.devDependencies;
        delete normalizedData.resolutions;
        const keys = [...this._dependencies.keys()].sort();
        for (const packageName of keys) {
            const dependency = this._dependencies.get(packageName);
            switch (dependency.dependencyType) {
                case DependencyType.Regular:
                    if (!normalizedData.dependencies) {
                        normalizedData.dependencies = {};
                    }
                    normalizedData.dependencies[dependency.name] = dependency.version;
                    break;
                case DependencyType.Optional:
                    if (!normalizedData.optionalDependencies) {
                        normalizedData.optionalDependencies = {};
                    }
                    normalizedData.optionalDependencies[dependency.name] = dependency.version;
                    break;
                case DependencyType.Peer:
                    if (!normalizedData.peerDependencies) {
                        normalizedData.peerDependencies = {};
                    }
                    normalizedData.peerDependencies[dependency.name] = dependency.version;
                    break;
                case DependencyType.Dev: // uses this._devDependencies instead
                case DependencyType.YarnResolutions: // uses this._resolutions instead
                default:
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Unsupported DependencyType');
            }
        }
        const devDependenciesKeys = [...this._devDependencies.keys()].sort();
        for (const packageName of devDependenciesKeys) {
            const dependency = this._devDependencies.get(packageName);
            if (!normalizedData.devDependencies) {
                normalizedData.devDependencies = {};
            }
            normalizedData.devDependencies[dependency.name] = dependency.version;
        }
        // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)
        for (const packageName of this._resolutions.keys()) {
            const dependency = this._resolutions.get(packageName);
            if (!normalizedData.resolutions) {
                normalizedData.resolutions = {};
            }
            normalizedData.resolutions[dependency.name] = dependency.version;
        }
        return normalizedData;
    }
}
//# sourceMappingURL=PackageJsonEditor.js.map

/***/ }),

/***/ 644443:
/*!**********************************************!*\
  !*** ./lib-esnext/api/PackageNameParsers.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackageNameParsers": () => (/* binding */ PackageNameParsers)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class PackageNameParsers {
}
/**
 * This is the default for `RushConfiguration.packageNameParser`.
 */
PackageNameParsers.rushDefault = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageNameParser({});
/**
 * This is the `RushConfiguration.packageNameParser` used when `allowMostlyStandardPackageNames = true`
 * in rush.json.
 */
PackageNameParsers.mostlyStandard = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageNameParser({
    allowUpperCase: true
});
/**
 * Use this in contexts where we don't have easy access to `RushConfiguration.packageNameParser`
 * AND the package name was already validated at some earlier stage.
 */
PackageNameParsers.permissive = PackageNameParsers.mostlyStandard;

//# sourceMappingURL=PackageNameParsers.js.map

/***/ }),

/***/ 465002:
/*!********************************!*\
  !*** ./lib-esnext/api/Rush.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rush": () => (/* binding */ Rush)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_SetRushLibPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/SetRushLibPath */ 407929);
/* harmony import */ var _cli_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cli/RushCommandLineParser */ 365416);
/* harmony import */ var _cli_RushStartupBanner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cli/RushStartupBanner */ 149507);
/* harmony import */ var _cli_RushXCommandLine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cli/RushXCommandLine */ 125373);
/* harmony import */ var _cli_CommandLineMigrationAdvisor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cli/CommandLineMigrationAdvisor */ 795805);
/* harmony import */ var _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EnvironmentConfiguration */ 382806);
/* harmony import */ var _cli_RushPnpmCommandLine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cli/RushPnpmCommandLine */ 66976);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.









/**
 * General operations for the Rush engine.
 *
 * @public
 */
class Rush {
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush" binary
     * and start a new Node.js process.
     *
     * @remarks
     * Earlier versions of the rush frontend used a different API contract. In the old contract,
     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.
     *
     * Even though this API isn't documented, it is still supported for legacy compatibility.
     */
    static launch(launcherVersion, arg) {
        const options = Rush._normalizeLaunchOptions(arg);
        if (!_cli_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_3__.RushCommandLineParser.shouldRestrictConsoleOutput()) {
            _cli_RushStartupBanner__WEBPACK_IMPORTED_MODULE_4__.RushStartupBanner.logBanner(Rush.version, options.isManaged);
        }
        if (!_cli_CommandLineMigrationAdvisor__WEBPACK_IMPORTED_MODULE_5__.CommandLineMigrationAdvisor.checkArgv(process.argv)) {
            // The migration advisor recognized an obsolete command-line
            process.exitCode = 1;
            return;
        }
        Rush._assignRushInvokedFolder();
        const parser = new _cli_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_3__.RushCommandLineParser({
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError,
            builtInPluginConfigurations: options.builtInPluginConfigurations
        });
        // eslint-disable-next-line no-console
        parser.execute().catch(console.error); // CommandLineParser.execute() should never reject the promise
    }
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rushx" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rushx" binary
     * and start a new Node.js process.
     */
    static launchRushX(launcherVersion, options) {
        options = Rush._normalizeLaunchOptions(options);
        Rush._assignRushInvokedFolder();
        _cli_RushXCommandLine__WEBPACK_IMPORTED_MODULE_6__.RushXCommandLine._launchRushXInternal(launcherVersion, Object.assign({}, options));
    }
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush-pnpm" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush-pnpm" binary
     * and start a new Node.js process.
     */
    static launchRushPnpm(launcherVersion, options) {
        Rush._assignRushInvokedFolder();
        _cli_RushPnpmCommandLine__WEBPACK_IMPORTED_MODULE_7__.RushPnpmCommandLine.launch(launcherVersion, Object.assign({}, options));
    }
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     */
    static get version() {
        return this._rushLibPackageJson.version;
    }
    /**
     * @internal
     */
    static get _rushLibPackageJson() {
        Rush._ensureOwnPackageJsonIsLoaded();
        return Rush.__rushLibPackageJson;
    }
    static get _rushLibPackageFolder() {
        Rush._ensureOwnPackageJsonIsLoaded();
        return Rush.__rushLibPackageFolder;
    }
    static _ensureOwnPackageJsonIsLoaded() {
        if (!Rush.__rushLibPackageJson) {
            const packageJsonFilePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(__dirname);
            if (!packageJsonFilePath) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Unable to locate the package.json file for this module');
            }
            Rush.__rushLibPackageFolder = path__WEBPACK_IMPORTED_MODULE_0__.dirname(packageJsonFilePath);
            Rush.__rushLibPackageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.PackageJsonLookup.instance.loadPackageJson(packageJsonFilePath);
        }
    }
    /**
     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when
     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.
     *
     * @remarks
     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate
     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,
     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.
     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use
     * `Executable.spawn()` or rushell.
     */
    static _assignRushInvokedFolder() {
        process.env[_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_8__.EnvironmentVariableNames.RUSH_INVOKED_FOLDER] = process.cwd();
    }
    /**
     * This function normalizes legacy options to the current {@link ILaunchOptions} object.
     */
    static _normalizeLaunchOptions(arg) {
        return typeof arg === 'boolean'
            ? { isManaged: arg } // In older versions of Rush, this the `launch` functions took a boolean arg for "isManaged"
            : arg;
    }
}
Rush.__rushLibPackageJson = undefined;
Rush.__rushLibPackageFolder = undefined;

//# sourceMappingURL=Rush.js.map

/***/ }),

/***/ 126002:
/*!*********************************************!*\
  !*** ./lib-esnext/api/RushConfiguration.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushConfiguration": () => (/* binding */ RushConfiguration)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! true-case-path */ 477156);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(true_case_path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../api/Rush */ 465002);
/* harmony import */ var _RushConfigurationProject__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./RushConfigurationProject */ 900491);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _ApprovedPackagesPolicy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ApprovedPackagesPolicy */ 986096);
/* harmony import */ var _EventHooks__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./EventHooks */ 519005);
/* harmony import */ var _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./VersionPolicyConfiguration */ 904624);
/* harmony import */ var _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EnvironmentConfiguration */ 382806);
/* harmony import */ var _CommonVersionsConfiguration__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./CommonVersionsConfiguration */ 989216);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _packageManager_NpmPackageManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./packageManager/NpmPackageManager */ 820330);
/* harmony import */ var _packageManager_YarnPackageManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./packageManager/YarnPackageManager */ 472222);
/* harmony import */ var _packageManager_PnpmPackageManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./packageManager/PnpmPackageManager */ 171257);
/* harmony import */ var _ExperimentsConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExperimentsConfiguration */ 259205);
/* harmony import */ var _PackageNameParsers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./PackageNameParsers */ 644443);
/* harmony import */ var _logic_RepoStateFile__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../logic/RepoStateFile */ 880175);
/* harmony import */ var _logic_LookupByPath__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../logic/LookupByPath */ 590211);
/* harmony import */ var _RushPluginsConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RushPluginsConfiguration */ 622837);
/* harmony import */ var _logic_pnpm_PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../logic/pnpm/PnpmOptionsConfiguration */ 402835);
/* harmony import */ var _logic_npm_NpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../logic/npm/NpmOptionsConfiguration */ 459476);
/* harmony import */ var _logic_yarn_YarnOptionsConfiguration__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../logic/yarn/YarnOptionsConfiguration */ 17314);
/* harmony import */ var _schemas_rush_schema_json__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../schemas/rush.schema.json */ 35475);
/* harmony import */ var _CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./CustomTipsConfiguration */ 268756);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/* eslint max-lines: off */


























const MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';
const DEFAULT_BRANCH = 'main';
const DEFAULT_REMOTE = 'origin';
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
const knownRushConfigFilenames = [
    '.npmrc-publish',
    '.npmrc',
    'deploy.json',
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.artifactoryFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.browserApprovedPackagesFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.buildCacheFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.cobuildFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.commandLineFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.commonVersionsFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.customTipsFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.experimentsFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.nonbrowserApprovedPackagesFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.pinnedVersionsFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.repoStateFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.versionPoliciesFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushPluginsConfigFilename,
    _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.pnpmConfigFilename
];
/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
class RushConfiguration {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    constructor(rushConfigurationJson, rushJsonFilename) {
        this.rushConfigurationJson = rushConfigurationJson;
        _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__.EnvironmentConfiguration.validate();
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver__WEBPACK_IMPORTED_MODULE_1__.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"' +
                    ` field from rush.json: "${rushConfigurationJson.nodeSupportedVersionRange}"`);
            }
            if (!semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                let message = `Your dev environment is running Node.js version ${process.version} which does` +
                    ` not meet the requirements for building this repository.  (The rush.json configuration` +
                    ` requires nodeSupportedVersionRange="${rushConfigurationJson.nodeSupportedVersionRange}")`;
                if (rushConfigurationJson.nodeSupportedVersionInstructions) {
                    message += '\n\n' + rushConfigurationJson.nodeSupportedVersionInstructions;
                }
                if (_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__.EnvironmentConfiguration.allowUnsupportedNodeVersion) {
                    // eslint-disable-next-line no-console
                    console.warn(message);
                }
                else {
                    throw new Error(message);
                }
            }
        }
        this.rushJsonFile = rushJsonFilename;
        this.rushJsonFolder = path__WEBPACK_IMPORTED_MODULE_0__.dirname(rushJsonFilename);
        this.commonFolder = path__WEBPACK_IMPORTED_MODULE_0__.resolve(path__WEBPACK_IMPORTED_MODULE_0__.join(this.rushJsonFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.commonFolderName));
        this.commonRushConfigFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, 'config', 'rush');
        this.commonTempFolder =
            _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__.EnvironmentConfiguration.rushTempFolderOverride ||
                path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushTempFolderName);
        this.commonScriptsFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, 'scripts');
        this.npmCacheFolder = path__WEBPACK_IMPORTED_MODULE_0__.resolve(path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, 'npm-cache'));
        this.npmTmpFolder = path__WEBPACK_IMPORTED_MODULE_0__.resolve(path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, 'npm-tmp'));
        this.yarnCacheFolder = path__WEBPACK_IMPORTED_MODULE_0__.resolve(path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, 'yarn-cache'));
        this.changesFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.changeFilesFolderName);
        this.currentVariantJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, 'current-variant.json');
        this.suppressNodeLtsWarning = !!rushConfigurationJson.suppressNodeLtsWarning;
        this.ensureConsistentVersions = !!rushConfigurationJson.ensureConsistentVersions;
        const experimentsConfigFile = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.experimentsFilename);
        this.experimentsConfiguration = new _ExperimentsConfiguration__WEBPACK_IMPORTED_MODULE_6__.ExperimentsConfiguration(experimentsConfigFile);
        const rushPluginsConfigFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushPluginsConfigFilename);
        this._rushPluginsConfiguration = new _RushPluginsConfiguration__WEBPACK_IMPORTED_MODULE_7__.RushPluginsConfiguration(rushPluginsConfigFilename);
        this.npmOptions = new _logic_npm_NpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_8__.NpmOptionsConfiguration(rushConfigurationJson.npmOptions || {});
        this.yarnOptions = new _logic_yarn_YarnOptionsConfiguration__WEBPACK_IMPORTED_MODULE_9__.YarnOptionsConfiguration(rushConfigurationJson.yarnOptions || {});
        try {
            this.pnpmOptions = _logic_pnpm_PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_10__.PnpmOptionsConfiguration.loadFromJsonFileOrThrow(`${this.commonRushConfigFolder}/${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.pnpmConfigFilename}`, this.commonTempFolder);
            if (rushConfigurationJson.pnpmOptions) {
                throw new Error('Because the new config file "common/config/rush/pnpm-config.json" is being used, ' +
                    'you must remove the old setting "pnpmOptions" from rush.json');
            }
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.isNotExistError(error)) {
                this.pnpmOptions = _logic_pnpm_PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_10__.PnpmOptionsConfiguration.loadFromJsonObject(rushConfigurationJson.pnpmOptions || {}, this.commonTempFolder);
            }
            else {
                throw error;
            }
        }
        // TODO: Add an actual "packageManager" field in rush.json
        const packageManagerFields = [];
        if (rushConfigurationJson.npmVersion) {
            this.packageManager = 'npm';
            this.packageManagerOptions = this.npmOptions;
            packageManagerFields.push('npmVersion');
        }
        if (rushConfigurationJson.pnpmVersion) {
            this.packageManager = 'pnpm';
            this.packageManagerOptions = this.pnpmOptions;
            packageManagerFields.push('pnpmVersion');
        }
        if (rushConfigurationJson.yarnVersion) {
            this.packageManager = 'yarn';
            this.packageManagerOptions = this.yarnOptions;
            packageManagerFields.push('yarnVersion');
        }
        if (packageManagerFields.length === 0) {
            throw new Error(`The rush.json configuration must specify one of: npmVersion, pnpmVersion, or yarnVersion`);
        }
        if (packageManagerFields.length > 1) {
            throw new Error(`The rush.json configuration cannot specify both ${packageManagerFields[0]}` +
                ` and ${packageManagerFields[1]} `);
        }
        if (this.packageManager === 'npm') {
            this.packageManagerToolVersion = rushConfigurationJson.npmVersion;
            this.packageManagerWrapper = new _packageManager_NpmPackageManager__WEBPACK_IMPORTED_MODULE_11__.NpmPackageManager(this.packageManagerToolVersion);
        }
        else if (this.packageManager === 'pnpm') {
            this.packageManagerToolVersion = rushConfigurationJson.pnpmVersion;
            this.packageManagerWrapper = new _packageManager_PnpmPackageManager__WEBPACK_IMPORTED_MODULE_12__.PnpmPackageManager(this.packageManagerToolVersion);
        }
        else {
            this.packageManagerToolVersion = rushConfigurationJson.yarnVersion;
            this.packageManagerWrapper = new _packageManager_YarnPackageManager__WEBPACK_IMPORTED_MODULE_13__.YarnPackageManager(this.packageManagerToolVersion);
        }
        this.shrinkwrapFilename = this.packageManagerWrapper.shrinkwrapFilename;
        this.tempShrinkwrapFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, this.shrinkwrapFilename);
        this.packageManagerToolFilename = path__WEBPACK_IMPORTED_MODULE_0__.resolve(path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonTempFolder, `${this.packageManager}-local`, 'node_modules', '.bin', `${this.packageManager}`));
        /// From "C:\repo\common\temp\pnpm-lock.yaml" --> "C:\repo\common\temp\pnpm-lock-preinstall.yaml"
        const parsedPath = path__WEBPACK_IMPORTED_MODULE_0__.parse(this.tempShrinkwrapFilename);
        this.tempShrinkwrapPreinstallFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);
        RushConfiguration._validateCommonRushConfigFolder(this.commonRushConfigFolder, this.packageManagerWrapper, this.experimentsConfiguration);
        this.projectFolderMinDepth =
            rushConfigurationJson.projectFolderMinDepth !== undefined
                ? rushConfigurationJson.projectFolderMinDepth
                : 1;
        if (this.projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this.projectFolderMaxDepth =
            rushConfigurationJson.projectFolderMaxDepth !== undefined
                ? rushConfigurationJson.projectFolderMaxDepth
                : 2;
        if (this.projectFolderMaxDepth < this.projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this.allowMostlyStandardPackageNames = !!rushConfigurationJson.allowMostlyStandardPackageNames;
        this.packageNameParser = this.allowMostlyStandardPackageNames
            ? _PackageNameParsers__WEBPACK_IMPORTED_MODULE_14__.PackageNameParsers.mostlyStandard
            : _PackageNameParsers__WEBPACK_IMPORTED_MODULE_14__.PackageNameParsers.rushDefault;
        this.approvedPackagesPolicy = new _ApprovedPackagesPolicy__WEBPACK_IMPORTED_MODULE_15__.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this.gitAllowedEmailRegExps = [];
        this.gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this.gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this.gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this.gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
            if (rushConfigurationJson.gitPolicy.versionBumpCommitMessage) {
                this.gitVersionBumpCommitMessage = rushConfigurationJson.gitPolicy.versionBumpCommitMessage;
            }
            if (rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage) {
                this.gitChangeLogUpdateCommitMessage = rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage;
            }
            if (rushConfigurationJson.gitPolicy.changefilesCommitMessage) {
                this.gitChangefilesCommitMessage = rushConfigurationJson.gitPolicy.changefilesCommitMessage;
            }
            if (rushConfigurationJson.gitPolicy.tagSeparator) {
                this.gitTagSeparator = rushConfigurationJson.gitPolicy.tagSeparator;
            }
        }
        this.hotfixChangeEnabled = false;
        if (rushConfigurationJson.hotfixChangeEnabled) {
            this.hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;
        }
        if (!rushConfigurationJson.repository) {
            rushConfigurationJson.repository = {};
        }
        this.repositoryDefaultBranch = rushConfigurationJson.repository.defaultBranch || DEFAULT_BRANCH;
        this.repositoryDefaultRemote = rushConfigurationJson.repository.defaultRemote || DEFAULT_REMOTE;
        const repositoryFieldWithMultipleUrls = rushConfigurationJson.repository;
        const repositoryFieldWithSingleUrl = rushConfigurationJson.repository;
        if (repositoryFieldWithMultipleUrls.urls) {
            if (repositoryFieldWithSingleUrl.url) {
                throw new Error("The 'repository.url' field cannot be used when 'repository.urls' is present");
            }
            this.repositoryUrls = repositoryFieldWithMultipleUrls.urls;
        }
        else if (repositoryFieldWithSingleUrl.url) {
            this.repositoryUrls = [repositoryFieldWithSingleUrl.url];
        }
        else {
            this.repositoryUrls = [];
        }
        this.telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        this.eventHooks = new _EventHooks__WEBPACK_IMPORTED_MODULE_16__.EventHooks(rushConfigurationJson.eventHooks || {});
        this.versionPolicyConfigurationFilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.versionPoliciesFilename);
        this.versionPolicyConfiguration = new _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_17__.VersionPolicyConfiguration(this.versionPolicyConfigurationFilePath);
        this.customTipsConfigurationFilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.customTipsFilename);
        this.customTipsConfiguration = new _CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_18__.CustomTipsConfiguration(this.customTipsConfigurationFilePath);
        this._variants = new Set();
        if (rushConfigurationJson.variants) {
            for (const variantOptions of rushConfigurationJson.variants) {
                const { variantName } = variantOptions;
                if (this._variants.has(variantName)) {
                    throw new Error(`Duplicate variant named '${variantName}' specified in configuration.`);
                }
                this._variants.add(variantName);
            }
        }
        this._pathTrees = new Map();
    }
    _initializeAndValidateLocalProjects() {
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        const sortedProjectJsons = this.rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));
        const allowedProjectTags = this.rushConfigurationJson.allowedProjectTags
            ? new Set(this.rushConfigurationJson.allowedProjectTags)
            : undefined;
        const usedTempNames = new Set();
        for (let i = 0, len = sortedProjectJsons.length; i < len; i++) {
            const projectJson = sortedProjectJsons[i];
            const tempProjectName = RushConfiguration._generateTempNameForProject(projectJson, usedTempNames);
            const project = new _RushConfigurationProject__WEBPACK_IMPORTED_MODULE_19__.RushConfigurationProject({
                projectJson,
                rushConfiguration: this,
                tempProjectName,
                allowedProjectTags
            });
            this._projects.push(project);
            if (this._projectsByName.has(project.packageName)) {
                throw new Error(`The project name "${project.packageName}" was specified more than once` +
                    ` in the rush.json configuration file.`);
            }
            this._projectsByName.set(project.packageName, project);
        }
        for (const project of this._projects) {
            project.decoupledLocalDependencies.forEach((decoupledLocalDependency) => {
                if (!this.getProjectByName(decoupledLocalDependency)) {
                    throw new Error(`In rush.json, the "${decoupledLocalDependency}" project does not exist,` +
                        ` but was referenced by the decoupledLocalDependencies (previously cyclicDependencyProjects) for ${project.packageName}`);
                }
            });
            this.versionPolicyConfiguration.validate(this.projectsByName);
            // Consumer relationships will be established the first time one is requested
        }
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename) {
        let resolvedRushJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.resolve(rushJsonFilename);
        // Load the rush.json before we fix the casing. If the case is wrong on a case-sensitive filesystem,
        // the next line show throw.
        const rushConfigurationJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.load(resolvedRushJsonFilename);
        try {
            resolvedRushJsonFilename = (0,true_case_path__WEBPACK_IMPORTED_MODULE_3__.trueCasePathSync)(resolvedRushJsonFilename);
        }
        catch (error) {
            /* ignore errors from true-case-path */
        }
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,
        // but we'll validate anyway.
        const expectedRushVersion = rushConfigurationJson.rushVersion;
        const rushJsonBaseName = path__WEBPACK_IMPORTED_MODULE_0__.basename(resolvedRushJsonFilename);
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (expectedRushVersion && semver__WEBPACK_IMPORTED_MODULE_1__.valid(expectedRushVersion)) {
            // Make sure the requested version isn't too old
            if (semver__WEBPACK_IMPORTED_MODULE_1__.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {
                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +
                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);
            }
            // Make sure the requested version isn't too new.
            //
            // If the major/minor versions are the same, then we consider the file to be compatible.
            // This is somewhat lax, e.g. "5.0.2-dev.3" will be assumed to be loadable by rush-lib 5.0.0.
            //
            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must
            // increment the minor version number for Rush.
            if (semver__WEBPACK_IMPORTED_MODULE_1__.major(_api_Rush__WEBPACK_IMPORTED_MODULE_20__.Rush.version) !== semver__WEBPACK_IMPORTED_MODULE_1__.major(expectedRushVersion) ||
                semver__WEBPACK_IMPORTED_MODULE_1__.minor(_api_Rush__WEBPACK_IMPORTED_MODULE_20__.Rush.version) !== semver__WEBPACK_IMPORTED_MODULE_1__.minor(expectedRushVersion)) {
                // If the major/minor are different, then make sure it's an older version.
                if (semver__WEBPACK_IMPORTED_MODULE_1__.lt(_api_Rush__WEBPACK_IMPORTED_MODULE_20__.Rush.version, expectedRushVersion)) {
                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is` +
                        ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${_api_Rush__WEBPACK_IMPORTED_MODULE_20__.Rush.version}.` +
                        ` Consider upgrading the library.`);
                }
            }
        }
        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, resolvedRushJsonFilename);
        return new RushConfiguration(rushConfigurationJson, resolvedRushJsonFilename);
    }
    static tryLoadFromDefaultLocation(options) {
        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation(options);
        if (rushJsonLocation) {
            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);
        }
    }
    static loadFromDefaultLocation(options) {
        const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation(options);
        if (rushConfiguration) {
            return rushConfiguration;
        }
        else {
            throw _utilities_Utilities__WEBPACK_IMPORTED_MODULE_21__.Utilities.getRushConfigNotFoundError();
        }
    }
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     *
     * @privateRemarks
     * Keep this in sync with `findRushJsonLocation` in `rush-sdk/src/index.ts`.
     */
    static tryFindRushJsonLocation(options) {
        const optionsIn = options || {};
        const verbose = optionsIn.showVerbose || false;
        let currentFolder = optionsIn.startingFolder || process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (let i = 0; i < 10; ++i) {
            const rushJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(currentFolder, 'rush.json');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(rushJsonFilename)) {
                if (i > 0 && verbose) {
                    // eslint-disable-next-line no-console
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                if (verbose) {
                    // eslint-disable-next-line no-console
                    console.log('');
                }
                return rushJsonFilename;
            }
            const parentFolder = path__WEBPACK_IMPORTED_MODULE_0__.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        return undefined;
    }
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    static _generateTempNameForProject(projectJson, usedTempNames) {
        // If the name is "@ms/MyProject", extract the "MyProject" part
        const unscopedName = _PackageNameParsers__WEBPACK_IMPORTED_MODULE_14__.PackageNameParsers.permissive.getUnscopedName(projectJson.packageName);
        // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
        // there is a naming conflict
        let counter = 0;
        let tempProjectName = `${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushTempNpmScope}/${unscopedName}`;
        while (usedTempNames.has(tempProjectName)) {
            ++counter;
            tempProjectName = `${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;
        }
        usedTempNames.add(tempProjectName);
        return tempProjectName;
    }
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManagerWrapper, experiments) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(commonRushConfigFolder)) {
            // eslint-disable-next-line no-console
            console.log(`Creating folder: ${commonRushConfigFolder}`);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolder(commonRushConfigFolder);
            return;
        }
        for (const filename of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemNames(commonRushConfigFolder)) {
            // Ignore things that aren't actual files
            const stat = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getLinkStatistics(path__WEBPACK_IMPORTED_MODULE_0__.join(commonRushConfigFolder, filename));
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            const fileExtension = path__WEBPACK_IMPORTED_MODULE_0__.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            // Ignore hidden files such as ".DS_Store"
            if (filename.startsWith('.')) {
                continue;
            }
            if (filename.startsWith('deploy-') && fileExtension === '.json') {
                // Ignore "rush deploy" files, which use the naming pattern "deploy-<scenario-name>.json".
                continue;
            }
            const knownSet = new Set(knownRushConfigFilenames.map((x) => x.toUpperCase()));
            // Add the shrinkwrap filename for the package manager to the known set.
            knownSet.add(packageManagerWrapper.shrinkwrapFilename.toUpperCase());
            // If the package manager is pnpm, then also add the pnpm file to the known set.
            if (packageManagerWrapper.packageManager === 'pnpm') {
                knownSet.add(packageManagerWrapper.pnpmfileFilename.toUpperCase());
            }
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error(`An unrecognized file "${filename}" was found in the Rush config folder:` +
                    ` ${commonRushConfigFolder}`);
            }
        }
        const pinnedVersionsFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.pinnedVersionsFilename);
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(pinnedVersionsFilename)) {
            throw new Error('The "pinned-versions.json" config file is no longer supported;' +
                ' please move your settings to the "preferredVersions" field of a "common-versions.json" config file.' +
                ` (See the ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushWebSiteUrl} documentation for details.)\n\n` +
                pinnedVersionsFilename);
        }
    }
    /**
     * The fully resolved path for the "autoinstallers" folder.
     * Example: `C:\MyRepo\common\autoinstallers`
     */
    get commonAutoinstallersFolder() {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, 'autoinstallers');
    }
    /**
     * The folder where rush-plugin options json files are stored.
     * Example: `C:\MyRepo\common\config\rush-plugins`
     */
    get rushPluginOptionsFolder() {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonFolder, 'config', 'rush-plugins');
    }
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\npm-shrinkwrap.json` or `C:\MyRepo\common\pnpm-lock.yaml`
     *
     * @deprecated Use `getCommittedShrinkwrapFilename` instead, which gets the correct common
     * shrinkwrap file name for a given active variant.
     */
    get committedShrinkwrapFilename() {
        return this.getCommittedShrinkwrapFilename();
    }
    /**
     * Returns an English phrase such as "shrinkwrap file" that can be used in logging messages
     * to refer to the shrinkwrap file using appropriate terminology for the currently selected
     * package manager.
     */
    get shrinkwrapFilePhrase() {
        if (this.packageManager === 'yarn') {
            // Eventually we'd like to be consistent with Yarn's terminology of calling this a "lock file",
            // but a lot of Rush documentation uses "shrinkwrap" file and would all need to be updated.
            return 'shrinkwrap file (yarn.lock)';
        }
        else {
            return 'shrinkwrap file';
        }
    }
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: `C:\MyRepo\common\temp\rush-link.json`
     *
     * @deprecated The "rush-link.json" file was removed in Rush 5.30.0.
     * Use `RushConfigurationProject.localDependencyProjects` instead.
     */
    get rushLinkJsonFilename() {
        throw new Error('The "rush-link.json" file was removed in Rush 5.30.0. Use ' +
            'RushConfigurationProject.localDependencyProjects instead.');
    }
    /**
     * The default fully-qualified git remote branch of the repository. This helps "rush change" find the right branch to compare against.
     */
    get repositoryDefaultFullyQualifiedRemoteBranch() {
        return `${this.repositoryDefaultRemote}/${this.repositoryDefaultBranch}`;
    }
    get projects() {
        if (!this._projects) {
            this._initializeAndValidateLocalProjects();
        }
        return this._projects;
    }
    get projectsByName() {
        if (!this._projectsByName) {
            this._initializeAndValidateLocalProjects();
        }
        return this._projectsByName;
    }
    /**
     * Obtains the mapping from custom tags to projects.
     * @beta
     */
    get projectsByTag() {
        if (!this._projectsByTag) {
            const projectsByTag = new Map();
            for (const project of this.projects) {
                for (const tag of project.tags) {
                    let collection = projectsByTag.get(tag);
                    if (!collection) {
                        projectsByTag.set(tag, (collection = new Set()));
                    }
                    collection.add(project);
                }
            }
            this._projectsByTag = projectsByTag;
        }
        return this._projectsByTag;
    }
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     *
     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data
     * for a given active variant.
     */
    get commonVersions() {
        return this.getCommonVersions();
    }
    /**
     * Gets the currently-installed variant, if an installation has occurred.
     * For Rush operations which do not take a --variant parameter, this method
     * determines which variant, if any, was last specified when performing "rush install"
     * or "rush update".
     */
    get currentInstalledVariant() {
        let variant;
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(this.currentVariantJsonFilename)) {
            const currentVariantJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.load(this.currentVariantJsonFilename);
            variant = currentVariantJson.variant || undefined;
        }
        return variant;
    }
    /**
     * Gets the path to the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersionsFilePath(variant) {
        const commonVersionsFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, ...(variant ? [_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushVariantsFolderName, variant] : []), _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.commonVersionsFilename);
        return commonVersionsFilename;
    }
    /**
     * Gets the settings from the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersions(variant) {
        if (!this._commonVersionsConfigurationsByVariant) {
            this._commonVersionsConfigurationsByVariant = new Map();
        }
        // Use an empty string as the key when no variant provided. Anything else would possibly conflict
        // with a variant created by the user
        const variantKey = variant || '';
        let commonVersionsConfiguration = this._commonVersionsConfigurationsByVariant.get(variantKey);
        if (!commonVersionsConfiguration) {
            const commonVersionsFilename = this.getCommonVersionsFilePath(variant);
            commonVersionsConfiguration = _CommonVersionsConfiguration__WEBPACK_IMPORTED_MODULE_22__.CommonVersionsConfiguration.loadFromFile(commonVersionsFilename);
            this._commonVersionsConfigurationsByVariant.set(variantKey, commonVersionsConfiguration);
        }
        return commonVersionsConfiguration;
    }
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     * @param variant - The name of the current variant in use by the active command.
     *
     * @returns A map of dependency name --\> version specifier for implicitly preferred versions.
     */
    getImplicitlyPreferredVersions(variant) {
        // TODO: During the next major release of Rush, replace this `require` call with a dynamic import, and
        // change this function to be async.
        const DependencyAnalyzerModule = __webpack_require__(/*! ../logic/DependencyAnalyzer */ 728446);
        const dependencyAnalyzer = DependencyAnalyzerModule.DependencyAnalyzer.forRushConfiguration(this);
        const dependencyAnalysis = dependencyAnalyzer.getAnalysis(variant);
        return dependencyAnalysis.implicitlyPreferredVersionByPackageName;
    }
    /**
     * Gets the path to the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoStateFilePath(variant) {
        const repoStateFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, ...(variant ? [_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushVariantsFolderName, variant] : []), _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.repoStateFilename);
        return repoStateFilename;
    }
    /**
     * Gets the contents from the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoState(variant) {
        const repoStateFilename = this.getRepoStateFilePath(variant);
        return _logic_RepoStateFile__WEBPACK_IMPORTED_MODULE_23__.RepoStateFile.loadFromFile(repoStateFilename, variant);
    }
    /**
     * Gets the committed shrinkwrap file name for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommittedShrinkwrapFilename(variant) {
        if (variant) {
            if (!this._variants.has(variant)) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Array.from(this._variants.values())
                        .map((name) => `"${name}"`)
                        .join(', ')}.`);
            }
        }
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path__WEBPACK_IMPORTED_MODULE_0__.join(variantConfigFolderPath, this.shrinkwrapFilename);
    }
    /**
     * Gets the absolute path for "pnpmfile.js" for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     * @remarks
     * The file path is returned even if PNPM is not configured as the package manager.
     */
    getPnpmfilePath(variant) {
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path__WEBPACK_IMPORTED_MODULE_0__.join(variantConfigFolderPath, this.packageManagerWrapper.pnpmfileFilename);
    }
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName) {
        return this.projectsByName.get(projectName);
    }
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like `@something/example`.  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName) {
        // Is there an exact match?
        let result = this.projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (const project of this.projects) {
            if (this.packageNameParser.getUnscopedName(project.packageName) === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    }
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName) {
        // Is there an approximate match?
        for (const project of this.projects) {
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    }
    /**
     * @returns An optimized lookup engine to find a project by its path relative to the specified root.
     * @beta
     */
    getProjectLookupForRoot(rootPath) {
        let pathTree = this._pathTrees.get(rootPath);
        if (!pathTree) {
            this._pathTrees.set(rootPath, (pathTree = new _logic_LookupByPath__WEBPACK_IMPORTED_MODULE_24__.LookupByPath()));
            for (const project of this.projects) {
                const relativePath = path__WEBPACK_IMPORTED_MODULE_0__.relative(rootPath, project.projectFolder);
                pathTree.setItemFromSegments(_logic_LookupByPath__WEBPACK_IMPORTED_MODULE_24__.LookupByPath.iteratePathSegments(relativePath, path__WEBPACK_IMPORTED_MODULE_0__.sep), project);
            }
        }
        return pathTree;
    }
    /**
     * Returns the project for which the specified path is underneath that project's folder.
     * If the path is not under any project's folder, returns undefined.
     */
    tryGetProjectForPath(currentFolderPath) {
        // TODO: Improve the method in which a package is found, perhaps without having to sort / loop though the entire package list
        const resolvedPath = path__WEBPACK_IMPORTED_MODULE_0__.resolve(currentFolderPath);
        const sortedProjects = this.projects.sort((a, b) => b.projectFolder.length - a.projectFolder.length);
        for (const project of sortedProjects) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Path.isUnderOrEqual(resolvedPath, project.projectFolder)) {
                return project;
            }
        }
        return undefined;
    }
    _getVariantConfigFolderPath(variant) {
        if (variant) {
            if (!this._variants.has(variant)) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Array.from(this._variants.values())
                        .map((name) => `"${name}"`)
                        .join(', ')}.`);
            }
        }
        return path__WEBPACK_IMPORTED_MODULE_0__.join(this.commonRushConfigFolder, ...(variant ? [_logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushVariantsFolderName, variant] : []));
    }
}
RushConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonSchema.fromLoadedObject(_schemas_rush_schema_json__WEBPACK_IMPORTED_MODULE_25__);

//# sourceMappingURL=RushConfiguration.js.map

/***/ }),

/***/ 900491:
/*!****************************************************!*\
  !*** ./lib-esnext/api/RushConfigurationProject.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushConfigurationProject": () => (/* binding */ RushConfigurationProject)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _PackageNameParsers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PackageNameParsers */ 644443);
/* harmony import */ var _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../logic/DependencySpecifier */ 68654);
/* harmony import */ var _SaveCallbackPackageJsonEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SaveCallbackPackageJsonEditor */ 739048);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







/**
 * This represents the configuration of a project that is built by Rush, based on
 * the Rush.json configuration file.
 * @public
 */
class RushConfigurationProject {
    /**
     * The parsed NPM "package.json" file from projectFolder.
     */
    get packageJson() {
        return this._packageJson;
    }
    /** @internal */
    constructor(options) {
        this._versionPolicy = undefined;
        this._dependencyProjects = undefined;
        this._consumingProjects = undefined;
        const { projectJson, rushConfiguration, tempProjectName, allowedProjectTags } = options;
        this.rushConfiguration = rushConfiguration;
        this.packageName = projectJson.packageName;
        this.projectRelativeFolder = projectJson.projectFolder;
        // For example, the depth of "a/b/c" would be 3.  The depth of "a" is 1.
        const projectFolderDepth = projectJson.projectFolder.split('/').length;
        if (projectFolderDepth < rushConfiguration.projectFolderMinDepth) {
            throw new Error(`To keep things organized, this repository has a projectFolderMinDepth policy` +
                ` requiring project folders to be at least ${rushConfiguration.projectFolderMinDepth} levels deep.` +
                `  Problem folder: "${projectJson.projectFolder}"`);
        }
        if (projectFolderDepth > rushConfiguration.projectFolderMaxDepth) {
            throw new Error(`To keep things organized, this repository has a projectFolderMaxDepth policy` +
                ` preventing project folders from being deeper than ${rushConfiguration.projectFolderMaxDepth} levels.` +
                `  Problem folder:  "${projectJson.projectFolder}"`);
        }
        this.projectFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(rushConfiguration.rushJsonFolder, projectJson.projectFolder);
        const packageJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this.projectFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileConstants.PackageJson);
        try {
            const packageJsonText = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFile(packageJsonFilename);
            // JSON.parse is native and runs in less than 1/2 the time of jju.parse. package.json is required to be strict JSON by NodeJS.
            this._packageJson = JSON.parse(packageJsonText);
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.isNotExistError(error)) {
                throw new Error(`Could not find package.json for ${projectJson.packageName} at ${packageJsonFilename}`);
            }
            throw error;
        }
        this.projectRushConfigFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.projectFolder, 'config', 'rush');
        this.projectRushTempFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.projectFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.projectRushFolderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushTempFolderName);
        // Are we using a package review file?
        if (rushConfiguration.approvedPackagesPolicy.enabled) {
            // If so, then every project needs to have a reviewCategory that was defined
            // by the reviewCategories array.
            if (!projectJson.reviewCategory) {
                throw new Error(`The "approvedPackagesPolicy" feature is enabled rush.json, but a reviewCategory` +
                    ` was not specified for the project "${projectJson.packageName}".`);
            }
            if (!rushConfiguration.approvedPackagesPolicy.reviewCategories.has(projectJson.reviewCategory)) {
                throw new Error(`The project "${projectJson.packageName}" specifies its reviewCategory as` +
                    `"${projectJson.reviewCategory}" which is not one of the defined reviewCategories.`);
            }
            this.reviewCategory = projectJson.reviewCategory;
        }
        if (this.packageJson.name !== this.packageName) {
            throw new Error(`The package name "${this.packageName}" specified in rush.json does not` +
                ` match the name "${this.packageJson.name}" from package.json`);
        }
        if (!semver__WEBPACK_IMPORTED_MODULE_1__.valid(this.packageJson.version)) {
            throw new Error(`The value "${this.packageJson.version}" is not valid SemVer syntax for the \"version\" field` +
                ` in the file "${packageJsonFilename}"`);
        }
        this.packageJsonEditor = _SaveCallbackPackageJsonEditor__WEBPACK_IMPORTED_MODULE_4__.SaveCallbackPackageJsonEditor.fromObjectWithCallback({
            object: this.packageJson,
            filename: packageJsonFilename,
            onSaved: (newObject) => {
                // Just update the in-memory copy, don't bother doing the validation again
                this._packageJson = newObject;
                this._dependencyProjects = undefined; // Reset the cached dependency projects
            }
        });
        this.tempProjectName = tempProjectName;
        // The "rushProject.tempProjectName" is guaranteed to be unique name (e.g. by adding the "-2"
        // suffix).  Even after we strip the NPM scope, it will still be unique.
        // Example: "my-project-2"
        this.unscopedTempProjectName = _PackageNameParsers__WEBPACK_IMPORTED_MODULE_5__.PackageNameParsers.permissive.getUnscopedName(tempProjectName);
        this.decoupledLocalDependencies = new Set();
        if (projectJson.cyclicDependencyProjects || projectJson.decoupledLocalDependencies) {
            if (projectJson.cyclicDependencyProjects && projectJson.decoupledLocalDependencies) {
                throw new Error('A project configuration cannot specify both "decoupledLocalDependencies" and "cyclicDependencyProjects". Please use "decoupledLocalDependencies" only -- the other name is deprecated.');
            }
            for (const cyclicDependencyProject of projectJson.cyclicDependencyProjects ||
                projectJson.decoupledLocalDependencies) {
                this.decoupledLocalDependencies.add(cyclicDependencyProject);
            }
        }
        this._shouldPublish = !!projectJson.shouldPublish;
        this.skipRushCheck = !!projectJson.skipRushCheck;
        this.versionPolicyName = projectJson.versionPolicyName;
        if (this._shouldPublish && this.packageJson.private) {
            throw new Error(`The project "${projectJson.packageName}" specifies "shouldPublish": true, ` +
                `but the package.json file specifies "private": true.`);
        }
        this.publishFolder = this.projectFolder;
        if (projectJson.publishFolder) {
            this.publishFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.publishFolder, projectJson.publishFolder);
        }
        if (allowedProjectTags && projectJson.tags) {
            this.tags = new Set();
            for (const tag of projectJson.tags) {
                if (!allowedProjectTags.has(tag)) {
                    throw new Error(`The tag "${tag}" specified for project "${this.packageName}" is not listed in the ` +
                        `allowedProjectTags field in rush.json.`);
                }
                else {
                    this.tags.add(tag);
                }
            }
        }
        else {
            this.tags = new Set(projectJson.tags);
        }
    }
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     *
     * @deprecated Use `decoupledLocalDependencies` instead, as it better describes the purpose of the data.
     */
    get cyclicDependencyProjects() {
        return this.decoupledLocalDependencies;
    }
    /**
     * An array of projects within the Rush configuration which directly depend on this package.
     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get downstreamDependencyProjects() {
        return Array.from(this.consumingProjects, (project) => project.packageName);
    }
    /**
     * An array of projects within the Rush configuration which this project declares as dependencies.
     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get localDependencyProjects() {
        return [...this.dependencyProjects];
    }
    /**
     * The set of projects within the Rush configuration which this project declares as dependencies.
     *
     * @remarks
     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly
     * referenced from this project.
     */
    get dependencyProjects() {
        let dependencyProjects = this._dependencyProjects;
        if (!dependencyProjects) {
            this._dependencyProjects = dependencyProjects = new Set();
            const { packageJson } = this;
            for (const dependencySet of [
                packageJson.dependencies,
                packageJson.devDependencies,
                packageJson.optionalDependencies
            ]) {
                if (dependencySet) {
                    for (const [dependency, version] of Object.entries(dependencySet)) {
                        // Skip if we can't find the local project or it's a cyclic dependency
                        const localProject = this.rushConfiguration.getProjectByName(dependency);
                        if (localProject && !this.decoupledLocalDependencies.has(dependency)) {
                            // Set the value if it's a workspace project, or if we have a local project and the semver is satisfied
                            const dependencySpecifier = new _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_6__.DependencySpecifier(dependency, version);
                            switch (dependencySpecifier.specifierType) {
                                case _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_6__.DependencySpecifierType.Version:
                                case _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_6__.DependencySpecifierType.Range:
                                    if (semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(localProject.packageJson.version, dependencySpecifier.versionSpecifier)) {
                                        dependencyProjects.add(localProject);
                                    }
                                    break;
                                case _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_6__.DependencySpecifierType.Workspace:
                                    dependencyProjects.add(localProject);
                                    break;
                            }
                        }
                    }
                }
            }
        }
        return dependencyProjects;
    }
    /**
     * The set of projects within the Rush configuration which declare this project as a dependency.
     * Excludes those that declare this project as a `cyclicDependencyProject`.
     *
     * @remarks
     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency
     * graph to find all projects which will be impacted by changes to this project.
     */
    get consumingProjects() {
        if (!this._consumingProjects) {
            // Force initialize all dependency relationships
            // This needs to operate on every project in the set because the relationships are only specified
            // in the consuming project
            const { projects } = this.rushConfiguration;
            for (const project of projects) {
                project._consumingProjects = new Set();
            }
            for (const project of projects) {
                for (const dependency of project.dependencyProjects) {
                    dependency._consumingProjects.add(project);
                }
            }
        }
        return this._consumingProjects;
    }
    /**
     * A flag which indicates whether changes to this project should be published. This controls
     * whether or not the project would show up when running `rush change`, and whether or not it
     * should be published during `rush publish`.
     */
    get shouldPublish() {
        return this._shouldPublish || !!this.versionPolicyName;
    }
    /**
     * Version policy of the project
     * @beta
     */
    get versionPolicy() {
        if (!this._versionPolicy) {
            if (this.versionPolicyName && this.rushConfiguration.versionPolicyConfiguration) {
                this._versionPolicy = this.rushConfiguration.versionPolicyConfiguration.getVersionPolicy(this.versionPolicyName);
            }
        }
        return this._versionPolicy;
    }
    /**
     * Indicate whether this project is the main project for the related version policy.
     *
     * False if the project is not for publishing.
     * True if the project is individually versioned or if its lockstep version policy does not specify main project.
     * False if the project is lockstepped and is not the main project for its version policy.
     *
     * @beta
     */
    get isMainProject() {
        if (!this.shouldPublish) {
            return false;
        }
        let isMain = true;
        if (this.versionPolicy && this.versionPolicy.isLockstepped) {
            const lockStepPolicy = this.versionPolicy;
            if (lockStepPolicy.mainProject && lockStepPolicy.mainProject !== this.packageName) {
                isMain = false;
            }
        }
        return isMain;
    }
}
//# sourceMappingURL=RushConfigurationProject.js.map

/***/ }),

/***/ 164409:
/*!********************************************!*\
  !*** ./lib-esnext/api/RushGlobalFolder.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushGlobalFolder": () => (/* binding */ RushGlobalFolder)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnvironmentConfiguration */ 382806);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * This class provides global folders that are used for rush's internal install locations.
 *
 * @internal
 */
class RushGlobalFolder {
    constructor() {
        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration
        // is initialized, we need to read it using a special internal API.
        const rushGlobalFolderOverride = _EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_1__.EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        if (rushGlobalFolderOverride !== undefined) {
            this.path = rushGlobalFolderOverride;
        }
        else {
            this.path = path__WEBPACK_IMPORTED_MODULE_0__.join(_utilities_Utilities__WEBPACK_IMPORTED_MODULE_2__.Utilities.getHomeFolder(), '.rush');
        }
        const normalizedNodeVersion = process.version.match(/^[a-z0-9\-\.]+$/i)
            ? process.version
            : 'unknown-version';
        this.nodeSpecificPath = path__WEBPACK_IMPORTED_MODULE_0__.join(this.path, `node-${normalizedNodeVersion}`);
    }
}
//# sourceMappingURL=RushGlobalFolder.js.map

/***/ }),

/***/ 882917:
/*!*****************************************!*\
  !*** ./lib-esnext/api/RushInternals.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushInternals": () => (/* binding */ RushInternals)
/* harmony export */ });
/* harmony import */ var _Rush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rush */ 465002);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Used by rush-sdk to access internals of rush-lib.
 * @internal
 */
class RushInternals {
    /**
     * Used by rush-sdk to load an internal API specified by its module path.
     *
     * @param srcImportPath - The module path to load.  For example, to refer to `src/api/ChangeFile.ts`,
     * the `srcImportPath` would be `"api/ChangeFile"`.
     * @returns the module object as would be returned by `require()`
     */
    static loadModule(srcImportPath) {
        const libPath = `${_Rush__WEBPACK_IMPORTED_MODULE_0__.Rush._rushLibPackageFolder}/lib/${srcImportPath}`;
        try {
            return require(libPath);
        }
        catch (e) {
            throw new Error(`The specified internal API "src/${srcImportPath}" is not implemented by Rush ${_Rush__WEBPACK_IMPORTED_MODULE_0__.Rush.version}`);
        }
    }
}
//# sourceMappingURL=RushInternals.js.map

/***/ }),

/***/ 622837:
/*!****************************************************!*\
  !*** ./lib-esnext/api/RushPluginsConfiguration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushPluginsConfiguration": () => (/* binding */ RushPluginsConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _schemas_rush_plugins_schema_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../schemas/rush-plugins.schema.json */ 328689);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class RushPluginsConfiguration {
    constructor(jsonFilename) {
        this._jsonFilename = jsonFilename;
        this.configuration = {
            plugins: []
        };
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(this._jsonFilename)) {
            this.configuration = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(this._jsonFilename, RushPluginsConfiguration._jsonSchema);
        }
    }
}
RushPluginsConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_rush_plugins_schema_json__WEBPACK_IMPORTED_MODULE_1__);

//# sourceMappingURL=RushPluginsConfiguration.js.map

/***/ }),

/***/ 514639:
/*!****************************************************!*\
  !*** ./lib-esnext/api/RushProjectConfiguration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushProjectConfiguration": () => (/* binding */ RushProjectConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/heft-config-file */ 579208);
/* harmony import */ var _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_rig_package__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/rig-package */ 192492);
/* harmony import */ var _rushstack_rig_package__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_rig_package__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _utilities_OverlappingPathAnalyzer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/OverlappingPathAnalyzer */ 529462);
/* harmony import */ var _schemas_rush_project_schema_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../schemas/rush-project.schema.json */ 262256);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







const RUSH_PROJECT_CONFIGURATION_FILE = new _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__.ConfigurationFile({
    projectRelativeFilePath: `config/${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushProjectConfigFilename}`,
    jsonSchemaObject: _schemas_rush_project_schema_json__WEBPACK_IMPORTED_MODULE_4__,
    propertyInheritance: {
        operationSettings: {
            inheritanceType: _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__.InheritanceType.custom,
            inheritanceFunction: (child, parent) => {
                if (!child) {
                    return parent;
                }
                else if (!parent) {
                    return child;
                }
                else {
                    // Merge any properties that need to be merged
                    const resultOperationSettingsByOperationName = new Map();
                    for (const parentOperationSettings of parent) {
                        resultOperationSettingsByOperationName.set(parentOperationSettings.operationName, parentOperationSettings);
                    }
                    const childEncounteredOperationNames = new Set();
                    for (const childOperationSettings of child) {
                        const operationName = childOperationSettings.operationName;
                        if (childEncounteredOperationNames.has(operationName)) {
                            // If the operation settings already exist, but didn't come from the parent, then
                            // it shows up multiple times in the child.
                            const childSourceFilePath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child);
                            throw new Error(`The operation "${operationName}" occurs multiple times in the "operationSettings" array ` +
                                `in "${childSourceFilePath}".`);
                        }
                        childEncounteredOperationNames.add(operationName);
                        let mergedOperationSettings = resultOperationSettingsByOperationName.get(operationName);
                        if (mergedOperationSettings) {
                            // The parent operation settings object already exists
                            const outputFolderNames = mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames
                                ? [
                                    ...mergedOperationSettings.outputFolderNames,
                                    ...childOperationSettings.outputFolderNames
                                ]
                                : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;
                            const dependsOnEnvVars = mergedOperationSettings.dependsOnEnvVars && childOperationSettings.dependsOnEnvVars
                                ? [
                                    ...mergedOperationSettings.dependsOnEnvVars,
                                    ...childOperationSettings.dependsOnEnvVars
                                ]
                                : mergedOperationSettings.dependsOnEnvVars || childOperationSettings.dependsOnEnvVars;
                            mergedOperationSettings = Object.assign(Object.assign(Object.assign(Object.assign({}, mergedOperationSettings), childOperationSettings), (outputFolderNames ? { outputFolderNames } : {})), (dependsOnEnvVars ? { dependsOnEnvVars } : {}));
                            resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);
                        }
                        else {
                            resultOperationSettingsByOperationName.set(operationName, childOperationSettings);
                        }
                    }
                    return Array.from(resultOperationSettingsByOperationName.values());
                }
            }
        },
        incrementalBuildIgnoredGlobs: {
            inheritanceType: _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__.InheritanceType.replace
        }
    }
});
const OLD_RUSH_PROJECT_CONFIGURATION_FILE = new _rushstack_heft_config_file__WEBPACK_IMPORTED_MODULE_1__.ConfigurationFile({
    projectRelativeFilePath: RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,
    jsonSchemaObject: _schemas_rush_project_schema_json__WEBPACK_IMPORTED_MODULE_4__
});
/**
 * Use this class to load the "config/rush-project.json" config file.
 *
 * This file provides project-specific configuration options.
 * @alpha
 */
class RushProjectConfiguration {
    constructor(project, rushProjectJson, operationSettingsByOperationName) {
        this._validationCache = new WeakSet();
        this.project = project;
        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];
        this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;
        this.operationSettingsByOperationName = operationSettingsByOperationName;
    }
    /**
     * Validates that the requested phases are compatible.
     * Deferral of this logic to its own method means that Rush no longer eagerly validates
     * all defined commands in command-line.json. As such, while validation will be run for a given
     * command upon invoking that command, defining overlapping phases in "rush custom-command"
     * that are not used by "rush build" will not cause "rush build" to exit with an error.
     */
    validatePhaseConfiguration(phases, terminal) {
        // Don't repeatedly validate the same set of phases for the same project.
        if (this._validationCache.has(phases)) {
            return;
        }
        const overlappingPathAnalyzer = new _utilities_OverlappingPathAnalyzer__WEBPACK_IMPORTED_MODULE_5__.OverlappingPathAnalyzer();
        const { operationSettingsByOperationName, project } = this;
        let hasErrors = false;
        for (const phase of phases) {
            const operationName = phase.name;
            const operationSettings = operationSettingsByOperationName.get(operationName);
            if (operationSettings) {
                if (operationSettings.outputFolderNames) {
                    for (const outputFolderName of operationSettings.outputFolderNames) {
                        const otherOverlappingOperationNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);
                        if (otherOverlappingOperationNames) {
                            const overlapsWithOwnOperation = otherOverlappingOperationNames === null || otherOverlappingOperationNames === void 0 ? void 0 : otherOverlappingOperationNames.includes(operationName);
                            if (overlapsWithOwnOperation) {
                                terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                    `"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines an ` +
                                    `operation with overlapping paths in the "outputFolderNames" list. The operation is ` +
                                    `"${operationName}", and the conflicting path is "${outputFolderName}".`);
                            }
                            else {
                                terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                    `"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines ` +
                                    'two operations in the same command whose "outputFolderNames" would overlap. ' +
                                    'Operations outputs in the same command must be disjoint so that they can be independently cached. ' +
                                    `The "${outputFolderName}" path overlaps between these operations: ` +
                                    `"${operationName}", "${otherOverlappingOperationNames.join('", "')}"`);
                            }
                            hasErrors = true;
                        }
                    }
                }
            }
        }
        this._validationCache.add(phases);
        if (hasErrors) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
    }
    /**
     * Examines the list of source files for the project and the target phase and returns a reason
     * why the project cannot enable the build cache for that phase, or undefined if it is safe to so do.
     */
    getCacheDisabledReason(trackedFileNames, phaseName) {
        if (this.disableBuildCacheForProject) {
            return 'Caching has been disabled for this project.';
        }
        const normalizedProjectRelativeFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Path.convertToSlashes(this.project.projectRelativeFolder);
        const operationSettings = this.operationSettingsByOperationName.get(phaseName);
        if (!operationSettings) {
            return `This project does not define the caching behavior of the "${phaseName}" command, so caching has been disabled.`;
        }
        if (operationSettings.disableBuildCacheForOperation) {
            return `Caching has been disabled for this project's "${phaseName}" command.`;
        }
        const { outputFolderNames } = operationSettings;
        if (!outputFolderNames) {
            return;
        }
        const normalizedOutputFolders = outputFolderNames.map((outputFolderName) => `${normalizedProjectRelativeFolder}/${outputFolderName}/`);
        const inputOutputFiles = [];
        for (const file of trackedFileNames) {
            for (const outputFolder of normalizedOutputFolders) {
                if (file.startsWith(outputFolder)) {
                    inputOutputFiles.push(file);
                }
            }
        }
        if (inputOutputFiles.length > 0) {
            return ('The following files are used to calculate project state ' +
                `and are considered project output: ${inputOutputFiles.join(', ')}`);
        }
    }
    /**
     * Loads the rush-project.json data for the specified project.
     */
    static async tryLoadForProjectAsync(project, terminal) {
        // false is a signal that the project config does not exist
        const cacheEntry = RushProjectConfiguration._configCache.get(project);
        if (cacheEntry !== undefined) {
            return cacheEntry || undefined;
        }
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        if (rushProjectJson) {
            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, terminal);
            RushProjectConfiguration._configCache.set(project, result);
            return result;
        }
        else {
            RushProjectConfiguration._configCache.set(project, false);
            return undefined;
        }
    }
    /**
     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping
     * validation of other parts of the config file.
     *
     * @remarks
     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without
     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.
     */
    static async tryLoadIgnoreGlobsForProjectAsync(project, terminal) {
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        return rushProjectJson === null || rushProjectJson === void 0 ? void 0 : rushProjectJson.incrementalBuildIgnoredGlobs;
    }
    /**
     * Load the rush-project.json data for all selected projects.
     * Validate compatibility of output folders across all selected phases.
     */
    static async tryLoadForProjectsAsync(projects, terminal) {
        const result = new Map();
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(projects, async (project) => {
            const projectConfig = await RushProjectConfiguration.tryLoadForProjectAsync(project, terminal);
            if (projectConfig) {
                result.set(project, projectConfig);
            }
        }, { concurrency: 50 });
        return result;
    }
    static async _tryLoadJsonForProjectAsync(project, terminal) {
        const rigConfig = await _rushstack_rig_package__WEBPACK_IMPORTED_MODULE_2__.RigConfig.loadForProjectFolderAsync({
            projectFolderPath: project.projectFolder
        });
        try {
            return await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
        }
        catch (e1) {
            // Detect if the project is using the old rush-project.json schema
            let oldRushProjectJson;
            try {
                oldRushProjectJson =
                    await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
            }
            catch (e2) {
                // Ignore
            }
            if ((oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.projectOutputFolderNames) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.phaseOptions) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.buildCacheOptions)) {
                throw new Error(`The ${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +
                    'in an outdated format. Please see the UPGRADING.md notes for details. ' +
                    'Quick link: https://rushjs.io/link/upgrading');
            }
            else {
                throw e1;
            }
        }
    }
    static _getRushProjectConfiguration(project, rushProjectJson, terminal) {
        const operationSettingsByOperationName = new Map();
        let hasErrors = false;
        if (rushProjectJson.operationSettings) {
            for (const operationSettings of rushProjectJson.operationSettings) {
                const operationName = operationSettings.operationName;
                const existingOperationSettings = operationSettingsByOperationName.get(operationName);
                if (existingOperationSettings) {
                    const existingOperationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);
                    const operationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);
                    hasErrors = true;
                    let errorMessage = `The operation "${operationName}" appears multiple times in the "${project.packageName}" project's ` +
                        `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +
                        'operationSettings property.';
                    if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {
                        if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {
                            errorMessage +=
                                ` It first appears in "${existingOperationSettingsJsonPath}" and again ` +
                                    `in "${operationSettingsJsonPath}".`;
                        }
                        else if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Path.convertToSlashes(project.projectFolder))) {
                            errorMessage += ` It appears multiple times in "${operationSettingsJsonPath}".`;
                        }
                    }
                    terminal.writeErrorLine(errorMessage);
                }
                else {
                    operationSettingsByOperationName.set(operationName, operationSettings);
                }
            }
        }
        if (hasErrors) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
        return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);
    }
}
RushProjectConfiguration._configCache = new Map();

//# sourceMappingURL=RushProjectConfiguration.js.map

/***/ }),

/***/ 354981:
/*!*************************************************!*\
  !*** ./lib-esnext/api/RushUserConfiguration.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushUserConfiguration": () => (/* binding */ RushUserConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _schemas_rush_user_settings_schema_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../schemas/rush-user-settings.schema.json */ 33477);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * Rush per-user configuration data.
 *
 * @beta
 */
class RushUserConfiguration {
    constructor(rushUserConfigurationJson) {
        this.buildCacheFolder = rushUserConfigurationJson === null || rushUserConfigurationJson === void 0 ? void 0 : rushUserConfigurationJson.buildCacheFolder;
        if (this.buildCacheFolder && !path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute(this.buildCacheFolder)) {
            throw new Error('buildCacheFolder must be an absolute path');
        }
    }
    static async initializeAsync() {
        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();
        const rushUserSettingsFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(rushUserFolderPath, 'settings.json');
        let rushUserSettingsJson;
        try {
            rushUserSettingsJson = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidateAsync(rushUserSettingsFilePath, RushUserConfiguration._schema);
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        return new RushUserConfiguration(rushUserSettingsJson);
    }
    static getRushUserFolderPath() {
        const homeFolderPath = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_2__.Utilities.getHomeFolder();
        const rushUserSettingsFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(homeFolderPath, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushUserConfigurationFolderName);
        return rushUserSettingsFilePath;
    }
}
RushUserConfiguration._schema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_rush_user_settings_schema_json__WEBPACK_IMPORTED_MODULE_4__);

//# sourceMappingURL=RushUserConfiguration.js.map

/***/ }),

/***/ 739048:
/*!*********************************************************!*\
  !*** ./lib-esnext/api/SaveCallbackPackageJsonEditor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SaveCallbackPackageJsonEditor": () => (/* binding */ SaveCallbackPackageJsonEditor)
/* harmony export */ });
/* harmony import */ var _PackageJsonEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PackageJsonEditor */ 73666);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class SaveCallbackPackageJsonEditor extends _PackageJsonEditor__WEBPACK_IMPORTED_MODULE_0__.PackageJsonEditor {
    constructor(options) {
        super(options.filename, options.object);
        this._onSaved = options.onSaved;
    }
    static fromObjectWithCallback(options) {
        return new SaveCallbackPackageJsonEditor(options);
    }
    saveIfModified() {
        const modified = super.saveIfModified();
        if (this._onSaved) {
            this._onSaved(this.saveToObject());
        }
        return modified;
    }
}
//# sourceMappingURL=SaveCallbackPackageJsonEditor.js.map

/***/ }),

/***/ 782487:
/*!************************************!*\
  !*** ./lib-esnext/api/Variants.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Variants": () => (/* binding */ Variants)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Namespace for utilities relating to the Variants feature.
 */
class Variants {
}
/**
 * Provides the parameter configuration for '--variant'.
 */
Variants.VARIANT_PARAMETER = {
    parameterLongName: '--variant',
    argumentName: 'VARIANT',
    description: 'Run command using a variant installation configuration',
    environmentVariable: 'RUSH_VARIANT'
};

//# sourceMappingURL=Variants.js.map

/***/ }),

/***/ 734331:
/*!*****************************************!*\
  !*** ./lib-esnext/api/VersionPolicy.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BumpType": () => (/* binding */ BumpType),
/* harmony export */   "IndividualVersionPolicy": () => (/* binding */ IndividualVersionPolicy),
/* harmony export */   "LockStepVersionPolicy": () => (/* binding */ LockStepVersionPolicy),
/* harmony export */   "VersionPolicy": () => (/* binding */ VersionPolicy),
/* harmony export */   "VersionPolicyDefinitionName": () => (/* binding */ VersionPolicyDefinitionName)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VersionPolicyConfiguration */ 904624);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * Type of version bumps
 * @public
 */
var BumpType;
(function (BumpType) {
    // No version bump
    BumpType[BumpType["none"] = 0] = "none";
    // Prerelease version bump
    BumpType[BumpType["prerelease"] = 1] = "prerelease";
    // Patch version bump
    BumpType[BumpType["patch"] = 2] = "patch";
    // Minor version bump
    BumpType[BumpType["minor"] = 4] = "minor";
    // Major version bump
    BumpType[BumpType["major"] = 5] = "major";
})(BumpType || (BumpType = {}));
/**
 * Version policy base type names
 * @public
 */
var VersionPolicyDefinitionName;
(function (VersionPolicyDefinitionName) {
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["lockStepVersion"] = 0] = "lockStepVersion";
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["individualVersion"] = 1] = "individualVersion";
})(VersionPolicyDefinitionName || (VersionPolicyDefinitionName = {}));
/**
 * This is the base class for version policy which controls how versions get bumped.
 * @public
 */
class VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        this.policyName = versionPolicyJson.policyName;
        this.definitionName = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        this.exemptFromRushChange = versionPolicyJson.exemptFromRushChange || false;
        this.includeEmailInChangeFile = versionPolicyJson.includeEmailInChangeFile || false;
        const jsonDependencies = versionPolicyJson.dependencies || {};
        this._versionFormatForCommit = jsonDependencies.versionFormatForCommit || _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_2__.VersionFormatForCommit.original;
        this._versionFormatForPublish =
            jsonDependencies.versionFormatForPublish || _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_2__.VersionFormatForPublish.original;
    }
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson) {
        const definition = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        if (definition === VersionPolicyDefinitionName.lockStepVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new LockStepVersionPolicy(versionPolicyJson);
        }
        else if (definition === VersionPolicyDefinitionName.individualVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new IndividualVersionPolicy(versionPolicyJson);
        }
        return undefined;
    }
    /**
     * Whether it is a lockstepped version policy
     */
    get isLockstepped() {
        return this.definitionName === VersionPolicyDefinitionName.lockStepVersion;
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for publishing.
     */
    setDependenciesBeforePublish(packageName, configuration) {
        if (this._versionFormatForPublish === _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_2__.VersionFormatForPublish.exact) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    const dependencyVersion = rushDependencyProject.packageJson.version;
                    dependency.setVersion(dependencyVersion);
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for checked-in source.
     */
    setDependenciesBeforeCommit(packageName, configuration) {
        if (this._versionFormatForCommit === _VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_2__.VersionFormatForCommit.wildcard) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    dependency.setVersion('*');
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
}
/**
 * This policy indicates all related projects should use the same version.
 * @public
 */
class LockStepVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._version = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(versionPolicyJson.version);
        this.nextBump =
            versionPolicyJson.nextBump !== undefined
                ? _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Enum.getValueByKey(BumpType, versionPolicyJson.nextBump)
                : undefined;
        this.mainProject = versionPolicyJson.mainProject;
    }
    /**
     * The value of the lockstep version
     */
    get version() {
        return this._version.format();
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName],
            version: this.version
        };
        if (this.nextBump !== undefined) {
            json.nextBump = BumpType[this.nextBump];
        }
        if (this.mainProject !== undefined) {
            json.mainProject = this.mainProject;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        const packageVersion = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(project.version);
        const compareResult = packageVersion.compare(this._version);
        if (compareResult === 0) {
            return undefined;
        }
        else if (compareResult > 0 && !force) {
            const errorMessage = `Version ${project.version} in package ${project.name}` +
                ` is higher than locked version ${this._version.format()}.`;
            throw new Error(errorMessage);
        }
        return this._updatePackageVersion(project, this._version);
    }
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType, identifier) {
        const nextBump = bumpType !== null && bumpType !== void 0 ? bumpType : this.nextBump;
        if (nextBump === undefined) {
            // let change files drive version bump.
            return;
        }
        this._version.inc(this._getReleaseType(nextBump), identifier);
    }
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString) {
        const newVersion = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(newVersionString);
        if (!newVersion || this._version === newVersion) {
            return false;
        }
        this._version = newVersion;
        return true;
    }
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(versionString, false);
        if (this._version.compare(versionToTest) !== 0) {
            throw new Error(`Invalid version ${versionString} in ${packageName}`);
        }
    }
    _updatePackageVersion(project, newVersion) {
        const updatedProject = (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_3__.cloneDeep)(project);
        updatedProject.version = newVersion.format();
        return updatedProject;
    }
    _getReleaseType(bumpType) {
        // Eventually we should just use ReleaseType and get rid of bump type.
        return BumpType[bumpType];
    }
}
/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @public
 */
class IndividualVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this.lockedMajor = versionPolicyJson.lockedMajor;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName]
        };
        if (this.lockedMajor !== undefined) {
            json.lockedMajor = this.lockedMajor;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        if (this.lockedMajor) {
            const version = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(project.version);
            if (version.major < this.lockedMajor) {
                const updatedProject = (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_3__.cloneDeep)(project);
                updatedProject.version = `${this.lockedMajor}.0.0`;
                return updatedProject;
            }
            else if (version.major > this.lockedMajor) {
                const errorMessage = `Version ${project.version} in package ${project.name}` +
                    ` is higher than locked major version ${this.lockedMajor}.`;
                throw new Error(errorMessage);
            }
        }
        return undefined;
    }
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType, identifier) {
        // individual version policy lets change files drive version bump.
    }
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(versionString, false);
        if (this.lockedMajor !== undefined) {
            if (this.lockedMajor !== versionToTest.major) {
                throw new Error(`Invalid major version ${versionString} in ${packageName}`);
            }
        }
    }
}
//# sourceMappingURL=VersionPolicy.js.map

/***/ }),

/***/ 904624:
/*!******************************************************!*\
  !*** ./lib-esnext/api/VersionPolicyConfiguration.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionFormatForCommit": () => (/* binding */ VersionFormatForCommit),
/* harmony export */   "VersionFormatForPublish": () => (/* binding */ VersionFormatForPublish),
/* harmony export */   "VersionPolicyConfiguration": () => (/* binding */ VersionPolicyConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _VersionPolicy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VersionPolicy */ 734331);
/* harmony import */ var _schemas_version_policies_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../schemas/version-policies.schema.json */ 982478);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



var VersionFormatForPublish;
(function (VersionFormatForPublish) {
    VersionFormatForPublish["original"] = "original";
    VersionFormatForPublish["exact"] = "exact";
})(VersionFormatForPublish || (VersionFormatForPublish = {}));
var VersionFormatForCommit;
(function (VersionFormatForCommit) {
    VersionFormatForCommit["wildcard"] = "wildcard";
    VersionFormatForCommit["original"] = "original";
})(VersionFormatForCommit || (VersionFormatForCommit = {}));
/**
 * Use this class to load and save the "common/config/rush/version-policies.json" config file.
 * This config file configures how different groups of projects will be published by Rush,
 * and how their version numbers will be determined.
 * @public
 */
class VersionPolicyConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this.versionPolicies = new Map();
        this._loadFile();
    }
    /**
     * Validate the version policy configuration against the rush config
     */
    validate(projectsByName) {
        if (!this.versionPolicies) {
            return;
        }
        this.versionPolicies.forEach((policy) => {
            const lockStepPolicy = policy;
            if (lockStepPolicy.mainProject && !projectsByName.get(lockStepPolicy.mainProject)) {
                throw new Error(`Version policy \"${policy.policyName}\" has a non-existing mainProject:` +
                    ` ${lockStepPolicy.mainProject}.`);
            }
        });
    }
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName) {
        const policy = this.versionPolicies.get(policyName);
        if (!policy) {
            throw new Error(`Failed to find version policy by name \'${policyName}\'`);
        }
        return policy;
    }
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName, bumpType, identifier, shouldCommit) {
        if (versionPolicyName) {
            const policy = this.versionPolicies.get(versionPolicyName);
            if (policy) {
                policy.bump(bumpType, identifier);
            }
        }
        else {
            this.versionPolicies.forEach((versionPolicy) => {
                if (versionPolicy) {
                    versionPolicy.bump(bumpType, identifier);
                }
            });
        }
        this._saveFile(!!shouldCommit);
    }
    /**
     * Updates the version directly for the specified version policy
     * @param versionPolicyName - version policy name
     * @param newVersion - new version
     */
    update(versionPolicyName, newVersion, shouldCommit) {
        const policy = this.versionPolicies.get(versionPolicyName);
        if (!policy || !policy.isLockstepped) {
            throw new Error(`Lockstep Version policy with name "${versionPolicyName}" cannot be found`);
        }
        const lockStepVersionPolicy = policy;
        const previousVersion = lockStepVersionPolicy.version;
        if (lockStepVersionPolicy.update(newVersion)) {
            // eslint-disable-next-line no-console
            console.log(`\nUpdate version policy ${versionPolicyName} from ${previousVersion} to ${newVersion}`);
            this._saveFile(!!shouldCommit);
        }
    }
    _loadFile() {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(this._jsonFileName)) {
            return;
        }
        const versionPolicyJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(this._jsonFileName, VersionPolicyConfiguration._jsonSchema);
        versionPolicyJson.forEach((policyJson) => {
            const policy = _VersionPolicy__WEBPACK_IMPORTED_MODULE_1__.VersionPolicy.load(policyJson);
            if (policy) {
                this.versionPolicies.set(policy.policyName, policy);
            }
        });
    }
    _saveFile(shouldCommit) {
        const versionPolicyJson = [];
        this.versionPolicies.forEach((versionPolicy) => {
            versionPolicyJson.push(versionPolicy._json);
        });
        if (shouldCommit) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.save(versionPolicyJson, this._jsonFileName, { updateExistingFile: true });
        }
    }
}
VersionPolicyConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_version_policies_schema_json__WEBPACK_IMPORTED_MODULE_2__);

//# sourceMappingURL=VersionPolicyConfiguration.js.map

/***/ }),

/***/ 820330:
/*!************************************************************!*\
  !*** ./lib-esnext/api/packageManager/NpmPackageManager.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmPackageManager": () => (/* binding */ NpmPackageManager)
/* harmony export */ });
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _PackageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PackageManager */ 923109);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Support for interacting with the NPM package manager.
 */
class NpmPackageManager extends _PackageManager__WEBPACK_IMPORTED_MODULE_0__.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'npm', _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.npmShrinkwrapFilename);
    }
}
//# sourceMappingURL=NpmPackageManager.js.map

/***/ }),

/***/ 923109:
/*!*********************************************************!*\
  !*** ./lib-esnext/api/packageManager/PackageManager.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackageManager": () => (/* binding */ PackageManager)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.
 * @public
 */
class PackageManager {
    /** @internal */
    constructor(version, packageManager, shrinkwrapFilename) {
        this.version = version;
        this.packageManager = packageManager;
        this.shrinkwrapFilename = shrinkwrapFilename;
    }
}
//# sourceMappingURL=PackageManager.js.map

/***/ }),

/***/ 171257:
/*!*************************************************************!*\
  !*** ./lib-esnext/api/packageManager/PnpmPackageManager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmPackageManager": () => (/* binding */ PnpmPackageManager)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _PackageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PackageManager */ 923109);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * Support for interacting with the PNPM package manager.
 */
class PnpmPackageManager extends _PackageManager__WEBPACK_IMPORTED_MODULE_2__.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'pnpm', _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.pnpmV3ShrinkwrapFilename);
        const parsedVersion = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(version);
        if (parsedVersion.major >= 6) {
            // Introduced in version 6.0.0
            this.pnpmfileFilename = _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.pnpmfileV6Filename;
        }
        else {
            this.pnpmfileFilename = _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.pnpmfileV1Filename;
        }
        // node_modules/.pnpm/lock.yaml
        // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0 for more details.
        this.internalShrinkwrapRelativePath = path__WEBPACK_IMPORTED_MODULE_1__.join('node_modules', '.pnpm', 'lock.yaml');
    }
}
//# sourceMappingURL=PnpmPackageManager.js.map

/***/ }),

/***/ 472222:
/*!*************************************************************!*\
  !*** ./lib-esnext/api/packageManager/YarnPackageManager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YarnPackageManager": () => (/* binding */ YarnPackageManager)
/* harmony export */ });
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _PackageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PackageManager */ 923109);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Support for interacting with the Yarn package manager.
 */
class YarnPackageManager extends _PackageManager__WEBPACK_IMPORTED_MODULE_0__.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'yarn', _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.yarnShrinkwrapFilename);
    }
}
//# sourceMappingURL=YarnPackageManager.js.map

/***/ }),

/***/ 795805:
/*!*******************************************************!*\
  !*** ./lib-esnext/cli/CommandLineMigrationAdvisor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommandLineMigrationAdvisor": () => (/* binding */ CommandLineMigrationAdvisor)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class CommandLineMigrationAdvisor {
    // NOTE: THIS RUNS BEFORE THE REAL COMMAND-LINE PARSING.
    // TAKE EXTREME CARE THAT THE HEURISTICS CANNOT FALSELY MATCH A VALID COMMAND LINE.
    static checkArgv(argv) {
        // 0=node.exe, 1=script name
        const args = process.argv.slice(2);
        if (args.length > 0) {
            if (args[0] === 'generate') {
                CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush generate", use "rush update" or "rush update --full".');
                return false;
            }
            if (args[0] === 'install') {
                if (args.indexOf('--full-clean') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install --full-clean", use "rush purge --unsafe".');
                    return false;
                }
                if (args.indexOf('-C') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install -C", use "rush purge --unsafe".');
                    return false;
                }
                if (args.indexOf('--clean') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install --clean", use "rush install --purge".');
                    return false;
                }
                if (args.indexOf('-c') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install -c", use "rush install --purge".');
                    return false;
                }
            }
        }
        // Everything is okay
        return true;
    }
    static _reportDeprecated(message) {
        // eslint-disable-next-line no-console
        console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.PrintUtilities.wrapWords('ERROR: You specified an outdated command-line that is no longer supported by this version of Rush:')));
        // eslint-disable-next-line no-console
        console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.PrintUtilities.wrapWords(message)));
        // eslint-disable-next-line no-console
        console.error();
        // eslint-disable-next-line no-console
        console.error(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.PrintUtilities.wrapWords(`For command-line help, type "rush -h".  For migration instructions,` +
            ` please visit ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.rushWebSiteUrl}`));
    }
}
//# sourceMappingURL=CommandLineMigrationAdvisor.js.map

/***/ }),

/***/ 365416:
/*!*************************************************!*\
  !*** ./lib-esnext/cli/RushCommandLineParser.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushCommandLineParser": () => (/* binding */ RushCommandLineParser)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/ts-command-line */ 806427);
/* harmony import */ var _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/RushConfiguration */ 126002);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _api_CommandLineConfiguration__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../api/CommandLineConfiguration */ 563114);
/* harmony import */ var _actions_AddAction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./actions/AddAction */ 850906);
/* harmony import */ var _actions_ChangeAction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./actions/ChangeAction */ 903296);
/* harmony import */ var _actions_CheckAction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./actions/CheckAction */ 839726);
/* harmony import */ var _actions_DeployAction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./actions/DeployAction */ 771917);
/* harmony import */ var _actions_InitAction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./actions/InitAction */ 68066);
/* harmony import */ var _actions_InitAutoinstallerAction__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./actions/InitAutoinstallerAction */ 334293);
/* harmony import */ var _actions_InitDeployAction__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./actions/InitDeployAction */ 635830);
/* harmony import */ var _actions_InstallAction__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./actions/InstallAction */ 680041);
/* harmony import */ var _actions_LinkAction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./actions/LinkAction */ 875901);
/* harmony import */ var _actions_ListAction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./actions/ListAction */ 700972);
/* harmony import */ var _actions_PublishAction__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./actions/PublishAction */ 999279);
/* harmony import */ var _actions_PurgeAction__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./actions/PurgeAction */ 784476);
/* harmony import */ var _actions_RemoveAction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./actions/RemoveAction */ 120926);
/* harmony import */ var _actions_ScanAction__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./actions/ScanAction */ 224996);
/* harmony import */ var _actions_UnlinkAction__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./actions/UnlinkAction */ 885577);
/* harmony import */ var _actions_UpdateAction__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./actions/UpdateAction */ 492778);
/* harmony import */ var _actions_UpdateAutoinstallerAction__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./actions/UpdateAutoinstallerAction */ 258082);
/* harmony import */ var _actions_VersionAction__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./actions/VersionAction */ 669821);
/* harmony import */ var _actions_UpdateCloudCredentialsAction__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./actions/UpdateCloudCredentialsAction */ 800947);
/* harmony import */ var _actions_UpgradeInteractiveAction__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./actions/UpgradeInteractiveAction */ 272500);
/* harmony import */ var _scriptActions_GlobalScriptAction__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./scriptActions/GlobalScriptAction */ 415578);
/* harmony import */ var _logic_Telemetry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../logic/Telemetry */ 827933);
/* harmony import */ var _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/RushGlobalFolder */ 164409);
/* harmony import */ var _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../logic/NodeJsCompatibility */ 161593);
/* harmony import */ var _actions_SetupAction__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./actions/SetupAction */ 14961);
/* harmony import */ var _pluginFramework_PluginManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pluginFramework/PluginManager */ 196314);
/* harmony import */ var _pluginFramework_RushSession__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pluginFramework/RushSession */ 964818);
/* harmony import */ var _scriptActions_PhasedScriptAction__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./scriptActions/PhasedScriptAction */ 62165);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




































class RushCommandLineParser extends _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__.CommandLineParser {
    constructor(options) {
        super({
            toolFilename: 'rush',
            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish' +
                ' many packages from a central Git repo.  It is designed to handle very large repositories' +
                ' supporting many projects and people.  Rush provides policies, protections, and customizations' +
                ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs' +
                ' and automates package publishing.  It can manage decoupled subsets of projects with different' +
                ' release and versioning strategies.  A full API is included to facilitate integration with other' +
                ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,' +
                ' Rush is for you.',
            enableTabCompletionAction: true
        });
        this._restrictConsoleOutput = RushCommandLineParser.shouldRestrictConsoleOutput();
        this._debugParameter = this.defineFlagParameter({
            parameterLongName: '--debug',
            parameterShortName: '-d',
            description: 'Show the full call stack if an error occurs while executing the tool'
        });
        this._quietParameter = this.defineFlagParameter({
            parameterLongName: '--quiet',
            parameterShortName: '-q',
            description: 'Hide rush startup information'
        });
        this._terminalProvider = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.ConsoleTerminalProvider();
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Terminal(this._terminalProvider);
        this._rushOptions = this._normalizeOptions(options || {});
        try {
            const rushJsonFilename = _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_5__.RushConfiguration.tryFindRushJsonLocation({
                startingFolder: this._rushOptions.cwd,
                showVerbose: !this._restrictConsoleOutput
            });
            if (rushJsonFilename) {
                this.rushConfiguration = _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_5__.RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
            }
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
        _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_6__.NodeJsCompatibility.warnAboutCompatibilityIssues({
            isRushLib: true,
            alreadyReportedNodeTooNewError: this._rushOptions.alreadyReportedNodeTooNewError,
            rushConfiguration: this.rushConfiguration
        });
        this.rushGlobalFolder = new _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_7__.RushGlobalFolder();
        this.rushSession = new _pluginFramework_RushSession__WEBPACK_IMPORTED_MODULE_8__.RushSession({
            getIsDebugMode: () => this.isDebug,
            terminalProvider: this._terminalProvider
        });
        this.pluginManager = new _pluginFramework_PluginManager__WEBPACK_IMPORTED_MODULE_9__.PluginManager({
            rushSession: this.rushSession,
            rushConfiguration: this.rushConfiguration,
            terminal: this._terminal,
            builtInPluginConfigurations: this._rushOptions.builtInPluginConfigurations,
            restrictConsoleOutput: this._restrictConsoleOutput,
            rushGlobalFolder: this.rushGlobalFolder
        });
        this._populateActions();
        const pluginCommandLineConfigurations = this.pluginManager.tryGetCustomCommandLineConfigurationInfos();
        for (const { commandLineConfiguration, pluginLoader } of pluginCommandLineConfigurations) {
            try {
                this._addCommandLineConfigActions(commandLineConfiguration);
            }
            catch (e) {
                this._terminal.writeErrorLine(`Error from plugin ${pluginLoader.pluginName} by ${pluginLoader.packageName}: ${e.toString()}`);
            }
        }
    }
    get isDebug() {
        return this._debugParameter.value;
    }
    get isQuiet() {
        return this._quietParameter.value;
    }
    /**
     * Utility to determine if the app should restrict writing to the console.
     */
    static shouldRestrictConsoleOutput() {
        if (_rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__.CommandLineHelper.isTabCompletionActionRequest(process.argv)) {
            return true;
        }
        for (let i = 2; i < process.argv.length; i++) {
            const arg = process.argv[i];
            if (arg === '-q' || arg === '--quiet' || arg === '--json') {
                return true;
            }
        }
        return false;
    }
    flushTelemetry() {
        var _a;
        (_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.flush();
    }
    async execute(args) {
        // debugParameter will be correctly parsed during super.execute(), so manually parse here.
        this._terminalProvider.verboseEnabled = this._terminalProvider.debugEnabled =
            process.argv.indexOf('--debug') >= 0;
        await this.pluginManager.tryInitializeUnassociatedPluginsAsync();
        return await super.execute(args);
    }
    async onExecute() {
        var _a;
        // Defensively set the exit code to 1 so if Rush crashes for whatever reason, we'll have a nonzero exit code.
        // For example, Node.js currently has the inexcusable design of terminating with zero exit code when
        // there is an uncaught promise exception.  This will supposedly be fixed in Node.js 9.
        // Ideally we should do this for all the Rush actions, but "rush build" is the most critical one
        // -- if it falsely appears to succeed, we could merge bad PRs, publish empty packages, etc.
        process.exitCode = 1;
        if (this._debugParameter.value) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.InternalError.breakInDebugger = true;
        }
        try {
            await this._wrapOnExecuteAsync();
            // If we make it here, everything went fine, so reset the exit code back to 0
            process.exitCode = 0;
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
        await ((_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.ensureFlushedAsync());
    }
    _normalizeOptions(options) {
        return {
            cwd: options.cwd || process.cwd(),
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false,
            builtInPluginConfigurations: options.builtInPluginConfigurations || []
        };
    }
    async _wrapOnExecuteAsync() {
        if (this.rushConfiguration) {
            this.telemetry = new _logic_Telemetry__WEBPACK_IMPORTED_MODULE_10__.Telemetry(this.rushConfiguration, this.rushSession);
        }
        await super.onExecute();
        if (this.telemetry) {
            this.flushTelemetry();
        }
    }
    _populateActions() {
        try {
            // Alphabetical order
            this.addAction(new _actions_AddAction__WEBPACK_IMPORTED_MODULE_11__.AddAction(this));
            this.addAction(new _actions_ChangeAction__WEBPACK_IMPORTED_MODULE_12__.ChangeAction(this));
            this.addAction(new _actions_CheckAction__WEBPACK_IMPORTED_MODULE_13__.CheckAction(this));
            this.addAction(new _actions_DeployAction__WEBPACK_IMPORTED_MODULE_14__.DeployAction(this));
            this.addAction(new _actions_InitAction__WEBPACK_IMPORTED_MODULE_15__.InitAction(this));
            this.addAction(new _actions_InitAutoinstallerAction__WEBPACK_IMPORTED_MODULE_16__.InitAutoinstallerAction(this));
            this.addAction(new _actions_InitDeployAction__WEBPACK_IMPORTED_MODULE_17__.InitDeployAction(this));
            this.addAction(new _actions_InstallAction__WEBPACK_IMPORTED_MODULE_18__.InstallAction(this));
            this.addAction(new _actions_LinkAction__WEBPACK_IMPORTED_MODULE_19__.LinkAction(this));
            this.addAction(new _actions_ListAction__WEBPACK_IMPORTED_MODULE_20__.ListAction(this));
            this.addAction(new _actions_PublishAction__WEBPACK_IMPORTED_MODULE_21__.PublishAction(this));
            this.addAction(new _actions_PurgeAction__WEBPACK_IMPORTED_MODULE_22__.PurgeAction(this));
            this.addAction(new _actions_RemoveAction__WEBPACK_IMPORTED_MODULE_23__.RemoveAction(this));
            this.addAction(new _actions_ScanAction__WEBPACK_IMPORTED_MODULE_24__.ScanAction(this));
            this.addAction(new _actions_SetupAction__WEBPACK_IMPORTED_MODULE_25__.SetupAction(this));
            this.addAction(new _actions_UnlinkAction__WEBPACK_IMPORTED_MODULE_26__.UnlinkAction(this));
            this.addAction(new _actions_UpdateAction__WEBPACK_IMPORTED_MODULE_27__.UpdateAction(this));
            this.addAction(new _actions_UpdateAutoinstallerAction__WEBPACK_IMPORTED_MODULE_28__.UpdateAutoinstallerAction(this));
            this.addAction(new _actions_UpdateCloudCredentialsAction__WEBPACK_IMPORTED_MODULE_29__.UpdateCloudCredentialsAction(this));
            this.addAction(new _actions_UpgradeInteractiveAction__WEBPACK_IMPORTED_MODULE_30__.UpgradeInteractiveAction(this));
            this.addAction(new _actions_VersionAction__WEBPACK_IMPORTED_MODULE_31__.VersionAction(this));
            this._populateScriptActions();
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
    }
    _populateScriptActions() {
        // If there is not a rush.json file, we still want "build" and "rebuild" to appear in the
        // command-line help
        let commandLineConfigFilePath;
        if (this.rushConfiguration) {
            commandLineConfigFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.commandLineFilename);
        }
        const commandLineConfiguration = _api_CommandLineConfiguration__WEBPACK_IMPORTED_MODULE_33__.CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFilePath);
        this._addCommandLineConfigActions(commandLineConfiguration);
    }
    _addCommandLineConfigActions(commandLineConfiguration) {
        // Register each custom command
        for (const command of commandLineConfiguration.commands.values()) {
            this._addCommandLineConfigAction(commandLineConfiguration, command);
        }
    }
    _addCommandLineConfigAction(commandLineConfiguration, command) {
        if (this.tryGetAction(command.name)) {
            throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.commandLineFilename} defines a command "${command.name}"` +
                ` using a name that already exists`);
        }
        switch (command.commandKind) {
            case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.globalCommandKind: {
                this._addGlobalScriptAction(commandLineConfiguration, command);
                break;
            }
            case _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.phasedCommandKind: {
                if (!command.isSynthetic && // synthetic commands come from bulk commands
                    !this.rushConfiguration.experimentsConfiguration.configuration.phasedCommands) {
                    throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.commandLineFilename} defines a command "${command.name}" ` +
                        `that uses the "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.phasedCommandKind}" command kind. To use this command kind, ` +
                        'the "phasedCommands" experiment must be enabled. Note that this feature is not complete ' +
                        'and will not work as expected.');
                }
                this._addPhasedCommandLineConfigAction(commandLineConfiguration, command);
                break;
            }
            default:
                throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.commandLineFilename} defines a command "${command.name}"` +
                    ` using an unsupported command kind "${command.commandKind}"`);
        }
    }
    _getSharedCommandActionOptions(commandLineConfiguration, command) {
        return {
            actionName: command.name,
            summary: command.summary,
            documentation: command.description || command.summary,
            safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,
            command,
            parser: this,
            commandLineConfiguration: commandLineConfiguration
        };
    }
    _addGlobalScriptAction(commandLineConfiguration, command) {
        if (command.name === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.buildCommandName ||
            command.name === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.rebuildCommandName) {
            throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.commandLineFilename} defines a command "${command.name}" using ` +
                `the command kind "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.globalCommandKind}". This command can only be designated as a command ` +
                `kind "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.bulkCommandKind}" or "${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.phasedCommandKind}".`);
        }
        const sharedCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);
        this.addAction(new _scriptActions_GlobalScriptAction__WEBPACK_IMPORTED_MODULE_34__.GlobalScriptAction(Object.assign(Object.assign({}, sharedCommandOptions), { shellCommand: command.shellCommand, autoinstallerName: command.autoinstallerName })));
    }
    _addPhasedCommandLineConfigAction(commandLineConfiguration, command) {
        var _a;
        const baseCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);
        this.addAction(new _scriptActions_PhasedScriptAction__WEBPACK_IMPORTED_MODULE_35__.PhasedScriptAction(Object.assign(Object.assign({}, baseCommandOptions), { enableParallelism: command.enableParallelism, incremental: command.incremental || false, disableBuildCache: command.disableBuildCache || false, initialPhases: command.phases, originalPhases: command.originalPhases, watchPhases: command.watchPhases, watchDebounceMs: (_a = command.watchDebounceMs) !== null && _a !== void 0 ? _a : _logic_RushConstants__WEBPACK_IMPORTED_MODULE_32__.RushConstants.defaultWatchDebounceMs, phases: commandLineConfiguration.phases, alwaysWatch: command.alwaysWatch, alwaysInstall: command.alwaysInstall })));
    }
    _reportErrorAndSetExitCode(error) {
        if (!(error instanceof _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError)) {
            const prefix = 'ERROR: ';
            // The colors package will eat multi-newlines, which could break formatting
            // in user-specified messages and instructions, so we prefer to color each
            // line individually.
            const message = _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.PrintUtilities.wrapWords(prefix + error.message)
                .split(/\r?\n/)
                .map((line) => colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(line))
                .join('\n');
            // eslint-disable-next-line no-console
            console.error(`\n${message}`);
        }
        if (this._debugParameter.value) {
            // If catchSyncErrors() called this, then show a call stack similar to what Node.js
            // would show for an uncaught error
            // eslint-disable-next-line no-console
            console.error(`\n${error.stack}`);
        }
        this.flushTelemetry();
        // Ideally we want to eliminate all calls to process.exit() from our code, and replace them
        // with normal control flow that properly cleans up its data structures.
        // For this particular call, we have a problem that the RushCommandLineParser constructor
        // performs nontrivial work that can throw an exception.  Either the Rush class would need
        // to handle reporting for those exceptions, or else _populateActions() should be moved
        // to a RushCommandLineParser lifecycle stage that can handle it.
        if (process.exitCode !== undefined) {
            process.exit(process.exitCode);
        }
        else {
            process.exit(1);
        }
    }
}
//# sourceMappingURL=RushCommandLineParser.js.map

/***/ }),

/***/ 66976:
/*!***********************************************!*\
  !*** ./lib-esnext/cli/RushPnpmCommandLine.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushPnpmCommandLine": () => (/* binding */ RushPnpmCommandLine)
/* harmony export */ });
/* harmony import */ var _RushPnpmCommandLineParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RushPnpmCommandLineParser */ 977221);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class RushPnpmCommandLine {
    static launch(launcherVersion, options) {
        _RushPnpmCommandLineParser__WEBPACK_IMPORTED_MODULE_0__.RushPnpmCommandLineParser.initializeAsync(options)
            // RushPnpmCommandLineParser.executeAsync should never reject the promise
            .then((rushPnpmCommandLineParser) => rushPnpmCommandLineParser.executeAsync())
            // eslint-disable-next-line no-console
            .catch(console.error);
    }
}
//# sourceMappingURL=RushPnpmCommandLine.js.map

/***/ }),

/***/ 977221:
/*!*****************************************************!*\
  !*** ./lib-esnext/cli/RushPnpmCommandLineParser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushPnpmCommandLineParser": () => (/* binding */ RushPnpmCommandLineParser)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/RushConfiguration */ 126002);
/* harmony import */ var _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logic/NodeJsCompatibility */ 161593);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/RushGlobalFolder */ 164409);
/* harmony import */ var _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../logic/PurgeManager */ 371186);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.









const RUSH_SKIP_CHECKS_PARAMETER = '--rush-skip-checks';
function _reportErrorAndSetExitCode(error, terminal, debugEnabled) {
    var _a;
    if (!(error instanceof _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError)) {
        const prefix = 'ERROR: ';
        terminal.writeErrorLine('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(prefix + error.message));
    }
    if (debugEnabled) {
        // If catchSyncErrors() called this, then show a call stack similar to what Node.js
        // would show for an uncaught error
        terminal.writeErrorLine('\n' + error.stack);
    }
    process.exit((_a = process.exitCode) !== null && _a !== void 0 ? _a : 1);
}
class RushPnpmCommandLineParser {
    constructor(options, terminal, debugEnabled) {
        this._debugEnabled = debugEnabled;
        this._terminal = terminal;
        // Are we in a Rush repo?
        const rushConfiguration = _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_3__.RushConfiguration.tryLoadFromDefaultLocation({
            // showVerbose is false because the logging message may break JSON output
            showVerbose: false
        });
        _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_4__.NodeJsCompatibility.warnAboutCompatibilityIssues({
            isRushLib: true,
            alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,
            rushConfiguration
        });
        if (!rushConfiguration) {
            throw new Error('The "rush-pnpm" command must be executed in a folder that is under a Rush workspace folder');
        }
        this._rushConfiguration = rushConfiguration;
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error('The "rush-pnpm" command requires your rush.json to be configured to use the PNPM package manager');
        }
        if (!rushConfiguration.pnpmOptions.useWorkspaces) {
            const pnpmConfigFilename = rushConfiguration.pnpmOptions.jsonFilename || 'rush.json';
            throw new Error(`The "rush-pnpm" command requires the "useWorkspaces" setting to be enabled in ${pnpmConfigFilename}`);
        }
        const workspaceFolder = rushConfiguration.commonTempFolder;
        const workspaceFilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(workspaceFolder, 'pnpm-workspace.yaml');
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(workspaceFilePath)) {
            this._terminal.writeErrorLine('Error: The PNPM workspace file has not been generated:');
            this._terminal.writeErrorLine(`  ${workspaceFilePath}\n`);
            this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(`Do you need to run "rush install" or "rush update"?`));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(rushConfiguration.packageManagerToolFilename)) {
            this._terminal.writeErrorLine('Error: The PNPM local binary has not been installed yet.');
            this._terminal.writeLine('\n' + _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(`Do you need to run "rush install" or "rush update"?`));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        // 0 = node.exe
        // 1 = rush-pnpm
        const pnpmArgs = process.argv.slice(2);
        this._pnpmArgs = pnpmArgs;
    }
    static async initializeAsync(options) {
        var _a;
        const debugEnabled = process.argv.indexOf('--debug') >= 0;
        const verboseEnabled = process.argv.indexOf('--verbose') >= 0;
        const localTerminalProvider = (_a = options.terminalProvider) !== null && _a !== void 0 ? _a : new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ConsoleTerminalProvider({
            debugEnabled,
            verboseEnabled
        });
        const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(localTerminalProvider);
        try {
            const rushPnpmCommandLineParser = new RushPnpmCommandLineParser(options, terminal, debugEnabled);
            await rushPnpmCommandLineParser._validatePnpmUsageAsync(rushPnpmCommandLineParser._pnpmArgs);
            return rushPnpmCommandLineParser;
        }
        catch (error) {
            _reportErrorAndSetExitCode(error, terminal, debugEnabled);
        }
    }
    async executeAsync() {
        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught
        // promise exception), so we start with the assumption that the exit code is 1
        // and set it to 0 only on success.
        process.exitCode = 1;
        this._execute();
        if (process.exitCode === 0) {
            await this._postExecuteAsync();
        }
    }
    async _validatePnpmUsageAsync(pnpmArgs) {
        if (pnpmArgs[0] === RUSH_SKIP_CHECKS_PARAMETER) {
            pnpmArgs.shift();
            // Ignore other checks
            return;
        }
        if (pnpmArgs.length === 0) {
            return;
        }
        const firstArg = pnpmArgs[0];
        // Detect common safe invocations
        if (pnpmArgs.includes('-h') || pnpmArgs.includes('--help') || pnpmArgs.includes('-?')) {
            return;
        }
        if (pnpmArgs.length === 1) {
            if (firstArg === '-v' || firstArg === '--version') {
                return;
            }
        }
        const BYPASS_NOTICE = `To bypass this check, add "${RUSH_SKIP_CHECKS_PARAMETER}" as the very first command line option.`;
        if (!/^[a-z]+([a-z0-9\-])*$/.test(firstArg)) {
            // We can't parse this CLI syntax
            this._terminal.writeErrorLine(`Warning: The "rush-pnpm" wrapper expects a command verb before "${firstArg}"\n`);
            this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(BYPASS_NOTICE));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        else {
            const commandName = firstArg;
            // Also accept SKIP_RUSH_CHECKS_PARAMETER immediately after the command verb
            if (pnpmArgs[1] === RUSH_SKIP_CHECKS_PARAMETER) {
                pnpmArgs.splice(1, 1);
                return;
            }
            if (pnpmArgs.indexOf(RUSH_SKIP_CHECKS_PARAMETER) >= 0) {
                // We do not attempt to parse PNPM's complete CLI syntax, so we cannot be sure how to interpret
                // strings that appear outside of the specific patterns that this parser recognizes
                this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "${RUSH_SKIP_CHECKS_PARAMETER}" option must be the first parameter for the "rush-pnpm" command.`));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
            }
            this._commandName = commandName;
            // Warn about commands known not to work
            /* eslint-disable no-fallthrough */
            switch (commandName) {
                // Blocked
                case 'import': {
                    this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command is known to be incompatible with Rush's environment.`) + '\n');
                    this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(BYPASS_NOTICE));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
                }
                // Show warning for install commands
                case 'add':
                case 'install':
                /* synonym */
                case 'i':
                case 'install-test':
                /* synonym */
                case 'it': {
                    this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command is incompatible with Rush's environment.` +
                        ` Use the "rush install" or "rush update" commands instead.`) + '\n');
                    this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(BYPASS_NOTICE));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
                }
                // Show warning
                case 'link':
                /* synonym */
                case 'ln':
                case 'remove':
                /* synonym */
                case 'rm':
                case 'unlink':
                case 'update':
                /* synonym */
                case 'up': {
                    this._terminal.writeWarningLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Warning: The "pnpm ${commandName}" command makes changes that may invalidate Rush's workspace state.`) + '\n');
                    this._terminal.writeWarningLine(`==> Consider running "rush install" or "rush update" afterwards.\n`);
                    break;
                }
                // Know safe after validation
                case 'patch': {
                    const semver = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! semver */ 710912, 23));
                    /**
                     * If you were to accidentally attempt to use rush-pnpm patch with a pnpmVersion < 7.4.0, pnpm patch may fallback to the system patch command.
                     * For instance, /usr/bin/patch which may just hangs forever
                     * So, erroring out the command if the pnpm version is < 7.4.0
                     */
                    if (semver.lt(this._rushConfiguration.packageManagerToolVersion, '7.4.0')) {
                        this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "pnpm patch" command is added after pnpm@7.4.0.` +
                            ` Please update "pnpmVersion" >= 7.4.0 in rush.json file and run "rush update" to use this command.`) + '\n');
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
                    }
                    break;
                }
                case 'patch-commit': {
                    const pnpmOptionsJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonRushConfigFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.pnpmConfigFilename);
                    if (this._rushConfiguration.rushConfigurationJson.pnpmOptions) {
                        this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "pnpm patch-commit" command is incompatible with specifying "pnpmOptions" in rush.json file.` +
                            ` Please move the content of "pnpmOptions" in rush.json file to ${pnpmOptionsJsonFilename}`) + '\n');
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
                    }
                    break;
                }
                // Known safe
                case 'audit':
                case 'exec':
                case 'list':
                /* synonym */
                case 'ls':
                case 'outdated':
                case 'pack':
                case 'prune':
                case 'publish':
                case 'rebuild':
                /* synonym */
                case 'rb':
                case 'root':
                case 'run':
                case 'start':
                case 'store':
                case 'test':
                /* synonym */
                case 't':
                case 'why': {
                    break;
                }
                // Unknown
                default: {
                    this._terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command has not been tested with Rush's environment. It may be incompatible.`) + '\n');
                    this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(BYPASS_NOTICE));
                }
            }
            /* eslint-enable no-fallthrough */
        }
    }
    _execute() {
        const rushConfiguration = this._rushConfiguration;
        const workspaceFolder = rushConfiguration.commonTempFolder;
        const pnpmEnvironmentMap = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.EnvironmentMap(process.env);
        pnpmEnvironmentMap.set('NPM_CONFIG_WORKSPACE_DIR', workspaceFolder);
        if (rushConfiguration.pnpmOptions.pnpmStorePath) {
            pnpmEnvironmentMap.set('NPM_CONFIG_STORE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);
            pnpmEnvironmentMap.set('NPM_CONFIG_CACHE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);
            pnpmEnvironmentMap.set('NPM_CONFIG_STATE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);
        }
        if (rushConfiguration.pnpmOptions.environmentVariables) {
            for (const [envKey, { value: envValue, override }] of Object.entries(rushConfiguration.pnpmOptions.environmentVariables)) {
                if (override) {
                    pnpmEnvironmentMap.set(envKey, envValue);
                }
                else {
                    if (undefined === pnpmEnvironmentMap.get(envKey)) {
                        pnpmEnvironmentMap.set(envKey, envValue);
                    }
                }
            }
        }
        const result = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Executable.spawnSync(rushConfiguration.packageManagerToolFilename, this._pnpmArgs, {
            environmentMap: pnpmEnvironmentMap,
            stdio: 'inherit'
        });
        if (result.error) {
            throw new Error('Failed to invoke PNPM: ' + result.error);
        }
        if (result.status === null) {
            throw new Error('Failed to invoke PNPM: Spawn completed without an exit code');
        }
        process.exitCode = result.status;
    }
    async _postExecuteAsync() {
        var _a;
        const commandName = this._commandName;
        if (!commandName) {
            return;
        }
        switch (commandName) {
            case 'patch-commit': {
                // Example: "C:\MyRepo\common\temp\package.json"
                const commonPackageJsonFilename = `${this._rushConfiguration.commonTempFolder}/${_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileConstants.PackageJson}`;
                const commonPackageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.load(commonPackageJsonFilename);
                const newGlobalPatchedDependencies = (_a = commonPackageJson === null || commonPackageJson === void 0 ? void 0 : commonPackageJson.pnpm) === null || _a === void 0 ? void 0 : _a.patchedDependencies;
                const currentGlobalPatchedDependencies = this._rushConfiguration.pnpmOptions.globalPatchedDependencies;
                if (!(0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_6__.objectsAreDeepEqual)(currentGlobalPatchedDependencies, newGlobalPatchedDependencies)) {
                    const commonTempPnpmPatchesFolder = `${this._rushConfiguration.commonTempFolder}/${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.pnpmPatchesFolderName}`;
                    const rushPnpmPatchesFolder = `${this._rushConfiguration.commonFolder}/pnpm-${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.pnpmPatchesFolderName}`;
                    // Copy (or delete) common\temp\patches\ --> common\pnpm-patches\
                    if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(commonTempPnpmPatchesFolder)) {
                        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.ensureEmptyFolder(rushPnpmPatchesFolder);
                        // eslint-disable-next-line no-console
                        console.log(`Copying ${commonTempPnpmPatchesFolder}`);
                        // eslint-disable-next-line no-console
                        console.log(`  --> ${rushPnpmPatchesFolder}`);
                        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFiles({
                            sourcePath: commonTempPnpmPatchesFolder,
                            destinationPath: rushPnpmPatchesFolder
                        });
                    }
                    else {
                        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(rushPnpmPatchesFolder)) {
                            // eslint-disable-next-line no-console
                            console.log(`Deleting ${rushPnpmPatchesFolder}`);
                            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.deleteFolder(rushPnpmPatchesFolder);
                        }
                    }
                    // Update patchedDependencies to pnpm configuration file
                    this._rushConfiguration.pnpmOptions.updateGlobalPatchedDependencies(newGlobalPatchedDependencies);
                    // Rerun installation to update
                    await this._doRushUpdateAsync();
                    this._terminal.writeWarningLine(`Rush refreshed the ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.pnpmConfigFilename}, shrinkwrap file and patch files under the "common/pnpm/patches" folder.\n` +
                        '  Please commit this change to Git.');
                }
                break;
            }
        }
    }
    async _doRushUpdateAsync() {
        this._terminal.writeLine();
        this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.green('Running "rush update"'));
        this._terminal.writeLine();
        const rushGlobalFolder = new _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_7__.RushGlobalFolder();
        const purgeManager = new _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_8__.PurgeManager(this._rushConfiguration, rushGlobalFolder);
        const installManagerOptions = {
            debug: this._debugEnabled,
            allowShrinkwrapUpdates: true,
            bypassPolicy: false,
            noLink: false,
            fullUpgrade: false,
            recheckShrinkwrap: true,
            networkConcurrency: undefined,
            collectLogFile: false,
            variant: undefined,
            maxInstallAttempts: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.defaultMaxInstallAttempts,
            pnpmFilterArguments: [],
            checkOnly: false
        };
        const installManagerFactoryModule = await __webpack_require__.e(/*! import() | InstallManagerFactory */ "InstallManagerFactory").then(__webpack_require__.bind(__webpack_require__, /*! ../logic/InstallManagerFactory */ 611779));
        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this._rushConfiguration, rushGlobalFolder, purgeManager, installManagerOptions);
        try {
            await installManager.doInstallAsync();
        }
        finally {
            purgeManager.deleteAll();
        }
    }
}
//# sourceMappingURL=RushPnpmCommandLineParser.js.map

/***/ }),

/***/ 149507:
/*!*********************************************!*\
  !*** ./lib-esnext/cli/RushStartupBanner.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushStartupBanner": () => (/* binding */ RushStartupBanner)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
/* harmony import */ var _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logic/NodeJsCompatibility */ 161593);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class RushStartupBanner {
    static logBanner(rushVersion, isManaged) {
        const nodeVersion = this._formatNodeVersion();
        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';
        // eslint-disable-next-line no-console
        console.log('\n' +
            colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Rush Multi-Project Build Tool${versionSuffix}`) +
            colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(` - ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.rushWebSiteUrl}`) +
            `\nNode.js version is ${nodeVersion}\n`);
    }
    static logStreamlinedBanner(rushVersion, isManaged) {
        const nodeVersion = this._formatNodeVersion();
        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';
        // eslint-disable-next-line no-console
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Rush Multi-Project Build Tool${versionSuffix}`) + ` - Node.js ${nodeVersion}`);
    }
    static _formatNodeVersion() {
        const nodeVersion = process.versions.node;
        const nodeReleaseLabel = _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_2__.NodeJsCompatibility.isOddNumberedVersion
            ? 'unstable'
            : _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_2__.NodeJsCompatibility.isLtsVersion
                ? 'LTS'
                : 'pre-LTS';
        return `${nodeVersion} (${nodeReleaseLabel})`;
    }
    static _formatRushVersion(rushVersion, isManaged) {
        return rushVersion + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(isManaged ? '' : ' (unmanaged)');
    }
}
//# sourceMappingURL=RushStartupBanner.js.map

/***/ }),

/***/ 125373:
/*!********************************************!*\
  !*** ./lib-esnext/cli/RushXCommandLine.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushXCommandLine": () => (/* binding */ RushXCommandLine)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _logic_ProjectCommandSet__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../logic/ProjectCommandSet */ 949799);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/Rush */ 465002);
/* harmony import */ var _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/RushConfiguration */ 126002);
/* harmony import */ var _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../logic/NodeJsCompatibility */ 161593);
/* harmony import */ var _RushStartupBanner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RushStartupBanner */ 149507);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.










class RushXCommandLine {
    static launchRushX(launcherVersion, isManaged) {
        RushXCommandLine._launchRushXInternal(launcherVersion, { isManaged });
    }
    /**
     * @internal
     */
    static _launchRushXInternal(launcherVersion, options) {
        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught
        // promise exception), so we start with the assumption that the exit code is 1
        // and set it to 0 only on success.
        process.exitCode = 1;
        const args = this._getCommandLineArguments();
        if (!args.quiet) {
            _RushStartupBanner__WEBPACK_IMPORTED_MODULE_4__.RushStartupBanner.logStreamlinedBanner(_api_Rush__WEBPACK_IMPORTED_MODULE_5__.Rush.version, options.isManaged);
        }
        try {
            // Are we in a Rush repo?
            const rushConfiguration = _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_6__.RushConfiguration.tryLoadFromDefaultLocation({
                showVerbose: false
            });
            _logic_NodeJsCompatibility__WEBPACK_IMPORTED_MODULE_7__.NodeJsCompatibility.warnAboutCompatibilityIssues({
                isRushLib: true,
                alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,
                rushConfiguration
            });
            // Find the governing package.json for this folder:
            const packageJsonLookup = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.PackageJsonLookup();
            const packageJsonFilePath = packageJsonLookup.tryGetPackageJsonFilePathFor(process.cwd());
            if (!packageJsonFilePath) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('This command should be used inside a project folder.'));
                // eslint-disable-next-line no-console
                console.log(`Unable to find a package.json file in the current working directory or any of its parents.`);
                return;
            }
            if (rushConfiguration && !rushConfiguration.tryGetProjectForPath(process.cwd())) {
                // GitHub #2713: Users reported confusion resulting from a situation where "rush install"
                // did not install the project's dependencies, because the project was not registered.
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Warning: You are invoking "rushx" inside a Rush repository, but this project is not registered in rush.json.'));
            }
            const packageJson = packageJsonLookup.loadPackageJson(packageJsonFilePath);
            const projectCommandSet = new _logic_ProjectCommandSet__WEBPACK_IMPORTED_MODULE_8__.ProjectCommandSet(packageJson);
            if (args.help) {
                RushXCommandLine._showUsage(packageJson, projectCommandSet);
                return;
            }
            const scriptBody = projectCommandSet.tryGetScriptBody(args.commandName);
            if (scriptBody === undefined) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`Error: The command "${args.commandName}" is not defined in the` +
                    ` package.json file for this project.`));
                if (projectCommandSet.commandNames.length > 0) {
                    // eslint-disable-next-line no-console
                    console.log('\nAvailable commands for this project are: ' +
                        projectCommandSet.commandNames.map((x) => `"${x}"`).join(', '));
                }
                // eslint-disable-next-line no-console
                console.log(`Use ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('"rushx --help"')} for more information.`);
                return;
            }
            let commandWithArgs = scriptBody;
            let commandWithArgsForDisplay = scriptBody;
            if (args.commandArgs.length > 0) {
                // This approach is based on what NPM 7 now does:
                // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34
                const escapedRemainingArgs = args.commandArgs.map((x) => _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.escapeShellParameter(x));
                commandWithArgs += ' ' + escapedRemainingArgs.join(' ');
                // Display it nicely without the extra quotes
                commandWithArgsForDisplay += ' ' + args.commandArgs.join(' ');
            }
            if (!args.quiet) {
                // eslint-disable-next-line no-console
                console.log(`> ${JSON.stringify(commandWithArgsForDisplay)}\n`);
            }
            const packageFolder = path__WEBPACK_IMPORTED_MODULE_1__.dirname(packageJsonFilePath);
            const exitCode = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.executeLifecycleCommand(commandWithArgs, {
                rushConfiguration,
                workingDirectory: packageFolder,
                // If there is a rush.json then use its .npmrc from the temp folder.
                // Otherwise look for npmrc in the project folder.
                initCwd: rushConfiguration ? rushConfiguration.commonTempFolder : packageFolder,
                handleOutput: false,
                environmentPathOptions: {
                    includeProjectBin: true
                }
            });
            if (exitCode > 0) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`The script failed with exit code ${exitCode}`));
            }
            process.exitCode = exitCode;
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('Error: ' + error.message));
        }
    }
    static _getCommandLineArguments() {
        // 0 = node.exe
        // 1 = rushx
        const args = process.argv.slice(2);
        const unknownArgs = [];
        let help = false;
        let quiet = false;
        let commandName = '';
        const commandArgs = [];
        for (let index = 0; index < args.length; index++) {
            const argValue = args[index];
            if (!commandName) {
                if (argValue === '-q' || argValue === '--quiet') {
                    quiet = true;
                }
                else if (argValue === '-h' || argValue === '--help') {
                    help = true;
                }
                else if (argValue.startsWith('-')) {
                    unknownArgs.push(args[index]);
                }
                else {
                    commandName = args[index];
                }
            }
            else {
                commandArgs.push(args[index]);
            }
        }
        if (!commandName) {
            help = true;
        }
        if (unknownArgs.length > 0) {
            // Future TODO: Instead of just displaying usage info, we could display a
            // specific error about the unknown flag the user tried to pass to rushx.
            help = true;
        }
        return {
            help,
            quiet,
            commandName,
            commandArgs
        };
    }
    static _showUsage(packageJson, projectCommandSet) {
        // eslint-disable-next-line no-console
        console.log('usage: rushx [-h]');
        // eslint-disable-next-line no-console
        console.log('       rushx [-q/--quiet] <command> ...\n');
        // eslint-disable-next-line no-console
        console.log('Optional arguments:');
        // eslint-disable-next-line no-console
        console.log('  -h, --help            Show this help message and exit.');
        // eslint-disable-next-line no-console
        console.log('  -q, --quiet           Hide rushx startup information.\n');
        if (projectCommandSet.commandNames.length > 0) {
            // eslint-disable-next-line no-console
            console.log(`Project commands for ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(packageJson.name)}:`);
            // Calculate the length of the longest script name, for formatting
            let maxLength = 0;
            for (const commandName of projectCommandSet.commandNames) {
                maxLength = Math.max(maxLength, commandName.length);
            }
            for (const commandName of projectCommandSet.commandNames) {
                const escapedScriptBody = JSON.stringify(projectCommandSet.getScriptBody(commandName));
                // The length of the string e.g. "  command: "
                const firstPartLength = 2 + maxLength + 2;
                // The length for truncating the escaped escapedScriptBody so it doesn't wrap
                // to the next line
                const consoleWidth = _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__.PrintUtilities.getConsoleWidth() || _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CONSOLE_WIDTH;
                const truncateLength = Math.max(0, consoleWidth - firstPartLength) - 1;
                // eslint-disable-next-line no-console
                console.log(
                // Example: "  command: "
                '  ' +
                    colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Text.padEnd(commandName + ':', maxLength + 2)) +
                    // Example: "do some thin..."
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Text.truncateWithEllipsis(escapedScriptBody, truncateLength));
            }
            if (projectCommandSet.malformedScriptNames.length > 0) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Warning: Some "scripts" entries in the package.json file' +
                        ' have malformed names: ' +
                        projectCommandSet.malformedScriptNames.map((x) => `"${x}"`).join(', ')));
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Warning: No commands are defined yet for this project.'));
            // eslint-disable-next-line no-console
            console.log('You can define a command by adding a "scripts" table to the project\'s package.json file.');
        }
    }
}
//# sourceMappingURL=RushXCommandLine.js.map

/***/ }),

/***/ 850906:
/*!*********************************************!*\
  !*** ./lib-esnext/cli/actions/AddAction.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddAction": () => (/* binding */ AddAction)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseAddAndRemoveAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseAddAndRemoveAction */ 486042);
/* harmony import */ var _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logic/DependencySpecifier */ 68654);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class AddAction extends _BaseAddAndRemoveAction__WEBPACK_IMPORTED_MODULE_1__.BaseAddAndRemoveAction {
    constructor(parser) {
        const documentation = [
            'Adds specified package(s) to the dependencies of the current project (as determined by the current working directory)' +
                ' and then runs "rush update". If no version is specified, a version will be automatically detected (typically' +
                ' either the latest version or a version that won\'t break the "ensureConsistentVersions" policy). If a version' +
                ' range (or a workspace range) is specified, the latest version in the range will be used. The version will be' +
                ' automatically prepended with a tilde, unless the "--exact" or "--caret" flags are used. The "--make-consistent"' +
                ' flag can be used to update all packages with the dependency.'
        ].join('\n');
        super({
            actionName: 'add',
            summary: 'Adds one or more dependencies to the package.json and runs rush update.',
            documentation,
            safeForSimultaneousRushProcesses: false,
            parser
        });
        this._packageNameList = this.defineStringListParameter({
            parameterLongName: '--package',
            parameterShortName: '-p',
            required: true,
            argumentName: 'PACKAGE',
            description: 'The name of the package which should be added as a dependency.' +
                ' A SemVer version specifier can be appended after an "@" sign.  WARNING: Symbol characters' +
                " are usually interpreted by your shell, so it's recommended to use quotes." +
                ' For example, write "rush add --package "example@^1.2.3"" instead of "rush add --package example@^1.2.3".' +
                ' To add multiple packages, write "rush add --package foo --package bar".'
        });
        this._exactFlag = this.defineFlagParameter({
            parameterLongName: '--exact',
            description: 'If specified, the SemVer specifier added to the' +
                ' package.json will be an exact version (e.g. without tilde or caret).'
        });
        this._caretFlag = this.defineFlagParameter({
            parameterLongName: '--caret',
            description: 'If specified, the SemVer specifier added to the' +
                ' package.json will be a prepended with a "caret" specifier ("^").'
        });
        this._devDependencyFlag = this.defineFlagParameter({
            parameterLongName: '--dev',
            description: 'If specified, the package will be added to the "devDependencies" section of the package.json'
        });
        this._peerDependencyFlag = this.defineFlagParameter({
            parameterLongName: '--peer',
            description: 'If specified, the package will be added to the "peerDependencies" section of the package.json'
        });
        this._makeConsistentFlag = this.defineFlagParameter({
            parameterLongName: '--make-consistent',
            parameterShortName: '-m',
            description: 'If specified, other packages with this dependency will have their package.json' +
                ' files updated to use the same version of the dependency.'
        });
        this._allFlag = this.defineFlagParameter({
            parameterLongName: '--all',
            description: 'If specified, the dependency will be added to all projects.'
        });
    }
    getUpdateOptions() {
        const projects = super.getProjects();
        if (this._caretFlag.value && this._exactFlag.value) {
            throw new Error(`Only one of "${this._caretFlag.longName}" and "${this._exactFlag.longName}" should be specified`);
        }
        const packagesToAdd = [];
        for (const specifiedPackageName of this.specifiedPackageNameList) {
            /**
             * Name & Version
             */
            let packageName = specifiedPackageName;
            let version = undefined;
            const parts = packageName.split('@');
            if (parts[0] === '') {
                // this is a scoped package
                packageName = '@' + parts[1];
                version = parts[2];
            }
            else {
                packageName = parts[0];
                version = parts[1];
            }
            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {
                throw new Error(`The package name "${packageName}" is not valid.`);
            }
            if (version && version !== 'latest') {
                const specifier = new _logic_DependencySpecifier__WEBPACK_IMPORTED_MODULE_2__.DependencySpecifier(packageName, version);
                if (!semver__WEBPACK_IMPORTED_MODULE_0__.validRange(specifier.versionSpecifier) && !semver__WEBPACK_IMPORTED_MODULE_0__.valid(specifier.versionSpecifier)) {
                    throw new Error(`The SemVer specifier "${version}" is not valid.`);
                }
            }
            /**
             * RangeStyle
             */
            let rangeStyle;
            if (version && version !== 'latest') {
                if (this._exactFlag.value || this._caretFlag.value) {
                    throw new Error(`The "${this._caretFlag.longName}" and "${this._exactFlag.longName}" flags may not be specified if a ` +
                        `version is provided in the ${this._packageNameList.longName} specifier. In this case "${version}" was provided.`);
                }
                rangeStyle = "passthrough" /* SemVerStyle.Passthrough */;
            }
            else {
                rangeStyle = this._caretFlag.value
                    ? "caret" /* SemVerStyle.Caret */
                    : this._exactFlag.value
                        ? "exact" /* SemVerStyle.Exact */
                        : "tilde" /* SemVerStyle.Tilde */;
            }
            packagesToAdd.push({ packageName, version, rangeStyle });
        }
        return {
            projects: projects,
            packagesToUpdate: packagesToAdd,
            devDependency: this._devDependencyFlag.value,
            peerDependency: this._peerDependencyFlag.value,
            updateOtherPackages: this._makeConsistentFlag.value,
            skipUpdate: this._skipUpdateFlag.value,
            debugInstall: this.parser.isDebug,
            actionName: this.actionName
        };
    }
}
//# sourceMappingURL=AddAction.js.map

/***/ }),

/***/ 486042:
/*!**********************************************************!*\
  !*** ./lib-esnext/cli/actions/BaseAddAndRemoveAction.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseAddAndRemoveAction": () => (/* binding */ BaseAddAndRemoveAction)
/* harmony export */ });
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * This is the common base class for AddAction and RemoveAction.
 */
class BaseAddAndRemoveAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    get specifiedPackageNameList() {
        return this._packageNameList.values;
    }
    constructor(options) {
        super(options);
        this._skipUpdateFlag = this.defineFlagParameter({
            parameterLongName: '--skip-update',
            parameterShortName: '-s',
            description: 'If specified, the "rush update" command will not be run after updating the package.json files.'
        });
    }
    getProjects() {
        if (this._allFlag.value) {
            return this.rushConfiguration.projects;
        }
        else {
            const currentProject = this.rushConfiguration.tryGetProjectForPath(process.cwd());
            if (!currentProject) {
                throw new Error(`The rush "${this.actionName}" command must be invoked under a project` +
                    ` folder that is registered in rush.json unless the ${this._allFlag.longName} is used.`);
            }
            return [currentProject];
        }
    }
    async runAsync() {
        const packageJsonUpdater = await Promise.all(/*! import() | PackageJsonUpdater */[__webpack_require__.e("InstallManagerFactory"), __webpack_require__.e("PackageJsonUpdater")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/PackageJsonUpdater */ 628039));
        const updater = new packageJsonUpdater.PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);
        await updater.doRushUpdateAsync(this.getUpdateOptions());
    }
}
//# sourceMappingURL=BaseAddAndRemoveAction.js.map

/***/ }),

/***/ 823791:
/*!*****************************************************!*\
  !*** ./lib-esnext/cli/actions/BaseInstallAction.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseInstallAction": () => (/* binding */ BaseInstallAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _api_EventHooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../api/EventHooks */ 519005);
/* harmony import */ var _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../logic/PurgeManager */ 371186);
/* harmony import */ var _logic_SetupChecks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logic/SetupChecks */ 60296);
/* harmony import */ var _logic_StandardScriptUpdater__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../logic/StandardScriptUpdater */ 427424);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/versionMismatch/VersionMismatchFinder */ 936800);
/* harmony import */ var _api_Variants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../api/Variants */ 782487);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.











/**
 * This is the common base class for InstallAction and UpdateAction.
 */
class BaseInstallAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__.BaseRushAction {
    constructor(options) {
        super(options);
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ConsoleTerminalProvider({ verboseEnabled: options.parser.isDebug }));
        this._purgeParameter = this.defineFlagParameter({
            parameterLongName: '--purge',
            parameterShortName: '-p',
            description: 'Perform "rush purge" before starting the installation'
        });
        this._bypassPolicyParameter = this.defineFlagParameter({
            parameterLongName: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.bypassPolicyFlagLongName,
            description: 'Overrides enforcement of the "gitPolicy" rules from rush.json (use honorably!)'
        });
        this._noLinkParameter = this.defineFlagParameter({
            parameterLongName: '--no-link',
            description: 'If "--no-link" is specified, then project symlinks will NOT be created' +
                ' after the installation completes.  You will need to run "rush link" manually.' +
                ' This flag is useful for automated builds that want to report stages individually' +
                ' or perform extra operations in between the two stages. This flag is not supported' +
                ' when using workspaces.'
        });
        this._networkConcurrencyParameter = this.defineIntegerParameter({
            parameterLongName: '--network-concurrency',
            argumentName: 'COUNT',
            description: 'If specified, limits the maximum number of concurrent network requests.' +
                '  This is useful when troubleshooting network failures.'
        });
        this._debugPackageManagerParameter = this.defineFlagParameter({
            parameterLongName: '--debug-package-manager',
            description: 'Activates verbose logging for the package manager. You will probably want to pipe' +
                ' the output of Rush to a file when using this command.'
        });
        this._maxInstallAttempts = this.defineIntegerParameter({
            parameterLongName: '--max-install-attempts',
            argumentName: 'NUMBER',
            description: `Overrides the default maximum number of install attempts.`,
            defaultValue: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.defaultMaxInstallAttempts
        });
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        this._variant = this.defineStringParameter(_api_Variants__WEBPACK_IMPORTED_MODULE_4__.Variants.VARIANT_PARAMETER);
    }
    async runAsync() {
        _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_5__.VersionMismatchFinder.ensureConsistentVersions(this.rushConfiguration, this._terminal, {
            variant: this._variant.value
        });
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_6__.Stopwatch.start();
        _logic_SetupChecks__WEBPACK_IMPORTED_MODULE_7__.SetupChecks.validate(this.rushConfiguration);
        let warnAboutScriptUpdate = false;
        if (this.actionName === 'update') {
            warnAboutScriptUpdate = await _logic_StandardScriptUpdater__WEBPACK_IMPORTED_MODULE_8__.StandardScriptUpdater.updateAsync(this.rushConfiguration);
        }
        else {
            await _logic_StandardScriptUpdater__WEBPACK_IMPORTED_MODULE_8__.StandardScriptUpdater.validateAsync(this.rushConfiguration);
        }
        this.eventHooksManager.handle(_api_EventHooks__WEBPACK_IMPORTED_MODULE_9__.Event.preRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);
        const purgeManager = new _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_10__.PurgeManager(this.rushConfiguration, this.rushGlobalFolder);
        if (this._purgeParameter.value) {
            // eslint-disable-next-line no-console
            console.log('The --purge flag was specified, so performing "rush purge"');
            purgeManager.purgeNormal();
            // eslint-disable-next-line no-console
            console.log('');
        }
        if (this._networkConcurrencyParameter.value) {
            if (this.rushConfiguration.packageManager !== 'pnpm') {
                throw new Error(`The "${this._networkConcurrencyParameter.longName}" parameter is` +
                    ` only supported when using the PNPM package manager.`);
            }
        }
        // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
        // it is safe to assume that the value is not null
        if (this._maxInstallAttempts.value < 1) {
            throw new Error(`The value of "${this._maxInstallAttempts.longName}" must be positive and nonzero.`);
        }
        const installManagerOptions = await this.buildInstallOptionsAsync();
        const installManagerFactoryModule = await __webpack_require__.e(/*! import() | InstallManagerFactory */ "InstallManagerFactory").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/InstallManagerFactory */ 611779));
        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this.rushConfiguration, this.rushGlobalFolder, purgeManager, installManagerOptions);
        let installSuccessful = true;
        try {
            await installManager.doInstallAsync();
            if (warnAboutScriptUpdate) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Rush refreshed some files in the "common/scripts" folder.' +
                        '  Please commit this change to Git.'));
            }
            // eslint-disable-next-line no-console
            console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Rush ${this.actionName} finished successfully. (${stopwatch.toString()})`));
        }
        catch (error) {
            installSuccessful = false;
            throw error;
        }
        finally {
            purgeManager.deleteAll();
            stopwatch.stop();
            this._collectTelemetry(stopwatch, installManagerOptions, installSuccessful);
            this.parser.flushTelemetry();
            this.eventHooksManager.handle(_api_EventHooks__WEBPACK_IMPORTED_MODULE_9__.Event.postRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);
        }
    }
    _collectTelemetry(stopwatch, installManagerOptions, success) {
        var _a;
        if (this.parser.telemetry) {
            const extraData = Object.assign(Object.assign({ mode: this.actionName, clean: (!!this._purgeParameter.value).toString(), debug: installManagerOptions.debug.toString(), full: installManagerOptions.fullUpgrade.toString() }, this.getParameterStringMap()), (_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getTelemetry());
            this.parser.telemetry.log({
                name: 'install',
                durationInSeconds: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
        }
    }
}
//# sourceMappingURL=BaseInstallAction.js.map

/***/ }),

/***/ 164546:
/*!**************************************************!*\
  !*** ./lib-esnext/cli/actions/BaseRushAction.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseConfiglessRushAction": () => (/* binding */ BaseConfiglessRushAction),
/* harmony export */   "BaseRushAction": () => (/* binding */ BaseRushAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/ts-command-line */ 806427);
/* harmony import */ var _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _logic_EventHooksManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/EventHooksManager */ 353470);
/* harmony import */ var _RushCommandLineParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../RushCommandLineParser */ 365416);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







/**
 * The base class for a few specialized Rush command-line actions that
 * can be used without a rush.json configuration.
 */
class BaseConfiglessRushAction extends _rushstack_ts_command_line__WEBPACK_IMPORTED_MODULE_2__.CommandLineAction {
    get rushConfiguration() {
        return this.parser.rushConfiguration;
    }
    get rushSession() {
        return this.parser.rushSession;
    }
    get rushGlobalFolder() {
        return this.parser.rushGlobalFolder;
    }
    constructor(options) {
        super(options);
        this.parser = options.parser;
        this._safeForSimultaneousRushProcesses = !!options.safeForSimultaneousRushProcesses;
    }
    onExecute() {
        this._ensureEnvironment();
        if (this.rushConfiguration) {
            if (!this._safeForSimultaneousRushProcesses) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.LockFile.tryAcquire(this.rushConfiguration.commonTempFolder, 'rush')) {
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`Another Rush command is already running in this repository.`));
                    process.exit(1);
                }
            }
        }
        if (!_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_4__.RushCommandLineParser.shouldRestrictConsoleOutput()) {
            // eslint-disable-next-line no-console
            console.log(`Starting "rush ${this.actionName}"\n`);
        }
        return this.runAsync();
    }
    _ensureEnvironment() {
        if (this.rushConfiguration) {
            // eslint-disable-next-line dot-notation
            let environmentPath = process.env['PATH'];
            environmentPath =
                path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, 'node_modules', '.bin') +
                    path__WEBPACK_IMPORTED_MODULE_1__.delimiter +
                    environmentPath;
            // eslint-disable-next-line dot-notation
            process.env['PATH'] = environmentPath;
        }
    }
}
/**
 * The base class that most Rush command-line actions should extend.
 */
class BaseRushAction extends BaseConfiglessRushAction {
    get eventHooksManager() {
        if (!this._eventHooksManager) {
            this._eventHooksManager = new _logic_EventHooksManager__WEBPACK_IMPORTED_MODULE_5__.EventHooksManager(this.rushConfiguration);
        }
        return this._eventHooksManager;
    }
    get rushConfiguration() {
        return super.rushConfiguration;
    }
    async onExecute() {
        if (!this.rushConfiguration) {
            throw _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__.Utilities.getRushConfigNotFoundError();
        }
        this._throwPluginErrorIfNeed();
        await this.parser.pluginManager.tryInitializeAssociatedCommandPluginsAsync(this.actionName);
        this._throwPluginErrorIfNeed();
        const { hooks: sessionHooks } = this.rushSession;
        if (sessionHooks.initialize.isUsed()) {
            // Avoid the cost of compiling the hook if it wasn't tapped.
            await sessionHooks.initialize.promise(this);
        }
        return super.onExecute();
    }
    /**
     * If an error is encountered while trying to load plugins, it is saved in the `PluginManager.error`
     * property, so we can defer throwing it until when `_throwPluginErrorIfNeed()` is called.
     */
    _throwPluginErrorIfNeed() {
        // If the plugin configuration is broken, these three commands are used to fix the problem:
        //
        //   "rush update"
        //   "rush init-autoinstaller"
        //   "rush update-autoinstaller"
        //
        // In addition, the "rush setup" command is designed to help new users configure their access
        // to a private NPM registry, which means it can't rely on plugins that might live in that
        // registry.
        //
        // Thus we do not report plugin errors when invoking these commands.
        if (!['update', 'init-autoinstaller', 'update-autoinstaller', 'setup'].includes(this.actionName)) {
            const pluginError = this.parser.pluginManager.error;
            if (pluginError) {
                throw pluginError;
            }
        }
    }
}
//# sourceMappingURL=BaseRushAction.js.map

/***/ }),

/***/ 903296:
/*!************************************************!*\
  !*** ./lib-esnext/cli/actions/ChangeAction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeAction": () => (/* binding */ ChangeAction)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! child_process */ 532081);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/package-deps-hash */ 717642);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../api/ChangeManagement */ 780924);
/* harmony import */ var _api_ChangeFile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../api/ChangeFile */ 202137);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_ChangeFiles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../logic/ChangeFiles */ 392020);
/* harmony import */ var _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../api/VersionPolicy */ 734331);
/* harmony import */ var _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../logic/ProjectChangeAnalyzer */ 311605);
/* harmony import */ var _logic_Git__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logic/Git */ 668229);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.













const BULK_LONG_NAME = '--bulk';
const BULK_MESSAGE_LONG_NAME = '--message';
const BULK_BUMP_TYPE_LONG_NAME = '--bump-type';
class ChangeAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_5__.BaseRushAction {
    constructor(parser) {
        const documentation = [
            'Asks a series of questions and then generates a <branchname>-<timestamp>.json file ' +
                'in the common folder. The `publish` command will consume these files and perform the proper ' +
                'version bumps. Note these changes will eventually be published in a changelog.md file in each package.',
            '',
            'The possible types of changes are: ',
            '',
            'MAJOR - these are breaking changes that are not backwards compatible. ' +
                'Examples are: renaming a public class, adding/removing a non-optional ' +
                'parameter from a public API, or renaming an variable or function that ' +
                'is exported.',
            '',
            'MINOR - these are changes that are backwards compatible (but not ' +
                'forwards compatible). Examples are: adding a new public API or adding an ' +
                'optional parameter to a public API',
            '',
            'PATCH - these are changes that are backwards and forwards compatible. ' +
                'Examples are: Modifying a private API or fixing a bug in the logic ' +
                'of how an existing API works.',
            '',
            "NONE - these are changes that are backwards and forwards compatible and don't require an immediate release. " +
                'Examples are: Modifying dev tooling configuration like eslint.',
            '',
            'HOTFIX (EXPERIMENTAL) - these are changes that are hotfixes targeting a ' +
                'specific older version of the package. When a hotfix change is added, ' +
                'other changes will not be able to increment the version number. ' +
                "Enable this feature by setting 'hotfixChangeEnabled' in your rush.json.",
            ''
        ].join('\n');
        super({
            actionName: 'change',
            summary: 'Records changes made to projects, indicating how the package version number should be bumped ' +
                'for the next publish.',
            documentation,
            safeForSimultaneousRushProcesses: true,
            parser
        });
        this._git = new _logic_Git__WEBPACK_IMPORTED_MODULE_6__.Git(this.rushConfiguration);
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));
        this._verifyParameter = this.defineFlagParameter({
            parameterLongName: '--verify',
            parameterShortName: '-v',
            description: 'Verify the change file has been generated and that it is a valid JSON file'
        });
        this._noFetchParameter = this.defineFlagParameter({
            parameterLongName: '--no-fetch',
            description: 'Skips fetching the baseline branch before running "git diff" to detect changes.'
        });
        this._targetBranchParameter = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this parameter is specified, compare the checked out branch with the specified branch to ' +
                'determine which projects were changed. If this parameter is not specified, the checked out branch ' +
                'is compared against the "main" branch.'
        });
        this._overwriteFlagParameter = this.defineFlagParameter({
            parameterLongName: '--overwrite',
            description: `If a changefile already exists, overwrite without prompting ` +
                `(or erroring in ${BULK_LONG_NAME} mode).`
        });
        this._commitChangesFlagParameter = this.defineFlagParameter({
            parameterLongName: '--commit',
            parameterShortName: '-c',
            description: `If this flag is specified generated changefiles will be commited automatically.`
        });
        this._commitChangesMessageStringParameter = this.defineStringParameter({
            parameterLongName: '--commit-message',
            argumentName: 'COMMIT_MESSAGE',
            description: `If this parameter is specified generated changefiles will be commited automatically with the specified commit message.`
        });
        this._changeEmailParameter = this.defineStringParameter({
            parameterLongName: '--email',
            argumentName: 'EMAIL',
            description: 'The email address to use in changefiles. If this parameter is not provided, the email address ' +
                'will be detected or prompted for in interactive mode.'
        });
        this._bulkChangeParameter = this.defineFlagParameter({
            parameterLongName: BULK_LONG_NAME,
            description: 'If this flag is specified, apply the same change message and bump type to all changed projects. ' +
                `The ${BULK_MESSAGE_LONG_NAME} and the ${BULK_BUMP_TYPE_LONG_NAME} parameters must be specified if the ` +
                `${BULK_LONG_NAME} parameter is specified`
        });
        this._bulkChangeMessageParameter = this.defineStringParameter({
            parameterLongName: BULK_MESSAGE_LONG_NAME,
            argumentName: 'MESSAGE',
            description: `The message to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`
        });
        this._bulkChangeBumpTypeParameter = this.defineChoiceParameter({
            parameterLongName: BULK_BUMP_TYPE_LONG_NAME,
            alternatives: [...Object.keys(this._getBumpOptions())],
            description: `The bump type to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`
        });
    }
    async runAsync() {
        // eslint-disable-next-line no-console
        console.log(`The target branch is ${this._targetBranch}`);
        if (this._verifyParameter.value) {
            const errors = [
                this._bulkChangeParameter,
                this._bulkChangeMessageParameter,
                this._bulkChangeBumpTypeParameter,
                this._overwriteFlagParameter,
                this._commitChangesFlagParameter
            ]
                .map((parameter) => {
                return parameter.value
                    ? `The {${this._bulkChangeParameter.longName} parameter cannot be provided with the ` +
                        `${this._verifyParameter.longName} parameter`
                    : '';
            })
                .filter((error) => error !== '');
            if (errors.length > 0) {
                errors.forEach((error) => {
                    // eslint-disable-next-line no-console
                    console.error(error);
                });
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
            }
            await this._verifyAsync();
            return;
        }
        const sortedProjectList = (await this._getChangedProjectNamesAsync()).sort();
        if (sortedProjectList.length === 0) {
            this._logNoChangeFileRequired();
            this._warnUnstagedChanges();
            return;
        }
        this._warnUnstagedChanges();
        const inquirer = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! inquirer */ 493290, 23));
        const promptModule = inquirer.createPromptModule();
        let changeFileData = new Map();
        let interactiveMode = false;
        if (this._bulkChangeParameter.value) {
            if (!this._bulkChangeBumpTypeParameter.value ||
                (!this._bulkChangeMessageParameter.value &&
                    this._bulkChangeBumpTypeParameter.value !== _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none])) {
                throw new Error(`The ${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} ` +
                    `parameters must provided if the ${this._bulkChangeParameter.longName} flag is provided. If the value ` +
                    `"${_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none]}" is provided to the ${this._bulkChangeBumpTypeParameter.longName} ` +
                    `parameter, the ${this._bulkChangeMessageParameter.longName} parameter may be omitted.`);
            }
            const email = this._changeEmailParameter.value || this._detectEmail();
            if (!email) {
                throw new Error("Unable to detect Git email and an email address wasn't provided using the " +
                    `${this._changeEmailParameter.longName} parameter.`);
            }
            const errors = [];
            const comment = this._bulkChangeMessageParameter.value || '';
            const changeType = this._bulkChangeBumpTypeParameter.value;
            for (const packageName of sortedProjectList) {
                const allowedBumpTypes = Object.keys(this._getBumpOptions(packageName));
                let projectChangeType = changeType;
                if (allowedBumpTypes.length === 0) {
                    projectChangeType = _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none];
                }
                else if (projectChangeType !== _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none] &&
                    allowedBumpTypes.indexOf(projectChangeType) === -1) {
                    errors.push(`The "${projectChangeType}" change type is not allowed for package "${packageName}".`);
                }
                changeFileData.set(packageName, {
                    changes: [
                        {
                            comment,
                            type: projectChangeType,
                            packageName
                        }
                    ],
                    packageName,
                    email
                });
            }
            if (errors.length > 0) {
                for (const error of errors) {
                    // eslint-disable-next-line no-console
                    console.error(error);
                }
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
            }
        }
        else if (this._bulkChangeBumpTypeParameter.value || this._bulkChangeMessageParameter.value) {
            throw new Error(`The ${this._bulkChangeParameter.longName} flag must be provided with the ` +
                `${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} parameters.`);
        }
        else {
            interactiveMode = true;
            const existingChangeComments = _logic_ChangeFiles__WEBPACK_IMPORTED_MODULE_8__.ChangeFiles.getChangeComments(this._getChangeFiles());
            changeFileData = await this._promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments);
            if (this._isEmailRequired(changeFileData)) {
                const email = this._changeEmailParameter.value
                    ? this._changeEmailParameter.value
                    : await this._detectOrAskForEmail(promptModule);
                changeFileData.forEach((changeFile) => {
                    var _a, _b;
                    changeFile.email = ((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile)
                        ? email
                        : '';
                });
            }
        }
        let changefiles;
        try {
            changefiles = await this._writeChangeFiles(promptModule, changeFileData, this._overwriteFlagParameter.value, interactiveMode);
        }
        catch (error) {
            throw new Error(`There was an error creating a change file: ${error.toString()}`);
        }
        if (this._commitChangesFlagParameter.value || this._commitChangesMessageStringParameter.value) {
            if (changefiles && changefiles.length !== 0) {
                this._stageAndCommitGitChanges(changefiles, this._commitChangesMessageStringParameter.value ||
                    this.rushConfiguration.gitChangefilesCommitMessage ||
                    'Rush change');
            }
            else {
                this._terminal.writeWarningLine('Warning: No change files generated, nothing to commit.');
            }
        }
    }
    _generateHostMap() {
        var _a;
        const hostMap = new Map();
        for (const project of this.rushConfiguration.projects) {
            let hostProjectName = project.packageName;
            if ((_a = project.versionPolicy) === null || _a === void 0 ? void 0 : _a.isLockstepped) {
                const lockstepPolicy = project.versionPolicy;
                hostProjectName = lockstepPolicy.mainProject || project.packageName;
            }
            hostMap.set(project, hostProjectName);
        }
        return hostMap;
    }
    async _verifyAsync() {
        const changedPackages = await this._getChangedProjectNamesAsync();
        if (changedPackages.length > 0) {
            this._validateChangeFile(changedPackages);
        }
        else {
            this._logNoChangeFileRequired();
        }
    }
    get _targetBranch() {
        if (!this._targetBranchName) {
            this._targetBranchName = this._targetBranchParameter.value || this._git.getRemoteDefaultBranch();
        }
        return this._targetBranchName;
    }
    async _getChangedProjectNamesAsync() {
        var _a;
        const projectChangeAnalyzer = new _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_9__.ProjectChangeAnalyzer(this.rushConfiguration);
        const changedProjects = await projectChangeAnalyzer.getChangedProjectsAsync({
            targetBranchName: this._targetBranch,
            terminal: this._terminal,
            shouldFetch: !this._noFetchParameter.value,
            // Lockfile evaluation will expand the set of projects that request change files
            // Not enabling, since this would be a breaking change
            includeExternalDependencies: false,
            // Since install may not have happened, cannot read rush-project.json
            enableFiltering: false
        });
        const projectHostMap = this._generateHostMap();
        const changedProjectNames = new Set();
        for (const changedProject of changedProjects) {
            if (changedProject.shouldPublish && !((_a = changedProject.versionPolicy) === null || _a === void 0 ? void 0 : _a.exemptFromRushChange)) {
                const hostName = projectHostMap.get(changedProject);
                if (hostName) {
                    changedProjectNames.add(hostName);
                }
            }
        }
        return Array.from(changedProjectNames);
    }
    _validateChangeFile(changedPackages) {
        const files = this._getChangeFiles();
        _logic_ChangeFiles__WEBPACK_IMPORTED_MODULE_8__.ChangeFiles.validate(files, changedPackages, this.rushConfiguration);
    }
    _getChangeFiles() {
        const repoRoot = (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__.getRepoRoot)(this.rushConfiguration.rushJsonFolder);
        const relativeChangesFolder = path__WEBPACK_IMPORTED_MODULE_0__.relative(repoRoot, this.rushConfiguration.changesFolder);
        return this._git
            .getChangedFiles(this._targetBranch, this._terminal, true, relativeChangesFolder)
            .map((relativePath) => {
            return path__WEBPACK_IMPORTED_MODULE_0__.join(repoRoot, relativePath);
        });
    }
    /**
     * The main loop which prompts the user for information on changed projects.
     */
    async _promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments) {
        const changedFileData = new Map();
        for (const projectName of sortedProjectList) {
            const changeInfo = await this._askQuestions(promptModule, projectName, existingChangeComments);
            if (changeInfo) {
                // Save the info into the change file
                let changeFile = changedFileData.get(changeInfo.packageName);
                if (!changeFile) {
                    changeFile = {
                        changes: [],
                        packageName: changeInfo.packageName,
                        email: undefined
                    };
                    changedFileData.set(changeInfo.packageName, changeFile);
                }
                changeFile.changes.push(changeInfo);
            }
        }
        return changedFileData;
    }
    /**
     * Asks all questions which are needed to generate changelist for a project.
     */
    async _askQuestions(promptModule, packageName, existingChangeComments) {
        // eslint-disable-next-line no-console
        console.log(`\n${packageName}`);
        const comments = existingChangeComments.get(packageName);
        if (comments) {
            // eslint-disable-next-line no-console
            console.log(`Found existing comments:`);
            comments.forEach((comment) => {
                // eslint-disable-next-line no-console
                console.log(`    > ${comment}`);
            });
            const { appendComment } = await promptModule({
                name: 'appendComment',
                type: 'list',
                default: 'skip',
                message: 'Append to existing comments or skip?',
                choices: [
                    {
                        name: 'Skip',
                        value: 'skip'
                    },
                    {
                        name: 'Append',
                        value: 'append'
                    }
                ]
            });
            if (appendComment === 'skip') {
                return undefined;
            }
            else {
                return await this._promptForComments(promptModule, packageName);
            }
        }
        else {
            return await this._promptForComments(promptModule, packageName);
        }
    }
    async _promptForComments(promptModule, packageName) {
        const bumpOptions = this._getBumpOptions(packageName);
        const { comment } = await promptModule({
            name: 'comment',
            type: 'input',
            message: `Describe changes, or ENTER if no changes:`
        });
        if (Object.keys(bumpOptions).length === 0 || !comment) {
            return {
                packageName: packageName,
                comment: comment || '',
                type: _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none]
            };
        }
        else {
            const { bumpType } = await promptModule({
                choices: Object.keys(bumpOptions).map((option) => {
                    return {
                        value: option,
                        name: bumpOptions[option]
                    };
                }),
                default: 'patch',
                message: 'Select the type of change:',
                name: 'bumpType',
                type: 'list'
            });
            return {
                packageName: packageName,
                comment: comment,
                type: bumpType
            };
        }
    }
    _getBumpOptions(packageName) {
        let bumpOptions = this.rushConfiguration && this.rushConfiguration.hotfixChangeEnabled
            ? {
                [_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.hotfix]]: 'hotfix - for changes that need to be published in a separate hotfix package'
            }
            : {
                [_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.major]]: 'major - for changes that break compatibility, e.g. removing an API',
                [_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.minor]]: 'minor - for backwards compatible changes, e.g. adding a new API',
                [_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.patch]]: 'patch - for changes that do not affect compatibility, e.g. fixing a bug',
                [_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.none]]: 'none - for changes that do not need an immediate release, e.g. eslint config change'
            };
        if (packageName) {
            const project = this.rushConfiguration.getProjectByName(packageName);
            const versionPolicy = project.versionPolicy;
            if (versionPolicy) {
                if (versionPolicy.definitionName === _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_10__.VersionPolicyDefinitionName.lockStepVersion) {
                    const lockStepPolicy = versionPolicy;
                    // No need to ask for bump types if project is lockstep versioned with an explicit nextBump
                    if (lockStepPolicy.nextBump !== undefined) {
                        bumpOptions = {};
                    }
                }
                else if (versionPolicy.definitionName === _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_10__.VersionPolicyDefinitionName.individualVersion) {
                    const individualPolicy = versionPolicy;
                    if (individualPolicy.lockedMajor !== undefined) {
                        delete bumpOptions[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType[_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_7__.ChangeType.major]];
                    }
                }
            }
        }
        return bumpOptions;
    }
    _isEmailRequired(changeFileData) {
        return [...changeFileData.values()].some((changeFile) => {
            var _a, _b;
            return !!((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile);
        });
    }
    /**
     * Will determine a user's email by first detecting it from their Git config,
     * or will ask for it if it is not found or the Git config is wrong.
     */
    async _detectOrAskForEmail(promptModule) {
        return (await this._detectAndConfirmEmail(promptModule)) || (await this._promptForEmail(promptModule));
    }
    _detectEmail() {
        try {
            return child_process__WEBPACK_IMPORTED_MODULE_1__.execSync('git config user.email')
                .toString()
                .replace(/(\r\n|\n|\r)/gm, '');
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log('There was an issue detecting your Git email...');
            return undefined;
        }
    }
    /**
     * Detects the user's email address from their Git configuration, prompts the user to approve the
     * detected email. It returns undefined if it cannot be detected.
     */
    async _detectAndConfirmEmail(promptModule) {
        const email = this._detectEmail();
        if (email) {
            const { isCorrectEmail } = await promptModule([
                {
                    type: 'confirm',
                    name: 'isCorrectEmail',
                    default: 'Y',
                    message: `Is your email address ${email}?`
                }
            ]);
            return isCorrectEmail ? email : undefined;
        }
        else {
            return undefined;
        }
    }
    /**
     * Asks the user for their email address
     */
    async _promptForEmail(promptModule) {
        const { email } = await promptModule([
            {
                type: 'input',
                name: 'email',
                message: 'What is your email address?',
                validate: (input) => {
                    return true; // @todo should be an email
                }
            }
        ]);
        return email;
    }
    _warnUnstagedChanges() {
        try {
            if (this._git.hasUnstagedChanges()) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    colors_safe__WEBPACK_IMPORTED_MODULE_2___default().yellow('Warning: You have unstaged changes, which do not trigger prompting for change ' +
                        'descriptions.'));
            }
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log(`An error occurred when detecting unstaged changes: ${error}`);
        }
    }
    /**
     * Writes change files to the common/changes folder. Will prompt for overwrite if file already exists.
     */
    async _writeChangeFiles(promptModule, changeFileData, overwrite, interactiveMode) {
        const writtenFiles = [];
        await changeFileData.forEach(async (changeFile) => {
            const writtenFile = await this._writeChangeFile(promptModule, changeFile, overwrite, interactiveMode);
            if (writtenFile) {
                writtenFiles.push(writtenFile);
            }
        });
        return writtenFiles;
    }
    async _writeChangeFile(promptModule, changeFileData, overwrite, interactiveMode) {
        const output = JSON.stringify(changeFileData, undefined, 2);
        const changeFile = new _api_ChangeFile__WEBPACK_IMPORTED_MODULE_11__.ChangeFile(changeFileData, this.rushConfiguration);
        const filePath = changeFile.generatePath();
        const fileExists = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(filePath);
        const shouldWrite = !fileExists ||
            overwrite ||
            (interactiveMode ? await this._promptForOverwrite(promptModule, filePath) : false);
        if (!interactiveMode && fileExists && !overwrite) {
            throw new Error(`Changefile ${filePath} already exists`);
        }
        if (shouldWrite) {
            this._writeFile(filePath, output, shouldWrite && fileExists);
            return filePath;
        }
    }
    async _promptForOverwrite(promptModule, filePath) {
        const overwrite = await promptModule([
            {
                name: 'overwrite',
                type: 'confirm',
                message: `Overwrite ${filePath}?`
            }
        ]);
        if (overwrite) {
            return true;
        }
        else {
            // eslint-disable-next-line no-console
            console.log(`Not overwriting ${filePath}`);
            return false;
        }
    }
    /**
     * Writes a file to disk, ensuring the directory structure up to that point exists
     */
    _writeFile(fileName, output, isOverwrite) {
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.writeFile(fileName, output, { ensureFolderExists: true });
        if (isOverwrite) {
            // eslint-disable-next-line no-console
            console.log(`Overwrote file: ${fileName}`);
        }
        else {
            // eslint-disable-next-line no-console
            console.log(`Created file: ${fileName}`);
        }
    }
    _logNoChangeFileRequired() {
        // eslint-disable-next-line no-console
        console.log('No changes were detected to relevant packages on this branch. Nothing to do.');
    }
    _stageAndCommitGitChanges(pattern, message) {
        try {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_12__.Utilities.executeCommand({
                command: 'git',
                args: ['add', ...pattern],
                workingDirectory: this.rushConfiguration.changesFolder
            });
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_12__.Utilities.executeCommand({
                command: 'git',
                args: ['commit', ...pattern, '-m', message],
                workingDirectory: this.rushConfiguration.changesFolder
            });
        }
        catch (error) {
            this._terminal.writeErrorLine(`ERROR: Cannot stage and commit git changes ${error.message}`);
        }
    }
}
//# sourceMappingURL=ChangeAction.js.map

/***/ }),

/***/ 839726:
/*!***********************************************!*\
  !*** ./lib-esnext/cli/actions/CheckAction.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckAction": () => (/* binding */ CheckAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/versionMismatch/VersionMismatchFinder */ 936800);
/* harmony import */ var _api_Variants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/Variants */ 782487);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





class CheckAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'check',
            summary: "Checks each project's package.json files and ensures that all dependencies are of the same " +
                'version throughout the repository.',
            documentation: "Checks each project's package.json files and ensures that all dependencies are of the " +
                'same version throughout the repository.',
            safeForSimultaneousRushProcesses: true,
            parser
        });
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));
        this._variant = this.defineStringParameter(_api_Variants__WEBPACK_IMPORTED_MODULE_3__.Variants.VARIANT_PARAMETER);
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
        this._verboseFlag = this.defineFlagParameter({
            parameterLongName: '--verbose',
            description: 'If this flag is specified, long lists of package names will not be truncated. ' +
                `This has no effect if the ${this._jsonFlag.longName} flag is also specified.`
        });
    }
    async runAsync() {
        const variant = this.rushConfiguration.currentInstalledVariant;
        if (!this._variant.value && variant) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Variant '${variant}' has been installed, but 'rush check' is currently checking the default variant. ` +
                `Use 'rush check --variant '${variant}' to check the current installation.`));
        }
        _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_4__.VersionMismatchFinder.rushCheck(this.rushConfiguration, this._terminal, {
            variant: this._variant.value,
            printAsJson: this._jsonFlag.value,
            truncateLongPackageNameLists: !this._verboseFlag.value
        });
    }
}
//# sourceMappingURL=CheckAction.js.map

/***/ }),

/***/ 771917:
/*!************************************************!*\
  !*** ./lib-esnext/cli/actions/DeployAction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeployAction": () => (/* binding */ DeployAction)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logic/pnpm/PnpmfileConfiguration */ 238032);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class DeployAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'deploy',
            summary: 'Prepares a deployment by copying a subset of Rush projects and their dependencies' +
                ' to a target folder',
            documentation: 'After building the repo, "rush deploy" can be used to prepare a deployment by copying' +
                ' a subset of Rush projects and their dependencies to a target folder, which can then be uploaded to' +
                ' a production server.  The "rush deploy" behavior is specified by a scenario config file that must' +
                ' be created first, using the "rush init-deploy" command.',
            parser,
            // It is okay to invoke multiple instances of "rush deploy" simultaneously, if they are writing
            // to different target folders.
            safeForSimultaneousRushProcesses: true
        });
        this._logger = this.rushSession.getLogger('deploy');
        this._project = this.defineStringParameter({
            parameterLongName: '--project',
            parameterShortName: '-p',
            argumentName: 'PROJECT_NAME',
            description: 'Specifies the name of the main Rush project to be deployed. It must appear in the' +
                ' "deploymentProjectNames" setting in the deployment config file.'
        });
        this._scenario = this.defineStringParameter({
            parameterLongName: '--scenario',
            parameterShortName: '-s',
            argumentName: 'SCENARIO_NAME',
            description: 'By default, the deployment configuration is specified in "common/config/rush/deploy.json".' +
                ' You can use "--scenario" to specify an alternate name. The name must be lowercase and separated by dashes.' +
                ' For example, if SCENARIO_NAME is "web", then the config file would be "common/config/rush/deploy-web.json".'
        });
        this._overwrite = this.defineFlagParameter({
            parameterLongName: '--overwrite',
            description: 'By default, deployment will fail if the target folder is not empty.  SPECIFYING THIS FLAG' +
                ' WILL RECURSIVELY DELETE EXISTING CONTENTS OF THE TARGET FOLDER.'
        });
        this._targetFolder = this.defineStringParameter({
            parameterLongName: '--target-folder',
            parameterShortName: '-t',
            argumentName: 'PATH',
            environmentVariable: 'RUSH_DEPLOY_TARGET_FOLDER',
            description: 'By default, files are deployed to the "common/deploy" folder inside the Rush repo.' +
                ' Use this parameter to specify a different location. ' +
                ' WARNING: USE CAUTION WHEN COMBINING WITH "--overwrite"'
        });
        this._createArchivePath = this.defineStringParameter({
            parameterLongName: '--create-archive',
            argumentName: 'ARCHIVE_PATH',
            description: 'If specified, after the deployment has been prepared, "rush deploy"' +
                ' will create an archive containing the contents of the target folder.' +
                ' The newly created archive file will be placed according to the designated path, relative' +
                ' to the target folder. Supported file extensions: .zip'
        });
        this._createArchiveOnly = this.defineFlagParameter({
            parameterLongName: '--create-archive-only',
            description: 'If specified, "rush deploy" will only create an archive containing the contents of the target folder.' +
                ' The target folder will not be modified other than to create the archive file.'
        });
    }
    async runAsync() {
        const scenarioName = this._scenario.value;
        const { DeployScenarioConfiguration } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/deploy/DeployScenarioConfiguration */ 544987));
        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(scenarioName, this.rushConfiguration);
        const scenarioConfiguration = DeployScenarioConfiguration.loadFromFile(this._logger.terminal, scenarioFilePath, this.rushConfiguration);
        let mainProjectName = this._project.value;
        if (!mainProjectName) {
            if (scenarioConfiguration.json.deploymentProjectNames.length === 1) {
                // If there is only one project, then "--project" is optional
                mainProjectName = scenarioConfiguration.json.deploymentProjectNames[0];
            }
            else {
                throw new Error(`The ${path__WEBPACK_IMPORTED_MODULE_0__.basename(scenarioFilePath)} configuration specifies multiple items for` +
                    ` "deploymentProjectNames". Use the "--project" parameter to indicate the project to be deployed.`);
            }
        }
        else {
            if (scenarioConfiguration.json.deploymentProjectNames.indexOf(mainProjectName) < 0) {
                throw new Error(`The project "${mainProjectName}" does not appear in the list of "deploymentProjectNames"` +
                    ` from ${path__WEBPACK_IMPORTED_MODULE_0__.basename(scenarioFilePath)}.`);
            }
        }
        const targetRootFolder = this._targetFolder.value
            ? path__WEBPACK_IMPORTED_MODULE_0__.resolve(this._targetFolder.value)
            : path__WEBPACK_IMPORTED_MODULE_0__.join(this.rushConfiguration.commonFolder, 'deploy');
        const createArchiveFilePath = this._createArchivePath.value
            ? path__WEBPACK_IMPORTED_MODULE_0__.resolve(targetRootFolder, this._createArchivePath.value)
            : undefined;
        const createArchiveOnly = this._createArchiveOnly.value;
        let transformPackageJson;
        let pnpmInstallFolder;
        if (this.rushConfiguration.packageManager === 'pnpm') {
            const pnpmfileConfiguration = await _logic_pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_2__.PnpmfileConfiguration.initializeAsync(this.rushConfiguration);
            transformPackageJson = pnpmfileConfiguration.transform.bind(pnpmfileConfiguration);
            if (!scenarioConfiguration.json.omitPnpmWorkaroundLinks) {
                pnpmInstallFolder = this.rushConfiguration.commonTempFolder;
            }
        }
        // Construct the project list for the deployer
        const projectConfigurations = [];
        for (const project of this.rushConfiguration.projects) {
            const scenarioProjectJson = scenarioConfiguration.projectJsonsByName.get(project.packageName);
            projectConfigurations.push({
                projectName: project.packageName,
                projectFolder: project.projectFolder,
                additionalProjectsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalProjectsToInclude,
                additionalDependenciesToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalDependenciesToInclude,
                dependenciesToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.dependenciesToExclude,
                patternsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToInclude,
                patternsToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToExclude
            });
        }
        // Call the deploy manager
        const { PackageExtractor } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @rushstack/package-extractor */ 297839, 23));
        const deployManager = new PackageExtractor();
        await deployManager.extractAsync({
            terminal: this._logger.terminal,
            overwriteExisting: !!this._overwrite.value,
            includeDevDependencies: scenarioConfiguration.json.includeDevDependencies,
            includeNpmIgnoreFiles: scenarioConfiguration.json.includeNpmIgnoreFiles,
            folderToCopy: scenarioConfiguration.json.folderToCopy,
            linkCreation: scenarioConfiguration.json.linkCreation,
            sourceRootFolder: this.rushConfiguration.rushJsonFolder,
            targetRootFolder,
            mainProjectName,
            projectConfigurations,
            dependencyConfigurations: scenarioConfiguration.json.dependencySettings,
            createArchiveFilePath,
            createArchiveOnly,
            pnpmInstallFolder,
            transformPackageJson
        });
    }
}
//# sourceMappingURL=DeployAction.js.map

/***/ }),

/***/ 68066:
/*!**********************************************!*\
  !*** ./lib-esnext/cli/actions/InitAction.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InitAction": () => (/* binding */ InitAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../api/Rush */ 465002);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/PathConstants */ 287644);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






// Matches a well-formed BEGIN macro starting a block section.
// Example:  /*[BEGIN "DEMO"]*/
//
// Group #1 is the indentation spaces before the macro
// Group #2 is the section name
const BEGIN_MARCO_REGEXP = /^(\s*)\/\*\[BEGIN "([A-Z]+)"\]\s*\*\/\s*$/;
// Matches a well-formed END macro ending a block section.
// Example:  /*[END "DEMO"]*/
//
// Group #1 is the indentation spaces before the macro
// Group #2 is the section name
const END_MACRO_REGEXP = /^(\s*)\/\*\[END "([A-Z]+)"\]\s*\*\/\s*$/;
// Matches a well-formed single-line section, including the space character after it
// if present.
// Example:  /*[LINE "HYPOTHETICAL"]*/
//
// Group #1 is the section name
const LINE_MACRO_REGEXP = /\/\*\[LINE "([A-Z]+)"\]\s*\*\/\s?/;
// Matches a variable expansion.
// Example:  [%RUSH_VERSION%]
//
// Group #1 is the variable name including the dollar sign
const VARIABLE_MACRO_REGEXP = /\[(%[A-Z0-9_]+%)\]/;
// Matches anything that starts with "/*[" and ends with "]*/"
// Used to catch malformed macro expressions
const ANY_MACRO_REGEXP = /\/\*\s*\[.*\]\s*\*\//;
class InitAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_3__.BaseConfiglessRushAction {
    constructor(parser) {
        super({
            actionName: 'init',
            summary: 'Initializes a new repository to be managed by Rush',
            documentation: 'When invoked in an empty folder, this command provisions a standard' +
                ' set of config file templates to start managing projects using Rush.',
            parser
        });
        // template section name --> whether it should be commented out
        this._commentedBySectionName = new Map();
        this._overwriteParameter = this.defineFlagParameter({
            parameterLongName: '--overwrite-existing',
            description: 'By default "rush init" will not overwrite existing config files.' +
                ' Specify this switch to override that. This can be useful when upgrading' +
                ' your repo to a newer release of Rush. WARNING: USE WITH CARE!'
        });
        this._rushExampleParameter = this.defineFlagParameter({
            parameterLongName: '--rush-example-repo',
            description: 'When copying the template config files, this uncomments fragments that are used' +
                ' by the "rush-example" GitHub repo, which is a sample monorepo that illustrates many Rush' +
                ' features. This option is primarily intended for maintaining that example.'
        });
    }
    async runAsync() {
        const initFolder = process.cwd();
        if (!this._overwriteParameter.value) {
            if (!this._validateFolderIsEmpty(initFolder)) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
            }
        }
        this._defineMacroSections();
        this._copyTemplateFiles(initFolder);
    }
    _defineMacroSections() {
        this._commentedBySectionName.clear();
        // The "HYPOTHETICAL" sections are always commented out by "rush init".
        // They are uncommented in the "assets" source folder so that we can easily validate
        // that they conform to their JSON schema.
        this._commentedBySectionName.set('HYPOTHETICAL', true);
        // The "DEMO" sections are uncommented only when "--rush-example-repo" is specified.
        this._commentedBySectionName.set('DEMO', !this._rushExampleParameter.value);
    }
    // Check whether it's safe to run "rush init" in the current working directory.
    _validateFolderIsEmpty(initFolder) {
        if (this.rushConfiguration !== undefined) {
            // eslint-disable-next-line no-console
            console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('ERROR: Found an existing configuration in: ' + this.rushConfiguration.rushJsonFile));
            // eslint-disable-next-line no-console
            console.log('\nThe "rush init" command must be run in a new folder without an existing Rush configuration.');
            return false;
        }
        for (const itemName of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemNames(initFolder)) {
            if (itemName.substr(0, 1) === '.') {
                // Ignore any items that start with ".", for example ".git"
                continue;
            }
            const itemPath = path__WEBPACK_IMPORTED_MODULE_1__.join(initFolder, itemName);
            const stats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getStatistics(itemPath);
            // Ignore any loose files in the current folder, e.g. "README.md"
            // or "CONTRIBUTING.md"
            if (stats.isDirectory()) {
                // eslint-disable-next-line no-console
                console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`ERROR: Found a subdirectory: "${itemName}"`));
                // eslint-disable-next-line no-console
                console.log('\nThe "rush init" command must be run in a new folder with no projects added yet.');
                return false;
            }
            else {
                if (itemName.toLowerCase() === 'package.json') {
                    // eslint-disable-next-line no-console
                    console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`ERROR: Found a package.json file in this folder`));
                    // eslint-disable-next-line no-console
                    console.log('\nThe "rush init" command must be run in a new folder with no projects added yet.');
                    return false;
                }
            }
        }
        return true;
    }
    _copyTemplateFiles(initFolder) {
        // The "[dot]" base name is used for hidden files to prevent various tools from interpreting them.
        // For example, "npm publish" will always exclude the filename ".gitignore"
        const templateFilePaths = [
            '[dot]github/workflows/ci.yml',
            'common/config/rush/.pnpmfile.cjs',
            'common/config/rush/[dot]npmrc',
            'common/config/rush/[dot]npmrc-publish',
            'common/config/rush/artifactory.json',
            'common/config/rush/build-cache.json',
            'common/config/rush/cobuild.json',
            'common/config/rush/command-line.json',
            'common/config/rush/common-versions.json',
            'common/config/rush/custom-tips.json',
            'common/config/rush/experiments.json',
            'common/config/rush/pnpm-config.json',
            'common/config/rush/rush-plugins.json',
            'common/config/rush/version-policies.json',
            'common/git-hooks/commit-msg.sample',
            '[dot]gitattributes',
            '[dot]gitignore',
            'rush.json'
        ];
        const assetsSubfolder = `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_4__.assetsFolderPath}/rush-init`;
        for (const templateFilePath of templateFilePaths) {
            const sourcePath = path__WEBPACK_IMPORTED_MODULE_1__.join(assetsSubfolder, templateFilePath);
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(sourcePath)) {
                // If this happens, please report a Rush bug
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError('Unable to find template input file: ' + sourcePath);
            }
            const destinationPath = path__WEBPACK_IMPORTED_MODULE_1__.join(initFolder, templateFilePath).replace('[dot]', '.');
            this._copyTemplateFile(sourcePath, destinationPath);
        }
    }
    // Copy the template from sourcePath, transform any macros, and write the output to destinationPath.
    //
    // We implement a simple template engine.  "Single-line section" macros have this form:
    //
    //     /*[LINE "NAME"]*/ (content goes here)
    //
    // ...and when commented out will look like this:
    //
    //     // (content goes here)
    //
    // "Block section" macros have this form:
    //
    //     /*[BEGIN "NAME"]*/
    //     (content goes
    //     here)
    //     /*[END "NAME"]*/
    //
    // ...and when commented out will look like this:
    //
    //     // (content goes
    //     // here)
    //
    // Lastly, a variable expansion has this form:
    //
    //     // The value is [%NAME%].
    //
    // ...and when expanded with e.g. "123" will look like this:
    //
    //     // The value is 123.
    //
    // The section names must be one of the predefined names used by "rush init".
    // A single-line section may appear inside a block section, in which case it will get
    // commented twice.
    _copyTemplateFile(sourcePath, destinationPath) {
        const destinationFileExists = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(destinationPath);
        if (!this._overwriteParameter.value) {
            if (destinationFileExists) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Not overwriting already existing file: ') + destinationPath);
                return;
            }
        }
        if (destinationFileExists) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Overwriting: ${destinationPath}`));
        }
        else {
            // eslint-disable-next-line no-console
            console.log(`Generating: ${destinationPath}`);
        }
        const outputLines = [];
        const lines = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFile(sourcePath, { convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.NewlineKind.Lf }).split('\n');
        let activeBlockSectionName = undefined;
        let activeBlockIndent = '';
        for (const line of lines) {
            let match;
            // Check for a block section start
            // Example:  /*[BEGIN "DEMO"]*/
            match = line.match(BEGIN_MARCO_REGEXP);
            if (match) {
                if (activeBlockSectionName) {
                    // If this happens, please report a Rush bug
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template contains an unmatched BEGIN macro for "${activeBlockSectionName}"`);
                }
                activeBlockSectionName = match[2];
                activeBlockIndent = match[1];
                // Remove the entire line containing the macro
                continue;
            }
            // Check for a block section end
            // Example:  /*[END "DEMO"]*/
            match = line.match(END_MACRO_REGEXP);
            if (match) {
                if (activeBlockSectionName === undefined) {
                    // If this happens, please report a Rush bug
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template contains an unmatched END macro for "${activeBlockSectionName}"`);
                }
                if (activeBlockSectionName !== match[2]) {
                    // If this happens, please report a Rush bug
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template contains an mismatched END macro for "${activeBlockSectionName}"`);
                }
                if (activeBlockIndent !== match[1]) {
                    // If this happens, please report a Rush bug
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template contains an inconsistently indented section "${activeBlockSectionName}"`);
                }
                activeBlockSectionName = undefined;
                // Remove the entire line containing the macro
                continue;
            }
            let transformedLine = line;
            // Check for a single-line section
            // Example:  /*[LINE "HYPOTHETICAL"]*/
            match = transformedLine.match(LINE_MACRO_REGEXP);
            if (match) {
                const sectionName = match[1];
                const replacement = this._isSectionCommented(sectionName) ? '// ' : '';
                transformedLine = transformedLine.replace(LINE_MACRO_REGEXP, replacement);
            }
            // Check for variable expansions
            // Example:  [%RUSH_VERSION%]
            while ((match = transformedLine.match(VARIABLE_MACRO_REGEXP))) {
                const variableName = match[1];
                const replacement = this._expandMacroVariable(variableName);
                transformedLine = transformedLine.replace(VARIABLE_MACRO_REGEXP, replacement);
            }
            // Verify that all macros were handled
            match = transformedLine.match(ANY_MACRO_REGEXP);
            if (match) {
                // If this happens, please report a Rush bug
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError('The template contains a malformed macro expression: ' + JSON.stringify(match[0]));
            }
            // If we are inside a block section that is commented out, then insert the "//" after indentation
            if (activeBlockSectionName !== undefined) {
                if (this._isSectionCommented(activeBlockSectionName)) {
                    // Is the line indented properly?
                    if (transformedLine.substr(0, activeBlockIndent.length).trim().length > 0) {
                        // If this happens, please report a Rush bug
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template contains inconsistently indented lines inside` +
                            ` the "${activeBlockSectionName}" section`);
                    }
                    // Insert comment characters after the indentation
                    const contentAfterIndent = transformedLine.substr(activeBlockIndent.length);
                    transformedLine = activeBlockIndent + '// ' + contentAfterIndent;
                }
            }
            outputLines.push(transformedLine);
        }
        // Write the output
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.writeFile(destinationPath, outputLines.join('\n'), {
            ensureFolderExists: true
        });
    }
    _isSectionCommented(sectionName) {
        const value = this._commentedBySectionName.get(sectionName);
        if (value === undefined) {
            // If this happens, please report a Rush bug
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template references an undefined section name ${sectionName}`);
        }
        return value;
    }
    _expandMacroVariable(variableName) {
        switch (variableName) {
            case '%RUSH_VERSION%':
                return _api_Rush__WEBPACK_IMPORTED_MODULE_5__.Rush.version;
            default:
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError(`The template references an undefined variable "${variableName}"`);
        }
    }
}
//# sourceMappingURL=InitAction.js.map

/***/ }),

/***/ 334293:
/*!***********************************************************!*\
  !*** ./lib-esnext/cli/actions/InitAutoinstallerAction.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InitAutoinstallerAction": () => (/* binding */ InitAutoinstallerAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/Autoinstaller */ 140603);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class InitAutoinstallerAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'init-autoinstaller',
            summary: 'Initializes a new autoinstaller',
            documentation: 'Use this command to initialize a new autoinstaller folder.  Autoinstallers provide a way to' +
                ' manage a set of related dependencies that are used for scripting scenarios outside of the usual' +
                ' "rush install" context.  See the command-line.json documentation for an example.',
            parser
        });
        this._name = this.defineStringParameter({
            parameterLongName: '--name',
            argumentName: 'AUTOINSTALLER_NAME',
            required: true,
            description: 'Specifies the name of the autoinstaller folder, which must conform to the naming rules for NPM packages.'
        });
    }
    async runAsync() {
        const autoinstallerName = this._name.value;
        const autoinstaller = new _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_3__.Autoinstaller({
            autoinstallerName,
            rushConfiguration: this.rushConfiguration,
            rushGlobalFolder: this.rushGlobalFolder
        });
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(autoinstaller.folderFullPath)) {
            // It's okay if the folder is empty
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFolderItemNames(autoinstaller.folderFullPath).length > 0) {
                throw new Error('The target folder already exists: ' + autoinstaller.folderFullPath);
            }
        }
        const packageJson = {
            name: autoinstallerName,
            version: '1.0.0',
            private: true,
            dependencies: {}
        };
        // eslint-disable-next-line no-console
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Creating package: ') + autoinstaller.packageJsonPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.save(packageJson, autoinstaller.packageJsonPath, {
            ensureFolderExists: true,
            newlineConversion: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.NewlineKind.OsDefault
        });
        // eslint-disable-next-line no-console
        console.log('\nFile successfully written. Add your dependencies before committing.');
    }
}
//# sourceMappingURL=InitAutoinstallerAction.js.map

/***/ }),

/***/ 635830:
/*!****************************************************!*\
  !*** ./lib-esnext/cli/actions/InitDeployAction.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InitDeployAction": () => (/* binding */ InitDeployAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_deploy_DeployScenarioConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/deploy/DeployScenarioConfiguration */ 544987);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/PathConstants */ 287644);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





const CONFIG_TEMPLATE_PATH = `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_2__.assetsFolderPath}/rush-init-deploy/scenario-template.json`;
class InitDeployAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_3__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'init-deploy',
            summary: 'Creates a deployment scenario config file for use with "rush deploy".',
            documentation: 'Use this command to initialize a new scenario config file for use with "rush deploy".' +
                ' The default filename is common/config/rush/deploy.json. However, if you need to manage multiple' +
                ' deployments with different settings, you can use use "--scenario" to create additional config files.',
            parser
        });
        this._project = this.defineStringParameter({
            parameterLongName: '--project',
            parameterShortName: '-p',
            argumentName: 'PROJECT_NAME',
            required: true,
            description: 'Specifies the name of the main Rush project to be deployed in this scenario.' +
                ' It will be added to the "deploymentProjectNames" setting.'
        });
        this._scenario = this.defineStringParameter({
            parameterLongName: '--scenario',
            parameterShortName: '-s',
            argumentName: 'SCENARIO',
            description: 'By default, the deployment configuration will be written to "common/config/rush/deploy.json".' +
                ' You can use "--scenario" to specify an alternate name. The name must be lowercase and separated by dashes.' +
                ' For example, if the name is "web", then the config file would be "common/config/rush/deploy-web.json".'
        });
    }
    async runAsync() {
        const scenarioFilePath = _logic_deploy_DeployScenarioConfiguration__WEBPACK_IMPORTED_MODULE_4__.DeployScenarioConfiguration.getConfigFilePath(this._scenario.value, this.rushConfiguration);
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(scenarioFilePath)) {
            throw new Error('The target file already exists:\n' +
                scenarioFilePath +
                '\nIf you intend to replace it, please delete the old file first.');
        }
        // eslint-disable-next-line no-console
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Creating scenario file: ') + scenarioFilePath);
        const shortProjectName = this._project.value;
        const rushProject = this.rushConfiguration.findProjectByShorthandName(shortProjectName);
        if (!rushProject) {
            throw new Error(`The specified project was not found in rush.json: "${shortProjectName}"`);
        }
        const templateContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFile(CONFIG_TEMPLATE_PATH);
        const expandedContent = templateContent.replace('[%PROJECT_NAME_TO_DEPLOY%]', rushProject.packageName);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.writeFile(scenarioFilePath, expandedContent, {
            ensureFolderExists: true,
            convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.NewlineKind.OsDefault
        });
        // eslint-disable-next-line no-console
        console.log('\nFile successfully written. Please review the file contents before committing.');
    }
}
//# sourceMappingURL=InitDeployAction.js.map

/***/ }),

/***/ 680041:
/*!*************************************************!*\
  !*** ./lib-esnext/cli/actions/InstallAction.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstallAction": () => (/* binding */ InstallAction)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseInstallAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseInstallAction */ 823791);
/* harmony import */ var _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsing/SelectionParameterSet */ 40787);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class InstallAction extends _BaseInstallAction__WEBPACK_IMPORTED_MODULE_1__.BaseInstallAction {
    constructor(parser) {
        super({
            actionName: 'install',
            summary: 'Install package dependencies for all projects in the repo according to the shrinkwrap file',
            documentation: 'The "rush install" command installs package dependencies for all your projects,' +
                ' based on the shrinkwrap file that is created/updated using "rush update".' +
                ' (This "shrinkwrap" file stores a central inventory of all dependencies and versions' +
                ' for projects in your repo. It is found in the "common/config/rush" folder.)' +
                ' If the shrinkwrap file is missing or outdated (e.g. because project package.json files have' +
                ' changed), "rush install" will fail and tell you to run "rush update" instead.' +
                ' This read-only nature is the main feature:  Continuous integration builds should use' +
                ' "rush install" instead of "rush update" to catch developers who forgot to commit their' +
                ' shrinkwrap changes.  Cautious people can also use "rush install" if they want to avoid' +
                ' accidentally updating their shrinkwrap file.',
            parser
        });
        this._selectionParameters = new _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_2__.SelectionParameterSet(this.rushConfiguration, this, {
            // Include lockfile processing since this expands the selection, and we need to select
            // at least the same projects selected with the same query to "rush build"
            includeExternalDependencies: true,
            // Disable filtering because rush-project.json is riggable and therefore may not be available
            enableFiltering: false
        });
        this._checkOnlyParameter = this.defineFlagParameter({
            parameterLongName: '--check-only',
            description: `Only check the validity of the shrinkwrap file without performing an install.`
        });
    }
    async buildInstallOptionsAsync() {
        const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.ConsoleTerminalProvider());
        return {
            debug: this.parser.isDebug,
            allowShrinkwrapUpdates: false,
            bypassPolicyAllowed: true,
            bypassPolicy: this._bypassPolicyParameter.value,
            noLink: this._noLinkParameter.value,
            fullUpgrade: false,
            recheckShrinkwrap: false,
            networkConcurrency: this._networkConcurrencyParameter.value,
            collectLogFile: this._debugPackageManagerParameter.value,
            variant: this._variant.value,
            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
            // it is safe to assume that the value is not null
            maxInstallAttempts: this._maxInstallAttempts.value,
            // These are derived independently of the selection for command line brevity
            pnpmFilterArguments: await this._selectionParameters.getPnpmFilterArgumentsAsync(terminal),
            checkOnly: this._checkOnlyParameter.value,
            beforeInstallAsync: () => this.rushSession.hooks.beforeInstall.promise(this)
        };
    }
}
//# sourceMappingURL=InstallAction.js.map

/***/ }),

/***/ 875901:
/*!**********************************************!*\
  !*** ./lib-esnext/cli/actions/LinkAction.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkAction": () => (/* binding */ LinkAction)
/* harmony export */ });
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class LinkAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'link',
            summary: 'Create node_modules symlinks for all projects',
            documentation: 'Create node_modules symlinks for all projects.  This operation is normally performed' +
                ' automatically as part of "rush install" or "rush update".  You should only need to use "rush link"' +
                ' if you performed "rush unlink" for some reason, or if you specified the "--no-link" option' +
                ' for "rush install" or "rush update".',
            parser
        });
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: '-f',
            description: 'Deletes and recreates all links, even if the filesystem state seems to indicate that this is ' +
                'unnecessary.'
        });
    }
    async runAsync() {
        const linkManagerFactoryModule = await __webpack_require__.e(/*! import() | LinkManagerFactory */ "LinkManagerFactory").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/LinkManagerFactory */ 662116));
        const linkManager = linkManagerFactoryModule.LinkManagerFactory.getLinkManager(this.rushConfiguration);
        await linkManager.createSymlinksForProjects(this._force.value);
    }
}
//# sourceMappingURL=LinkAction.js.map

/***/ }),

/***/ 700972:
/*!**********************************************!*\
  !*** ./lib-esnext/cli/actions/ListAction.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListAction": () => (/* binding */ ListAction)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/VersionPolicy */ 734331);
/* harmony import */ var _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsing/SelectionParameterSet */ 40787);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class ListAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'list',
            summary: 'List package information for all projects in the repo',
            documentation: 'List package names, and optionally version (--version) and ' +
                'path (--path) or full path (--full-path), for projects in the ' +
                'current rush config.',
            parser,
            safeForSimultaneousRushProcesses: true
        });
        this._version = this.defineFlagParameter({
            parameterLongName: '--version',
            parameterShortName: '-v',
            description: 'If this flag is specified, the project version will be ' +
                'displayed in a column along with the package name.'
        });
        this._path = this.defineFlagParameter({
            parameterLongName: '--path',
            parameterShortName: '-p',
            description: 'If this flag is specified, the project path will be ' +
                'displayed in a column along with the package name.'
        });
        this._fullPath = this.defineFlagParameter({
            parameterLongName: '--full-path',
            description: 'If this flag is specified, the project full path will ' +
                'be displayed in a column along with the package name.'
        });
        this._detailedFlag = this.defineFlagParameter({
            parameterLongName: '--detailed',
            description: 'For the non --json view, if this flag is specified, ' +
                'include path (-p), version (-v) columns along with ' +
                "the project's applicable: versionPolicy, versionPolicyName, " +
                'shouldPublish, reviewPolicy, and tags fields.'
        });
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
        this._selectionParameters = new _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_2__.SelectionParameterSet(this.rushConfiguration, this, {
            // Include lockfile processing since this expands the selection, and we need to select
            // at least the same projects selected with the same query to "rush build"
            includeExternalDependencies: true,
            // Disable filtering because rush-project.json is riggable and therefore may not be available
            enableFiltering: false
        });
    }
    async runAsync() {
        const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.ConsoleTerminalProvider());
        const selection = await this._selectionParameters.getSelectedProjectsAsync(terminal);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Sort.sortSetBy(selection, (x) => x.packageName);
        if (this._jsonFlag.value && this._detailedFlag.value) {
            throw new Error(`The parameters "--json" and "--detailed" cannot be used together.`);
        }
        if (this._jsonFlag.value) {
            this._printJson(selection);
        }
        else if (this._version.value || this._path.value || this._fullPath.value || this._detailedFlag.value) {
            await this._printListTableAsync(selection);
        }
        else {
            this._printList(selection);
        }
    }
    _printJson(selection) {
        const projects = Array.from(selection, (config) => {
            let reviewCategory;
            let shouldPublish;
            let versionPolicy;
            let versionPolicyName;
            if (config.versionPolicy !== undefined) {
                const definitionName = _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_3__.VersionPolicyDefinitionName[config.versionPolicy.definitionName];
                versionPolicy = `${definitionName}`;
                versionPolicyName = config.versionPolicy.policyName;
            }
            else {
                shouldPublish = config.shouldPublish;
            }
            if (config.reviewCategory) {
                reviewCategory = config.reviewCategory;
            }
            return {
                name: config.packageName,
                version: config.packageJson.version,
                path: config.projectRelativeFolder,
                fullPath: config.projectFolder,
                versionPolicy,
                versionPolicyName,
                shouldPublish,
                reviewCategory,
                tags: Array.from(config.tags)
            };
        });
        const output = {
            projects
        };
        // eslint-disable-next-line no-console
        console.log(JSON.stringify(output, undefined, 2));
    }
    _printList(selection) {
        for (const project of selection) {
            // eslint-disable-next-line no-console
            console.log(project.packageName);
        }
    }
    async _printListTableAsync(selection) {
        const tableHeader = ['Project'];
        if (this._version.value || this._detailedFlag.value) {
            tableHeader.push('Version');
        }
        if (this._path.value || this._detailedFlag.value) {
            tableHeader.push('Path');
        }
        if (this._fullPath.value) {
            tableHeader.push('Full Path');
        }
        if (this._detailedFlag.value) {
            tableHeader.push('Version policy');
            tableHeader.push('Version policy name');
            tableHeader.push('Should publish');
            tableHeader.push('Review category');
            tableHeader.push('Tags');
        }
        const { default: CliTable } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! cli-table */ 13593, 23));
        const table = new CliTable({
            head: tableHeader
        });
        for (const project of selection) {
            const packageRow = [];
            function appendToPackageRow(value) {
                packageRow.push(value === undefined ? 'UNDEFINED' : value);
            }
            appendToPackageRow(project.packageName);
            if (this._version.value || this._detailedFlag.value) {
                appendToPackageRow(project.packageJson.version);
            }
            if (this._path.value || this._detailedFlag.value) {
                appendToPackageRow(project.projectRelativeFolder);
            }
            if (this._fullPath.value) {
                appendToPackageRow(project.projectFolder);
            }
            if (this._detailedFlag.value) {
                // When we HAVE a version policy
                let versionPolicyDefinitionName = '';
                let versionPolicyName = '';
                // When we DO NOT have version policy, fallback to shouldPublish boolean
                let shouldPublish = '';
                let reviewCategory = '';
                if (project.versionPolicy !== undefined) {
                    const definitionName = _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_3__.VersionPolicyDefinitionName[project.versionPolicy.definitionName];
                    versionPolicyDefinitionName = definitionName;
                    versionPolicyName = project.versionPolicy.policyName;
                }
                else {
                    shouldPublish = `${project.shouldPublish}`;
                }
                if (project.reviewCategory) {
                    reviewCategory = project.reviewCategory;
                }
                appendToPackageRow(versionPolicyDefinitionName);
                appendToPackageRow(versionPolicyName);
                appendToPackageRow(shouldPublish);
                appendToPackageRow(reviewCategory);
                appendToPackageRow(Array.from(project.tags).join(', '));
            }
            table.push(packageRow);
        }
        // eslint-disable-next-line no-console
        console.log(table.toString());
    }
}
//# sourceMappingURL=ListAction.js.map

/***/ }),

/***/ 999279:
/*!*************************************************!*\
  !*** ./lib-esnext/cli/actions/PublishAction.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PublishAction": () => (/* binding */ PublishAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../api/ChangeManagement */ 780924);
/* harmony import */ var _utilities_Npm__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/Npm */ 450153);
/* harmony import */ var _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../logic/PublishUtilities */ 189294);
/* harmony import */ var _logic_ChangelogGenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logic/ChangelogGenerator */ 268371);
/* harmony import */ var _logic_PrereleaseToken__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../logic/PrereleaseToken */ 862346);
/* harmony import */ var _logic_ChangeManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../logic/ChangeManager */ 121467);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_PublishGit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../logic/PublishGit */ 797811);
/* harmony import */ var _logic_policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/policy/PolicyValidator */ 999291);
/* harmony import */ var _VersionAction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./VersionAction */ 669821);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _logic_Git__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logic/Git */ 668229);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
















class PublishAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_4__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'publish',
            summary: 'Reads and processes package publishing change requests generated by "rush change".',
            documentation: 'Reads and processes package publishing change requests generated by "rush change". This will perform a ' +
                // eslint-disable-next-line no-console
                'read-only operation by default, printing operations executed to the console. To commit ' +
                'changes and publish packages, you must use the --commit flag and/or the --publish flag.',
            parser
        });
        this._apply = this.defineFlagParameter({
            parameterLongName: '--apply',
            parameterShortName: '-a',
            description: 'If this flag is specified, the change requests will be applied to package.json files.'
        });
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this flag is specified, applied changes and deleted change requests will be ' +
                'committed and merged into the target branch.'
        });
        this._publish = this.defineFlagParameter({
            parameterLongName: '--publish',
            parameterShortName: '-p',
            description: 'If this flag is specified, applied changes will be published to the NPM registry.'
        });
        this._addCommitDetails = this.defineFlagParameter({
            parameterLongName: '--add-commit-details',
            parameterShortName: undefined,
            description: 'Adds commit author and hash to the changelog.json files for each change.'
        });
        this._regenerateChangelogs = this.defineFlagParameter({
            parameterLongName: '--regenerate-changelogs',
            parameterShortName: undefined,
            description: 'Regenerates all changelog files based on the current JSON content.'
        });
        // NPM registry related parameters
        this._registryUrl = this.defineStringParameter({
            parameterLongName: '--registry',
            parameterShortName: '-r',
            argumentName: 'REGISTRY',
            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +
                'tagged.'
        });
        this._npmAuthToken = this.defineStringParameter({
            parameterLongName: '--npm-auth-token',
            parameterShortName: '-n',
            argumentName: 'TOKEN',
            description: '(DEPRECATED) Specifies the authentication token to use during publishing. This parameter is deprecated' +
                ' because command line parameters may be readable by unrelated processes on a lab machine. Instead, a' +
                ' safer practice is to pass the token via an environment variable and reference it from your ' +
                ' common/config/rush/.npmrc-publish file.'
        });
        this._npmTag = this.defineStringParameter({
            parameterLongName: '--tag',
            parameterShortName: '-t',
            argumentName: 'TAG',
            description: `The tag option to pass to npm publish. By default NPM will publish using the 'latest' tag, even if ` +
                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +
                `a tag is important. When hotfix changes are made, this parameter defaults to 'hotfix'.`
        });
        this._npmAccessLevel = this.defineChoiceParameter({
            alternatives: ['public', 'restricted'],
            parameterLongName: '--set-access-level',
            parameterShortName: undefined,
            description: `By default, when Rush invokes "npm publish" it will publish scoped packages with an access level ` +
                `of "restricted". Scoped packages can be published with an access level of "public" by specifying ` +
                `that value for this flag with the initial publication. NPM always publishes unscoped packages with ` +
                `an access level of "public". For more information, see the NPM documentation for the "--access" ` +
                `option of "npm publish".`
        });
        // NPM pack tarball related parameters
        this._pack = this.defineFlagParameter({
            parameterLongName: '--pack',
            description: `Packs projects into tarballs instead of publishing to npm repository. It can only be used when ` +
                `--include-all is specified. If this flag is specified, NPM registry related parameters will be ignored.`
        });
        this._releaseFolder = this.defineStringParameter({
            parameterLongName: '--release-folder',
            argumentName: 'FOLDER',
            description: `This parameter is used with --pack parameter to provide customized location for the tarballs instead of ` +
                `the default value. `
        });
        // End of NPM pack tarball related parameters
        this._includeAll = this.defineFlagParameter({
            parameterLongName: '--include-all',
            parameterShortName: undefined,
            description: 'If this flag is specified, all packages with shouldPublish=true in rush.json ' +
                'or with a specified version policy ' +
                'will be published if their version is newer than published version.'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            argumentName: 'POLICY',
            description: 'Version policy name. Only projects with this version policy will be published if used ' +
                'with --include-all.'
        });
        this._prereleaseName = this.defineStringParameter({
            parameterLongName: '--prerelease-name',
            argumentName: 'NAME',
            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'
        });
        this._partialPrerelease = this.defineFlagParameter({
            parameterLongName: '--partial-prerelease',
            parameterShortName: undefined,
            description: 'Used with --prerelease-name. Only bump packages to a prerelease version if they have changes.'
        });
        this._suffix = this.defineStringParameter({
            parameterLongName: '--suffix',
            argumentName: 'SUFFIX',
            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'
        });
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: undefined,
            description: 'If this flag is specified with --publish, packages will be published with --force on npm'
        });
        this._applyGitTagsOnPack = this.defineFlagParameter({
            parameterLongName: '--apply-git-tags-on-pack',
            description: `If specified with --publish and --pack, git tags will be applied for packages` +
                ` as if a publish was being run without --pack.`
        });
        this._commitId = this.defineStringParameter({
            parameterLongName: '--commit',
            parameterShortName: '-c',
            argumentName: 'COMMIT_ID',
            description: `Used in conjunction with git tagging -- apply git tags at the commit hash` +
                ` specified. If not provided, the current HEAD will be tagged.`
        });
        this._ignoreGitHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-git-hooks',
            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`
        });
    }
    /**
     * Executes the publish action, which will read change request files, apply changes to package.jsons,
     */
    async runAsync() {
        await _logic_policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_5__.validatePolicyAsync(this.rushConfiguration, { bypassPolicy: false });
        // Example: "common\temp\publish-home"
        this._targetNpmrcPublishFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, 'publish-home');
        // Example: "common\temp\publish-home\.npmrc"
        this._targetNpmrcPublishPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._targetNpmrcPublishFolder, '.npmrc');
        const allPackages = this.rushConfiguration.projectsByName;
        if (this._regenerateChangelogs.value) {
            // eslint-disable-next-line no-console
            console.log('Regenerating changelogs');
            _logic_ChangelogGenerator__WEBPACK_IMPORTED_MODULE_6__.ChangelogGenerator.regenerateChangelogs(allPackages, this.rushConfiguration);
            return;
        }
        this._validate();
        this._addNpmPublishHome();
        const git = new _logic_Git__WEBPACK_IMPORTED_MODULE_7__.Git(this.rushConfiguration);
        const publishGit = new _logic_PublishGit__WEBPACK_IMPORTED_MODULE_8__.PublishGit(git, this._targetBranch.value);
        if (this._includeAll.value) {
            this._publishAll(publishGit, allPackages);
        }
        else {
            this._prereleaseToken = new _logic_PrereleaseToken__WEBPACK_IMPORTED_MODULE_9__.PrereleaseToken(this._prereleaseName.value, this._suffix.value, this._partialPrerelease.value);
            await this._publishChangesAsync(git, publishGit, allPackages);
        }
        // eslint-disable-next-line no-console
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Rush publish finished successfully.'));
    }
    /**
     * Validate some input parameters
     */
    _validate() {
        if (this._pack.value && !this._includeAll.value) {
            throw new Error('--pack can only be used with --include-all');
        }
        if (this._releaseFolder.value && !this._pack.value) {
            throw new Error(`--release-folder can only be used with --pack`);
        }
        if (this._applyGitTagsOnPack.value && !this._pack.value) {
            throw new Error(`${this._applyGitTagsOnPack.longName} must be used with ${this._pack.longName}`);
        }
    }
    async _publishChangesAsync(git, publishGit, allPackages) {
        const changeManager = new _logic_ChangeManager__WEBPACK_IMPORTED_MODULE_10__.ChangeManager(this.rushConfiguration);
        await changeManager.loadAsync(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);
        if (changeManager.hasChanges()) {
            const orderedChanges = changeManager.packageChanges;
            const tempBranchName = `publish-${Date.now()}`;
            // Make changes in temp branch.
            publishGit.checkout(tempBranchName, true);
            this._setDependenciesBeforePublish();
            // Make changes to package.json and change logs.
            changeManager.apply(this._apply.value);
            await changeManager.updateChangelogAsync(this._apply.value);
            this._setDependenciesBeforeCommit();
            if (git.hasUncommittedChanges()) {
                // Stage, commit, and push the changes to remote temp branch.
                publishGit.addChanges(':/*');
                publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || _VersionAction__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);
                this._setDependenciesBeforePublish();
                // Override tag parameter if there is a hotfix change.
                for (const change of orderedChanges) {
                    if (change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_12__.ChangeType.hotfix) {
                        this._hotfixTagOverride = 'hotfix';
                        break;
                    }
                }
                // npm publish the things that need publishing.
                for (const change of orderedChanges) {
                    if (change.changeType && change.changeType > _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_12__.ChangeType.dependency) {
                        const project = allPackages.get(change.packageName);
                        if (project) {
                            if (!this._packageExists(project)) {
                                this._npmPublish(change.packageName, project.publishFolder);
                            }
                            else {
                                // eslint-disable-next-line no-console
                                console.log(`Skip ${change.packageName}. Package exists.`);
                            }
                        }
                        else {
                            // eslint-disable-next-line no-console
                            console.log(`Skip ${change.packageName}. Failed to find its project.`);
                        }
                    }
                }
                this._setDependenciesBeforeCommit();
                // Create and push appropriate Git tags.
                this._gitAddTags(publishGit, orderedChanges);
                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);
                // Now merge to target branch.
                publishGit.checkout(this._targetBranch.value);
                publishGit.pull(!this._ignoreGitHooksParameter.value);
                publishGit.merge(tempBranchName, !this._ignoreGitHooksParameter.value);
                publishGit.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);
                publishGit.deleteBranch(tempBranchName, true, !this._ignoreGitHooksParameter.value);
            }
            else {
                publishGit.checkout(this._targetBranch.value);
                publishGit.deleteBranch(tempBranchName, false, !this._ignoreGitHooksParameter.value);
            }
        }
    }
    _publishAll(git, allPackages) {
        // eslint-disable-next-line no-console
        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);
        let updated = false;
        allPackages.forEach((packageConfig, packageName) => {
            if (packageConfig.shouldPublish &&
                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {
                const applyTag = (apply) => {
                    if (!apply) {
                        return;
                    }
                    const packageVersion = packageConfig.packageJson.version;
                    // Do not create a new tag if one already exists, this will result in a fatal error
                    if (git.hasTag(packageConfig)) {
                        // eslint-disable-next-line no-console
                        console.log(`Not tagging ${packageName}@${packageVersion}. A tag already exists for this version.`);
                        return;
                    }
                    git.addTag(!!this._publish.value, packageName, packageVersion, this._commitId.value, this._prereleaseName.value);
                    updated = true;
                };
                if (this._pack.value) {
                    // packs to tarball instead of publishing to NPM repository
                    this._npmPack(packageName, packageConfig);
                    applyTag(this._applyGitTagsOnPack.value);
                }
                else if (this._force.value || !this._packageExists(packageConfig)) {
                    // Publish to npm repository
                    this._npmPublish(packageName, packageConfig.publishFolder);
                    applyTag(true);
                }
                else {
                    // eslint-disable-next-line no-console
                    console.log(`Skip ${packageName}. Not updated.`);
                }
            }
        });
        if (updated) {
            git.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);
        }
    }
    _gitAddTags(git, orderedChanges) {
        for (const change of orderedChanges) {
            if (change.changeType &&
                change.changeType > _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_12__.ChangeType.dependency &&
                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {
                git.addTag(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion, this._commitId.value, this._prereleaseName.value);
            }
        }
    }
    _npmPublish(packageName, packagePath) {
        const env = _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__.PublishUtilities.getEnvArgs();
        const args = ['publish'];
        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {
            this._addSharedNpmConfig(env, args);
            if (this._npmTag.value) {
                args.push(`--tag`, this._npmTag.value);
            }
            else if (this._hotfixTagOverride) {
                args.push(`--tag`, this._hotfixTagOverride);
            }
            if (this._force.value) {
                args.push(`--force`);
            }
            if (this._npmAccessLevel.value) {
                args.push(`--access`, this._npmAccessLevel.value);
            }
            if (this.rushConfiguration.packageManager === 'pnpm') {
                // PNPM 4.11.0 introduced a feature that may interrupt publishing and prompt the user for input.
                // See this issue for details: https://github.com/microsoft/rushstack/issues/1940
                args.push('--no-git-checks');
            }
            // TODO: Yarn's "publish" command line is fairly different from NPM and PNPM.  The right thing to do here
            // would be to remap our options to the Yarn equivalents.  But until we get around to that, we'll simply invoke
            // whatever NPM binary happens to be installed in the global path.
            const packageManagerToolFilename = this.rushConfiguration.packageManager === 'yarn'
                ? 'npm'
                : this.rushConfiguration.packageManagerToolFilename;
            // If the auth token was specified via the command line, avoid printing it on the console
            const secretSubstring = this._npmAuthToken.value;
            _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__.PublishUtilities.execCommand(!!this._publish.value, packageManagerToolFilename, args, packagePath, env, secretSubstring);
        }
    }
    _packageExists(packageConfig) {
        const env = _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__.PublishUtilities.getEnvArgs();
        const args = [];
        this._addSharedNpmConfig(env, args);
        const publishedVersions = _utilities_Npm__WEBPACK_IMPORTED_MODULE_14__.Npm.publishedVersions(packageConfig.packageName, packageConfig.publishFolder, env, args);
        const packageVersion = packageConfig.packageJsonEditor.version;
        // SemVer supports an obscure (and generally deprecated) feature where "build metadata" can be
        // appended to a version.  For example if our version is "1.2.3-beta.4+extra567", then "+extra567" is the
        // build metadata part.  The suffix has no effect on version comparisons and is mostly ignored by
        // the NPM registry.  Importantly, the queried version number will not include it, so we need to discard
        // it before comparing against the list of already published versions.
        const parsedVersion = semver__WEBPACK_IMPORTED_MODULE_2__.parse(packageVersion);
        if (!parsedVersion) {
            throw new Error(`The package "${packageConfig.packageName}" has an invalid "version" value`);
        }
        // For example, normalize "1.2.3-beta.4+extra567" -->"1.2.3-beta.4".
        //
        // This is redundant in the current API, but might change in the future:
        // https://github.com/npm/node-semver/issues/264
        parsedVersion.build = [];
        const normalizedVersion = parsedVersion.format();
        return publishedVersions.indexOf(normalizedVersion) >= 0;
    }
    _npmPack(packageName, project) {
        const args = ['pack'];
        const env = _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__.PublishUtilities.getEnvArgs();
        _logic_PublishUtilities__WEBPACK_IMPORTED_MODULE_13__.PublishUtilities.execCommand(!!this._publish.value, this.rushConfiguration.packageManagerToolFilename, args, project.publishFolder, env);
        if (this._publish.value) {
            // Copy the tarball the release folder
            const tarballName = this._calculateTarballName(project);
            const tarballPath = path__WEBPACK_IMPORTED_MODULE_1__.join(project.publishFolder, tarballName);
            const destFolder = this._releaseFolder.value
                ? this._releaseFolder.value
                : path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, 'artifacts', 'packages');
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.move({
                sourcePath: tarballPath,
                destinationPath: path__WEBPACK_IMPORTED_MODULE_1__.join(destFolder, tarballName),
                overwrite: true
            });
        }
    }
    _calculateTarballName(project) {
        // Same logic as how npm forms the tarball name
        const packageName = project.packageName;
        const name = packageName[0] === '@' ? packageName.substr(1).replace(/\//g, '-') : packageName;
        if (this.rushConfiguration.packageManager === 'yarn') {
            // yarn tarballs have a "v" before the version number
            return `${name}-v${project.packageJson.version}.tgz`;
        }
        else {
            return `${name}-${project.packageJson.version}.tgz`;
        }
    }
    _setDependenciesBeforePublish() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _setDependenciesBeforeCommit() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _addNpmPublishHome() {
        // Create "common\temp\publish-home" folder, if it doesn't exist
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.createFolderWithRetry(this._targetNpmrcPublishFolder);
        // Copy down the committed "common\config\rush\.npmrc-publish" file, if there is one
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this._targetNpmrcPublishFolder, true);
    }
    _addSharedNpmConfig(env, args) {
        const userHomeEnvVariable = process.platform === 'win32' ? 'USERPROFILE' : 'HOME';
        let registry = '//registry.npmjs.org/';
        // Check if .npmrc file exists in "common\temp\publish-home"
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(this._targetNpmrcPublishPath)) {
            // Redirect userHomeEnvVariable, NPM will use config in "common\temp\publish-home\.npmrc"
            env[userHomeEnvVariable] = this._targetNpmrcPublishFolder;
        }
        // Check if registryUrl and token are specified via command-line
        if (this._registryUrl.value) {
            const registryUrl = this._registryUrl.value;
            env['npm_config_registry'] = registryUrl; // eslint-disable-line dot-notation
            registry = registryUrl.substring(registryUrl.indexOf('//'));
        }
        if (this._npmAuthToken.value) {
            args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);
        }
    }
}
//# sourceMappingURL=PublishAction.js.map

/***/ }),

/***/ 784476:
/*!***********************************************!*\
  !*** ./lib-esnext/cli/actions/PurgeAction.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PurgeAction": () => (/* binding */ PurgeAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/PurgeManager */ 371186);
/* harmony import */ var _logic_UnlinkManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/UnlinkManager */ 645421);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





class PurgeAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'purge',
            summary: 'For diagnostic purposes, use this command to delete caches and other temporary files used by Rush',
            documentation: 'The "rush purge" command is used to delete temporary files created by Rush.  This is' +
                ' useful if you are having problems and suspect that cache files may be corrupt.',
            parser
        });
        this._unsafeParameter = this.defineFlagParameter({
            parameterLongName: '--unsafe',
            description: '(UNSAFE!) Also delete shared files such as the package manager instances stored in' +
                ' the ".rush" folder in the user\'s home directory.  This is a more aggressive fix that is' +
                ' NOT SAFE to run in a live environment because it will cause other concurrent Rush processes to fail.'
        });
    }
    async runAsync() {
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__.Stopwatch.start();
        const unlinkManager = new _logic_UnlinkManager__WEBPACK_IMPORTED_MODULE_3__.UnlinkManager(this.rushConfiguration);
        const purgeManager = new _logic_PurgeManager__WEBPACK_IMPORTED_MODULE_4__.PurgeManager(this.rushConfiguration, this.rushGlobalFolder);
        unlinkManager.unlink(/*force:*/ true);
        if (this._unsafeParameter.value) {
            purgeManager.purgeUnsafe();
        }
        else {
            purgeManager.purgeNormal();
        }
        purgeManager.deleteAll();
        // eslint-disable-next-line no-console
        console.log('\n' +
            colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Rush purge started successfully and will complete asynchronously. (${stopwatch.toString()})`));
    }
}
//# sourceMappingURL=PurgeAction.js.map

/***/ }),

/***/ 120926:
/*!************************************************!*\
  !*** ./lib-esnext/cli/actions/RemoveAction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveAction": () => (/* binding */ RemoveAction)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseAddAndRemoveAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseAddAndRemoveAction */ 486042);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class RemoveAction extends _BaseAddAndRemoveAction__WEBPACK_IMPORTED_MODULE_1__.BaseAddAndRemoveAction {
    constructor(parser) {
        const documentation = [
            'Removes specified package(s) from the dependencies of the current project (as determined by the current working directory)' +
                ' and then runs "rush update".'
        ].join('\n');
        super({
            actionName: 'remove',
            summary: 'Removes one or more dependencies from the package.json and runs rush update.',
            documentation,
            safeForSimultaneousRushProcesses: false,
            parser
        });
        this._terminalProvider = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.ConsoleTerminalProvider();
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(this._terminalProvider);
        this._packageNameList = this.defineStringListParameter({
            parameterLongName: '--package',
            parameterShortName: '-p',
            required: true,
            argumentName: 'PACKAGE',
            description: 'The name of the package which should be removed.' +
                ' To remove multiple packages, run "rush remove --package foo --package bar".'
        });
        this._allFlag = this.defineFlagParameter({
            parameterLongName: '--all',
            description: 'If specified, the dependency will be removed from all projects that declare it.'
        });
    }
    getUpdateOptions() {
        const projects = super.getProjects();
        const packagesToRemove = [];
        for (const specifiedPackageName of this.specifiedPackageNameList) {
            /**
             * Name
             */
            const packageName = specifiedPackageName;
            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {
                throw new Error(`The package name "${packageName}" is not valid.`);
            }
            for (const project of projects) {
                if (!project.packageJsonEditor.tryGetDependency(packageName) &&
                    !project.packageJsonEditor.tryGetDevDependency(packageName)) {
                    this._terminal.writeLine(`The project "${project.packageName}" do not have ${packageName} in package.json.`);
                }
            }
            packagesToRemove.push({ packageName });
        }
        return {
            projects: projects,
            packagesToUpdate: packagesToRemove,
            skipUpdate: this._skipUpdateFlag.value,
            debugInstall: this.parser.isDebug,
            actionName: this.actionName
        };
    }
}
//# sourceMappingURL=RemoveAction.js.map

/***/ }),

/***/ 224996:
/*!**********************************************!*\
  !*** ./lib-esnext/cli/actions/ScanAction.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScanAction": () => (/* binding */ ScanAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var builtin_modules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! builtin-modules */ 421439);
/* harmony import */ var builtin_modules__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(builtin_modules__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





class ScanAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_4__.BaseConfiglessRushAction {
    constructor(parser) {
        super({
            actionName: 'scan',
            summary: 'When migrating projects into a Rush repo, this command is helpful for detecting' +
                ' undeclared dependencies.',
            documentation: `The Node.js module system allows a project to import NPM packages without explicitly` +
                ` declaring them as dependencies in the package.json file.  Such "phantom dependencies"` +
                ` can cause problems.  Rush and PNPM use symlinks specifically to protect against phantom dependencies.` +
                ` These protections may cause runtime errors for existing projects when they are first migrated into` +
                ` a Rush monorepo.  The "rush scan" command is a handy tool for fixing these errors. It scans the "./src"` +
                ` and "./lib" folders for import syntaxes such as "import __ from '__'", "require('__')",` +
                ` and "System.import('__').  It prints a report of the referenced packages.  This heuristic is` +
                ` not perfect, but it can save a lot of time when migrating projects.`,
            safeForSimultaneousRushProcesses: true,
            parser
        });
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
        this._allFlag = this.defineFlagParameter({
            parameterLongName: '--all',
            description: 'If this flag is specified, output will list all detected dependencies.'
        });
    }
    async runAsync() {
        const packageJsonFilename = path__WEBPACK_IMPORTED_MODULE_1__.resolve('./package.json');
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(packageJsonFilename)) {
            throw new Error('You must run "rush scan" in a project folder containing a package.json file.');
        }
        const requireRegExps = [
            // Example: require('something')
            /\brequire\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: require.ensure('something')
            /\brequire.ensure\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire.ensure\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: require.resolve('something')
            /\brequire.resolve\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire.resolve\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: System.import('something')
            /\bSystem.import\s*\(\s*[']([^']+\s*)[']\)/,
            /\bSystem.import\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example:
            //
            // import {
            //   A, B
            // } from 'something';
            /\bfrom\s*[']([^']+)[']/,
            /\bfrom\s*["]([^"]+)["]/,
            // Example:  import 'something';
            /\bimport\s*[']([^']+)[']\s*\;/,
            /\bimport\s*["]([^"]+)["]\s*\;/,
            // Example:
            // /// <reference types="something" />
            /\/\/\/\s*<\s*reference\s+types\s*=\s*["]([^"]+)["]\s*\/>/
        ];
        // Example: "my-package/lad/dee/dah" --> "my-package"
        // Example: "@ms/my-package" --> "@ms/my-package"
        // Example: "lodash.get" --> "lodash.get"
        const packageRegExp = /^((@[a-z\-0-9!_]+\/)?[a-z\-0-9!_][a-z\-0-9!_.]*)\/?/;
        const requireMatches = new Set();
        const { default: glob } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fast-glob */ 142479, 23));
        const scanResults = await glob(['./*.{ts,js,tsx,jsx}', './{src,lib}/**/*.{ts,js,tsx,jsx}']);
        for (const filename of scanResults) {
            try {
                const contents = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.readFile(filename);
                const lines = contents.split('\n');
                for (const line of lines) {
                    for (const requireRegExp of requireRegExps) {
                        const requireRegExpResult = requireRegExp.exec(line);
                        if (requireRegExpResult) {
                            requireMatches.add(requireRegExpResult[1]);
                        }
                    }
                }
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Skipping file due to error: ' + filename));
            }
        }
        const packageMatches = new Set();
        requireMatches.forEach((requireMatch) => {
            const packageRegExpResult = packageRegExp.exec(requireMatch);
            if (packageRegExpResult) {
                packageMatches.add(packageRegExpResult[1]);
            }
        });
        const detectedPackageNames = [];
        packageMatches.forEach((packageName) => {
            if (builtin_modules__WEBPACK_IMPORTED_MODULE_2___default().indexOf(packageName) < 0) {
                detectedPackageNames.push(packageName);
            }
        });
        detectedPackageNames.sort();
        const declaredDependencies = new Set();
        const declaredDevDependencies = new Set();
        const missingDependencies = [];
        const unusedDependencies = [];
        const packageJsonContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.readFile(packageJsonFilename);
        try {
            const manifest = JSON.parse(packageJsonContent);
            if (manifest.dependencies) {
                for (const depName of Object.keys(manifest.dependencies)) {
                    declaredDependencies.add(depName);
                }
            }
            if (manifest.devDependencies) {
                for (const depName of Object.keys(manifest.devDependencies)) {
                    declaredDevDependencies.add(depName);
                }
            }
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(`JSON.parse ${packageJsonFilename} error`);
        }
        for (const detectedPkgName of detectedPackageNames) {
            /**
             * Missing(phantom) dependencies are
             * - used in source code
             * - not decalred in dependencies and devDependencies in package.json
             */
            if (!declaredDependencies.has(detectedPkgName) && !declaredDevDependencies.has(detectedPkgName)) {
                missingDependencies.push(detectedPkgName);
            }
        }
        for (const declaredPkgName of declaredDependencies) {
            /**
             * Unused dependencies are
             * - declared in dependencies in package.json (devDependencies not included)
             * - not used in source code
             */
            if (!detectedPackageNames.includes(declaredPkgName) && !declaredPkgName.startsWith('@types/')) {
                unusedDependencies.push(declaredPkgName);
            }
        }
        const output = {
            detectedDependencies: detectedPackageNames,
            missingDependencies: missingDependencies,
            unusedDependencies: unusedDependencies
        };
        if (this._jsonFlag.value) {
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(output, undefined, 2));
        }
        else if (this._allFlag.value) {
            if (detectedPackageNames.length !== 0) {
                // eslint-disable-next-line no-console
                console.log('Dependencies that seem to be imported by this project:');
                for (const packageName of detectedPackageNames) {
                    // eslint-disable-next-line no-console
                    console.log('  ' + packageName);
                }
            }
            else {
                // eslint-disable-next-line no-console
                console.log('This project does not seem to import any NPM packages.');
            }
        }
        else {
            let wroteAnything = false;
            if (missingDependencies.length > 0) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Possible phantom dependencies') +
                    " - these seem to be imported but aren't listed in package.json:");
                for (const packageName of missingDependencies) {
                    // eslint-disable-next-line no-console
                    console.log('  ' + packageName);
                }
                wroteAnything = true;
            }
            if (unusedDependencies.length > 0) {
                if (wroteAnything) {
                    // eslint-disable-next-line no-console
                    console.log('');
                }
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Possible unused dependencies') +
                    " - these are listed in package.json but don't seem to be imported:");
                for (const packageName of unusedDependencies) {
                    // eslint-disable-next-line no-console
                    console.log('  ' + packageName);
                }
                wroteAnything = true;
            }
            if (!wroteAnything) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Everything looks good.') + '  No missing or unused dependencies were found.');
            }
        }
    }
}
//# sourceMappingURL=ScanAction.js.map

/***/ }),

/***/ 14961:
/*!***********************************************!*\
  !*** ./lib-esnext/cli/actions/SetupAction.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetupAction": () => (/* binding */ SetupAction)
/* harmony export */ });
/* harmony import */ var _logic_setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/setup/SetupPackageRegistry */ 555992);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class SetupAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'setup',
            summary: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +
                ' prerequisites are installed and permissions are configured.',
            documentation: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +
                ' prerequisites are installed and permissions are configured.  The initial implementation' +
                ' configures the NPM registry credentials.  More features will be added later.',
            parser
        });
    }
    async runAsync() {
        const setupPackageRegistry = new _logic_setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_1__.SetupPackageRegistry({
            rushConfiguration: this.rushConfiguration,
            isDebug: this.parser.isDebug,
            syncNpmrcAlreadyCalled: false
        });
        await setupPackageRegistry.checkAndSetup();
    }
}
//# sourceMappingURL=SetupAction.js.map

/***/ }),

/***/ 885577:
/*!************************************************!*\
  !*** ./lib-esnext/cli/actions/UnlinkAction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnlinkAction": () => (/* binding */ UnlinkAction)
/* harmony export */ });
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_UnlinkManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/UnlinkManager */ 645421);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class UnlinkAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'unlink',
            summary: 'Delete node_modules symlinks for all projects in the repo',
            documentation: 'This removes the symlinks created by the "rush link" command. This is useful for' +
                ' cleaning a repo using "git clean" without accidentally deleting source files, or for using standard NPM' +
                ' commands on a project.',
            parser
        });
    }
    async runAsync() {
        const unlinkManager = new _logic_UnlinkManager__WEBPACK_IMPORTED_MODULE_1__.UnlinkManager(this.rushConfiguration);
        if (!unlinkManager.unlink()) {
            // eslint-disable-next-line no-console
            console.log('Nothing to do.');
        }
        else {
            // eslint-disable-next-line no-console
            console.log('\nDone.');
        }
    }
}
//# sourceMappingURL=UnlinkAction.js.map

/***/ }),

/***/ 492778:
/*!************************************************!*\
  !*** ./lib-esnext/cli/actions/UpdateAction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpdateAction": () => (/* binding */ UpdateAction)
/* harmony export */ });
/* harmony import */ var _BaseInstallAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseInstallAction */ 823791);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class UpdateAction extends _BaseInstallAction__WEBPACK_IMPORTED_MODULE_0__.BaseInstallAction {
    constructor(parser) {
        super({
            actionName: 'update',
            summary: 'Install package dependencies for all projects in the repo,' +
                ' and create or update the shrinkwrap file as needed',
            documentation: 'The "rush update" command installs the dependencies described in your' +
                ' package.json files, and updates the shrinkwrap file as needed.' +
                ' (This "shrinkwrap" file stores a central inventory of all dependencies and versions' +
                ' for projects in your repo. It is found in the "common/config/rush" folder.)' +
                ' Note that Rush always performs a single install for all projects in your repo.' +
                ' You should run "rush update" whenever you start working in a Rush repo,' +
                ' after you pull from Git, and after you modify a package.json file.' +
                ' If there is nothing to do, "rush update" is instantaneous.' +
                ' NOTE: In certain cases "rush install" should be used instead of "rush update"' +
                ' -- for details, see the command help for "rush install".',
            parser
        });
        this._fullParameter = this.defineFlagParameter({
            parameterLongName: '--full',
            description: 'Normally "rush update" tries to preserve your existing installed versions' +
                ' and only makes the minimum updates needed to satisfy the package.json files.' +
                ' This conservative approach prevents your PR from getting involved with package updates that' +
                ' are unrelated to your work. Use "--full" when you really want to update all dependencies' +
                ' to the latest SemVer-compatible version.  This should be done periodically by a person' +
                ' or robot whose role is to deal with potential upgrade regressions.'
        });
        this._recheckParameter = this.defineFlagParameter({
            parameterLongName: '--recheck',
            description: 'If the shrinkwrap file appears to already satisfy the package.json files,' +
                ' then "rush update" will skip invoking the package manager at all.  In certain situations' +
                ' this heuristic may be inaccurate.  Use the "--recheck" flag to force the package manager' +
                " to process the shrinkwrap file.  This will also update your shrinkwrap file with Rush's fixups." +
                ' (To minimize shrinkwrap churn, these fixups are normally performed only in the temporary folder.)'
        });
    }
    async runAsync() {
        await this.parser.pluginManager.updateAsync();
        if (this.parser.pluginManager.error) {
            await this.parser.pluginManager.reinitializeAllPluginsForCommandAsync(this.actionName);
        }
        return super.runAsync();
    }
    async buildInstallOptionsAsync() {
        return {
            debug: this.parser.isDebug,
            allowShrinkwrapUpdates: true,
            bypassPolicyAllowed: true,
            bypassPolicy: this._bypassPolicyParameter.value,
            noLink: this._noLinkParameter.value,
            fullUpgrade: this._fullParameter.value,
            recheckShrinkwrap: this._recheckParameter.value,
            networkConcurrency: this._networkConcurrencyParameter.value,
            collectLogFile: this._debugPackageManagerParameter.value,
            variant: this._variant.value,
            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
            // it is safe to assume that the value is not null
            maxInstallAttempts: this._maxInstallAttempts.value,
            pnpmFilterArguments: [],
            checkOnly: false,
            beforeInstallAsync: () => this.rushSession.hooks.beforeInstall.promise(this)
        };
    }
}
//# sourceMappingURL=UpdateAction.js.map

/***/ }),

/***/ 258082:
/*!*************************************************************!*\
  !*** ./lib-esnext/cli/actions/UpdateAutoinstallerAction.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpdateAutoinstallerAction": () => (/* binding */ UpdateAutoinstallerAction)
/* harmony export */ });
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/Autoinstaller */ 140603);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class UpdateAutoinstallerAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'update-autoinstaller',
            summary: 'Updates autoinstaller package dependencies',
            documentation: 'Use this command to regenerate the shrinkwrap file for an autoinstaller folder.',
            parser
        });
        this._name = this.defineStringParameter({
            parameterLongName: '--name',
            argumentName: 'AUTOINSTALLER_NAME',
            required: true,
            description: 'Specifies the name of the autoinstaller, which must be one of the folders under common/autoinstallers.'
        });
    }
    async runAsync() {
        const autoinstallerName = this._name.value;
        const autoinstaller = new _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_1__.Autoinstaller({
            autoinstallerName,
            rushConfiguration: this.rushConfiguration,
            rushGlobalFolder: this.rushGlobalFolder
        });
        // Do not run `autoinstaller.prepareAsync` here. It tries to install the autoinstaller with
        // --frozen-lockfile or equivalent, which will fail if the autoinstaller's dependencies
        // have been changed.
        await autoinstaller.updateAsync();
        // eslint-disable-next-line no-console
        console.log('\nSuccess.');
    }
}
//# sourceMappingURL=UpdateAutoinstallerAction.js.map

/***/ }),

/***/ 800947:
/*!****************************************************************!*\
  !*** ./lib-esnext/cli/actions/UpdateCloudCredentialsAction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpdateCloudCredentialsAction": () => (/* binding */ UpdateCloudCredentialsAction)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/BuildCacheConfiguration */ 541976);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class UpdateCloudCredentialsAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_1__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.updateCloudCredentialsCommandName,
            summary: '(EXPERIMENTAL) Update the credentials used by the build cache provider.',
            documentation: '(EXPERIMENTAL) If the build caching feature is configured, this command facilitates ' +
                'updating the credentials used by a cloud-based provider.',
            safeForSimultaneousRushProcesses: false,
            parser
        });
        this._interactiveModeFlag = this.defineFlagParameter({
            parameterLongName: '--interactive',
            parameterShortName: '-i',
            description: 'Run the credential update operation in interactive mode, if supported by the provider.'
        });
        this._credentialParameter = this.defineStringParameter({
            parameterLongName: '--credential',
            argumentName: 'CREDENTIAL_STRING',
            description: 'A static credential, to be cached.'
        });
        this._deleteFlag = this.defineFlagParameter({
            parameterLongName: '--delete',
            parameterShortName: '-d',
            description: 'If specified, delete stored credentials.'
        });
    }
    async runAsync() {
        const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.ConsoleTerminalProvider());
        const buildCacheConfiguration = await _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_3__.BuildCacheConfiguration.loadAndRequireEnabledAsync(terminal, this.rushConfiguration, this.rushSession);
        if (this._deleteFlag.value) {
            if (this._interactiveModeFlag.value || this._credentialParameter.value !== undefined) {
                terminal.writeErrorLine(`If the ${this._deleteFlag.longName} is provided, no other parameters may be provided.`);
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
            }
            else if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.deleteCachedCredentialsAsync(terminal);
            }
            else {
                terminal.writeLine('A cloud build cache is not configured; there is nothing to delete.');
            }
        }
        else if (this._interactiveModeFlag.value && this._credentialParameter.value !== undefined) {
            terminal.writeErrorLine(`Both the ${this._interactiveModeFlag.longName} and the ` +
                `${this._credentialParameter.longName} parameters were provided. Only one ` +
                'or the other may be used at a time.');
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
        else if (this._interactiveModeFlag.value) {
            if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialInteractiveAsync(terminal);
            }
            else {
                terminal.writeLine('A cloud build cache is not configured. Credentials are not required.');
            }
        }
        else if (this._credentialParameter.value !== undefined) {
            if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialAsync(terminal, this._credentialParameter.value);
            }
            else {
                terminal.writeErrorLine('A cloud build cache is not configured. Credentials are not supported.');
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
            }
        }
        else {
            terminal.writeErrorLine(`One of the ${this._interactiveModeFlag.longName} parameter, the ` +
                `${this._credentialParameter.longName} parameter, or the ` +
                `${this._deleteFlag.longName} parameter must be provided.`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
    }
}
//# sourceMappingURL=UpdateCloudCredentialsAction.js.map

/***/ }),

/***/ 272500:
/*!************************************************************!*\
  !*** ./lib-esnext/cli/actions/UpgradeInteractiveAction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpgradeInteractiveAction": () => (/* binding */ UpgradeInteractiveAction)
/* harmony export */ });
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class UpgradeInteractiveAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(parser) {
        const documentation = [
            'Provide an interactive way to upgrade your dependencies. Running the command will open an interactive prompt' +
                ' that will ask you which projects and which dependencies you would like to upgrade.' +
                ' It will then update your package.json files, and run "rush update" for you.' +
                ' If you are using ensureConsistentVersions policy, upgrade-interactive will update all packages which use the' +
                ' dependencies that you are upgrading and match their SemVer range if provided. If ensureConsistentVersions' +
                ' is not enabled, upgrade-interactive will only update the dependency in the package you specify.' +
                ' This can be overriden by using the --make-consistent flag.'
        ];
        super({
            actionName: 'upgrade-interactive',
            summary: 'Provides interactive prompt for upgrading package dependencies per project',
            safeForSimultaneousRushProcesses: false,
            documentation: documentation.join(''),
            parser
        });
        this._makeConsistentFlag = this.defineFlagParameter({
            parameterLongName: '--make-consistent',
            description: 'When upgrading dependencies from a single project, also upgrade dependencies from other projects.'
        });
        this._skipUpdateFlag = this.defineFlagParameter({
            parameterLongName: '--skip-update',
            parameterShortName: '-s',
            description: 'If specified, the "rush update" command will not be run after updating the package.json files.'
        });
    }
    async runAsync() {
        const [{ PackageJsonUpdater }, { InteractiveUpgrader }] = await Promise.all([
            Promise.all(/*! import() | PackageJsonUpdater */[__webpack_require__.e("InstallManagerFactory"), __webpack_require__.e("PackageJsonUpdater")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/PackageJsonUpdater */ 628039)),
            __webpack_require__.e(/*! import() | InteractiveUpgrader */ "InteractiveUpgrader").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/InteractiveUpgrader */ 933877))
        ]);
        const packageJsonUpdater = new PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);
        const interactiveUpgrader = new InteractiveUpgrader(this.rushConfiguration);
        const shouldMakeConsistent = this.rushConfiguration.ensureConsistentVersions || this._makeConsistentFlag.value;
        const { projects, depsToUpgrade } = await interactiveUpgrader.upgrade();
        await packageJsonUpdater.doRushUpgradeAsync({
            projects: projects,
            packagesToAdd: depsToUpgrade.packages,
            updateOtherPackages: shouldMakeConsistent,
            skipUpdate: this._skipUpdateFlag.value,
            debugInstall: this.parser.isDebug
        });
    }
}
//# sourceMappingURL=UpgradeInteractiveAction.js.map

/***/ }),

/***/ 669821:
/*!*************************************************!*\
  !*** ./lib-esnext/cli/actions/VersionAction.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CHANGELOG_UPDATE_MESSAGE": () => (/* binding */ DEFAULT_CHANGELOG_UPDATE_MESSAGE),
/* harmony export */   "DEFAULT_PACKAGE_UPDATE_MESSAGE": () => (/* binding */ DEFAULT_PACKAGE_UPDATE_MESSAGE),
/* harmony export */   "VersionAction": () => (/* binding */ VersionAction)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/VersionPolicy */ 734331);
/* harmony import */ var _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../api/RushConfiguration */ 126002);
/* harmony import */ var _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../logic/versionMismatch/VersionMismatchFinder */ 936800);
/* harmony import */ var _logic_policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/policy/PolicyValidator */ 999291);
/* harmony import */ var _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseRushAction */ 164546);
/* harmony import */ var _logic_PublishGit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../logic/PublishGit */ 797811);
/* harmony import */ var _logic_Git__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/Git */ 668229);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.










const DEFAULT_PACKAGE_UPDATE_MESSAGE = 'Bump versions [skip ci]';
const DEFAULT_CHANGELOG_UPDATE_MESSAGE = 'Update changelogs [skip ci]';
class VersionAction extends _BaseRushAction__WEBPACK_IMPORTED_MODULE_2__.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'version',
            summary: 'Manage package versions in the repo.',
            documentation: 'use this "rush version" command to ensure version policies and bump versions.',
            parser
        });
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this flag is specified, changes will be committed and merged into the target branch.'
        });
        this._ensureVersionPolicy = this.defineFlagParameter({
            parameterLongName: '--ensure-version-policy',
            description: 'Updates package versions if needed to satisfy version policies.'
        });
        this._overrideVersion = this.defineStringParameter({
            parameterLongName: '--override-version',
            argumentName: 'NEW_VERSION',
            description: 'Override the version in the specified --version-policy. ' +
                'This setting only works for lock-step version policy and when --ensure-version-policy is specified.'
        });
        this._bumpVersion = this.defineFlagParameter({
            parameterLongName: '--bump',
            description: 'Bumps package version based on version policies.'
        });
        this._bypassPolicy = this.defineFlagParameter({
            parameterLongName: _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.bypassPolicyFlagLongName,
            description: 'Overrides "gitPolicy" enforcement (use honorably!)'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            argumentName: 'POLICY',
            description: 'The name of the version policy'
        });
        this._overwriteBump = this.defineStringParameter({
            parameterLongName: '--override-bump',
            argumentName: 'BUMPTYPE',
            description: 'Overrides the bump type in the version-policy.json for the specified version policy. ' +
                'Valid BUMPTYPE values include: prerelease, patch, minor, major. ' +
                'This setting only works for lock-step version policy in bump action.'
        });
        this._prereleaseIdentifier = this.defineStringParameter({
            parameterLongName: '--override-prerelease-id',
            argumentName: 'ID',
            description: 'Overrides the prerelease identifier in the version value of version-policy.json ' +
                'for the specified version policy. ' +
                'This setting only works for lock-step version policy. ' +
                'This setting increases to new prerelease id when "--bump" is provided but only replaces the ' +
                'prerelease name when "--ensure-version-policy" is provided.'
        });
        this._ignoreGitHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-git-hooks',
            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`
        });
    }
    async runAsync() {
        await _logic_policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_4__.validatePolicyAsync(this.rushConfiguration, {
            bypassPolicyAllowed: true,
            bypassPolicy: this._bypassPolicy.value
        });
        const git = new _logic_Git__WEBPACK_IMPORTED_MODULE_5__.Git(this.rushConfiguration);
        const userEmail = git.getGitEmail();
        this._validateInput();
        const versionManagerModule = await __webpack_require__.e(/*! import() | VersionManager */ "VersionManager").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/VersionManager */ 570488));
        const versionManager = new versionManagerModule.VersionManager(this.rushConfiguration, userEmail, this.rushConfiguration.versionPolicyConfiguration);
        if (this._ensureVersionPolicy.value) {
            this._overwritePolicyVersionIfNeeded();
            const tempBranch = 'version/ensure-' + new Date().getTime();
            versionManager.ensure(this._versionPolicy.value, true, !!this._overrideVersion.value || !!this._prereleaseIdentifier.value);
            const updatedPackages = versionManager.updatedProjects;
            if (updatedPackages.size > 0) {
                // eslint-disable-next-line no-console
                console.log(`${updatedPackages.size} packages are getting updated.`);
                this._gitProcess(tempBranch, this._targetBranch.value);
            }
        }
        else if (this._bumpVersion.value) {
            const tempBranch = 'version/bump-' + new Date().getTime();
            await versionManager.bumpAsync(this._versionPolicy.value, this._overwriteBump.value ? _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Enum.getValueByKey(_api_VersionPolicy__WEBPACK_IMPORTED_MODULE_6__.BumpType, this._overwriteBump.value) : undefined, this._prereleaseIdentifier.value, true);
            this._gitProcess(tempBranch, this._targetBranch.value);
        }
    }
    _overwritePolicyVersionIfNeeded() {
        if (!this._overrideVersion.value && !this._prereleaseIdentifier.value) {
            // No need to overwrite policy version
            return;
        }
        if (this._overrideVersion.value && this._prereleaseIdentifier.value) {
            throw new Error(`The parameters "--override-version" and "--override-prerelease-id" cannot be used together.`);
        }
        if (this._versionPolicy.value) {
            const versionConfig = this.rushConfiguration.versionPolicyConfiguration;
            const policy = versionConfig.getVersionPolicy(this._versionPolicy.value);
            if (!policy || !policy.isLockstepped) {
                throw new Error(`The lockstep version policy "${policy.policyName}" is not found.`);
            }
            let newVersion = undefined;
            if (this._overrideVersion.value) {
                newVersion = this._overrideVersion.value;
            }
            else if (this._prereleaseIdentifier.value) {
                const newPolicyVersion = new semver__WEBPACK_IMPORTED_MODULE_0__.SemVer(policy.version);
                if (newPolicyVersion.prerelease.length) {
                    // Update 1.5.0-alpha.10 to 1.5.0-beta.10
                    // For example, if we are parsing "1.5.0-alpha.10" then the newPolicyVersion.prerelease array
                    // would contain [ "alpha", 10 ], so we would replace "alpha" with "beta"
                    newPolicyVersion.prerelease = [
                        this._prereleaseIdentifier.value,
                        ...newPolicyVersion.prerelease.slice(1)
                    ];
                }
                else {
                    // Update 1.5.0 to 1.5.0-beta
                    // Since there is no length, we can just set to a new array
                    newPolicyVersion.prerelease = [this._prereleaseIdentifier.value];
                }
                newVersion = newPolicyVersion.format();
            }
            if (newVersion) {
                versionConfig.update(this._versionPolicy.value, newVersion, true);
            }
        }
        else {
            throw new Error('Missing --version-policy parameter to specify which version policy should be overwritten.');
        }
    }
    _validateInput() {
        if (this._bumpVersion.value && this._ensureVersionPolicy.value) {
            throw new Error('Please choose --bump or --ensure-version-policy but not together.');
        }
        if (this._overwriteBump.value && !_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Enum.tryGetValueByKey(_api_VersionPolicy__WEBPACK_IMPORTED_MODULE_6__.BumpType, this._overwriteBump.value)) {
            throw new Error('The value of override-bump is not valid.  ' +
                'Valid values include prerelease, patch, minor, and major');
        }
    }
    _validateResult() {
        // Load the config from file to avoid using inconsistent in-memory data.
        const rushConfig = _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_7__.RushConfiguration.loadFromConfigurationFile(this.rushConfiguration.rushJsonFile);
        // Respect the `ensureConsistentVersions` field in rush.json
        if (!rushConfig.ensureConsistentVersions) {
            return;
        }
        const mismatchFinder = _logic_versionMismatch_VersionMismatchFinder__WEBPACK_IMPORTED_MODULE_8__.VersionMismatchFinder.getMismatches(rushConfig);
        if (mismatchFinder.numberOfMismatches) {
            throw new Error('Unable to finish version bump because inconsistencies were encountered. ' +
                'Run "rush check" to find more details.');
        }
    }
    _gitProcess(tempBranch, targetBranch) {
        // Validate the result before commit.
        this._validateResult();
        const git = new _logic_Git__WEBPACK_IMPORTED_MODULE_5__.Git(this.rushConfiguration);
        const publishGit = new _logic_PublishGit__WEBPACK_IMPORTED_MODULE_9__.PublishGit(git, targetBranch);
        // Make changes in temp branch.
        publishGit.checkout(tempBranch, true);
        const uncommittedChanges = git.getUncommittedChanges();
        // Stage, commit, and push the changes to remote temp branch.
        // Need to commit the change log updates in its own commit
        const changeLogUpdated = uncommittedChanges.some((changePath) => {
            return changePath.indexOf('CHANGELOG.json') > 0;
        });
        if (changeLogUpdated) {
            publishGit.addChanges('.', this.rushConfiguration.changesFolder);
            publishGit.addChanges(':/**/CHANGELOG.json');
            publishGit.addChanges(':/**/CHANGELOG.md');
            publishGit.commit(this.rushConfiguration.gitChangeLogUpdateCommitMessage || DEFAULT_CHANGELOG_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
        }
        // Commit the package.json and change files updates.
        const packageJsonUpdated = uncommittedChanges.some((changePath) => {
            return changePath.indexOf(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileConstants.PackageJson) > 0;
        });
        if (packageJsonUpdated) {
            publishGit.addChanges(this.rushConfiguration.versionPolicyConfigurationFilePath);
            publishGit.addChanges(':/**/package.json');
            publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
        }
        if (changeLogUpdated || packageJsonUpdated) {
            publishGit.push(tempBranch, !this._ignoreGitHooksParameter.value);
            // Now merge to target branch.
            publishGit.fetch();
            publishGit.checkout(targetBranch);
            publishGit.pull(!this._ignoreGitHooksParameter.value);
            publishGit.merge(tempBranch, !this._ignoreGitHooksParameter.value);
            publishGit.push(targetBranch, !this._ignoreGitHooksParameter.value);
            publishGit.deleteBranch(tempBranch, true, !this._ignoreGitHooksParameter.value);
        }
        else {
            // skip commits
            publishGit.fetch();
            publishGit.checkout(targetBranch);
            publishGit.deleteBranch(tempBranch, false, !this._ignoreGitHooksParameter.value);
        }
    }
}
//# sourceMappingURL=VersionAction.js.map

/***/ }),

/***/ 798601:
/*!****************************************************!*\
  !*** ./lib-esnext/cli/parsing/ParseParallelism.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseParallelism": () => (/* binding */ parseParallelism)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Parses a command line specification for desired parallelism.
 * Factored out to enable unit tests
 */
function parseParallelism(rawParallelism, numberOfCores = os__WEBPACK_IMPORTED_MODULE_0__.cpus().length) {
    if (rawParallelism) {
        if (rawParallelism === 'max') {
            return numberOfCores;
        }
        else {
            const parallelismAsNumber = Number(rawParallelism);
            if (typeof rawParallelism === 'string' && rawParallelism.trim().endsWith('%')) {
                const parsedPercentage = Number(rawParallelism.trim().replace(/\%$/, ''));
                if (parsedPercentage <= 0 || parsedPercentage > 100) {
                    throw new Error(`Invalid percentage value of '${rawParallelism}', value cannot be less than '0%' or more than '100%'`);
                }
                const workers = Math.floor((parsedPercentage / 100) * numberOfCores);
                return Math.max(workers, 1);
            }
            else if (!isNaN(parallelismAsNumber)) {
                return Math.max(parallelismAsNumber, 1);
            }
            else {
                throw new Error(`Invalid parallelism value of '${rawParallelism}', expected a number, a percentage, or 'max'`);
            }
        }
    }
    else {
        // If an explicit parallelism number wasn't provided, then choose a sensible
        // default.
        if (os__WEBPACK_IMPORTED_MODULE_0__.platform() === 'win32') {
            // On desktop Windows, some people have complained that their system becomes
            // sluggish if Rush is using all the CPU cores.  Leave one thread for
            // other operations. For CI environments, you can use the "max" argument to use all available cores.
            return Math.max(numberOfCores - 1, 1);
        }
        else {
            // Unix-like operating systems have more balanced scheduling, so default
            // to the number of CPU cores
            return numberOfCores;
        }
    }
}
//# sourceMappingURL=ParseParallelism.js.map

/***/ }),

/***/ 40787:
/*!*********************************************************!*\
  !*** ./lib-esnext/cli/parsing/SelectionParameterSet.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionParameterSet": () => (/* binding */ SelectionParameterSet)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logic_Selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/Selection */ 138705);
/* harmony import */ var _logic_selectors_GitChangedProjectSelectorParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logic/selectors/GitChangedProjectSelectorParser */ 920415);
/* harmony import */ var _logic_selectors_NamedProjectSelectorParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/selectors/NamedProjectSelectorParser */ 92382);
/* harmony import */ var _logic_selectors_TagProjectSelectorParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/selectors/TagProjectSelectorParser */ 858595);
/* harmony import */ var _logic_selectors_VersionPolicyProjectSelectorParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/selectors/VersionPolicyProjectSelectorParser */ 71589);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






/**
 * This class is provides the set of command line parameters used to select projects
 * based on dependencies.
 *
 * It is a separate component such that unrelated actions can share the same parameters.
 */
class SelectionParameterSet {
    constructor(rushConfiguration, action, gitOptions) {
        this._rushConfiguration = rushConfiguration;
        const selectorParsers = new Map();
        const nameSelectorParser = new _logic_selectors_NamedProjectSelectorParser__WEBPACK_IMPORTED_MODULE_1__.NamedProjectSelectorParser(rushConfiguration);
        selectorParsers.set('name', nameSelectorParser);
        selectorParsers.set('git', new _logic_selectors_GitChangedProjectSelectorParser__WEBPACK_IMPORTED_MODULE_2__.GitChangedProjectSelectorParser(rushConfiguration, gitOptions));
        selectorParsers.set('tag', new _logic_selectors_TagProjectSelectorParser__WEBPACK_IMPORTED_MODULE_3__.TagProjectSelectorParser(rushConfiguration));
        selectorParsers.set('version-policy', new _logic_selectors_VersionPolicyProjectSelectorParser__WEBPACK_IMPORTED_MODULE_4__.VersionPolicyProjectSelectorParser(rushConfiguration));
        this._selectorParserByScope = selectorParsers;
        const getSpecifierCompletions = async () => {
            const completions = ['.'];
            for (const [prefix, selector] of selectorParsers) {
                for (const completion of selector.getCompletions()) {
                    completions.push(`${prefix}:${completion}`);
                }
            }
            // Include completions from the name parser without a scope
            for (const completion of nameSelectorParser.getCompletions()) {
                completions.push(completion);
            }
            return completions;
        };
        this._toProject = action.defineStringListParameter({
            parameterLongName: '--to',
            parameterShortName: '-t',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to" parameter expands this selection to include PROJECT and all its dependencies.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._toExceptProject = action.defineStringListParameter({
            parameterLongName: '--to-except',
            parameterShortName: '-T',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to-except" parameter expands this selection to include all dependencies of PROJECT,' +
                ' but not PROJECT itself.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._fromProject = action.defineStringListParameter({
            parameterLongName: '--from',
            parameterShortName: '-f',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--from" parameter expands this selection to include PROJECT and all projects that depend on it,' +
                ' plus all dependencies of this set.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._onlyProject = action.defineStringListParameter({
            parameterLongName: '--only',
            parameterShortName: '-o',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--only" parameter expands this selection to include PROJECT; its dependencies are not added.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._impactedByProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by',
            parameterShortName: '-i',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by" parameter expands this selection to include PROJECT and any projects that' +
                ' depend on PROJECT (and thus might be broken by changes to PROJECT).' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._impactedByExceptProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by-except',
            parameterShortName: '-I',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by-except" parameter works the same as "--impacted-by" except that PROJECT itself' +
                ' is not added to the selection.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._toVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--to-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--to-version-policy" parameter is equivalent to specifying "--to" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
        this._fromVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--from-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--from-version-policy" parameter is equivalent to specifying "--from" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
    }
    /**
     * Computes the set of selected projects based on all parameter values.
     *
     * If no parameters are specified, returns all projects in the Rush config file.
     */
    async getSelectedProjectsAsync(terminal) {
        // Hack out the old version-policy parameters
        for (const value of this._fromVersionPolicy.values) {
            this._fromProject.values.push(`version-policy:${value}`);
        }
        for (const value of this._toVersionPolicy.values) {
            this._toProject.values.push(`version-policy:${value}`);
        }
        const selectors = [
            this._onlyProject,
            this._fromProject,
            this._toProject,
            this._toExceptProject,
            this._impactedByProject,
            this._impactedByExceptProject
        ];
        // Check if any of the selection parameters have a value specified on the command line
        const isSelectionSpecified = selectors.some((param) => param.values.length > 0);
        // If no selection parameters are specified, return everything
        if (!isSelectionSpecified) {
            return new Set(this._rushConfiguration.projects);
        }
        const [
        // Include exactly these projects (--only)
        onlyProjects, 
        // Include all projects that depend on these projects, and all dependencies thereof
        fromProjects, 
        // --to
        toRaw, 
        // --to-except
        toExceptProjects, 
        // --impacted-by
        impactedByProjects, 
        // --impacted-by-except
        impactedByExceptProjects] = await Promise.all(selectors.map((param) => {
            return this._evaluateProjectParameterAsync(param, terminal);
        }));
        const selection = _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.union(
        // Safe command line options
        _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.expandAllDependencies(_logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.union(toRaw, _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.directDependenciesOf(toExceptProjects), 
        // --from / --from-version-policy
        _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.expandAllConsumers(fromProjects))), 
        // Unsafe command line option: --only
        onlyProjects, 
        // Unsafe command line options: --impacted-by, --impacted-by-except
        _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.expandAllConsumers(_logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.union(impactedByProjects, _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.directConsumersOf(impactedByExceptProjects))));
        return selection;
    }
    /**
     * Represents the selection as `--filter` parameters to pnpm.
     *
     * @remarks
     * This is a separate from the selection to allow the filters to be represented more concisely.
     *
     * @see https://pnpm.js.org/en/filtering
     */
    async getPnpmFilterArgumentsAsync(terminal) {
        const args = [];
        // Include exactly these projects (--only)
        for (const project of await this._evaluateProjectParameterAsync(this._onlyProject, terminal)) {
            args.push('--filter', project.packageName);
        }
        // Include all projects that depend on these projects, and all dependencies thereof
        const fromProjects = _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.union(
        // --from
        await this._evaluateProjectParameterAsync(this._fromProject, terminal));
        // All specified projects and all projects that they depend on
        for (const project of _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.union(
        // --to
        await this._evaluateProjectParameterAsync(this._toProject, terminal), 
        // --from / --from-version-policy
        _logic_Selection__WEBPACK_IMPORTED_MODULE_5__.Selection.expandAllConsumers(fromProjects))) {
            args.push('--filter', `${project.packageName}...`);
        }
        // --to-except
        // All projects that the project directly or indirectly declares as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._toExceptProject, terminal)) {
            args.push('--filter', `${project.packageName}^...`);
        }
        // --impacted-by
        // The project and all projects directly or indirectly declare it as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._impactedByProject, terminal)) {
            args.push('--filter', `...${project.packageName}`);
        }
        // --impacted-by-except
        // All projects that directly or indirectly declare the specified project as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._impactedByExceptProject, terminal)) {
            args.push('--filter', `...^${project.packageName}`);
        }
        return args;
    }
    /**
     * Usage telemetry for selection parameters. Only saved locally, and if requested in the config.
     */
    getTelemetry() {
        return {
            command_from: `${this._fromProject.values.length > 0}`,
            command_impactedBy: `${this._impactedByProject.values.length > 0}`,
            command_impactedByExcept: `${this._impactedByExceptProject.values.length > 0}`,
            command_only: `${this._onlyProject.values.length > 0}`,
            command_to: `${this._toProject.values.length > 0}`,
            command_toExcept: `${this._toExceptProject.values.length > 0}`,
            command_fromVersionPolicy: `${this._fromVersionPolicy.values.length > 0}`,
            command_toVersionPolicy: `${this._toVersionPolicy.values.length > 0}`
        };
    }
    /**
     * Computes the referents of parameters that accept a project identifier.
     * Handles '.', unscoped names, and scoped names.
     */
    async _evaluateProjectParameterAsync(listParameter, terminal) {
        const parameterName = listParameter.longName;
        const selection = new Set();
        for (const rawSelector of listParameter.values) {
            // Handle the special case of "current project" without a scope
            if (rawSelector === '.') {
                const packageJsonLookup = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageJsonLookup.instance;
                const packageJson = packageJsonLookup.tryLoadPackageJsonFor(process.cwd());
                if (packageJson) {
                    const project = this._rushConfiguration.getProjectByName(packageJson.name);
                    if (project) {
                        selection.add(project);
                    }
                    else {
                        terminal.writeErrorLine('Rush is not currently running in a project directory specified in rush.json. ' +
                            `The "." value for the ${parameterName} parameter is not allowed.`);
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
                    }
                }
                else {
                    terminal.writeErrorLine('Rush is not currently running in a project directory. ' +
                        `The "." value for the ${parameterName} parameter is not allowed.`);
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
                }
                continue;
            }
            const scopeIndex = rawSelector.indexOf(':');
            const scope = scopeIndex < 0 ? 'name' : rawSelector.slice(0, scopeIndex);
            const unscopedSelector = scopeIndex < 0 ? rawSelector : rawSelector.slice(scopeIndex + 1);
            const handler = this._selectorParserByScope.get(scope);
            if (!handler) {
                terminal.writeErrorLine(`Unsupported selector prefix "${scope}" passed to "${parameterName}": "${rawSelector}".` +
                    ` Supported prefixes: ${Array.from(this._selectorParserByScope.keys(), (selectorParserScope) => `"${selectorParserScope}:"`).join(', ')}`);
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
            }
            for (const project of await handler.evaluateSelectorAsync({
                unscopedSelector,
                terminal,
                parameterName
            })) {
                selection.add(project);
            }
        }
        return selection;
    }
}
//# sourceMappingURL=SelectionParameterSet.js.map

/***/ }),

/***/ 994567:
/*!**********************************************************!*\
  !*** ./lib-esnext/cli/scriptActions/BaseScriptAction.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseScriptAction": () => (/* binding */ BaseScriptAction)
/* harmony export */ });
/* harmony import */ var _actions_BaseRushAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/BaseRushAction */ 164546);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Base class for command-line actions that are implemented using user-defined scripts.
 *
 * @remarks
 * Compared to the normal built-in actions, these actions are special because (1) they
 * can be discovered dynamically via common/config/command-line.json, and (2)
 * user-defined command-line parameters can be passed through to the script.
 *
 * The two subclasses are BulkScriptAction and GlobalScriptAction.
 */
class BaseScriptAction extends _actions_BaseRushAction__WEBPACK_IMPORTED_MODULE_0__.BaseRushAction {
    constructor(options) {
        super(options);
        this.customParameters = new Map();
        this.commandLineConfiguration = options.commandLineConfiguration;
        this.command = options.command;
    }
    defineScriptParameters() {
        if (!this.commandLineConfiguration) {
            return;
        }
        // Find any parameters that are associated with this command
        for (const parameter of this.command.associatedParameters) {
            let tsCommandLineParameter;
            switch (parameter.parameterKind) {
                case 'flag':
                    tsCommandLineParameter = this.defineFlagParameter({
                        parameterShortName: parameter.shortName,
                        parameterLongName: parameter.longName,
                        description: parameter.description,
                        required: parameter.required
                    });
                    break;
                case 'choice':
                    tsCommandLineParameter = this.defineChoiceParameter({
                        parameterShortName: parameter.shortName,
                        parameterLongName: parameter.longName,
                        description: parameter.description,
                        required: parameter.required,
                        alternatives: parameter.alternatives.map((x) => x.name),
                        defaultValue: parameter.defaultValue
                    });
                    break;
                case 'string':
                    tsCommandLineParameter = this.defineStringParameter({
                        parameterLongName: parameter.longName,
                        parameterShortName: parameter.shortName,
                        description: parameter.description,
                        required: parameter.required,
                        argumentName: parameter.argumentName
                    });
                    break;
                case 'integer':
                    tsCommandLineParameter = this.defineIntegerParameter({
                        parameterLongName: parameter.longName,
                        parameterShortName: parameter.shortName,
                        description: parameter.description,
                        required: parameter.required,
                        argumentName: parameter.argumentName
                    });
                    break;
                case 'stringList':
                    tsCommandLineParameter = this.defineStringListParameter({
                        parameterLongName: parameter.longName,
                        parameterShortName: parameter.shortName,
                        description: parameter.description,
                        required: parameter.required,
                        argumentName: parameter.argumentName
                    });
                    break;
                case 'integerList':
                    tsCommandLineParameter = this.defineIntegerListParameter({
                        parameterLongName: parameter.longName,
                        parameterShortName: parameter.shortName,
                        description: parameter.description,
                        required: parameter.required,
                        argumentName: parameter.argumentName
                    });
                    break;
                case 'choiceList':
                    tsCommandLineParameter = this.defineChoiceListParameter({
                        parameterShortName: parameter.shortName,
                        parameterLongName: parameter.longName,
                        description: parameter.description,
                        required: parameter.required,
                        alternatives: parameter.alternatives.map((x) => x.name)
                    });
                    break;
                default:
                    throw new Error(`${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" using an unsupported parameter kind "${parameter.parameterKind}"`);
            }
            this.customParameters.set(parameter, tsCommandLineParameter);
        }
    }
}
//# sourceMappingURL=BaseScriptAction.js.map

/***/ }),

/***/ 415578:
/*!************************************************************!*\
  !*** ./lib-esnext/cli/scriptActions/GlobalScriptAction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GlobalScriptAction": () => (/* binding */ GlobalScriptAction)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _BaseScriptAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseScriptAction */ 994567);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/Autoinstaller */ 140603);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







/**
 * This class implements custom commands that are run once globally for the entire repo
 * (versus bulk commands, which run separately for each project).  The action executes
 * a user-defined script file.
 *
 * @remarks
 * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as bulk commands, because they essentially just
 * invoke scripts from package.json in the same way as a custom command.
 */
class GlobalScriptAction extends _BaseScriptAction__WEBPACK_IMPORTED_MODULE_3__.BaseScriptAction {
    constructor(options) {
        super(options);
        this._shellCommand = options.shellCommand;
        this._autoinstallerName = options.autoinstallerName || '';
        if (this._autoinstallerName) {
            _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_4__.Autoinstaller.validateName(this._autoinstallerName);
            // Example: .../common/autoinstallers/my-task
            this._autoinstallerFullPath = path__WEBPACK_IMPORTED_MODULE_0__.join(this.rushConfiguration.commonAutoinstallersFolder, this._autoinstallerName);
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(this._autoinstallerFullPath)) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting` +
                    ' but the path does not exist: ' +
                    this._autoinstallerFullPath);
            }
            // Example: .../common/autoinstallers/my-task/package.json
            const packageJsonPath = path__WEBPACK_IMPORTED_MODULE_0__.join(this._autoinstallerFullPath, 'package.json');
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(packageJsonPath)) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting` +
                    ` whose package.json file was not found: ` +
                    packageJsonPath);
            }
            const packageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.load(packageJsonPath);
            if (packageJson.name !== this._autoinstallerName) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting,` +
                    ` but the package.json file's "name" field is not "${this._autoinstallerName}": ` +
                    packageJsonPath);
            }
        }
        else {
            this._autoinstallerFullPath = '';
        }
        this.defineScriptParameters();
    }
    async _prepareAutoinstallerName() {
        const autoInstaller = new _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_4__.Autoinstaller({
            autoinstallerName: this._autoinstallerName,
            rushConfiguration: this.rushConfiguration,
            rushGlobalFolder: this.rushGlobalFolder
        });
        await autoInstaller.prepareAsync();
    }
    async runAsync() {
        var _a, _b;
        const { hooks: sessionHooks } = this.rushSession;
        if (sessionHooks.runAnyGlobalCustomCommand.isUsed()) {
            // Avoid the cost of compiling the hook if it wasn't tapped.
            await sessionHooks.runAnyGlobalCustomCommand.promise(this);
        }
        const hookForAction = sessionHooks.runGlobalCustomCommand.get(this.actionName);
        if (hookForAction) {
            // Run the more specific hook for a command with this name after the general hook
            await hookForAction.promise(this);
        }
        const additionalPathFolders = ((_a = this.commandLineConfiguration) === null || _a === void 0 ? void 0 : _a.additionalPathFolders.slice()) || [];
        if (this._autoinstallerName) {
            await this._prepareAutoinstallerName();
            const autoinstallerNameBinPath = path__WEBPACK_IMPORTED_MODULE_0__.join(this._autoinstallerFullPath, 'node_modules', '.bin');
            additionalPathFolders.push(autoinstallerNameBinPath);
        }
        // Collect all custom parameter values
        const customParameterValues = [];
        for (const tsCommandLineParameter of this.customParameters.values()) {
            tsCommandLineParameter.appendToArgList(customParameterValues);
        }
        for (let i = 0; i < customParameterValues.length; i++) {
            let customParameterValue = customParameterValues[i];
            customParameterValue = customParameterValue.replace(/"/g, '\\"');
            if (customParameterValue.indexOf(' ') >= 0) {
                customParameterValue = `"${customParameterValue}"`;
            }
            customParameterValues[i] = customParameterValue;
        }
        let shellCommand = this._shellCommand;
        if (customParameterValues.length > 0) {
            shellCommand += ' ' + customParameterValues.join(' ');
        }
        const shellCommandTokenContext = (_b = this.commandLineConfiguration) === null || _b === void 0 ? void 0 : _b.shellCommandTokenContext;
        if (shellCommandTokenContext) {
            shellCommand = this._expandShellCommandWithTokens(shellCommand, shellCommandTokenContext);
        }
        this._rejectAnyTokensInShellCommand(shellCommand, shellCommandTokenContext);
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__.Stopwatch.start();
        const exitCode = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__.Utilities.executeLifecycleCommand(shellCommand, {
            rushConfiguration: this.rushConfiguration,
            workingDirectory: this.rushConfiguration.rushJsonFolder,
            initCwd: this.rushConfiguration.commonTempFolder,
            handleOutput: false,
            environmentPathOptions: {
                includeRepoBin: true,
                additionalPathFolders: additionalPathFolders
            }
        });
        process.exitCode = exitCode;
        stopwatch.stop();
        if (this.parser.telemetry) {
            this.parser.telemetry.log({
                name: this.actionName,
                durationInSeconds: stopwatch.duration,
                result: exitCode > 0 ? 'Failed' : 'Succeeded',
                extraData: {
                    customParameterValue: customParameterValues.join(' ')
                }
            });
            this.parser.flushTelemetry();
        }
        if (exitCode > 0) {
            // eslint-disable-next-line no-console
            console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_1___default().red(`The script failed with exit code ${exitCode}`));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
        }
    }
    _expandShellCommandWithTokens(shellCommand, tokenContext) {
        let expandedShellCommand = shellCommand;
        for (const [token, tokenReplacement] of Object.entries(tokenContext)) {
            expandedShellCommand = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Text.replaceAll(expandedShellCommand, `<${token}>`, tokenReplacement);
        }
        return expandedShellCommand;
    }
    _rejectAnyTokensInShellCommand(shellCommand, tokenContext) {
        if (shellCommand.indexOf('<') < 0 && shellCommand.indexOf('>') < 0) {
            return;
        }
        const tokenRegExp = /(\<[^<]*?\>)/;
        const match = tokenRegExp.exec(shellCommand);
        if (match) {
            throw new Error(`The "shellCommand" value contains an unrecognized token "${match[1]}".${tokenContext ? ` Available tokens are ${Object.keys(tokenContext).join(', ')}.` : ''}`);
        }
        throw new Error(`The "shellCommand" value contains extra token characters ("<" or ">"): ${shellCommand}`);
    }
}
//# sourceMappingURL=GlobalScriptAction.js.map

/***/ }),

/***/ 62165:
/*!************************************************************!*\
  !*** ./lib-esnext/cli/scriptActions/PhasedScriptAction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhasedScriptAction": () => (/* binding */ PhasedScriptAction)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _pluginFramework_PhasedCommandHooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../pluginFramework/PhasedCommandHooks */ 580814);
/* harmony import */ var _logic_SetupChecks__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../logic/SetupChecks */ 60296);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _BaseScriptAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseScriptAction */ 994567);
/* harmony import */ var _logic_operations_OperationExecutionManager__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../logic/operations/OperationExecutionManager */ 576472);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
/* harmony import */ var _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../api/BuildCacheConfiguration */ 541976);
/* harmony import */ var _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../parsing/SelectionParameterSet */ 40787);
/* harmony import */ var _logic_operations_PhasedOperationPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logic/operations/PhasedOperationPlugin */ 797379);
/* harmony import */ var _logic_operations_ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logic/operations/ShellOperationRunnerPlugin */ 658087);
/* harmony import */ var _api_EventHooks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../api/EventHooks */ 519005);
/* harmony import */ var _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../logic/ProjectChangeAnalyzer */ 311605);
/* harmony import */ var _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../logic/operations/OperationStatus */ 476597);
/* harmony import */ var _logic_operations_OperationResultSummarizerPlugin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../logic/operations/OperationResultSummarizerPlugin */ 195183);
/* harmony import */ var _parsing_ParseParallelism__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../parsing/ParseParallelism */ 798601);
/* harmony import */ var _api_CobuildConfiguration__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../api/CobuildConfiguration */ 13111);
/* harmony import */ var _logic_operations_CacheableOperationPlugin__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../logic/operations/CacheableOperationPlugin */ 223875);
/* harmony import */ var _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../api/RushProjectConfiguration */ 514639);
/* harmony import */ var _logic_operations_LegacySkipPlugin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../logic/operations/LegacySkipPlugin */ 74151);
/* harmony import */ var _logic_operations_ValidateOperationsPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logic/operations/ValidateOperationsPlugin */ 524699);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
























/**
 * This class implements phased commands which are run individually for each project in the repo,
 * possibly in parallel, and which may define multiple phases.
 *
 * @remarks
 * Phased commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as phased commands with a single phase that invokes the npm
 * "build" script for each project.
 */
class PhasedScriptAction extends _BaseScriptAction__WEBPACK_IMPORTED_MODULE_2__.BaseScriptAction {
    constructor(options) {
        var _a;
        super(options);
        this._enableParallelism = options.enableParallelism;
        this._isIncrementalBuildAllowed = options.incremental;
        this._disableBuildCache = options.disableBuildCache;
        this._originalPhases = options.originalPhases;
        this._initialPhases = options.initialPhases;
        this._watchPhases = options.watchPhases;
        this._watchDebounceMs = (_a = options.watchDebounceMs) !== null && _a !== void 0 ? _a : _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.defaultWatchDebounceMs;
        this._alwaysWatch = options.alwaysWatch;
        this._alwaysInstall = options.alwaysInstall;
        this._runsBeforeInstall = false;
        this._knownPhases = options.phases;
        this.hooks = new _pluginFramework_PhasedCommandHooks__WEBPACK_IMPORTED_MODULE_4__.PhasedCommandHooks();
        const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(this.rushSession.terminalProvider);
        this._terminal = terminal;
        // Generates the default operation graph
        new _logic_operations_PhasedOperationPlugin__WEBPACK_IMPORTED_MODULE_5__.PhasedOperationPlugin().apply(this.hooks);
        // Applies the Shell Operation Runner to selected operations
        new _logic_operations_ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_6__.ShellOperationRunnerPlugin().apply(this.hooks);
        new _logic_operations_ValidateOperationsPlugin__WEBPACK_IMPORTED_MODULE_7__.ValidateOperationsPlugin(terminal).apply(this.hooks);
        if (this._enableParallelism) {
            this._parallelismParameter = this.defineStringParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                argumentName: 'COUNT',
                environmentVariable: _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_8__.EnvironmentVariableNames.RUSH_PARALLELISM,
                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +
                    ' The COUNT should be a positive integer, a percentage value (eg. "50%%") or the word "max"' +
                    ' to specify a count that is equal to the number of CPU cores. If this parameter is omitted,' +
                    ' then the default value depends on the operating system and number of CPU cores.'
            });
            this._timelineParameter = this.defineFlagParameter({
                parameterLongName: '--timeline',
                description: 'After the build is complete, print additional statistics and CPU usage information,' +
                    ' including an ASCII chart of the start and stop times for each operation.'
            });
        }
        this._selectionParameters = new _parsing_SelectionParameterSet__WEBPACK_IMPORTED_MODULE_9__.SelectionParameterSet(this.rushConfiguration, this, {
            // Include lockfile processing since this expands the selection, and we need to select
            // at least the same projects selected with the same query to "rush build"
            includeExternalDependencies: true,
            // Enable filtering to reduce evaluation cost
            enableFiltering: true
        });
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        if (this._isIncrementalBuildAllowed) {
            this._changedProjectsOnly = this.defineFlagParameter({
                parameterLongName: '--changed-projects-only',
                parameterShortName: '-c',
                description: 'Normally the incremental build logic will rebuild changed projects as well as' +
                    ' any projects that directly or indirectly depend on a changed project. Specify "--changed-projects-only"' +
                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +
                    ' Note that this parameter is "unsafe"; it is up to the developer to ensure that the ignored projects' +
                    ' are okay to ignore.'
            });
        }
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        if (this._watchPhases.size > 0 && !this._alwaysWatch) {
            // Only define the parameter if it has an effect.
            this._watchParameter = this.defineFlagParameter({
                parameterLongName: '--watch',
                description: `Starts a file watcher after initial execution finishes. Will run the following phases on affected projects: ${Array.from(this._watchPhases, (phase) => phase.name).join(', ')}`
            });
        }
        // If `this._alwaysInstall === undefined`, Rush does not define the parameter
        // but a repository may still define a custom parameter with the same name.
        if (this._alwaysInstall === false) {
            this._installParameter = this.defineFlagParameter({
                parameterLongName: '--install',
                description: 'Normally a phased command expects "rush install" to have been manually run first. If this flag is specified, ' +
                    'Rush will automatically perform an install before processing the current command.'
            });
        }
        this.defineScriptParameters();
        for (const [{ associatedPhases }, tsCommandLineParameter] of this.customParameters) {
            if (associatedPhases) {
                for (const phaseName of associatedPhases) {
                    const phase = this._knownPhases.get(phaseName);
                    if (!phase) {
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Could not find a phase matching ${phaseName}.`);
                    }
                    phase.associatedParameters.add(tsCommandLineParameter);
                }
            }
        }
    }
    async runAsync() {
        var _a, _b, _c, _d;
        if (this._alwaysInstall || ((_a = this._installParameter) === null || _a === void 0 ? void 0 : _a.value)) {
            const { doBasicInstallAsync } = await Promise.all(/*! import() | doBasicInstallAsync */[__webpack_require__.e("InstallManagerFactory"), __webpack_require__.e("doBasicInstallAsync")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/installManager/doBasicInstallAsync */ 16504));
            await doBasicInstallAsync({
                terminal: this._terminal,
                rushConfiguration: this.rushConfiguration,
                rushGlobalFolder: this.rushGlobalFolder,
                isDebug: this.parser.isDebug
            });
        }
        if (!this._runsBeforeInstall) {
            // TODO: Replace with last-install.flag when "rush link" and "rush unlink" are removed
            const lastLinkFlag = _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_10__.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration);
            if (!lastLinkFlag.isValid()) {
                const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
                if (useWorkspaces) {
                    throw new Error('Link flag invalid.\nDid you run "rush install" or "rush update"?');
                }
                else {
                    throw new Error('Link flag invalid.\nDid you run "rush link"?');
                }
            }
        }
        this._doBeforeTask();
        // if this is parallelizable, then use the value from the flag (undefined or a number),
        // if parallelism is not enabled, then restrict to 1 core
        const parallelism = this._enableParallelism
            ? (0,_parsing_ParseParallelism__WEBPACK_IMPORTED_MODULE_11__.parseParallelism)((_b = this._parallelismParameter) === null || _b === void 0 ? void 0 : _b.value)
            : 1;
        const terminal = this._terminal;
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_12__.Stopwatch.start();
        const showTimeline = this._timelineParameter ? this._timelineParameter.value : false;
        if (showTimeline) {
            const { ConsoleTimelinePlugin } = await __webpack_require__.e(/*! import() | ConsoleTimelinePlugin */ "ConsoleTimelinePlugin").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/operations/ConsoleTimelinePlugin */ 598358));
            new ConsoleTimelinePlugin(terminal).apply(this.hooks);
        }
        // Enable the standard summary
        new _logic_operations_OperationResultSummarizerPlugin__WEBPACK_IMPORTED_MODULE_13__.OperationResultSummarizerPlugin(terminal).apply(this.hooks);
        const { hooks: sessionHooks } = this.rushSession;
        if (sessionHooks.runAnyPhasedCommand.isUsed()) {
            // Avoid the cost of compiling the hook if it wasn't tapped.
            await sessionHooks.runAnyPhasedCommand.promise(this);
        }
        const hookForAction = sessionHooks.runPhasedCommand.get(this.actionName);
        if (hookForAction) {
            // Run the more specific hook for a command with this name after the general hook
            await hookForAction.promise(this);
        }
        const isQuietMode = !this._verboseParameter.value;
        const changedProjectsOnly = !!((_c = this._changedProjectsOnly) === null || _c === void 0 ? void 0 : _c.value);
        let buildCacheConfiguration;
        let cobuildConfiguration;
        if (!this._disableBuildCache) {
            buildCacheConfiguration = await _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_14__.BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);
            cobuildConfiguration = await _api_CobuildConfiguration__WEBPACK_IMPORTED_MODULE_15__.CobuildConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);
            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.createLockProviderAsync(terminal));
        }
        try {
            const projectSelection = await this._selectionParameters.getSelectedProjectsAsync(terminal);
            if (!projectSelection.size) {
                terminal.writeLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`The command line selection parameters did not match any projects.`));
                return;
            }
            const isWatch = ((_d = this._watchParameter) === null || _d === void 0 ? void 0 : _d.value) || this._alwaysWatch;
            const customParametersByName = new Map();
            for (const [configParameter, parserParameter] of this.customParameters) {
                customParametersByName.set(configParameter.longName, parserParameter);
            }
            if (buildCacheConfiguration) {
                new _logic_operations_CacheableOperationPlugin__WEBPACK_IMPORTED_MODULE_16__.CacheableOperationPlugin({
                    allowWarningsInSuccessfulBuild: !!this.rushConfiguration.experimentsConfiguration.configuration
                        .buildCacheWithAllowWarningsInSuccessfulBuild,
                    buildCacheConfiguration,
                    cobuildConfiguration,
                    terminal
                }).apply(this.hooks);
            }
            else if (!this._disableBuildCache) {
                // Explicitly disabling the build cache also disables legacy skip detection.
                new _logic_operations_LegacySkipPlugin__WEBPACK_IMPORTED_MODULE_17__.LegacySkipPlugin({
                    terminal,
                    changedProjectsOnly,
                    isIncrementalBuildAllowed: this._isIncrementalBuildAllowed
                }).apply(this.hooks);
            }
            const projectConfigurations = this
                ._runsBeforeInstall
                ? new Map()
                : await _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_18__.RushProjectConfiguration.tryLoadForProjectsAsync(projectSelection, terminal);
            const projectChangeAnalyzer = new _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_19__.ProjectChangeAnalyzer(this.rushConfiguration);
            const initialCreateOperationsContext = {
                buildCacheConfiguration,
                cobuildConfiguration,
                customParameters: customParametersByName,
                isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,
                isInitial: true,
                isWatch,
                rushConfiguration: this.rushConfiguration,
                phaseOriginal: new Set(this._originalPhases),
                phaseSelection: new Set(this._initialPhases),
                projectChangeAnalyzer,
                projectSelection,
                projectConfigurations,
                projectsInUnknownState: projectSelection
            };
            const executionManagerOptions = {
                quietMode: isQuietMode,
                debugMode: this.parser.isDebug,
                parallelism,
                changedProjectsOnly,
                beforeExecuteOperation: async (record) => {
                    return await this.hooks.beforeExecuteOperation.promise(record);
                },
                afterExecuteOperation: async (record) => {
                    await this.hooks.afterExecuteOperation.promise(record);
                },
                beforeExecuteOperations: async (records) => {
                    await this.hooks.beforeExecuteOperations.promise(records, initialCreateOperationsContext);
                },
                onOperationStatusChanged: (record) => {
                    this.hooks.onOperationStatusChanged.call(record);
                }
            };
            const internalOptions = {
                initialCreateOperationsContext,
                executionManagerOptions,
                stopwatch,
                terminal
            };
            terminal.write('Analyzing repo state... ');
            const repoStateStopwatch = new _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_12__.Stopwatch();
            repoStateStopwatch.start();
            await projectChangeAnalyzer._ensureInitializedAsync(terminal);
            repoStateStopwatch.stop();
            terminal.writeLine(`DONE (${repoStateStopwatch.toString()})`);
            terminal.writeLine();
            await this._runInitialPhases(internalOptions);
            if (isWatch) {
                if (buildCacheConfiguration) {
                    // Cache writes are not supported during watch mode, only reads.
                    buildCacheConfiguration.cacheWriteEnabled = false;
                }
                await this._runWatchPhases(internalOptions);
            }
        }
        finally {
            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.destroyLockProviderAsync());
        }
    }
    async _runInitialPhases(options) {
        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;
        const operations = await this.hooks.createOperations.promise(new Set(), initialCreateOperationsContext);
        const initialOptions = {
            createOperationsContext: initialCreateOperationsContext,
            ignoreHooks: false,
            operations,
            stopwatch,
            executionManagerOptions,
            terminal
        };
        await this._executeOperations(initialOptions);
    }
    _registerWatchModeInterface(projectWatcher) {
        const toggleWatcherKey = 'w';
        const buildOnceKey = 'b';
        const terminal = this._terminal;
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', (key) => {
            switch (key) {
                case toggleWatcherKey:
                    if (projectWatcher.isPaused) {
                        terminal.writeLine(`Resuming project watcher...`);
                        projectWatcher.resume();
                    }
                    else {
                        terminal.writeLine(`Pausing project watcher...`);
                        projectWatcher.pause();
                    }
                    break;
                case buildOnceKey:
                    if (projectWatcher.isPaused) {
                        terminal.writeLine(`Building once...`);
                        projectWatcher.resume();
                        projectWatcher.pause();
                    }
                    break;
                case '\u0003':
                    process.kill(process.pid, 'SIGINT');
                    break;
            }
        });
    }
    /**
     * Runs the command in watch mode. Fundamentally is a simple loop:
     * 1) Wait for a change to one or more projects in the selection
     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects
     *    Uses the same algorithm as --impacted-by
     * 3) Goto (1)
     */
    async _runWatchPhases(options) {
        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;
        const phaseOriginal = new Set(this._watchPhases);
        const phaseSelection = new Set(this._watchPhases);
        const { projectChangeAnalyzer: initialState, projectSelection: projectsToWatch } = initialCreateOperationsContext;
        // Use async import so that we don't pay the cost for sync builds
        const { ProjectWatcher } = await __webpack_require__.e(/*! import() | ProjectWatcher */ "ProjectWatcher").then(__webpack_require__.bind(__webpack_require__, /*! ../../logic/ProjectWatcher */ 725223));
        const projectWatcher = new ProjectWatcher({
            debounceMs: this._watchDebounceMs,
            rushConfiguration: this.rushConfiguration,
            projectsToWatch,
            terminal,
            initialState
        });
        this._registerWatchModeInterface(projectWatcher);
        const onWaitingForChanges = () => {
            // Allow plugins to display their own messages when waiting for changes.
            this.hooks.waitingForChanges.call();
            // Report so that the developer can always see that it is in watch mode as the latest console line.
            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);
        };
        // Loop until Ctrl+C
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // On the initial invocation, this promise will return immediately with the full set of projects
            const { changedProjects, state } = await projectWatcher.waitForChange(onWaitingForChanges);
            if (stopwatch.state === _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_12__.StopwatchState.Stopped) {
                // Clear and reset the stopwatch so that we only report time from a single execution at a time
                stopwatch.reset();
                stopwatch.start();
            }
            terminal.writeLine(`Detected changes in ${changedProjects.size} project${changedProjects.size === 1 ? '' : 's'}:`);
            const names = [...changedProjects].map((x) => x.packageName).sort();
            for (const name of names) {
                terminal.writeLine(`    ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(name)}`);
            }
            // Account for consumer relationships
            const createOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { isInitial: false, projectChangeAnalyzer: state, projectsInUnknownState: changedProjects, phaseOriginal,
                phaseSelection });
            const operations = await this.hooks.createOperations.promise(new Set(), createOperationsContext);
            const executeOptions = {
                createOperationsContext,
                // For now, don't run pre-build or post-build in watch mode
                ignoreHooks: true,
                operations,
                stopwatch,
                executionManagerOptions: Object.assign(Object.assign({}, executionManagerOptions), { beforeExecuteOperations: async (records) => {
                        await this.hooks.beforeExecuteOperations.promise(records, createOperationsContext);
                    } }),
                terminal
            };
            try {
                // Delegate the the underlying command, for only the projects that need reprocessing
                await this._executeOperations(executeOptions);
            }
            catch (err) {
                // In watch mode, we want to rebuild even if the original build failed.
                if (!(err instanceof _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError)) {
                    throw err;
                }
            }
        }
    }
    /**
     * Runs a set of operations and reports the results.
     */
    async _executeOperations(options) {
        var _a;
        const { executionManagerOptions, ignoreHooks, operations, stopwatch, terminal } = options;
        const executionManager = new _logic_operations_OperationExecutionManager__WEBPACK_IMPORTED_MODULE_20__.OperationExecutionManager(operations, executionManagerOptions);
        const { isInitial, isWatch } = options.createOperationsContext;
        let success = false;
        let result;
        try {
            result = await executionManager.executeAsync();
            success = result.status === _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Success;
            await this.hooks.afterExecuteOperations.promise(result, options.createOperationsContext);
            stopwatch.stop();
            const message = `rush ${this.actionName} (${stopwatch.toString()})`;
            if (result.status === _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Success) {
                terminal.writeLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(message));
            }
            else {
                terminal.writeLine(message);
            }
        }
        catch (error) {
            success = false;
            stopwatch.stop();
            if (error instanceof _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError) {
                terminal.writeLine(`rush ${this.actionName} (${stopwatch.toString()})`);
            }
            else {
                if (error && error.message) {
                    if (this.parser.isDebug) {
                        terminal.writeErrorLine('Error: ' + error.stack);
                    }
                    else {
                        terminal.writeErrorLine('Error: ' + error.message);
                    }
                }
                terminal.writeErrorLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));
            }
        }
        if (!ignoreHooks) {
            this._doAfterTask();
        }
        if (this.parser.telemetry) {
            const operationResults = {};
            const extraData = Object.assign(Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap()), { isWatch,
                // Fields specific to the current operation set
                isInitial, countAll: 0, countSuccess: 0, countSuccessWithWarnings: 0, countFailure: 0, countBlocked: 0, countFromCache: 0, countSkipped: 0, countNoOp: 0 });
            if (result) {
                const nonSilentDependenciesByOperation = new Map();
                function getNonSilentDependencies(operation) {
                    let realDependencies = nonSilentDependenciesByOperation.get(operation);
                    if (!realDependencies) {
                        realDependencies = new Set();
                        nonSilentDependenciesByOperation.set(operation, realDependencies);
                        for (const dependency of operation.dependencies) {
                            if (dependency.runner.silent) {
                                for (const deepDependency of getNonSilentDependencies(dependency)) {
                                    realDependencies.add(deepDependency);
                                }
                            }
                            else {
                                realDependencies.add(dependency.name);
                            }
                        }
                    }
                    return realDependencies;
                }
                for (const [operation, operationResult] of result.operationResults) {
                    if ((_a = operation.runner) === null || _a === void 0 ? void 0 : _a.silent) {
                        // Architectural operation. Ignore.
                        continue;
                    }
                    const { startTime, endTime } = operationResult.stopwatch;
                    operationResults[operation.name] = {
                        startTimestampMs: startTime,
                        endTimestampMs: endTime,
                        nonCachedDurationMs: operationResult.nonCachedDurationMs,
                        result: operationResult.status,
                        dependencies: Array.from(getNonSilentDependencies(operation)).sort()
                    };
                    extraData.countAll++;
                    switch (operationResult.status) {
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Success:
                            extraData.countSuccess++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.SuccessWithWarning:
                            extraData.countSuccessWithWarnings++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Failure:
                            extraData.countFailure++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Blocked:
                            extraData.countBlocked++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.FromCache:
                            extraData.countFromCache++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.Skipped:
                            extraData.countSkipped++;
                            break;
                        case _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_21__.OperationStatus.NoOp:
                            extraData.countNoOp++;
                            break;
                        default:
                            // Do nothing.
                            break;
                    }
                }
            }
            const logEntry = {
                name: this.actionName,
                durationInSeconds: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData,
                operationResults
            };
            this.hooks.beforeLog.call(logEntry);
            this.parser.telemetry.log(logEntry);
            this.parser.flushTelemetry();
        }
        if (!success && !isWatch) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
    }
    _doBeforeTask() {
        if (this.actionName !== _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.buildCommandName &&
            this.actionName !== _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        _logic_SetupChecks__WEBPACK_IMPORTED_MODULE_22__.SetupChecks.validate(this.rushConfiguration);
        this.eventHooksManager.handle(_api_EventHooks__WEBPACK_IMPORTED_MODULE_23__.Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _doAfterTask() {
        if (this.actionName !== _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.buildCommandName &&
            this.actionName !== _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        this.eventHooksManager.handle(_api_EventHooks__WEBPACK_IMPORTED_MODULE_23__.Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
}
//# sourceMappingURL=PhasedScriptAction.js.map

/***/ }),

/***/ 905031:
/*!*****************************!*\
  !*** ./lib-esnext/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApprovedPackagesConfiguration": () => (/* reexport safe */ _api_ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_16__.ApprovedPackagesConfiguration),
/* harmony export */   "ApprovedPackagesItem": () => (/* reexport safe */ _api_ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_16__.ApprovedPackagesItem),
/* harmony export */   "ApprovedPackagesPolicy": () => (/* reexport safe */ _api_ApprovedPackagesPolicy__WEBPACK_IMPORTED_MODULE_0__.ApprovedPackagesPolicy),
/* harmony export */   "BuildCacheConfiguration": () => (/* reexport safe */ _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_6__.BuildCacheConfiguration),
/* harmony export */   "BumpType": () => (/* reexport safe */ _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__.BumpType),
/* harmony export */   "ChangeManager": () => (/* reexport safe */ _api_ChangeManager__WEBPACK_IMPORTED_MODULE_22__.ChangeManager),
/* harmony export */   "CobuildConfiguration": () => (/* reexport safe */ _api_CobuildConfiguration__WEBPACK_IMPORTED_MODULE_7__.CobuildConfiguration),
/* harmony export */   "CommonVersionsConfiguration": () => (/* reexport safe */ _api_CommonVersionsConfiguration__WEBPACK_IMPORTED_MODULE_17__.CommonVersionsConfiguration),
/* harmony export */   "CredentialCache": () => (/* reexport safe */ _logic_CredentialCache__WEBPACK_IMPORTED_MODULE_36__.CredentialCache),
/* harmony export */   "CustomTipId": () => (/* reexport safe */ _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_29__.CustomTipId),
/* harmony export */   "CustomTipSeverity": () => (/* reexport safe */ _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_29__.CustomTipSeverity),
/* harmony export */   "CustomTipType": () => (/* reexport safe */ _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_29__.CustomTipType),
/* harmony export */   "CustomTipsConfiguration": () => (/* reexport safe */ _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_29__.CustomTipsConfiguration),
/* harmony export */   "DependencyType": () => (/* reexport safe */ _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_18__.DependencyType),
/* harmony export */   "EnvironmentConfiguration": () => (/* reexport safe */ _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_9__.EnvironmentConfiguration),
/* harmony export */   "EnvironmentVariableNames": () => (/* reexport safe */ _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_9__.EnvironmentVariableNames),
/* harmony export */   "Event": () => (/* reexport safe */ _api_EventHooks__WEBPACK_IMPORTED_MODULE_21__.Event),
/* harmony export */   "EventHooks": () => (/* reexport safe */ _api_EventHooks__WEBPACK_IMPORTED_MODULE_21__.EventHooks),
/* harmony export */   "ExperimentsConfiguration": () => (/* reexport safe */ _api_ExperimentsConfiguration__WEBPACK_IMPORTED_MODULE_28__.ExperimentsConfiguration),
/* harmony export */   "FileSystemBuildCacheProvider": () => (/* reexport safe */ _logic_buildCache_FileSystemBuildCacheProvider__WEBPACK_IMPORTED_MODULE_8__.FileSystemBuildCacheProvider),
/* harmony export */   "IndividualVersionPolicy": () => (/* reexport safe */ _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__.IndividualVersionPolicy),
/* harmony export */   "LockStepVersionPolicy": () => (/* reexport safe */ _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__.LockStepVersionPolicy),
/* harmony export */   "LookupByPath": () => (/* reexport safe */ _logic_LookupByPath__WEBPACK_IMPORTED_MODULE_20__.LookupByPath),
/* harmony export */   "NpmOptionsConfiguration": () => (/* reexport safe */ _logic_npm_NpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_3__.NpmOptionsConfiguration),
/* harmony export */   "Operation": () => (/* reexport safe */ _logic_operations_Operation__WEBPACK_IMPORTED_MODULE_31__.Operation),
/* harmony export */   "OperationStatus": () => (/* reexport safe */ _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_32__.OperationStatus),
/* harmony export */   "PackageJsonDependency": () => (/* reexport safe */ _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_18__.PackageJsonDependency),
/* harmony export */   "PackageJsonEditor": () => (/* reexport safe */ _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_18__.PackageJsonEditor),
/* harmony export */   "PackageManager": () => (/* reexport safe */ _api_packageManager_PackageManager__WEBPACK_IMPORTED_MODULE_11__.PackageManager),
/* harmony export */   "PackageManagerOptionsConfigurationBase": () => (/* reexport safe */ _logic_base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_2__.PackageManagerOptionsConfigurationBase),
/* harmony export */   "PhasedCommandHooks": () => (/* reexport safe */ _pluginFramework_PhasedCommandHooks__WEBPACK_IMPORTED_MODULE_35__.PhasedCommandHooks),
/* harmony export */   "PnpmOptionsConfiguration": () => (/* reexport safe */ _logic_pnpm_PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_5__.PnpmOptionsConfiguration),
/* harmony export */   "ProjectChangeAnalyzer": () => (/* reexport safe */ _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_30__.ProjectChangeAnalyzer),
/* harmony export */   "RepoStateFile": () => (/* reexport safe */ _logic_RepoStateFile__WEBPACK_IMPORTED_MODULE_19__.RepoStateFile),
/* harmony export */   "Rush": () => (/* reexport safe */ _api_Rush__WEBPACK_IMPORTED_MODULE_26__.Rush),
/* harmony export */   "RushConfiguration": () => (/* reexport safe */ _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_1__.RushConfiguration),
/* harmony export */   "RushConfigurationProject": () => (/* reexport safe */ _api_RushConfigurationProject__WEBPACK_IMPORTED_MODULE_12__.RushConfigurationProject),
/* harmony export */   "RushConstants": () => (/* reexport safe */ _logic_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants),
/* harmony export */   "RushLifecycleHooks": () => (/* reexport safe */ _pluginFramework_RushLifeCycle__WEBPACK_IMPORTED_MODULE_34__.RushLifecycleHooks),
/* harmony export */   "RushProjectConfiguration": () => (/* reexport safe */ _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_13__.RushProjectConfiguration),
/* harmony export */   "RushSession": () => (/* reexport safe */ _pluginFramework_RushSession__WEBPACK_IMPORTED_MODULE_33__.RushSession),
/* harmony export */   "RushUserConfiguration": () => (/* reexport safe */ _api_RushUserConfiguration__WEBPACK_IMPORTED_MODULE_14__.RushUserConfiguration),
/* harmony export */   "VersionPolicy": () => (/* reexport safe */ _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__.VersionPolicy),
/* harmony export */   "VersionPolicyConfiguration": () => (/* reexport safe */ _api_VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_25__.VersionPolicyConfiguration),
/* harmony export */   "VersionPolicyDefinitionName": () => (/* reexport safe */ _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__.VersionPolicyDefinitionName),
/* harmony export */   "YarnOptionsConfiguration": () => (/* reexport safe */ _logic_yarn_YarnOptionsConfiguration__WEBPACK_IMPORTED_MODULE_4__.YarnOptionsConfiguration),
/* harmony export */   "_LastInstallFlag": () => (/* reexport safe */ _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_23__.LastInstallFlag),
/* harmony export */   "_OperationMetadataManager": () => (/* reexport safe */ _logic_operations_OperationMetadataManager__WEBPACK_IMPORTED_MODULE_38__.OperationMetadataManager),
/* harmony export */   "_OperationStateFile": () => (/* reexport safe */ _logic_operations_OperationStateFile__WEBPACK_IMPORTED_MODULE_37__.OperationStateFile),
/* harmony export */   "_RushGlobalFolder": () => (/* reexport safe */ _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_15__.RushGlobalFolder),
/* harmony export */   "_RushInternals": () => (/* reexport safe */ _api_RushInternals__WEBPACK_IMPORTED_MODULE_27__.RushInternals)
/* harmony export */ });
/* harmony import */ var _api_ApprovedPackagesPolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api/ApprovedPackagesPolicy */ 986096);
/* harmony import */ var _api_RushConfiguration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api/RushConfiguration */ 126002);
/* harmony import */ var _logic_base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logic/base/BasePackageManagerOptionsConfiguration */ 573404);
/* harmony import */ var _logic_npm_NpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logic/npm/NpmOptionsConfiguration */ 459476);
/* harmony import */ var _logic_yarn_YarnOptionsConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logic/yarn/YarnOptionsConfiguration */ 17314);
/* harmony import */ var _logic_pnpm_PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logic/pnpm/PnpmOptionsConfiguration */ 402835);
/* harmony import */ var _api_BuildCacheConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./api/BuildCacheConfiguration */ 541976);
/* harmony import */ var _api_CobuildConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./api/CobuildConfiguration */ 13111);
/* harmony import */ var _logic_buildCache_FileSystemBuildCacheProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./logic/buildCache/FileSystemBuildCacheProvider */ 339043);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./logic/RushConstants */ 951904);
/* harmony import */ var _api_packageManager_PackageManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./api/packageManager/PackageManager */ 923109);
/* harmony import */ var _api_RushConfigurationProject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./api/RushConfigurationProject */ 900491);
/* harmony import */ var _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./api/RushProjectConfiguration */ 514639);
/* harmony import */ var _api_RushUserConfiguration__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./api/RushUserConfiguration */ 354981);
/* harmony import */ var _api_RushGlobalFolder__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./api/RushGlobalFolder */ 164409);
/* harmony import */ var _api_ApprovedPackagesConfiguration__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./api/ApprovedPackagesConfiguration */ 589083);
/* harmony import */ var _api_CommonVersionsConfiguration__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./api/CommonVersionsConfiguration */ 989216);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./api/PackageJsonEditor */ 73666);
/* harmony import */ var _logic_RepoStateFile__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./logic/RepoStateFile */ 880175);
/* harmony import */ var _logic_LookupByPath__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./logic/LookupByPath */ 590211);
/* harmony import */ var _api_EventHooks__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./api/EventHooks */ 519005);
/* harmony import */ var _api_ChangeManager__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./api/ChangeManager */ 714304);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./api/LastInstallFlag */ 919846);
/* harmony import */ var _api_VersionPolicy__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./api/VersionPolicy */ 734331);
/* harmony import */ var _api_VersionPolicyConfiguration__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./api/VersionPolicyConfiguration */ 904624);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./api/Rush */ 465002);
/* harmony import */ var _api_RushInternals__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./api/RushInternals */ 882917);
/* harmony import */ var _api_ExperimentsConfiguration__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./api/ExperimentsConfiguration */ 259205);
/* harmony import */ var _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./api/CustomTipsConfiguration */ 268756);
/* harmony import */ var _logic_ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./logic/ProjectChangeAnalyzer */ 311605);
/* harmony import */ var _logic_operations_Operation__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./logic/operations/Operation */ 768667);
/* harmony import */ var _logic_operations_OperationStatus__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./logic/operations/OperationStatus */ 476597);
/* harmony import */ var _pluginFramework_RushSession__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./pluginFramework/RushSession */ 964818);
/* harmony import */ var _pluginFramework_RushLifeCycle__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./pluginFramework/RushLifeCycle */ 804876);
/* harmony import */ var _pluginFramework_PhasedCommandHooks__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./pluginFramework/PhasedCommandHooks */ 580814);
/* harmony import */ var _logic_CredentialCache__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./logic/CredentialCache */ 963954);
/* harmony import */ var _logic_operations_OperationStateFile__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./logic/operations/OperationStateFile */ 600463);
/* harmony import */ var _logic_operations_OperationMetadataManager__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./logic/operations/OperationMetadataManager */ 441895);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.
 * @packageDocumentation
 */







































//# sourceMappingURL=index.js.map

/***/ }),

/***/ 140603:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/Autoinstaller.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Autoinstaller": () => (/* binding */ Autoinstaller)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../api/PackageJsonEditor */ 73666);
/* harmony import */ var _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./installManager/InstallHelpers */ 741340);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RushConstants */ 951904);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/LastInstallFlag */ 919846);
/* harmony import */ var _cli_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cli/RushCommandLineParser */ 365416);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.










class Autoinstaller {
    constructor(options) {
        var _a;
        this.name = options.autoinstallerName;
        this._rushConfiguration = options.rushConfiguration;
        this._rushGlobalFolder = options.rushGlobalFolder;
        this._restrictConsoleOutput =
            (_a = options.restrictConsoleOutput) !== null && _a !== void 0 ? _a : _cli_RushCommandLineParser__WEBPACK_IMPORTED_MODULE_3__.RushCommandLineParser.shouldRestrictConsoleOutput();
        Autoinstaller.validateName(this.name);
    }
    // Example: .../common/autoinstallers/my-task
    get folderFullPath() {
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonAutoinstallersFolder, this.name);
    }
    // Example: .../common/autoinstallers/my-task/package-lock.yaml
    get shrinkwrapFilePath() {
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, this._rushConfiguration.shrinkwrapFilename);
    }
    // Example: .../common/autoinstallers/my-task/package.json
    get packageJsonPath() {
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, 'package.json');
    }
    static validateName(autoinstallerName) {
        const nameOrError = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.PackageName.tryParse(autoinstallerName);
        if (nameOrError.error) {
            throw new Error(`The specified name "${autoinstallerName}" is invalid: ` + nameOrError.error);
        }
        if (nameOrError.scope) {
            throw new Error(`The specified name "${autoinstallerName}" must not contain an NPM scope`);
        }
    }
    async prepareAsync() {
        const autoinstallerFullPath = this.folderFullPath;
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(autoinstallerFullPath)) {
            throw new Error(`The autoinstaller ${this.name} does not exist, Please run\nrush init-autoinstaller --name ${this.name}\n`);
        }
        await _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_4__.InstallHelpers.ensureLocalPackageManager(this._rushConfiguration, this._rushGlobalFolder, _RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);
        // Example: common/autoinstallers/my-task/package.json
        const relativePathForLogs = path__WEBPACK_IMPORTED_MODULE_1__.relative(this._rushConfiguration.rushJsonFolder, autoinstallerFullPath);
        this._logIfConsoleOutputIsNotRestricted(`Acquiring lock for "${relativePathForLogs}" folder...`);
        const lock = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.LockFile.acquire(autoinstallerFullPath, 'autoinstaller');
        try {
            // Example: .../common/autoinstallers/my-task/.rush/temp
            const lastInstallFlagPath = path__WEBPACK_IMPORTED_MODULE_1__.join(autoinstallerFullPath, _RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.projectRushFolderName, 'temp');
            const packageJsonPath = path__WEBPACK_IMPORTED_MODULE_1__.join(autoinstallerFullPath, 'package.json');
            const packageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.load(packageJsonPath);
            const lastInstallFlag = new _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_6__.LastInstallFlag(lastInstallFlagPath, {
                node: process.versions.node,
                packageManager: this._rushConfiguration.packageManager,
                packageManagerVersion: this._rushConfiguration.packageManagerToolVersion,
                packageJson: packageJson,
                rushJsonFolder: this._rushConfiguration.rushJsonFolder
            });
            // Example: ../common/autoinstallers/my-task/node_modules
            const nodeModulesFolder = `${autoinstallerFullPath}/${_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.nodeModulesFolderName}`;
            const flagPath = `${nodeModulesFolder}/rush-autoinstaller.flag`;
            const isLastInstallFlagDirty = !lastInstallFlag.isValid() || !_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(flagPath);
            if (isLastInstallFlagDirty || lock.dirtyWhenAcquired) {
                if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(nodeModulesFolder)) {
                    this._logIfConsoleOutputIsNotRestricted('Deleting old files from ' + nodeModulesFolder);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureEmptyFolder(nodeModulesFolder);
                }
                // Copy: .../common/autoinstallers/my-task/.npmrc
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, autoinstallerFullPath);
                this._logIfConsoleOutputIsNotRestricted(`Installing dependencies under ${autoinstallerFullPath}...\n`);
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.executeCommand({
                    command: this._rushConfiguration.packageManagerToolFilename,
                    args: ['install', '--frozen-lockfile'],
                    workingDirectory: autoinstallerFullPath,
                    keepEnvironment: true
                });
                // Create file: ../common/autoinstallers/my-task/.rush/temp/last-install.flag
                lastInstallFlag.create();
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.writeFile(flagPath, 'If this file is deleted, Rush will assume that the node_modules folder has been cleaned and will reinstall it.');
                this._logIfConsoleOutputIsNotRestricted('Auto install completed successfully\n');
            }
            else {
                this._logIfConsoleOutputIsNotRestricted('Autoinstaller folder is already up to date\n');
            }
        }
        finally {
            // Ensure the lockfile is released when we are finished.
            lock.release();
        }
    }
    async updateAsync() {
        await _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_4__.InstallHelpers.ensureLocalPackageManager(this._rushConfiguration, this._rushGlobalFolder, _RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);
        const autoinstallerPackageJsonPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.folderFullPath, 'package.json');
        if (!(await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.existsAsync(autoinstallerPackageJsonPath))) {
            throw new Error(`The specified autoinstaller path does not exist: ` + autoinstallerPackageJsonPath);
        }
        this._logIfConsoleOutputIsNotRestricted(`Updating autoinstaller package: ${autoinstallerPackageJsonPath}`);
        let oldFileContents = '';
        if (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.existsAsync(this.shrinkwrapFilePath)) {
            oldFileContents = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFile(this.shrinkwrapFilePath, { convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.NewlineKind.Lf });
            this._logIfConsoleOutputIsNotRestricted('Deleting ' + this.shrinkwrapFilePath);
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFileAsync(this.shrinkwrapFilePath);
            if (this._rushConfiguration.packageManager === 'pnpm') {
                // Workaround for https://github.com/pnpm/pnpm/issues/1890
                //
                // When "rush update-autoinstaller" is run, Rush deletes "common/autoinstallers/my-task/pnpm-lock.yaml"
                // so that a new lockfile will be generated. However "pnpm install" by design will try to recover
                // "pnpm-lock.yaml" from "my-task/node_modules/.pnpm/lock.yaml", which may prevent a full upgrade.
                // Deleting both files ensures that a new lockfile will always be generated.
                const pnpmPackageManager = this._rushConfiguration
                    .packageManagerWrapper;
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFileAsync(path__WEBPACK_IMPORTED_MODULE_1__.join(this.folderFullPath, pnpmPackageManager.internalShrinkwrapRelativePath));
            }
        }
        // Detect a common mistake where PNPM prints "Already up-to-date" without creating a shrinkwrap file
        const packageJsonEditor = _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_8__.PackageJsonEditor.load(this.packageJsonPath);
        if (packageJsonEditor.dependencyList.length === 0) {
            throw new Error('You must add at least one dependency to the autoinstaller package' +
                ' before invoking this command:\n' +
                this.packageJsonPath);
        }
        this._logIfConsoleOutputIsNotRestricted();
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, this.folderFullPath);
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.executeCommand({
            command: this._rushConfiguration.packageManagerToolFilename,
            args: ['install'],
            workingDirectory: this.folderFullPath,
            keepEnvironment: true
        });
        this._logIfConsoleOutputIsNotRestricted();
        if (this._rushConfiguration.packageManager === 'npm') {
            this._logIfConsoleOutputIsNotRestricted(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Running "npm shrinkwrap"...'));
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.executeCommand({
                command: this._rushConfiguration.packageManagerToolFilename,
                args: ['shrinkwrap'],
                workingDirectory: this.folderFullPath,
                keepEnvironment: true
            });
            this._logIfConsoleOutputIsNotRestricted('"npm shrinkwrap" completed');
            this._logIfConsoleOutputIsNotRestricted();
        }
        if (!(await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.existsAsync(this.shrinkwrapFilePath))) {
            throw new Error('The package manager did not create the expected shrinkwrap file: ' + this.shrinkwrapFilePath);
        }
        const newFileContents = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFileAsync(this.shrinkwrapFilePath, {
            convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.NewlineKind.Lf
        });
        if (oldFileContents !== newFileContents) {
            this._logIfConsoleOutputIsNotRestricted(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('The shrinkwrap file has been updated.') + '  Please commit the updated file:');
            this._logIfConsoleOutputIsNotRestricted(`\n  ${this.shrinkwrapFilePath}`);
        }
        else {
            this._logIfConsoleOutputIsNotRestricted(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Already up to date.'));
        }
    }
    _logIfConsoleOutputIsNotRestricted(message) {
        if (!this._restrictConsoleOutput) {
            // eslint-disable-next-line no-console
            console.log(message !== null && message !== void 0 ? message : '');
        }
    }
}
//# sourceMappingURL=Autoinstaller.js.map

/***/ }),

/***/ 392020:
/*!*****************************************!*\
  !*** ./lib-esnext/logic/ChangeFiles.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeFiles": () => (/* binding */ ChangeFiles)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _schemas_change_file_schema_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../schemas/change-file.schema.json */ 608725);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * This class represents the collection of change files existing in the repo and provides operations
 * for those change files.
 */
class ChangeFiles {
    constructor(changesPath) {
        this._changesPath = changesPath;
    }
    /**
     * Validate if the newly added change files match the changed packages.
     */
    static validate(newChangeFilePaths, changedPackages, rushConfiguration) {
        const schema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_change_file_schema_json__WEBPACK_IMPORTED_MODULE_1__);
        const projectsWithChangeDescriptions = new Set();
        newChangeFilePaths.forEach((filePath) => {
            // eslint-disable-next-line no-console
            console.log(`Found change file: ${filePath}`);
            const changeFile = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(filePath, schema);
            if (rushConfiguration.hotfixChangeEnabled) {
                if (changeFile && changeFile.changes) {
                    for (const change of changeFile.changes) {
                        if (change.type !== 'none' && change.type !== 'hotfix') {
                            throw new Error(`Change file ${filePath} specifies a type of '${change.type}' ` +
                                `but only 'hotfix' and 'none' change types may be used in a branch with 'hotfixChangeEnabled'.`);
                        }
                    }
                }
            }
            if (changeFile && changeFile.changes) {
                changeFile.changes.forEach((change) => projectsWithChangeDescriptions.add(change.packageName));
            }
            else {
                throw new Error(`Invalid change file: ${filePath}`);
            }
        });
        const projectsMissingChangeDescriptions = new Set(changedPackages);
        projectsWithChangeDescriptions.forEach((name) => projectsMissingChangeDescriptions.delete(name));
        if (projectsMissingChangeDescriptions.size > 0) {
            const projectsMissingChangeDescriptionsArray = [];
            projectsMissingChangeDescriptions.forEach((name) => projectsMissingChangeDescriptionsArray.push(name));
            throw new Error([
                'The following projects have been changed and require change descriptions, but change descriptions were not ' +
                    'detected for them:',
                ...projectsMissingChangeDescriptionsArray.map((projectName) => `- ${projectName}`),
                'To resolve this error, run "rush change". This will generate change description files that must be ' +
                    'committed to source control.'
            ].join('\n'));
        }
    }
    static getChangeComments(newChangeFilePaths) {
        const changes = new Map();
        newChangeFilePaths.forEach((filePath) => {
            // eslint-disable-next-line no-console
            console.log(`Found change file: ${filePath}`);
            const changeRequest = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.load(filePath);
            if (changeRequest && changeRequest.changes) {
                changeRequest.changes.forEach((change) => {
                    if (!changes.get(change.packageName)) {
                        changes.set(change.packageName, []);
                    }
                    if (change.comment && change.comment.length) {
                        changes.get(change.packageName).push(change.comment);
                    }
                });
            }
            else {
                throw new Error(`Invalid change file: ${filePath}`);
            }
        });
        return changes;
    }
    /**
     * Get the array of absolute paths of change files.
     */
    async getFilesAsync() {
        if (!this._files) {
            const { default: glob } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fast-glob */ 142479, 23));
            this._files = (await glob('**/*.json', { cwd: this._changesPath, absolute: true })) || [];
        }
        return this._files;
    }
    /**
     * Get the path of changes folder.
     */
    getChangesPath() {
        return this._changesPath;
    }
    /**
     * Delete all change files
     */
    async deleteAllAsync(shouldDelete, updatedChangelogs) {
        if (updatedChangelogs) {
            // Skip changes files if the package's change log is not updated.
            const packagesToInclude = new Set();
            updatedChangelogs.forEach((changelog) => {
                packagesToInclude.add(changelog.name);
            });
            const files = await this.getFilesAsync();
            const filesToDelete = [];
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(files, async (filePath) => {
                const changeRequest = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAsync(filePath);
                let shouldDeleteFile = true;
                for (const changeInfo of changeRequest.changes) {
                    if (!packagesToInclude.has(changeInfo.packageName)) {
                        shouldDeleteFile = false;
                        break;
                    }
                }
                if (shouldDeleteFile) {
                    filesToDelete.push(filePath);
                }
            }, { concurrency: 5 });
            return await this._deleteFilesAsync(filesToDelete, shouldDelete);
        }
        else {
            // Delete all change files.
            const files = await this.getFilesAsync();
            return await this._deleteFilesAsync(files, shouldDelete);
        }
    }
    async _deleteFilesAsync(files, shouldDelete) {
        if (files.length) {
            // eslint-disable-next-line no-console
            console.log(`\n* ${shouldDelete ? 'DELETING:' : 'DRYRUN: Deleting'} ${files.length} change file(s).`);
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(files, async (filePath) => {
                // eslint-disable-next-line no-console
                console.log(` - ${filePath}`);
                if (shouldDelete) {
                    await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFileAsync(filePath);
                }
            }, { concurrency: 5 });
        }
        return files.length;
    }
}
//# sourceMappingURL=ChangeFiles.js.map

/***/ }),

/***/ 121467:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/ChangeManager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeManager": () => (/* binding */ ChangeManager)
/* harmony export */ });
/* harmony import */ var _PublishUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublishUtilities */ 189294);
/* harmony import */ var _ChangeFiles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ChangeFiles */ 392020);
/* harmony import */ var _PrereleaseToken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrereleaseToken */ 862346);
/* harmony import */ var _ChangelogGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChangelogGenerator */ 268371);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * The class manages change files and controls how changes logged by change files
 * can be applied to package.json and change logs.
 */
class ChangeManager {
    constructor(rushConfiguration, projectsToExclude) {
        this._rushConfiguration = rushConfiguration;
        this._projectsToExclude = projectsToExclude;
    }
    /**
     * Load changes from change files
     * @param changesPath - location of change files
     * @param prereleaseToken - prerelease token
     * @param includeCommitDetails - whether commit details need to be included in changes
     */
    async loadAsync(changesPath, prereleaseToken = new _PrereleaseToken__WEBPACK_IMPORTED_MODULE_0__.PrereleaseToken(), includeCommitDetails = false) {
        this._allPackages = this._rushConfiguration.projectsByName;
        this._prereleaseToken = prereleaseToken;
        this._changeFiles = new _ChangeFiles__WEBPACK_IMPORTED_MODULE_1__.ChangeFiles(changesPath);
        this._allChanges = await _PublishUtilities__WEBPACK_IMPORTED_MODULE_2__.PublishUtilities.findChangeRequestsAsync(this._allPackages, this._rushConfiguration, this._changeFiles, includeCommitDetails, this._prereleaseToken, this._projectsToExclude);
        this._orderedChanges = _PublishUtilities__WEBPACK_IMPORTED_MODULE_2__.PublishUtilities.sortChangeRequests(this._allChanges.packageChanges);
    }
    hasChanges() {
        return ((this._orderedChanges && this._orderedChanges.length > 0) ||
            (this._allChanges && this._allChanges.versionPolicyChanges.size > 0));
    }
    get packageChanges() {
        return this._orderedChanges;
    }
    get allPackages() {
        return this._allPackages;
    }
    validateChanges(versionConfig) {
        this._allChanges.packageChanges.forEach((change, projectName) => {
            const projectInfo = this._rushConfiguration.getProjectByName(projectName);
            if (projectInfo) {
                if (projectInfo.versionPolicy) {
                    projectInfo.versionPolicy.validate(change.newVersion, projectName);
                }
            }
        });
    }
    /**
     * Apply changes to package.json
     * @param shouldCommit - If the value is true, package.json will be updated.
     * If the value is false, package.json and change logs will not be updated. It will only do a dry-run.
     */
    apply(shouldCommit) {
        if (!this.hasChanges()) {
            return;
        }
        // Update all the changed version policies
        this._allChanges.versionPolicyChanges.forEach((versionPolicyChange, versionPolicyName) => {
            this._rushConfiguration.versionPolicyConfiguration.update(versionPolicyName, versionPolicyChange.newVersion, shouldCommit);
        });
        // Apply all changes to package.json files.
        const updatedPackages = _PublishUtilities__WEBPACK_IMPORTED_MODULE_2__.PublishUtilities.updatePackages(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit, this._prereleaseToken, this._projectsToExclude);
        return updatedPackages;
    }
    async updateChangelogAsync(shouldCommit) {
        // Do not update changelog or delete the change files for prerelease.
        // Save them for the official release.
        if (!this._prereleaseToken.hasValue) {
            // Update changelogs.
            const updatedChangelogs = _ChangelogGenerator__WEBPACK_IMPORTED_MODULE_3__.ChangelogGenerator.updateChangelogs(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit);
            // Remove the change request files only if "-a" was provided.
            await this._changeFiles.deleteAllAsync(shouldCommit, updatedChangelogs);
        }
    }
}
//# sourceMappingURL=ChangeManager.js.map

/***/ }),

/***/ 268371:
/*!************************************************!*\
  !*** ./lib-esnext/logic/ChangelogGenerator.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangelogGenerator": () => (/* binding */ ChangelogGenerator)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _PublishUtilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublishUtilities */ 189294);
/* harmony import */ var _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/ChangeManagement */ 780924);
/* harmony import */ var _schemas_changelog_schema_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../schemas/changelog.schema.json */ 288445);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






const CHANGELOG_JSON = 'CHANGELOG.json';
const CHANGELOG_MD = 'CHANGELOG.md';
const EOL = '\n';
class ChangelogGenerator {
    /**
     * Updates the appropriate changelogs with the given changes.
     */
    static updateChangelogs(allChanges, allProjects, rushConfiguration, shouldCommit) {
        const updatedChangeLogs = [];
        allChanges.packageChanges.forEach((change, packageName) => {
            const project = allProjects.get(packageName);
            if (project && ChangelogGenerator._shouldUpdateChangeLog(project, allChanges)) {
                const changeLog = ChangelogGenerator.updateIndividualChangelog(change, project.projectFolder, shouldCommit, rushConfiguration, project.versionPolicy && project.versionPolicy.isLockstepped, project.isMainProject);
                if (changeLog) {
                    updatedChangeLogs.push(changeLog);
                }
            }
        });
        return updatedChangeLogs;
    }
    /**
     * Fully regenerate the markdown files based on the current json files.
     */
    static regenerateChangelogs(allProjects, rushConfiguration) {
        allProjects.forEach((project) => {
            const markdownPath = path__WEBPACK_IMPORTED_MODULE_0__.resolve(project.projectFolder, CHANGELOG_MD);
            const markdownJSONPath = path__WEBPACK_IMPORTED_MODULE_0__.resolve(project.projectFolder, CHANGELOG_JSON);
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(markdownPath)) {
                // eslint-disable-next-line no-console
                console.log('Found: ' + markdownPath);
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(markdownJSONPath)) {
                    throw new Error('A CHANGELOG.md without json: ' + markdownPath);
                }
                const changelog = ChangelogGenerator._getChangelog(project.packageName, project.projectFolder);
                const isLockstepped = !!project.versionPolicy && project.versionPolicy.isLockstepped;
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));
            }
        });
    }
    /**
     * Updates an individual changelog for a single project.
     */
    static updateIndividualChangelog(change, projectFolder, shouldCommit, rushConfiguration, isLockstepped = false, isMain = true) {
        if (isLockstepped && !isMain) {
            // Early return if the project is lockstepped and does not host change logs
            return undefined;
        }
        const changelog = ChangelogGenerator._getChangelog(change.packageName, projectFolder);
        if (!changelog.entries.some((entry) => entry.version === change.newVersion)) {
            const changelogEntry = {
                version: change.newVersion,
                tag: _PublishUtilities__WEBPACK_IMPORTED_MODULE_3__.PublishUtilities.createTagname(change.packageName, change.newVersion, rushConfiguration.gitTagSeparator),
                date: new Date().toUTCString(),
                comments: {}
            };
            change.changes.forEach((individualChange) => {
                if (individualChange.comment) {
                    // Initialize the comments array only as necessary.
                    const changeTypeString = _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_4__.ChangeType[individualChange.changeType];
                    changelogEntry.comments[changeTypeString] = changelogEntry.comments[changeTypeString] || [];
                    const comments = changelogEntry.comments[changeTypeString];
                    const changeLogComment = {
                        comment: individualChange.comment
                    };
                    if (individualChange.author) {
                        changeLogComment.author = individualChange.author;
                    }
                    if (individualChange.commit) {
                        changeLogComment.commit = individualChange.commit;
                    }
                    if (individualChange.customFields) {
                        changeLogComment.customFields = individualChange.customFields;
                    }
                    comments.push(changeLogComment);
                }
            });
            // Add the changelog entry to the start of the list.
            changelog.entries.unshift(changelogEntry);
            const changelogFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(projectFolder, CHANGELOG_JSON);
            // eslint-disable-next-line no-console
            console.log(`${EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ` +
                `Changelog update for "${change.packageName}@${change.newVersion}".`);
            if (shouldCommit) {
                // Write markdown transform.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.save(changelog, changelogFilename);
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_0__.join(projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));
            }
            return changelog;
        }
        // change log not updated.
        return undefined;
    }
    /**
     * Loads the changelog json from disk, or creates a new one if there isn't one.
     */
    static _getChangelog(packageName, projectFolder) {
        const changelogFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(projectFolder, CHANGELOG_JSON);
        let changelog = undefined;
        // Try to read the existing changelog.
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(changelogFilename)) {
            changelog = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.loadAndValidate(changelogFilename, ChangelogGenerator.jsonSchema);
        }
        if (!changelog) {
            changelog = {
                name: packageName,
                entries: []
            };
        }
        else {
            // Force the changelog name to be same as package name.
            // In case the package has been renamed but change log name is not updated.
            changelog.name = packageName;
        }
        return changelog;
    }
    /**
     * Translates the given changelog json object into a markdown string.
     */
    static _translateToMarkdown(changelog, rushConfiguration, isLockstepped = false) {
        let markdown = [
            `# Change Log - ${changelog.name}`,
            '',
            `This log was last generated on ${new Date().toUTCString()} and should not be manually modified.`,
            '',
            ''
        ].join(EOL);
        changelog.entries.forEach((entry, index) => {
            markdown += `## ${entry.version}${EOL}`;
            if (entry.date) {
                markdown += `${entry.date}${EOL}`;
            }
            markdown += EOL;
            let comments = '';
            comments += ChangelogGenerator._getChangeComments('Breaking changes', entry.comments.major);
            comments += ChangelogGenerator._getChangeComments('Minor changes', entry.comments.minor);
            comments += ChangelogGenerator._getChangeComments('Patches', entry.comments.patch);
            if (isLockstepped) {
                // In lockstepped projects, all changes are of type ChangeType.none.
                comments += ChangelogGenerator._getChangeComments('Updates', entry.comments.none);
            }
            if (rushConfiguration.hotfixChangeEnabled) {
                comments += ChangelogGenerator._getChangeComments('Hotfixes', entry.comments.hotfix);
            }
            if (!comments) {
                markdown +=
                    (changelog.entries.length === index + 1 ? '_Initial release_' : '_Version update only_') +
                        EOL +
                        EOL;
            }
            else {
                markdown += comments;
            }
        });
        return markdown;
    }
    /**
     * Helper to return the comments string to be appends to the markdown content.
     */
    static _getChangeComments(title, commentsArray) {
        let comments = '';
        if (commentsArray) {
            comments = `### ${title}${EOL + EOL}`;
            commentsArray.forEach((comment) => {
                comments += `- ${comment.comment}${EOL}`;
            });
            comments += EOL;
        }
        return comments;
    }
    /**
     * Changelogs should only be generated for publishable projects.
     * Do not update changelog or delete the change files for prerelease. Save them for the official release.
     * Unless the package is a hotfix, in which case do delete the change files.
     *
     * @param project
     * @param allChanges
     */
    static _shouldUpdateChangeLog(project, allChanges) {
        var _a;
        return (project.shouldPublish &&
            (!semver__WEBPACK_IMPORTED_MODULE_1__.prerelease(project.packageJson.version) ||
                ((_a = allChanges.packageChanges.get(project.packageName)) === null || _a === void 0 ? void 0 : _a.changeType) === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_4__.ChangeType.hotfix));
    }
}
/**
 * The JSON Schema for Changelog file (changelog.schema.json).
 */
ChangelogGenerator.jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonSchema.fromLoadedObject(_schemas_changelog_schema_json__WEBPACK_IMPORTED_MODULE_5__);

//# sourceMappingURL=ChangelogGenerator.js.map

/***/ }),

/***/ 963954:
/*!*********************************************!*\
  !*** ./lib-esnext/logic/CredentialCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CredentialCache": () => (/* binding */ CredentialCache)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _api_RushUserConfiguration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/RushUserConfiguration */ 354981);
/* harmony import */ var _schemas_credentials_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../schemas/credentials.schema.json */ 334875);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





const CACHE_FILENAME = 'credentials.json';
const LATEST_CREDENTIALS_JSON_VERSION = '0.1.0';
/**
 * @beta
 */
class CredentialCache /* implements IDisposable */ {
    constructor(cacheFilePath, loadedJson, lockfile) {
        this._modified = false;
        this._disposed = false;
        if (loadedJson && loadedJson.version !== LATEST_CREDENTIALS_JSON_VERSION) {
            throw new Error(`Unexpected credentials.json file version: ${loadedJson.version}`);
        }
        this._cacheFilePath = cacheFilePath;
        this._cacheEntries = new Map(Object.entries((loadedJson === null || loadedJson === void 0 ? void 0 : loadedJson.cacheEntries) || {}));
        this._supportsEditing = !!lockfile;
        this._lockfile = lockfile;
    }
    static async initializeAsync(options) {
        const rushUserFolderPath = _api_RushUserConfiguration__WEBPACK_IMPORTED_MODULE_1__.RushUserConfiguration.getRushUserFolderPath();
        const cacheFilePath = `${rushUserFolderPath}/${CACHE_FILENAME}`;
        const jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_credentials_schema_json__WEBPACK_IMPORTED_MODULE_2__);
        let loadedJson;
        try {
            loadedJson = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidateAsync(cacheFilePath, jsonSchema);
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isErrnoException(e)) {
                throw e;
            }
        }
        let lockfile;
        if (options.supportEditing) {
            lockfile = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.LockFile.acquire(rushUserFolderPath, `${CACHE_FILENAME}.lock`);
        }
        const credentialCache = new CredentialCache(cacheFilePath, loadedJson, lockfile);
        return credentialCache;
    }
    static async usingAsync(options, doActionAsync) {
        await _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__.Utilities.usingAsync(async () => await CredentialCache.initializeAsync(options), doActionAsync);
    }
    setCacheEntry(cacheId, entry) {
        this._validate(true);
        const { expires, credential, credentialMetadata } = entry;
        const expiresMilliseconds = (expires === null || expires === void 0 ? void 0 : expires.getTime()) || 0;
        const existingCacheEntry = this._cacheEntries.get(cacheId);
        if ((existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credential) !== credential ||
            (existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.expires) !== expiresMilliseconds ||
            !(0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_4__.objectsAreDeepEqual)(existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credentialMetadata, credentialMetadata)) {
            this._modified = true;
            this._cacheEntries.set(cacheId, {
                expires: expiresMilliseconds,
                credential,
                credentialMetadata
            });
        }
    }
    tryGetCacheEntry(cacheId) {
        this._validate(false);
        const cacheEntry = this._cacheEntries.get(cacheId);
        if (cacheEntry) {
            const result = {
                expires: cacheEntry.expires ? new Date(cacheEntry.expires) : undefined,
                credential: cacheEntry.credential,
                credentialMetadata: cacheEntry.credentialMetadata
            };
            return result;
        }
        else {
            return undefined;
        }
    }
    deleteCacheEntry(cacheId) {
        this._validate(true);
        if (this._cacheEntries.has(cacheId)) {
            this._modified = true;
            this._cacheEntries.delete(cacheId);
        }
    }
    trimExpiredEntries() {
        this._validate(true);
        const now = Date.now();
        for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {
            if (cacheEntry.expires < now) {
                this._cacheEntries.delete(cacheId);
                this._modified = true;
            }
        }
    }
    async saveIfModifiedAsync() {
        this._validate(true);
        if (this._modified) {
            const cacheEntriesJson = {};
            for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {
                cacheEntriesJson[cacheId] = cacheEntry;
            }
            const newJson = {
                version: LATEST_CREDENTIALS_JSON_VERSION,
                cacheEntries: cacheEntriesJson
            };
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.saveAsync(newJson, this._cacheFilePath, {
                ensureFolderExists: true,
                updateExistingFile: true,
                ignoreUndefinedValues: true
            });
            this._modified = false;
        }
    }
    dispose() {
        var _a;
        (_a = this._lockfile) === null || _a === void 0 ? void 0 : _a.release();
        this._disposed = true;
    }
    _validate(requiresEditing) {
        if (!this._supportsEditing && requiresEditing) {
            throw new Error(`This instance of ${CredentialCache.name} does not support editing.`);
        }
        if (this._disposed) {
            throw new Error(`This instance of ${CredentialCache.name} has been disposed.`);
        }
    }
}
//# sourceMappingURL=CredentialCache.js.map

/***/ }),

/***/ 728446:
/*!************************************************!*\
  !*** ./lib-esnext/logic/DependencyAnalyzer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyAnalyzer": () => (/* binding */ DependencyAnalyzer)
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/PackageJsonEditor */ 73666);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class DependencyAnalyzer {
    constructor(rushConfiguration) {
        this._analysisByVariant = new Map();
        this._rushConfiguration = rushConfiguration;
    }
    static forRushConfiguration(rushConfiguration) {
        if (!DependencyAnalyzer._dependencyAnalyzerByRushConfiguration) {
            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration = new WeakMap();
        }
        let analyzer = DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.get(rushConfiguration);
        if (!analyzer) {
            analyzer = new DependencyAnalyzer(rushConfiguration);
            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.set(rushConfiguration, analyzer);
        }
        return analyzer;
    }
    getAnalysis(variant) {
        // Use an empty string as the key when no variant provided. Anything else would possibly conflict
        // with a variant created by the user
        const variantKey = variant || '';
        let analysis = this._analysisByVariant.get(variantKey);
        if (!analysis) {
            analysis = this._getAnalysisInternal(variant);
            this._analysisByVariant.set(variantKey, analysis);
        }
        return analysis;
    }
    /**
     * Generates the {@link IDependencyAnalysis} for a variant.
     *
     * @remarks
     * The result of this function is not cached.
     */
    _getAnalysisInternal(variant) {
        var _a;
        const commonVersionsConfiguration = this._rushConfiguration.getCommonVersions(variant);
        const allVersionsByPackageName = new Map();
        const allowedAlternativeVersions = commonVersionsConfiguration.allowedAlternativeVersions;
        for (const project of this._rushConfiguration.projects) {
            const dependencies = [
                ...project.packageJsonEditor.dependencyList,
                ...project.packageJsonEditor.devDependencyList
            ];
            for (const { name: dependencyName, version: dependencyVersion, dependencyType } of dependencies) {
                if (dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_1__.DependencyType.Peer) {
                    // If this is a peer dependency, it isn't a real dependency in this context, so it shouldn't
                    // be included in the list of dependency versions.
                    continue;
                }
                // Is it a local project?
                const localProject = this._rushConfiguration.getProjectByName(dependencyName);
                if (localProject) {
                    if (!project.decoupledLocalDependencies.has(dependencyName) &&
                        semver__WEBPACK_IMPORTED_MODULE_0__.satisfies(localProject.packageJson.version, dependencyVersion)) {
                        // For now, ignore local dependencies (that aren't cyclic dependencies).
                        continue;
                    }
                }
                let allVersionForDependency = allVersionsByPackageName.get(dependencyName);
                if (!allVersionForDependency) {
                    allVersionForDependency = new Set();
                    allVersionsByPackageName.set(dependencyName, allVersionForDependency);
                }
                allVersionForDependency.add(dependencyVersion);
            }
        }
        const implicitlyPreferredVersionByPackageName = new Map();
        // Only generate implicitly preferred versions for variants that request it
        const useImplicitlyPreferredVersions = (_a = commonVersionsConfiguration.implicitlyPreferredVersions) !== null && _a !== void 0 ? _a : true;
        if (useImplicitlyPreferredVersions) {
            for (const [dependencyName, versions] of allVersionsByPackageName) {
                // For each dependency, we're collecting the set of all version specifiers that appear across the repo.
                // If there is only one version specifier, then that's the "preferred" one.
                const alternativesForThisDependency = new Set(allowedAlternativeVersions.get(dependencyName));
                let implicitlyPreferredVersion = undefined;
                for (const version of versions) {
                    // Versions listed in the common-versions.json's "allowedAlternativeVersions" property
                    // can be safely ignored in determining the set of implicitly preferred versions.
                    // (Even if it's the only version specifier anywhere in the repo, we still ignore it, because
                    // otherwise the rule would be difficult to explain.)
                    if (!alternativesForThisDependency.has(version)) {
                        if (implicitlyPreferredVersion === undefined) {
                            // There isn't a candidate for an implicitly preferred version yet. Set this value as a candidate.
                            implicitlyPreferredVersion = version;
                        }
                        else {
                            // There was already another version that was a candidate. Clear that out and break.
                            // This dependency does not have an implicitly preferred version because there are at least
                            // two candidates.
                            implicitlyPreferredVersion = undefined;
                            break;
                        }
                    }
                }
                if (implicitlyPreferredVersion !== undefined) {
                    implicitlyPreferredVersionByPackageName.set(dependencyName, implicitlyPreferredVersion);
                }
            }
        }
        return {
            commonVersionsConfiguration,
            implicitlyPreferredVersionByPackageName,
            allVersionsByPackageName
        };
    }
}
//# sourceMappingURL=DependencyAnalyzer.js.map

/***/ }),

/***/ 68654:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/DependencySpecifier.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencySpecifier": () => (/* binding */ DependencySpecifier),
/* harmony export */   "DependencySpecifierType": () => (/* binding */ DependencySpecifierType)
/* harmony export */ });
/* harmony import */ var npm_package_arg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! npm-package-arg */ 859591);
/* harmony import */ var npm_package_arg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(npm_package_arg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * The parsed format of a provided version specifier.
 */
var DependencySpecifierType;
(function (DependencySpecifierType) {
    /**
     * A git repository
     */
    DependencySpecifierType["Git"] = "Git";
    /**
     * A tagged version, e.g. "example@latest"
     */
    DependencySpecifierType["Tag"] = "Tag";
    /**
     * A specific version number, e.g. "example@1.2.3"
     */
    DependencySpecifierType["Version"] = "Version";
    /**
     * A version range, e.g. "example@2.x"
     */
    DependencySpecifierType["Range"] = "Range";
    /**
     * A local .tar.gz, .tar or .tgz file
     */
    DependencySpecifierType["File"] = "File";
    /**
     * A local directory
     */
    DependencySpecifierType["Directory"] = "Directory";
    /**
     * An HTTP url to a .tar.gz, .tar or .tgz file
     */
    DependencySpecifierType["Remote"] = "Remote";
    /**
     * A package alias, e.g. "npm:other-package@^1.2.3"
     */
    DependencySpecifierType["Alias"] = "Alias";
    /**
     * A package specified using workspace protocol, e.g. "workspace:^1.2.3"
     */
    DependencySpecifierType["Workspace"] = "Workspace";
})(DependencySpecifierType || (DependencySpecifierType = {}));
/**
 * An NPM "version specifier" is a string that can appear as a package.json "dependencies" value.
 * Example version specifiers: `^1.2.3`, `file:./blah.tgz`, `npm:other-package@~1.2.3`, and so forth.
 * A "dependency specifier" is the version specifier information, combined with the dependency package name.
 */
class DependencySpecifier {
    constructor(packageName, versionSpecifier) {
        this.packageName = packageName;
        this.versionSpecifier = versionSpecifier;
        // Workspace ranges are a feature from PNPM and Yarn. Set the version specifier
        // to the trimmed version range.
        if (versionSpecifier.startsWith('workspace:')) {
            this.specifierType = DependencySpecifierType.Workspace;
            this.versionSpecifier = versionSpecifier.slice(this.specifierType.length + 1).trim();
            this.aliasTarget = undefined;
            return;
        }
        const result = npm_package_arg__WEBPACK_IMPORTED_MODULE_0___default().resolve(packageName, versionSpecifier);
        this.specifierType = DependencySpecifier.getDependencySpecifierType(result.type);
        if (this.specifierType === DependencySpecifierType.Alias) {
            const aliasResult = result;
            if (!aliasResult.subSpec || !aliasResult.subSpec.name) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Unexpected result from npm-package-arg');
            }
            this.aliasTarget = new DependencySpecifier(aliasResult.subSpec.name, aliasResult.subSpec.rawSpec);
        }
        else {
            this.aliasTarget = undefined;
        }
    }
    static getDependencySpecifierType(specifierType) {
        switch (specifierType) {
            case 'git':
                return DependencySpecifierType.Git;
            case 'tag':
                return DependencySpecifierType.Tag;
            case 'version':
                return DependencySpecifierType.Version;
            case 'range':
                return DependencySpecifierType.Range;
            case 'file':
                return DependencySpecifierType.File;
            case 'directory':
                return DependencySpecifierType.Directory;
            case 'remote':
                return DependencySpecifierType.Remote;
            case 'alias':
                return DependencySpecifierType.Alias;
            default:
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Unexpected npm-package-arg result type "${specifierType}"`);
        }
    }
}
//# sourceMappingURL=DependencySpecifier.js.map

/***/ }),

/***/ 353470:
/*!***********************************************!*\
  !*** ./lib-esnext/logic/EventHooksManager.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventHooksManager": () => (/* binding */ EventHooksManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _api_EventHooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/EventHooks */ 519005);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/Stopwatch */ 314318);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class EventHooksManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._eventHooks = rushConfiguration.eventHooks;
        this._commonTempFolder = rushConfiguration.commonTempFolder;
    }
    handle(event, isDebug, ignoreHooks) {
        if (!this._eventHooks) {
            return;
        }
        const scripts = this._eventHooks.get(event);
        if (scripts.length > 0) {
            if (ignoreHooks) {
                // eslint-disable-next-line no-console
                console.log(`Skipping event hooks for ${_api_EventHooks__WEBPACK_IMPORTED_MODULE_1__.Event[event]} since --ignore-hooks was specified`);
                return;
            }
            const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__.Stopwatch.start();
            // eslint-disable-next-line no-console
            console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Executing event hooks for ${_api_EventHooks__WEBPACK_IMPORTED_MODULE_1__.Event[event]}`));
            const printEventHooksOutputToConsole = isDebug ||
                this._rushConfiguration.experimentsConfiguration.configuration.printEventHooksOutputToConsole;
            scripts.forEach((script) => {
                try {
                    _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__.Utilities.executeLifecycleCommand(script, {
                        rushConfiguration: this._rushConfiguration,
                        workingDirectory: this._rushConfiguration.rushJsonFolder,
                        initCwd: this._commonTempFolder,
                        handleOutput: !printEventHooksOutputToConsole,
                        environmentPathOptions: {
                            includeRepoBin: true
                        }
                    });
                }
                catch (error) {
                    // eslint-disable-next-line no-console
                    console.error('\n' +
                        colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Event hook "${script}" failed. Run "rush" with --debug` +
                            ` to see detailed error information.`));
                    if (isDebug) {
                        // eslint-disable-next-line no-console
                        console.error('\n' + error.message);
                    }
                }
            });
            stopwatch.stop();
            // eslint-disable-next-line no-console
            console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Event hooks finished. (${stopwatch.toString()})`));
        }
    }
}
//# sourceMappingURL=EventHooksManager.js.map

/***/ }),

/***/ 668229:
/*!*********************************!*\
  !*** ./lib-esnext/logic/Git.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_GIT_TAG_SEPARATOR": () => (/* binding */ DEFAULT_GIT_TAG_SEPARATOR),
/* harmony export */   "Git": () => (/* binding */ Git)
/* harmony export */ });
/* harmony import */ var git_repo_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! git-repo-info */ 927840);
/* harmony import */ var git_repo_info__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(git_repo_info__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ 257310);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! true-case-path */ 477156);
/* harmony import */ var true_case_path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(true_case_path__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @rushstack/package-deps-hash */ 717642);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _policy_GitEmailPolicy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./policy/GitEmailPolicy */ 613207);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _GitStatusParser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GitStatusParser */ 22051);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.











const DEFAULT_GIT_TAG_SEPARATOR = '_';
class Git {
    constructor(rushConfiguration) {
        this._checkedGitPath = false;
        this._checkedGitInfo = false;
        this._gitEmailResult = undefined;
        this._gitHooksPath = undefined;
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Returns the path to the Git binary if found. Otherwise, return undefined.
     */
    get gitPath() {
        if (!this._checkedGitPath) {
            this._gitPath = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_7__.EnvironmentConfiguration.gitBinaryPath || _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Executable.tryResolve('git');
            this._checkedGitPath = true;
        }
        return this._gitPath;
    }
    getGitPathOrThrow() {
        const gitPath = this.gitPath;
        if (!gitPath) {
            throw new Error('Git is not present');
        }
        else {
            return gitPath;
        }
    }
    /**
     * Returns true if the Git binary can be found.
     */
    isGitPresent() {
        return !!this.gitPath;
    }
    /**
     * Returns true if the Git binary was found and the current path is under a Git working tree.
     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,
     * the result of `this.getGitInfo()` is used.
     */
    isPathUnderGitWorkingTree(repoInfo) {
        if (this.isGitPresent()) {
            // Do we even have a Git binary?
            if (!repoInfo) {
                repoInfo = this.getGitInfo();
            }
            return !!(repoInfo && repoInfo.sha);
        }
        else {
            return false;
        }
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, undefined is returned.
     */
    tryGetGitEmail() {
        const emailResult = this._tryGetGitEmail();
        if (emailResult.result !== undefined && emailResult.result.length > 0) {
            return emailResult.result;
        }
        return undefined;
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, configuration instructions are printed to the console,
     * and AlreadyReportedError is thrown.
     */
    getGitEmail() {
        // Determine the user's account
        // Ex: "bob@example.com"
        const emailResult = this._tryGetGitEmail();
        if (emailResult.error) {
            // eslint-disable-next-line no-console
            console.log([
                `Error: ${emailResult.error.message}`,
                'Unable to determine your Git configuration using this command:',
                '',
                '    git config user.email',
                ''
            ].join('\n'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
        }
        if (emailResult.result === undefined || emailResult.result.length === 0) {
            // eslint-disable-next-line no-console
            console.log([
                'This operation requires that a Git email be specified.',
                '',
                `If you didn't configure your email yet, try something like this:`,
                '',
                ..._policy_GitEmailPolicy__WEBPACK_IMPORTED_MODULE_8__.getEmailExampleLines(this._rushConfiguration),
                ''
            ].join('\n'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
        }
        return emailResult.result;
    }
    /**
     * Get the folder where Git hooks should go for the current working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getHooksFolder() {
        const repoInfo = this.getGitInfo();
        if (repoInfo && repoInfo.worktreeGitDir) {
            return path__WEBPACK_IMPORTED_MODULE_1__.join(repoInfo.worktreeGitDir, 'hooks');
        }
        return undefined;
    }
    isHooksPathDefault() {
        const repoInfo = this.getGitInfo();
        if (!(repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.commonGitDir)) {
            // This should have never been called in a non-Git environment
            return true;
        }
        let commonGitDir = repoInfo.commonGitDir;
        try {
            commonGitDir = (0,true_case_path__WEBPACK_IMPORTED_MODULE_4__.trueCasePathSync)(commonGitDir);
        }
        catch (error) {
            /* ignore errors from true-case-path */
        }
        const defaultHooksPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(commonGitDir, 'hooks');
        const hooksResult = this._tryGetGitHooksPath();
        if (hooksResult.error) {
            // eslint-disable-next-line no-console
            console.log([
                `Error: ${hooksResult.error.message}`,
                'Unable to determine your Git configuration using this command:',
                '',
                '    git rev-parse --git-path hooks',
                '',
                'Assuming hooks can still be installed in the default location'
            ].join('\n'));
            return true;
        }
        if (hooksResult.result) {
            const absoluteHooksPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(this._rushConfiguration.rushJsonFolder, hooksResult.result);
            return absoluteHooksPath === defaultHooksPath;
        }
        // No error, but also empty result? Not sure it's possible.
        return true;
    }
    getConfigHooksPath() {
        let configHooksPath = '';
        const gitPath = this.getGitPathOrThrow();
        try {
            configHooksPath = this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'core.hooksPath']).trim();
        }
        catch (e) {
            // git config returns error code 1 if core.hooksPath is not set.
        }
        return configHooksPath;
    }
    /**
     * Get information about the current Git working tree.
     * Returns undefined if rush.json is not under a Git working tree.
     */
    getGitInfo() {
        if (!this._checkedGitInfo) {
            let repoInfo;
            try {
                // gitInfo() shouldn't usually throw, but wrapping in a try/catch just in case
                repoInfo = git_repo_info__WEBPACK_IMPORTED_MODULE_0___default()(this._rushConfiguration.rushJsonFolder);
            }
            catch (ex) {
                // if there's an error, assume we're not in a Git working tree
            }
            if (repoInfo && this.isPathUnderGitWorkingTree(repoInfo)) {
                this._gitInfo = repoInfo;
            }
            this._checkedGitInfo = true;
        }
        return this._gitInfo;
    }
    getMergeBase(targetBranch, terminal, shouldFetch = false) {
        if (shouldFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        try {
            const output = this._executeGitCommandAndCaptureOutput(gitPath, [
                '--no-optional-locks',
                'merge-base',
                '--',
                'HEAD',
                targetBranch
            ]);
            const result = output.trim();
            return result;
        }
        catch (e) {
            terminal.writeErrorLine(`Unable to determine merge base for branch "${targetBranch}". ` +
                'This can occur if the current clone is a shallow clone. If this clone is running in a CI ' +
                'pipeline, check your pipeline settings to ensure that the clone depth includes ' +
                'the expected merge base. If this clone is running locally, consider running "git fetch --deepen=<depth>".');
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
        }
    }
    getBlobContent({ blobSpec, repositoryRoot }) {
        const gitPath = this.getGitPathOrThrow();
        const output = this._executeGitCommandAndCaptureOutput(gitPath, ['cat-file', 'blob', blobSpec, '--'], repositoryRoot);
        return output;
    }
    /**
     * @param pathPrefix - An optional path prefix "git diff"s should be filtered by.
     * @returns
     * An array of paths of repo-root-relative paths of files that are different from
     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,
     * this function only returns results under the that path.
     */
    getChangedFiles(targetBranch, terminal, skipFetch = false, pathPrefix) {
        if (!skipFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        const output = this._executeGitCommandAndCaptureOutput(gitPath, [
            'diff',
            `${targetBranch}...`,
            '--name-only',
            '--no-renames',
            '--diff-filter=A'
        ]);
        return output
            .split('\n')
            .map((line) => {
            if (line) {
                const trimmedLine = line.trim();
                if (!pathPrefix || _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.isUnderOrEqual(trimmedLine, pathPrefix)) {
                    return trimmedLine;
                }
            }
            else {
                return undefined;
            }
        })
            .filter((line) => {
            return line && line.length > 0;
        });
    }
    /**
     * Gets the remote default branch that maps to the provided repository url.
     * This method is used by 'Rush change' to find the default remote branch to compare against.
     * If repository url is not provided or if there is no match, returns the default remote's
     * default branch 'origin/main'.
     * If there are more than one matches, returns the first remote's default branch.
     *
     * @param rushConfiguration - rush configuration
     */
    getRemoteDefaultBranch() {
        const repositoryUrls = this._rushConfiguration.repositoryUrls;
        if (repositoryUrls.length > 0) {
            const gitPath = this.getGitPathOrThrow();
            const output = this._executeGitCommandAndCaptureOutput(gitPath, ['remote']).trim();
            const normalizedRepositoryUrls = new Set();
            for (const repositoryUrl of repositoryUrls) {
                // Apply toUpperCase() for a case-insensitive comparison
                normalizedRepositoryUrls.add(Git.normalizeGitUrlForComparison(repositoryUrl).toUpperCase());
            }
            const matchingRemotes = output.split('\n').filter((remoteName) => {
                if (remoteName) {
                    const remoteUrl = this._executeGitCommandAndCaptureOutput(gitPath, [
                        'remote',
                        'get-url',
                        '--',
                        remoteName
                    ]).trim();
                    if (!remoteUrl) {
                        return false;
                    }
                    // Also apply toUpperCase() for a case-insensitive comparison
                    const normalizedRemoteUrl = Git.normalizeGitUrlForComparison(remoteUrl).toUpperCase();
                    if (normalizedRepositoryUrls.has(normalizedRemoteUrl)) {
                        return true;
                    }
                }
                return false;
            });
            if (matchingRemotes.length > 0) {
                if (matchingRemotes.length > 1) {
                    // eslint-disable-next-line no-console
                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);
                }
                return `${matchingRemotes[0]}/${this._rushConfiguration.repositoryDefaultBranch}`;
            }
            else {
                const errorMessage = repositoryUrls.length > 1
                    ? `Unable to find a git remote matching one of the repository URLs (${repositoryUrls.join(', ')}). `
                    : `Unable to find a git remote matching the repository URL (${repositoryUrls[0]}). `;
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_3___default().yellow(errorMessage + 'Detected changes are likely to be incorrect.'));
                return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_3___default().yellow('A git remote URL has not been specified in rush.json. Setting the baseline remote URL is recommended.'));
            return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
        }
    }
    hasUncommittedChanges() {
        const gitStatusEntries = this.getGitStatus();
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const gitStatusEntry of gitStatusEntries) {
            // If there are any changes, return true. We only need to evaluate the first iterator entry
            return true;
        }
        return false;
    }
    hasUnstagedChanges() {
        const gitStatusEntries = this.getGitStatus();
        for (const gitStatusEntry of gitStatusEntries) {
            if (gitStatusEntry.kind === 'untracked' ||
                gitStatusEntry.unstagedChangeType !== undefined) {
                return true;
            }
        }
        return false;
    }
    /**
     * The list of files changed but not committed
     */
    getUncommittedChanges() {
        const result = [];
        const gitStatusEntries = this.getGitStatus();
        for (const gitStatusEntry of gitStatusEntries) {
            result.push(gitStatusEntry.path);
        }
        return result;
    }
    getTagSeparator() {
        return this._rushConfiguration.gitTagSeparator || DEFAULT_GIT_TAG_SEPARATOR;
    }
    getGitStatus() {
        const gitPath = this.getGitPathOrThrow();
        // See Git.test.ts for example output
        const output = this._executeGitCommandAndCaptureOutput(gitPath, [
            'status',
            '--porcelain=2',
            '--null',
            '--ignored=no'
        ]);
        return (0,_GitStatusParser__WEBPACK_IMPORTED_MODULE_9__.parseGitStatus)(output);
    }
    /**
     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS
     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS
     * NOT NECESSARILY A VALID GIT URL.
     *
     * @example
     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`
     */
    static normalizeGitUrlForComparison(gitUrl) {
        // Git URL formats are documented here: https://www.git-scm.com/docs/git-clone#_git_urls
        let result = gitUrl.trim();
        // [user@]host.xz:path/to/repo.git/
        // "This syntax is only recognized if there are no slashes before the first colon. This helps
        // differentiate a local path that contains a colon."
        //
        // Match patterns like this:
        //   user@host.ext:path/to/repo
        //   host.ext:path/to/repo
        //   localhost:/~user/path/to/repo
        //
        // But not:
        //   http://blah
        //   c:/windows/path.txt
        //
        const scpLikeSyntaxRegExp = /^(?:[^@:\/]+\@)?([^:\/]{2,})\:((?!\/\/).+)$/;
        // Example: "user@host.ext:path/to/repo"
        const scpLikeSyntaxMatch = scpLikeSyntaxRegExp.exec(gitUrl);
        if (scpLikeSyntaxMatch) {
            // Example: "host.ext"
            const host = scpLikeSyntaxMatch[1];
            // Example: "path/to/repo"
            const urlPath = scpLikeSyntaxMatch[2];
            if (urlPath.startsWith('/')) {
                result = `https://${host}${urlPath}`;
            }
            else {
                result = `https://${host}/${urlPath}`;
            }
        }
        const parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(result);
        // Only convert recognized schemes
        switch (parsedUrl.protocol) {
            case 'http:':
            case 'https:':
            case 'ssh:':
            case 'ftp:':
            case 'ftps:':
            case 'git:':
            case 'git+http:':
            case 'git+https:':
            case 'git+ssh:':
            case 'git+ftp:':
            case 'git+ftps:':
                // Assemble the parts we want:
                result = `https://${parsedUrl.host}${parsedUrl.pathname}`;
                break;
        }
        // Trim ".git" or ".git/" from the end
        result = result.replace(/.git\/?$/, '');
        return result;
    }
    _tryGetGitEmail() {
        if (this._gitEmailResult === undefined) {
            const gitPath = this.getGitPathOrThrow();
            try {
                this._gitEmailResult = {
                    result: this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'user.email']).trim()
                };
            }
            catch (e) {
                this._gitEmailResult = {
                    error: e
                };
            }
        }
        return this._gitEmailResult;
    }
    _tryGetGitHooksPath() {
        if (this._gitHooksPath === undefined) {
            const gitPath = this.getGitPathOrThrow();
            try {
                this._gitHooksPath = {
                    result: this._executeGitCommandAndCaptureOutput(gitPath, [
                        'rev-parse',
                        '--git-path',
                        'hooks'
                    ]).trim()
                };
            }
            catch (e) {
                this._gitHooksPath = {
                    error: e
                };
            }
        }
        return this._gitHooksPath;
    }
    _tryFetchRemoteBranch(remoteBranchName) {
        const firstSlashIndex = remoteBranchName.indexOf('/');
        if (firstSlashIndex === -1) {
            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +
                'Expected branch to be in the <remote>/<branch name> format.');
        }
        const remoteName = remoteBranchName.substr(0, firstSlashIndex);
        const branchName = remoteBranchName.substr(firstSlashIndex + 1);
        const gitPath = this.getGitPathOrThrow();
        const spawnResult = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Executable.spawnSync(gitPath, ['fetch', '--', remoteName, branchName], {
            stdio: 'ignore'
        });
        return spawnResult.status === 0;
    }
    _fetchRemoteBranch(remoteBranchName, terminal) {
        // eslint-disable-next-line no-console
        console.log(`Checking for updates to ${remoteBranchName}...`);
        const fetchResult = this._tryFetchRemoteBranch(remoteBranchName);
        if (!fetchResult) {
            terminal.writeWarningLine(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`);
        }
    }
    /**
     * @internal
     */
    _executeGitCommandAndCaptureOutput(gitPath, args, repositoryRoot = this._rushConfiguration.rushJsonFolder) {
        try {
            return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_10__.Utilities.executeCommandAndCaptureOutput(gitPath, args, repositoryRoot);
        }
        catch (e) {
            (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_6__.ensureGitMinimumVersion)(gitPath);
            throw e;
        }
    }
}
//# sourceMappingURL=Git.js.map

/***/ }),

/***/ 22051:
/*!*********************************************!*\
  !*** ./lib-esnext/logic/GitStatusParser.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseGitStatus": () => (/* binding */ parseGitStatus)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
function _parseGitStatusChangeType(str) {
    switch (str) {
        case 'M': {
            return 'modified';
        }
        case 'T': {
            return 'type-changed';
        }
        case 'A': {
            return 'added';
        }
        case 'D': {
            return 'deleted';
        }
        case 'R': {
            return 'renamed';
        }
        case 'C': {
            return 'copied';
        }
        case '.': {
            return undefined;
        }
        default: {
            throw new Error(`Unexpected git status change type: ${str}`);
        }
    }
}
function _parseIsInSubmodule(submoduleState) {
    // This field is actually four characters long, but this parser only handles if the entry is in a
    // submodule or not. That is represented by a "N" or an "S" in the first character.
    const submoduleMode = submoduleState.charAt(0);
    if (submoduleMode === 'N') {
        return false;
    }
    else if (submoduleMode === 'S') {
        return true;
    }
    else {
        throw new Error(`Unexpected submodule state: ${submoduleState}`);
    }
}
function* parseGitStatus(gitStatusOutput) {
    // See reference https://git-scm.com/docs/git-status?msclkid=1cff552bcdce11ecadf77a086eded66c#_porcelain_format_version_2
    let pos = 0;
    function getFieldAndAdvancePos(delimiter) {
        const newPos = gitStatusOutput.indexOf(delimiter, pos);
        if (newPos === -1) {
            throw new Error(`Unexpected end of git status output after position ${pos}`);
        }
        const field = gitStatusOutput.substring(pos, newPos);
        pos = newPos + delimiter.length;
        return field;
    }
    /**
     * @example
     * ```
     * ? path/g.ts
     * ```
     */
    function parseUntrackedEntry() {
        const path = getFieldAndAdvancePos('\0');
        const entry = {
            kind: 'untracked',
            path
        };
        return entry;
    }
    /**
     * @example
     * ```
     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 a171a25d2c978ba071959f39dbeaa339fe84f768 path/a.ts\0
     * 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
     * 1 .D N... 100644 100644 000000 3fcb58810c113c90c366dd81d16443425c7b95fa 3fcb58810c113c90c366dd81d16443425c7b95fa path/c.ts\0
     * 1 D. N... 100644 000000 000000 91b0203b85a7bb605e35f842d1d05d66a6275e10 0000000000000000000000000000000000000000 path/d.ts\0
     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 451de43c5cb012af55a79cc3463849ab3cfa0457 path/f.ts\0
     * 1 AM N... 000000 100644 100644 0000000000000000000000000000000000000000 9d9ab4adc79c591c0aa72f7fd29a008c80893e3e path/h.ts\0
     * ```
     */
    function parseAddModifyOrDeleteEntry() {
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //   ^
        const changeTypeField = getFieldAndAdvancePos(' ');
        const rawStagedChangeType = changeTypeField.charAt(0);
        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);
        const rawUnstagedChangeType = changeTypeField.charAt(1);
        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //      ^
        const submoduleState = getFieldAndAdvancePos(' ');
        const isInSubmodule = _parseIsInSubmodule(submoduleState);
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //           ^
        const headFileMode = getFieldAndAdvancePos(' ');
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //                  ^
        const indexFileMode = getFieldAndAdvancePos(' ');
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //                         ^
        const worktreeFileMode = getFieldAndAdvancePos(' ');
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //                                ^
        const headObjectName = getFieldAndAdvancePos(' ');
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //                                                                         ^
        const indexObjectName = getFieldAndAdvancePos(' ');
        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\0
        //                                                                                                                  ^
        const path = getFieldAndAdvancePos('\0');
        const entry = {
            kind: 'changed',
            stagedChangeType,
            unstagedChangeType,
            isInSubmodule,
            headFileMode,
            indexFileMode,
            worktreeFileMode,
            headObjectName,
            indexObjectName,
            path
        };
        return entry;
    }
    /**
     * @example
     * ```
     * 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
     * ```
     */
    function parseRenamedOrCopiedEntry() {
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //   ^
        const changeTypeField = getFieldAndAdvancePos(' ');
        const rawStagedChangeType = changeTypeField.charAt(0);
        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);
        const rawUnstagedChangeType = changeTypeField.charAt(1);
        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //      ^
        const submoduleState = getFieldAndAdvancePos(' ');
        const isInSubmodule = _parseIsInSubmodule(submoduleState);
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //           ^
        const headFileMode = getFieldAndAdvancePos(' ');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                  ^
        const indexFileMode = getFieldAndAdvancePos(' ');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                         ^
        const worktreeFileMode = getFieldAndAdvancePos(' ');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                                ^
        const headObjectName = getFieldAndAdvancePos(' ');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                                                                         ^
        const indexObjectName = getFieldAndAdvancePos(' ');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                                                                                                                  ^
        const renameOrCopyScoreField = getFieldAndAdvancePos(' ');
        const renameOrCopyMode = renameOrCopyScoreField.charAt(0);
        const rawRenameOrCopyScore = renameOrCopyScoreField.substring(1);
        const renameOrCopyScore = parseInt(rawRenameOrCopyScore, 10);
        let kind;
        if (renameOrCopyMode === 'R') {
            kind = 'renamed';
        }
        else if (renameOrCopyMode === 'C') {
            kind = 'copied';
        }
        else {
            throw new Error(`Unexpected rename or copy mode: ${renameOrCopyMode}`);
        }
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                                                                                                                       ^
        const path = getFieldAndAdvancePos('\0');
        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\0e2.ts\0
        //                                                                                                                                  ^
        const originalPath = getFieldAndAdvancePos('\0');
        const entry = {
            kind,
            stagedChangeType,
            unstagedChangeType,
            isInSubmodule,
            headFileMode,
            indexFileMode,
            worktreeFileMode,
            headObjectName,
            indexObjectName,
            renameOrCopyScore,
            path,
            originalPath
        };
        return entry;
    }
    /**
     * @example
     * ```
     * u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
     * ```
     */
    function parseUnmergedEntry() {
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //   ^
        const changeTypeField = getFieldAndAdvancePos(' ');
        const rawStagedChangeType = changeTypeField.charAt(0);
        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);
        const rawUnstagedChangeType = changeTypeField.charAt(1);
        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //      ^
        const submoduleState = getFieldAndAdvancePos(' ');
        const isInSubmodule = _parseIsInSubmodule(submoduleState);
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //           ^
        const stage1FileMode = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                  ^
        const stage2FileMode = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                         ^
        const stage3FileMode = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                                ^
        const worktreeFileMode = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                                       ^
        const stage1ObjectName = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                                                                                ^
        const stage2ObjectName = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                                                                                                                         ^
        const stage3ObjectName = getFieldAndAdvancePos(' ');
        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\0
        //                                                                                                                                                                  ^
        const path = getFieldAndAdvancePos('\0');
        const entry = {
            kind: 'unmerged',
            stagedChangeType,
            unstagedChangeType,
            isInSubmodule,
            stage1FileMode,
            stage2FileMode,
            stage3FileMode,
            worktreeFileMode,
            stage1ObjectName,
            stage2ObjectName,
            stage3ObjectName,
            path
        };
        return entry;
    }
    while (pos < gitStatusOutput.length) {
        const modeField = getFieldAndAdvancePos(' ');
        switch (modeField) {
            case '?': {
                // Untracked
                yield parseUntrackedEntry();
                break;
            }
            case '1': {
                // Simple change
                yield parseAddModifyOrDeleteEntry();
                break;
            }
            case '2': {
                // Renamed or copied
                yield parseRenamedOrCopiedEntry();
                break;
            }
            case 'u': {
                // Unmerged
                yield parseUnmergedEntry();
                break;
            }
            default: {
                throw new Error(`Unexpected git status mode: ${modeField}`);
            }
        }
    }
}
//# sourceMappingURL=GitStatusParser.js.map

/***/ }),

/***/ 866717:
/*!********************************************!*\
  !*** ./lib-esnext/logic/JsonSchemaUrls.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JsonSchemaUrls": () => (/* binding */ JsonSchemaUrls)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * JSON schema URLs that Rush writes into config files.
 */
class JsonSchemaUrls {
}
JsonSchemaUrls.approvedPackages = 'https://developer.microsoft.com/json-schemas/rush/v5/approved-packages.schema.json';
JsonSchemaUrls.commonVersions = 'https://developer.microsoft.com/json-schemas/rush/v5/common-versions.schema.json';

//# sourceMappingURL=JsonSchemaUrls.js.map

/***/ }),

/***/ 590211:
/*!******************************************!*\
  !*** ./lib-esnext/logic/LookupByPath.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LookupByPath": () => (/* binding */ LookupByPath)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This class is used to associate POSIX relative paths, such as those returned by `git` commands,
 * with entities that correspond with ancestor folders, such as Rush Projects.
 *
 * It is optimized for efficiently locating the nearest ancestor path with an associated value.
 *
 * @example
 * ```ts
 * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
 * tree.findChildPath('foo'); // returns 1
 * tree.findChildPath('foo/baz'); // returns 1
 * tree.findChildPath('baz'); // returns undefined
 * tree.findChildPath('foo/bar/baz'); returns 3
 * tree.findChildPath('bar/foo/bar'); returns 2
 * ```
 * @beta
 */
class LookupByPath {
    /**
     * Constructs a new `LookupByPath`
     *
     * @param entries - Initial path-value pairs to populate the tree.
     */
    constructor(entries, delimiter) {
        this._root = {
            value: undefined,
            children: undefined
        };
        this.delimiter = delimiter !== null && delimiter !== void 0 ? delimiter : '/';
        if (entries) {
            for (const [path, item] of entries) {
                this.setItem(path, item);
            }
        }
    }
    /**
     * Iterates over the segments of a serialized path.
     *
     * @example
     *
     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'
     *
     * `LookupByPath.iteratePathSegments('foo\\bar\\baz', '\\')` yields 'foo', 'bar', 'baz'
     */
    static *iteratePathSegments(serializedPath, delimiter = '/') {
        for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {
            yield prefixMatch.prefix;
        }
    }
    static *_iteratePrefixes(input, delimiter = '/') {
        if (!input) {
            return;
        }
        let previousIndex = 0;
        let nextIndex = input.indexOf(delimiter);
        // Leading segments
        while (nextIndex >= 0) {
            yield {
                prefix: input.slice(previousIndex, nextIndex),
                index: nextIndex
            };
            previousIndex = nextIndex + 1;
            nextIndex = input.indexOf(delimiter, previousIndex);
        }
        // Last segment
        if (previousIndex < input.length) {
            yield {
                prefix: input.slice(previousIndex, input.length),
                index: input.length
            };
        }
    }
    /**
     * Associates the value with the specified serialized path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItem(serializedPath, value) {
        return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);
    }
    /**
     * Associates the value with the specified path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItemFromSegments(pathSegments, value) {
        let node = this._root;
        for (const segment of pathSegments) {
            if (!node.children) {
                node.children = new Map();
            }
            let child = node.children.get(segment);
            if (!child) {
                node.children.set(segment, (child = {
                    value: undefined,
                    children: undefined
                }));
            }
            node = child;
        }
        node.value = value;
        return this;
    }
    /**
     * Searches for the item associated with `childPath`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPath('foo/baz'); // returns 1
     * tree.findChildPath('foo/bar/baz'); // returns 2
     * ```
     */
    findChildPath(childPath) {
        return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));
    }
    /**
     * Searches for the item for which the recorded prefix is the longest matching prefix of `query`.
     * Obtains both the item and the length of the matched prefix, so that the remainder of the path can be
     * extracted.
     *
     * @returns the found item and the length of the matched prefix, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findLongestPrefixMatch('foo/baz'); // returns { item: 1, index: 3 }
     * tree.findLongestPrefixMatch('foo/bar/baz'); // returns { item: 2, index: 7 }
     * ```
     */
    findLongestPrefixMatch(query) {
        return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, this.delimiter));
    }
    /**
     * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1
     * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2
     * ```
     */
    findChildPathFromSegments(childPathSegments) {
        var _a;
        let node = this._root;
        let best = node.value;
        // Trivial cases
        if (node.children) {
            for (const segment of childPathSegments) {
                const child = node.children.get(segment);
                if (!child) {
                    break;
                }
                node = child;
                best = (_a = node.value) !== null && _a !== void 0 ? _a : best;
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
    /**
     * Iterates through progressively longer prefixes of a given string and returns as soon
     * as the number of candidate items that match the prefix are 1 or 0.
     *
     * If a match is present, returns the matched itme and the length of the matched prefix.
     *
     * @returns the found item, or `undefined` if no item was found
     */
    _findLongestPrefixMatch(prefixes) {
        let node = this._root;
        let best = node.value
            ? {
                value: node.value,
                index: 0
            }
            : undefined;
        // Trivial cases
        if (node.children) {
            for (const { prefix: hash, index } of prefixes) {
                const child = node.children.get(hash);
                if (!child) {
                    break;
                }
                node = child;
                if (node.value !== undefined) {
                    best = {
                        value: node.value,
                        index
                    };
                }
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
}
//# sourceMappingURL=LookupByPath.js.map

/***/ }),

/***/ 161593:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/NodeJsCompatibility.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeJsCompatibility": () => (/* binding */ NodeJsCompatibility)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * This constant is the major version of the next LTS node Node.js release. This constant should be updated when
 * a new LTS version is added to Rush's support matrix.
 *
 * LTS schedule: https://nodejs.org/en/about/releases/
 * LTS versions: https://nodejs.org/en/download/releases/
 */
const UPCOMING_NODE_LTS_VERSION = 20;
const nodeVersion = process.versions.node;
const nodeMajorVersion = semver__WEBPACK_IMPORTED_MODULE_1__.major(nodeVersion);
/**
 * This class provides useful functions for warning if the current Node.js runtime isn't supported.
 *
 * @internal
 */
class NodeJsCompatibility {
    /**
     * This reports if the Node.js version is known to have serious incompatibilities.  In that situation, the user
     * should downgrade Rush to an older release that supported their Node.js version.
     */
    static reportAncientIncompatibleVersion() {
        // IMPORTANT: If this test fails, the Rush CLI front-end process will terminate with an error.
        // Only increment it when our code base is known to use newer features (e.g. "async"/"await") that
        // have no hope of working with older Node.js.
        if (semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(nodeVersion, '< 8.9.0')) {
            // eslint-disable-next-line no-console
            console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`Your version of Node.js (${nodeVersion}) is very old and incompatible with Rush. ` +
                `Please upgrade to the latest Long-Term Support (LTS) version.\n`));
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Detect whether the Node.js version is "supported" by the Rush maintainers.  We generally
     * only support versions that were "Long Term Support" (LTS) at the time when Rush was published.
     *
     * This is a warning only -- the user is free to ignore it and use Rush anyway.
     */
    static warnAboutCompatibilityIssues(options) {
        // Only show the first warning
        return (NodeJsCompatibility.reportAncientIncompatibleVersion() ||
            NodeJsCompatibility.warnAboutVersionTooNew(options) ||
            NodeJsCompatibility._warnAboutOddNumberedVersion() ||
            NodeJsCompatibility._warnAboutNonLtsVersion(options.rushConfiguration));
    }
    /**
     * Warn about a Node.js version that has not been tested yet with Rush.
     */
    static warnAboutVersionTooNew(options) {
        if (nodeMajorVersion >= UPCOMING_NODE_LTS_VERSION + 1) {
            if (!options.alreadyReportedNodeTooNewError) {
                // We are on a much newer release than we have tested and support
                if (options.isRushLib) {
                    // eslint-disable-next-line no-console
                    console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +
                        `of the Rush engine. Please consider upgrading the "rushVersion" setting in rush.json, ` +
                        `or downgrading Node.js.\n`));
                }
                else {
                    // eslint-disable-next-line no-console
                    console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +
                        `of Rush. Please consider installing a newer version of the "@microsoft/rush" ` +
                        `package, or downgrading Node.js.\n`));
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    static _warnAboutNonLtsVersion(rushConfiguration) {
        if (rushConfiguration && !rushConfiguration.suppressNodeLtsWarning && !NodeJsCompatibility.isLtsVersion) {
            // eslint-disable-next-line no-console
            console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Your version of Node.js (${nodeVersion}) is not a Long-Term Support (LTS) release. ` +
                'These versions frequently have bugs. Please consider installing a stable release.\n'));
            return true;
        }
        else {
            return false;
        }
    }
    static _warnAboutOddNumberedVersion() {
        if (NodeJsCompatibility.isOddNumberedVersion) {
            // eslint-disable-next-line no-console
            console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Your version of Node.js (${nodeVersion}) is an odd-numbered release. ` +
                `These releases frequently have bugs. Please consider installing a Long Term Support (LTS) ` +
                `version instead.\n`));
            return true;
        }
        else {
            return false;
        }
    }
    static get isLtsVersion() {
        return !!process.release.lts;
    }
    static get isOddNumberedVersion() {
        return nodeMajorVersion % 2 !== 0;
    }
}
//# sourceMappingURL=NodeJsCompatibility.js.map

/***/ }),

/***/ 862346:
/*!*********************************************!*\
  !*** ./lib-esnext/logic/PrereleaseToken.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrereleaseToken": () => (/* binding */ PrereleaseToken)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
class PrereleaseToken {
    constructor(prereleaseName, suffixName, partialPrerelease = false) {
        if (prereleaseName && suffixName) {
            throw new Error('Pre-release name and suffix cannot be provided at the same time.');
        }
        this.name = prereleaseName || suffixName;
        this._prereleaseName = prereleaseName;
        this._suffixName = suffixName;
        this._partialPrerelease = partialPrerelease;
    }
    get hasValue() {
        return !!this._prereleaseName || !!this._suffixName;
    }
    get isPrerelease() {
        return !!this._prereleaseName;
    }
    get isSuffix() {
        return !!this._suffixName;
    }
    get isPartialPrerelease() {
        return this.isPrerelease && this._partialPrerelease;
    }
}
//# sourceMappingURL=PrereleaseToken.js.map

/***/ }),

/***/ 311605:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/ProjectChangeAnalyzer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectChangeAnalyzer": () => (/* binding */ ProjectChangeAnalyzer)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ignore */ 493511);
/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ignore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/package-deps-hash */ 717642);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../api/RushProjectConfiguration */ 514639);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Git */ 668229);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./base/BaseProjectShrinkwrapFile */ 894306);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RushConstants */ 951904);
/* harmony import */ var _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pnpm/PnpmShrinkwrapFile */ 930997);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.











/**
 * @beta
 */
class ProjectChangeAnalyzer {
    constructor(rushConfiguration) {
        /**
         * UNINITIALIZED === we haven't looked
         * undefined === data isn't available (i.e. - git isn't present)
         */
        this._data = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_5__.UNINITIALIZED;
        this._filteredData = new Map();
        this._projectStateCache = new Map();
        this._rushConfiguration = rushConfiguration;
        this._git = new _Git__WEBPACK_IMPORTED_MODULE_6__.Git(this._rushConfiguration);
    }
    /**
     * Try to get a list of the specified project's dependencies and their hashes.
     *
     * @remarks
     * If the data can't be generated (i.e. - if Git is not present) this returns undefined.
     *
     * @internal
     */
    async _tryGetProjectDependenciesAsync(project, terminal) {
        // Check the cache for any existing data
        let filteredProjectData = this._filteredData.get(project);
        if (filteredProjectData) {
            return filteredProjectData;
        }
        const data = await this._ensureInitializedAsync(terminal);
        if (!data) {
            return undefined;
        }
        const { projectState, rootDir } = data;
        if (projectState === undefined) {
            return undefined;
        }
        const unfilteredProjectData = projectState.get(project);
        if (!unfilteredProjectData) {
            throw new Error(`Project "${project.packageName}" does not exist in the current Rush configuration.`);
        }
        filteredProjectData = await this._filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal);
        this._filteredData.set(project, filteredProjectData);
        return filteredProjectData;
    }
    /**
     * @internal
     */
    async _ensureInitializedAsync(terminal) {
        if (this._data === _utilities_Utilities__WEBPACK_IMPORTED_MODULE_5__.UNINITIALIZED) {
            this._data = await this._getDataAsync(terminal);
        }
        return this._data;
    }
    /**
     * The project state hash is calculated in the following way:
     * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)
     *   - If project dependencies cannot be collected (i.e. - if Git isn't available),
     *     this function returns `undefined`
     * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted
     * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its
     *   Git SHA is fed into the hash
     * - A hex digest of the hash is returned
     *
     * @internal
     */
    async _tryGetProjectStateHashAsync(project, terminal) {
        let projectState = this._projectStateCache.get(project);
        if (!projectState) {
            const packageDeps = await this._tryGetProjectDependenciesAsync(project, terminal);
            if (!packageDeps) {
                return undefined;
            }
            else {
                const sortedPackageDepsFiles = Array.from(packageDeps.keys()).sort();
                const hash = crypto__WEBPACK_IMPORTED_MODULE_1__.createHash('sha1');
                for (const packageDepsFile of sortedPackageDepsFiles) {
                    hash.update(packageDepsFile);
                    hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.hashDelimiter);
                    hash.update(packageDeps.get(packageDepsFile));
                    hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.hashDelimiter);
                }
                projectState = hash.digest('hex');
                this._projectStateCache.set(project, projectState);
            }
        }
        return projectState;
    }
    async _filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal) {
        const ignoreMatcher = await this._getIgnoreMatcherForProjectAsync(project, terminal);
        if (!ignoreMatcher) {
            return unfilteredProjectData;
        }
        const projectKey = path__WEBPACK_IMPORTED_MODULE_0__.relative(rootDir, project.projectFolder);
        const projectKeyLength = projectKey.length + 1;
        // At this point, `filePath` is guaranteed to start with `projectKey`, so
        // we can safely slice off the first N characters to get the file path relative to the
        // root of the project.
        const filteredProjectData = new Map();
        for (const [filePath, value] of unfilteredProjectData) {
            const relativePath = filePath.slice(projectKeyLength);
            if (!ignoreMatcher.ignores(relativePath)) {
                // Add the file path to the filtered data if it is not ignored
                filteredProjectData.set(filePath, value);
            }
        }
        return filteredProjectData;
    }
    /**
     * Gets a list of projects that have changed in the current state of the repo
     * when compared to the specified branch, optionally taking the shrinkwrap and settings in
     * the rush-project.json file into consideration.
     */
    async getChangedProjectsAsync(options) {
        const { _rushConfiguration: rushConfiguration } = this;
        const { targetBranchName, terminal, includeExternalDependencies, enableFiltering, shouldFetch } = options;
        const gitPath = this._git.getGitPathOrThrow();
        const repoRoot = (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__.getRepoRoot)(rushConfiguration.rushJsonFolder);
        const mergeCommit = this._git.getMergeBase(targetBranchName, terminal, shouldFetch);
        const repoChanges = (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__.getRepoChanges)(repoRoot, mergeCommit, gitPath);
        const changedProjects = new Set();
        if (includeExternalDependencies) {
            // Even though changing the installed version of a nested dependency merits a change file,
            // ignore lockfile changes for `rush change` for the moment
            // Determine the current variant from the link JSON.
            const variant = rushConfiguration.currentInstalledVariant;
            const fullShrinkwrapPath = rushConfiguration.getCommittedShrinkwrapFilename(variant);
            const shrinkwrapFile = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_0__.relative(repoRoot, fullShrinkwrapPath));
            const shrinkwrapStatus = repoChanges.get(shrinkwrapFile);
            if (shrinkwrapStatus) {
                if (shrinkwrapStatus.status !== 'M') {
                    terminal.writeLine(`Lockfile was created or deleted. Assuming all projects are affected.`);
                    return new Set(rushConfiguration.projects);
                }
                const { packageManager } = rushConfiguration;
                if (packageManager === 'pnpm') {
                    const currentShrinkwrap = _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__.PnpmShrinkwrapFile.loadFromFile(fullShrinkwrapPath);
                    if (!currentShrinkwrap) {
                        throw new Error(`Unable to obtain current shrinkwrap file.`);
                    }
                    const oldShrinkwrapText = this._git.getBlobContent({
                        // <ref>:<path> syntax: https://git-scm.com/docs/gitrevisions
                        blobSpec: `${mergeCommit}:${shrinkwrapFile}`,
                        repositoryRoot: repoRoot
                    });
                    const oldShrinkWrap = _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__.PnpmShrinkwrapFile.loadFromString(oldShrinkwrapText);
                    for (const project of rushConfiguration.projects) {
                        if (currentShrinkwrap
                            .getProjectShrinkwrap(project)
                            .hasChanges(oldShrinkWrap.getProjectShrinkwrap(project))) {
                            changedProjects.add(project);
                        }
                    }
                }
                else {
                    terminal.writeLine(`Lockfile has changed and lockfile content comparison is only supported for pnpm. Assuming all projects are affected.`);
                    return new Set(rushConfiguration.projects);
                }
            }
        }
        const changesByProject = new Map();
        const lookup = rushConfiguration.getProjectLookupForRoot(repoRoot);
        for (const [file, diffStatus] of repoChanges) {
            const project = lookup.findChildPath(file);
            if (project) {
                if (changedProjects.has(project)) {
                    // Lockfile changes cannot be ignored via rush-project.json
                    continue;
                }
                if (enableFiltering) {
                    let projectChanges = changesByProject.get(project);
                    if (!projectChanges) {
                        projectChanges = new Map();
                        changesByProject.set(project, projectChanges);
                    }
                    projectChanges.set(file, diffStatus);
                }
                else {
                    changedProjects.add(project);
                }
            }
        }
        if (enableFiltering) {
            // Reading rush-project.json may be problematic if, e.g. rush install has not yet occurred and rigs are in use
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(changesByProject, async ([project, projectChanges]) => {
                const filteredChanges = await this._filterProjectDataAsync(project, projectChanges, repoRoot, terminal);
                if (filteredChanges.size > 0) {
                    changedProjects.add(project);
                }
            }, { concurrency: 10 });
        }
        return changedProjects;
    }
    async _getDataAsync(terminal) {
        const repoState = await this._getRepoDepsAsync(terminal);
        if (!repoState) {
            // Mark as resolved, but no data
            return {
                projectState: undefined,
                rootDir: this._rushConfiguration.rushJsonFolder,
                rawHashes: new Map()
            };
        }
        const lookup = this._rushConfiguration.getProjectLookupForRoot(repoState.rootDir);
        const projectHashDeps = new Map();
        for (const project of this._rushConfiguration.projects) {
            projectHashDeps.set(project, new Map());
        }
        const { hashes: repoDeps, rootDir } = repoState;
        // Currently, only pnpm handles project shrinkwraps
        if (this._rushConfiguration.packageManager !== 'pnpm') {
            // Determine the current variant from the link JSON.
            const variant = this._rushConfiguration.currentInstalledVariant;
            // Add the shrinkwrap file to every project's dependencies
            const shrinkwrapFile = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_0__.relative(rootDir, this._rushConfiguration.getCommittedShrinkwrapFilename(variant)));
            const shrinkwrapHash = repoDeps.get(shrinkwrapFile);
            for (const projectDeps of projectHashDeps.values()) {
                if (shrinkwrapHash) {
                    projectDeps.set(shrinkwrapFile, shrinkwrapHash);
                }
            }
        }
        // Sort each project folder into its own package deps hash
        for (const [filePath, fileHash] of repoDeps) {
            // lookups in findChildPath are O(K)
            // K being the maximum folder depth of any project in rush.json (usually on the order of 3)
            const owningProject = lookup.findChildPath(filePath);
            if (owningProject) {
                const owningProjectHashDeps = projectHashDeps.get(owningProject);
                owningProjectHashDeps.set(filePath, fileHash);
            }
        }
        return {
            projectState: projectHashDeps,
            rootDir,
            rawHashes: repoState.hashes
        };
    }
    async _getIgnoreMatcherForProjectAsync(project, terminal) {
        const incrementalBuildIgnoredGlobs = await _api_RushProjectConfiguration__WEBPACK_IMPORTED_MODULE_9__.RushProjectConfiguration.tryLoadIgnoreGlobsForProjectAsync(project, terminal);
        if (incrementalBuildIgnoredGlobs && incrementalBuildIgnoredGlobs.length) {
            const ignoreMatcher = ignore__WEBPACK_IMPORTED_MODULE_2___default()();
            ignoreMatcher.add(incrementalBuildIgnoredGlobs);
            return ignoreMatcher;
        }
    }
    async _getRepoDepsAsync(terminal) {
        try {
            const gitPath = this._git.getGitPathOrThrow();
            if (this._git.isPathUnderGitWorkingTree()) {
                // Do not use getGitInfo().root; it is the root of the *primary* worktree, not the *current* one.
                const rootDir = (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__.getRepoRoot)(this._rushConfiguration.rushJsonFolder, gitPath);
                // Load the package deps hash for the whole repository
                // Include project shrinkwrap files as part of the computation
                const additionalFilesToHash = [];
                if (this._rushConfiguration.packageManager === 'pnpm') {
                    const absoluteFilePathsToCheck = [];
                    for (const project of this._rushConfiguration.projects) {
                        const projectShrinkwrapFilePath = _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_10__.BaseProjectShrinkwrapFile.getFilePathForProject(project);
                        absoluteFilePathsToCheck.push(projectShrinkwrapFilePath);
                        const relativeProjectShrinkwrapFilePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_0__.relative(rootDir, projectShrinkwrapFilePath));
                        additionalFilesToHash.push(relativeProjectShrinkwrapFilePath);
                    }
                    await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(absoluteFilePathsToCheck, async (filePath) => {
                        if (!(await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.existsAsync(filePath))) {
                            throw new Error(`A project dependency file (${filePath}) is missing. You may need to run ` +
                                '"rush install" or "rush update".');
                        }
                    });
                }
                const hashes = await (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_3__.getRepoStateAsync)(rootDir, additionalFilesToHash, gitPath);
                return {
                    gitPath,
                    hashes,
                    rootDir
                };
            }
            else {
                return undefined;
            }
        }
        catch (e) {
            // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about
            // the state of the files in the repo. This can happen if the environment doesn't have Git.
            terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`);
            return undefined;
        }
    }
}
//# sourceMappingURL=ProjectChangeAnalyzer.js.map

/***/ }),

/***/ 949799:
/*!***********************************************!*\
  !*** ./lib-esnext/logic/ProjectCommandSet.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectCommandSet": () => (/* binding */ ProjectCommandSet)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Parses the "scripts" section from package.json and provides support for executing scripts.
 */
class ProjectCommandSet {
    constructor(packageJson) {
        this.malformedScriptNames = [];
        this.commandNames = [];
        this._scriptsByName = new Map();
        const scripts = packageJson.scripts || {};
        for (const scriptName of Object.keys(scripts)) {
            if (scriptName[0] === '-' || scriptName.length === 0) {
                this.malformedScriptNames.push(scriptName);
            }
            else {
                this.commandNames.push(scriptName);
                this._scriptsByName.set(scriptName, scripts[scriptName]);
            }
        }
        this.commandNames.sort();
    }
    tryGetScriptBody(commandName) {
        return this._scriptsByName.get(commandName);
    }
    getScriptBody(commandName) {
        const result = this.tryGetScriptBody(commandName);
        if (result === undefined) {
            throw new Error(`The command "${commandName}" was not found`);
        }
        return result;
    }
}
//# sourceMappingURL=ProjectCommandSet.js.map

/***/ }),

/***/ 797811:
/*!****************************************!*\
  !*** ./lib-esnext/logic/PublishGit.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PublishGit": () => (/* binding */ PublishGit)
/* harmony export */ });
/* harmony import */ var _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PublishUtilities */ 189294);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


const DUMMY_BRANCH_NAME = '-branch-name-';
class PublishGit {
    constructor(git, targetBranch) {
        this._targetBranch = targetBranch;
        this._gitPath = git.getGitPathOrThrow();
        this._gitTagSeparator = git.getTagSeparator();
    }
    checkout(branchName, createBranch = false) {
        const params = ['checkout'];
        if (createBranch) {
            params.push('-b');
        }
        params.push(branchName || DUMMY_BRANCH_NAME);
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);
    }
    merge(branchName, verify = false) {
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
            'merge',
            branchName,
            '--no-edit',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    deleteBranch(branchName, hasRemote = true, verify = false) {
        if (!branchName) {
            branchName = DUMMY_BRANCH_NAME;
        }
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['branch', '-d', branchName]);
        if (hasRemote) {
            _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
                'push',
                'origin',
                '--delete',
                branchName,
                ...(verify ? [] : ['--no-verify'])
            ]);
        }
    }
    pull(verify = false) {
        const params = ['pull', 'origin'];
        if (this._targetBranch) {
            params.push(this._targetBranch);
        }
        if (!verify) {
            params.push('--no-verify');
        }
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);
    }
    fetch() {
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['fetch', 'origin']);
    }
    addChanges(pathspec, workingDirectory) {
        const files = pathspec ? pathspec : '.';
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['add', files], workingDirectory ? workingDirectory : process.cwd());
    }
    addTag(shouldExecute, packageName, packageVersion, commitId, preReleaseName) {
        // Tagging only happens if we're publishing to real NPM and committing to git.
        const tagName = _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.createTagname(packageName, packageVersion, this._gitTagSeparator);
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch && shouldExecute, this._gitPath, [
            'tag',
            '-a',
            preReleaseName ? `${tagName}-${preReleaseName}` : tagName,
            '-m',
            preReleaseName
                ? `${packageName} v${packageVersion}-${preReleaseName}`
                : `${packageName} v${packageVersion}`,
            ...(commitId ? [commitId] : [])
        ]);
    }
    hasTag(packageConfig) {
        const tagName = _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.createTagname(packageConfig.packageName, packageConfig.packageJson.version, this._gitTagSeparator);
        const tagOutput = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_1__.Utilities.executeCommandAndCaptureOutput(this._gitPath, ['tag', '-l', tagName], packageConfig.projectFolder, _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.getEnvArgs(), true).replace(/(\r\n|\n|\r)/gm, '');
        return tagOutput === tagName;
    }
    commit(commitMessage, verify = false) {
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
            'commit',
            '-m',
            commitMessage,
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    push(branchName, verify = false) {
        _PublishUtilities__WEBPACK_IMPORTED_MODULE_0__.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, 
        // We append "--no-verify" to prevent Git hooks from running.  For example, people may
        // want to invoke "rush change -v" as a pre-push hook.
        [
            'push',
            'origin',
            `HEAD:${branchName || DUMMY_BRANCH_NAME}`,
            '--follow-tags',
            '--verbose',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
}
//# sourceMappingURL=PublishGit.js.map

/***/ }),

/***/ 189294:
/*!**********************************************!*\
  !*** ./lib-esnext/logic/PublishUtilities.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PublishUtilities": () => (/* binding */ PublishUtilities)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ 532081);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/ChangeManagement */ 780924);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DependencySpecifier */ 68654);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Git */ 668229);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This file contains a set of helper functions that are unit tested and used with the PublishAction,
 * which itself is a thin wrapper around these helpers.
 */








class PublishUtilities {
    /**
     * Finds change requests in the given folder.
     * @param changesPath Path to the changes folder.
     * @returns Dictionary of all change requests, keyed by package name.
     */
    static async findChangeRequestsAsync(allPackages, rushConfiguration, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {
        const allChanges = {
            packageChanges: new Map(),
            versionPolicyChanges: new Map()
        };
        // eslint-disable-next-line no-console
        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);
        const files = await changeFiles.getFilesAsync();
        // Add the minimum changes defined by the change descriptions.
        for (const changeFilePath of files) {
            const changeRequest = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.JsonFile.load(changeFilePath);
            if (includeCommitDetails) {
                const git = new _Git__WEBPACK_IMPORTED_MODULE_4__.Git(rushConfiguration);
                PublishUtilities._updateCommitDetails(git, changeFilePath, changeRequest.changes);
            }
            for (const change of changeRequest.changes) {
                PublishUtilities._addChange({
                    change,
                    changeFilePath,
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
            }
        }
        // keep resolving downstream dependency changes and version policy changes
        // until no more changes are detected
        let hasChanges;
        do {
            hasChanges = false;
            // For each requested package change, ensure downstream dependencies are also updated.
            allChanges.packageChanges.forEach((change, packageName) => {
                hasChanges =
                    PublishUtilities._updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
            });
            // Bump projects affected by the version policy changes.
            allPackages.forEach((project) => {
                const versionPolicyChange = project.versionPolicyName !== undefined
                    ? allChanges.versionPolicyChanges.get(project.versionPolicyName)
                    : undefined;
                if (versionPolicyChange === undefined) {
                    return;
                }
                const projectHasChanged = this._addChange({
                    change: {
                        packageName: project.packageName,
                        changeType: versionPolicyChange.changeType,
                        newVersion: versionPolicyChange.newVersion // enforce the specific policy version
                    },
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
                if (projectHasChanged) {
                    // eslint-disable-next-line no-console
                    console.log(`\n* APPLYING: update ${project.packageName} to version ${versionPolicyChange.newVersion}`);
                }
                hasChanges = projectHasChanged || hasChanges;
            });
        } while (hasChanges);
        // Update orders so that downstreams are marked to come after upstreams.
        allChanges.packageChanges.forEach((change, packageName) => {
            const project = allPackages.get(packageName);
            const packageJson = project.packageJson;
            const deps = project.consumingProjects;
            // Write the new version expected for the change.
            const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
            if (skipVersionBump) {
                change.newVersion = packageJson.version;
            }
            else {
                // For hotfix changes, do not re-write new version
                change.newVersion =
                    change.changeType >= _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.patch
                        ? semver__WEBPACK_IMPORTED_MODULE_1__.inc(packageJson.version, PublishUtilities._getReleaseType(change.changeType))
                        : change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix
                            ? change.newVersion
                            : packageJson.version;
            }
            if (deps) {
                for (const dep of deps) {
                    const depChange = allChanges.packageChanges.get(dep.packageName);
                    if (depChange) {
                        depChange.order = Math.max(change.order + 1, depChange.order);
                    }
                }
            }
        });
        return allChanges;
    }
    /**
     * Given the changes hash, flattens them into a sorted array based on their dependency order.
     * @params packageChanges - hash of change requests.
     * @returns Sorted array of change requests.
     */
    static sortChangeRequests(packageChanges) {
        return [...packageChanges.values()].sort((a, b) => a.order === b.order ? a.packageName.localeCompare(b.packageName) : a.order < b.order ? -1 : 1);
    }
    /**
     * Given a single change request, updates the package json file with updated versions on disk.
     */
    static updatePackages(allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const updatedPackages = new Map();
        allChanges.packageChanges.forEach((change, packageName) => {
            const updatedPackage = PublishUtilities._writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude);
            updatedPackages.set(updatedPackage.name, updatedPackage);
        });
        return updatedPackages;
    }
    /**
     * Returns the generated tagname to use for a published commit, given package name and version.
     */
    static createTagname(packageName, version, separator = _Git__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_GIT_TAG_SEPARATOR) {
        return packageName + `${separator}v` + version;
    }
    static isRangeDependency(version) {
        const LOOSE_PKG_REGEX = />=?(?:\d+\.){2}\d+(\-[0-9A-Za-z-.]*)?\s+<(?:\d+\.){2}\d+/;
        return LOOSE_PKG_REGEX.test(version);
    }
    static getEnvArgs() {
        const env = {};
        // Copy existing process.env values (for nodist)
        Object.keys(process.env).forEach((key) => {
            env[key] = process.env[key];
        });
        return env;
    }
    /**
     * @param secretSubstring -- if specified, a substring to be replaced by `<<SECRET>>` to avoid printing secrets
     * on the console
     */
    static execCommand(shouldExecute, command, args = [], workingDirectory = process.cwd(), environment, secretSubstring) {
        let relativeDirectory = path__WEBPACK_IMPORTED_MODULE_0__.relative(process.cwd(), workingDirectory);
        if (relativeDirectory) {
            relativeDirectory = `(${relativeDirectory})`;
        }
        let commandArgs = args.join(' ');
        if (secretSubstring && secretSubstring.length > 0) {
            // Avoid printing the NPM publish token on the console when displaying the commandArgs
            commandArgs = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Text.replaceAll(commandArgs, secretSubstring, '<<SECRET>>');
        }
        // eslint-disable-next-line no-console
        console.log(`\n* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${commandArgs} ${relativeDirectory}`);
        if (shouldExecute) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_6__.Utilities.executeCommand({
                command,
                args,
                workingDirectory,
                environment,
                suppressOutput: false,
                keepEnvironment: true
            });
        }
    }
    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {
        const currentDependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifier(dependencyName, dependencies[dependencyName]);
        const currentDependencyVersion = currentDependencySpecifier.versionSpecifier;
        let newDependencyVersion;
        if (currentDependencyVersion === '*') {
            newDependencyVersion = '*';
        }
        else if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {
            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);
        }
        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {
            newDependencyVersion = '~' + newProjectVersion;
        }
        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {
            newDependencyVersion = '^' + newProjectVersion;
        }
        else {
            newDependencyVersion = newProjectVersion;
        }
        return currentDependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifierType.Workspace
            ? `workspace:${newDependencyVersion}`
            : newDependencyVersion;
    }
    static _getReleaseType(changeType) {
        switch (changeType) {
            case _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.major:
                return 'major';
            case _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.minor:
                return 'minor';
            case _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.patch:
                return 'patch';
            case _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix:
                return 'prerelease';
            default:
                throw new Error(`Wrong change type ${changeType}`);
        }
    }
    static _getChangeTypeForSemverReleaseType(releaseType) {
        switch (releaseType) {
            case 'major':
                return _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.major;
            case 'minor':
                return _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.minor;
            case 'patch':
                return _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.patch;
            case 'premajor':
            case 'prepatch':
            case 'prerelease':
                return _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix;
            default:
                throw new Error(`Unsupported release type "${releaseType}"`);
        }
    }
    static _getNewRangeDependency(newVersion) {
        let upperLimit = newVersion;
        if (semver__WEBPACK_IMPORTED_MODULE_1__.prerelease(newVersion)) {
            // Remove the prerelease first, then bump major.
            upperLimit = semver__WEBPACK_IMPORTED_MODULE_1__.inc(newVersion, 'patch');
        }
        upperLimit = semver__WEBPACK_IMPORTED_MODULE_1__.inc(upperLimit, 'major');
        return `>=${newVersion} <${upperLimit}`;
    }
    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {
        // Suffix does not bump up the version.
        // Excluded projects do not bump up version.
        return ((prereleaseToken && prereleaseToken.isSuffix) ||
            (projectsToExclude && projectsToExclude.has(project.packageName)) ||
            !project.shouldPublish);
    }
    static _updateCommitDetails(git, filename, changes) {
        try {
            const gitPath = git.getGitPathOrThrow();
            const fileLog = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.execSync)(`${gitPath} log -n 1 ${filename}`, {
                cwd: path__WEBPACK_IMPORTED_MODULE_0__.dirname(filename)
            }).toString();
            const author = fileLog.match(/Author: (.*)/)[1];
            const commit = fileLog.match(/commit (.*)/)[1];
            changes.forEach((change) => {
                change.author = author;
                change.commit = commit;
            });
        }
        catch (e) {
            /* no-op, best effort. */
        }
    }
    static _writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const project = allPackages.get(change.packageName);
        const packageJson = project.packageJson;
        const shouldSkipVersionBump = !project.shouldPublish || (!!projectsToExclude && projectsToExclude.has(change.packageName));
        const newVersion = shouldSkipVersionBump
            ? packageJson.version
            : PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);
        if (!shouldSkipVersionBump) {
            // eslint-disable-next-line no-console
            console.log(`\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType[change.changeType]} update ` +
                `for ${change.packageName} to ${newVersion}`);
        }
        else {
            // eslint-disable-next-line no-console
            console.log(`\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update for ${change.packageName} at ${newVersion}`);
        }
        const packagePath = path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileConstants.PackageJson);
        packageJson.version = newVersion;
        // Update the package's dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's dev dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.devDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's peer dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.peerDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        change.changes.forEach((subChange) => {
            if (subChange.comment) {
                // eslint-disable-next-line no-console
                console.log(` - [${_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType[subChange.changeType]}] ${subChange.comment}`);
            }
        });
        if (shouldCommit) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.JsonFile.save(packageJson, packagePath, { updateExistingFile: true });
        }
        return packageJson;
    }
    static _isCyclicDependency(allPackages, packageName, dependencyName) {
        const packageConfig = allPackages.get(packageName);
        return !!packageConfig && packageConfig.decoupledLocalDependencies.has(dependencyName);
    }
    static _updateDependencies(packageName, dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        if (dependencies) {
            Object.keys(dependencies).forEach((depName) => {
                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {
                    const depChange = allChanges.packageChanges.get(depName);
                    if (!depChange) {
                        return;
                    }
                    const depProject = allPackages.get(depName);
                    if (!depProject.shouldPublish || (projectsToExclude && projectsToExclude.has(depName))) {
                        // No version change.
                        return;
                    }
                    else if (prereleaseToken &&
                        prereleaseToken.hasValue &&
                        prereleaseToken.isPartialPrerelease &&
                        depChange.changeType < _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix) {
                        // For partial prereleases, do not version bump dependencies with the `prereleaseToken`
                        // value unless an actual change (hotfix, patch, minor, major) has occurred
                        return;
                    }
                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {
                        // TODO: treat prerelease version the same as non-prerelease version.
                        // For prerelease, the newVersion needs to be appended with prerelease name.
                        // And dependency should specify the specific prerelease version.
                        const currentSpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifier(depName, dependencies[depName]);
                        const newVersion = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);
                        dependencies[depName] =
                            currentSpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifierType.Workspace
                                ? `workspace:${newVersion}`
                                : newVersion;
                    }
                    else if (depChange && depChange.changeType >= _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix) {
                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages, rushConfiguration);
                    }
                }
            });
        }
    }
    /**
     * Gets the new version from the ChangeInfo.
     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,
     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why
     * this function should return a pre-released patch for that case. The exception to this is when we're
     * running a partial pre-release build. In this case, only user-changed packages should update.
     */
    static _getChangeInfoNewVersion(change, prereleaseToken) {
        let newVersion = change.newVersion;
        if (prereleaseToken && prereleaseToken.hasValue) {
            if (prereleaseToken.isPartialPrerelease && change.changeType <= _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix) {
                return newVersion;
            }
            if (prereleaseToken.isPrerelease && change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.dependency) {
                newVersion = semver__WEBPACK_IMPORTED_MODULE_1__.inc(newVersion, 'patch');
            }
            return `${newVersion}-${prereleaseToken.name}`;
        }
        else {
            return newVersion;
        }
    }
    /**
     * Adds the given change to the packageChanges map.
     *
     * @returns true if the change caused the dependency change type to increase.
     */
    static _addChange({ change, changeFilePath, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude }) {
        var _a, _b, _c;
        let hasChanged = false;
        const packageName = change.packageName;
        const project = allPackages.get(packageName);
        if (!project) {
            // eslint-disable-next-line no-console
            console.log(`The package ${packageName} was requested for publishing but does not exist. Skip this change.`);
            return false;
        }
        const packageJson = project.packageJson;
        // If the given change does not have a changeType, derive it from the "type" string.
        if (change.changeType === undefined) {
            change.changeType = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Enum.tryGetValueByKey(_api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType, change.type);
            if (change.changeType === undefined) {
                if (changeFilePath) {
                    throw new Error(`Invalid change type ${JSON.stringify(change.type)} in ${changeFilePath}`);
                }
                else {
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.InternalError(`Invalid change type ${JSON.stringify(change.type)}`);
                }
            }
        }
        let currentChange = allChanges.packageChanges.get(packageName);
        if (currentChange === undefined) {
            hasChanged = true;
            currentChange = {
                packageName,
                changeType: change.changeType,
                order: 0,
                changes: [change]
            };
            allChanges.packageChanges.set(packageName, currentChange);
        }
        else {
            const oldChangeType = currentChange.changeType;
            if (oldChangeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix && change.changeType > oldChangeType) {
                throw new Error(`Cannot apply ${this._getReleaseType(change.changeType)} change after hotfix on same package`);
            }
            if (change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix && oldChangeType > change.changeType) {
                throw new Error(`Cannot apply hotfix alongside ${this._getReleaseType(oldChangeType)} change on same package`);
            }
            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);
            currentChange.changes.push(change);
            hasChanged = hasChanged || oldChangeType !== currentChange.changeType;
            hasChanged =
                hasChanged ||
                    (change.newVersion !== undefined &&
                        currentChange.newVersion !== undefined &&
                        semver__WEBPACK_IMPORTED_MODULE_1__.gt(change.newVersion, currentChange.newVersion));
        }
        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
        if (skipVersionBump) {
            currentChange.newVersion = (_a = change.newVersion) !== null && _a !== void 0 ? _a : packageJson.version;
            hasChanged = false;
            currentChange.changeType = _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.none;
        }
        else {
            if (change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix) {
                const prereleaseComponents = semver__WEBPACK_IMPORTED_MODULE_1__.prerelease(packageJson.version);
                if (!rushConfiguration.hotfixChangeEnabled) {
                    throw new Error(`Cannot add hotfix change; hotfixChangeEnabled is false in configuration.`);
                }
                currentChange.newVersion = (_b = change.newVersion) !== null && _b !== void 0 ? _b : packageJson.version;
                if (!prereleaseComponents) {
                    currentChange.newVersion += '-hotfix';
                }
                currentChange.newVersion = semver__WEBPACK_IMPORTED_MODULE_1__.inc(currentChange.newVersion, 'prerelease');
            }
            else {
                // When there are multiple changes of this package, the final value of new version
                // should not depend on the order of the changes.
                let packageVersion = (_c = change.newVersion) !== null && _c !== void 0 ? _c : packageJson.version;
                if (currentChange.newVersion && semver__WEBPACK_IMPORTED_MODULE_1__.gt(currentChange.newVersion, packageVersion)) {
                    packageVersion = currentChange.newVersion;
                }
                const shouldBump = change.newVersion === undefined && change.changeType >= _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix;
                currentChange.newVersion = shouldBump
                    ? semver__WEBPACK_IMPORTED_MODULE_1__.inc(packageVersion, PublishUtilities._getReleaseType(currentChange.changeType))
                    : packageVersion;
                // set versionpolicy version to the current version
                if (hasChanged &&
                    project.versionPolicyName !== undefined &&
                    project.versionPolicy !== undefined &&
                    project.versionPolicy.isLockstepped) {
                    const projectVersionPolicy = project.versionPolicy;
                    const currentVersionPolicyChange = allChanges.versionPolicyChanges.get(project.versionPolicyName);
                    if (projectVersionPolicy.nextBump === undefined &&
                        (currentVersionPolicyChange === undefined ||
                            semver__WEBPACK_IMPORTED_MODULE_1__.gt(currentChange.newVersion, currentVersionPolicyChange.newVersion))) {
                        allChanges.versionPolicyChanges.set(project.versionPolicyName, {
                            versionPolicyName: project.versionPolicyName,
                            changeType: currentChange.changeType,
                            newVersion: currentChange.newVersion
                        });
                    }
                }
            }
            // If hotfix change, force new range dependency to be the exact new version
            currentChange.newRangeDependency =
                change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix
                    ? currentChange.newVersion
                    : PublishUtilities._getNewRangeDependency(currentChange.newVersion);
        }
        return hasChanged;
    }
    static _updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        let hasChanges = false;
        const packageName = change.packageName;
        const downstream = allPackages.get(packageName).consumingProjects;
        // Iterate through all downstream dependencies for the package.
        if (downstream) {
            if (change.changeType >= _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix || (prereleaseToken && prereleaseToken.hasValue)) {
                for (const dependency of downstream) {
                    const packageJson = dependency.packageJson;
                    hasChanges =
                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                    hasChanges =
                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.devDependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                }
            }
        }
        return hasChanges;
    }
    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        let hasChanges = false;
        if (dependencies &&
            dependencies[change.packageName] &&
            !PublishUtilities._isCyclicDependency(allPackages, parentPackageName, change.packageName)) {
            const requiredVersion = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifier(change.packageName, dependencies[change.packageName]);
            const isWorkspaceWildcardVersion = requiredVersion.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifierType.Workspace &&
                requiredVersion.versionSpecifier === '*';
            const isPrerelease = !!prereleaseToken && prereleaseToken.hasValue && !allChanges.packageChanges.has(parentPackageName);
            // If the version range exists and has not yet been updated to this version, update it.
            if (isPrerelease ||
                isWorkspaceWildcardVersion ||
                requiredVersion.versionSpecifier !== change.newRangeDependency) {
                let changeType;
                // Propagate hotfix changes to dependencies
                if (change.changeType === _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix) {
                    changeType = _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.hotfix;
                }
                else {
                    // Either it already satisfies the new version, or doesn't.
                    // If not, the downstream dep needs to be republished.
                    // The downstream dep will also need to be republished if using `workspace:*` as this will publish
                    // as the exact version.
                    changeType =
                        !isWorkspaceWildcardVersion &&
                            semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(change.newVersion, requiredVersion.versionSpecifier)
                            ? _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.dependency
                            : _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.patch;
                }
                hasChanges = PublishUtilities._addChange({
                    change: {
                        packageName: parentPackageName,
                        changeType
                    },
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
                if (hasChanges || isPrerelease) {
                    // Only re-evaluate downstream dependencies if updating the parent package's dependency
                    // caused a version bump.
                    hasChanges =
                        PublishUtilities._updateDownstreamDependencies(allChanges.packageChanges.get(parentPackageName), allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                }
            }
        }
        return hasChanges;
    }
    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages, rushConfiguration) {
        let currentDependencyVersion = dependencies[dependencyName];
        let newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);
        dependencies[dependencyName] = newDependencyVersion;
        // "*" is a special case for workspace ranges, since it will publish using the exact
        // version of the local dependency, so we need to modify what we write for our change
        // comment
        const currentDependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifier(dependencyName, currentDependencyVersion);
        currentDependencyVersion =
            currentDependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifierType.Workspace &&
                currentDependencySpecifier.versionSpecifier === '*'
                ? undefined
                : currentDependencySpecifier.versionSpecifier;
        const newDependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifier(dependencyName, newDependencyVersion);
        newDependencyVersion =
            newDependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_7__.DependencySpecifierType.Workspace &&
                newDependencySpecifier.versionSpecifier === '*'
                ? dependencyChange.newVersion
                : newDependencySpecifier.versionSpecifier;
        // Add dependency version update comment.
        PublishUtilities._addChange({
            change: {
                packageName: packageName,
                changeType: _api_ChangeManagement__WEBPACK_IMPORTED_MODULE_5__.ChangeType.dependency,
                comment: `Updating dependency "${dependencyName}" ` +
                    (currentDependencyVersion ? `from \`${currentDependencyVersion}\` ` : '') +
                    `to \`${newDependencyVersion}\``
            },
            allChanges,
            allPackages,
            rushConfiguration
        });
    }
}
//# sourceMappingURL=PublishUtilities.js.map

/***/ }),

/***/ 371186:
/*!******************************************!*\
  !*** ./lib-esnext/logic/PurgeManager.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PurgeManager": () => (/* binding */ PurgeManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_AsyncRecycler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/AsyncRecycler */ 21526);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * This class implements the logic for "rush purge"
 */
class PurgeManager {
    constructor(rushConfiguration, rushGlobalFolder) {
        this._rushConfiguration = rushConfiguration;
        this._rushGlobalFolder = rushGlobalFolder;
        const commonAsyncRecyclerPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.rushRecyclerFolderName);
        this.commonTempFolderRecycler = new _utilities_AsyncRecycler__WEBPACK_IMPORTED_MODULE_3__.AsyncRecycler(commonAsyncRecyclerPath);
        const rushUserAsyncRecyclerPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushGlobalFolder.path, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.rushRecyclerFolderName);
        this._rushUserFolderRecycler = new _utilities_AsyncRecycler__WEBPACK_IMPORTED_MODULE_3__.AsyncRecycler(rushUserAsyncRecyclerPath);
    }
    /**
     * Performs the AsyncRecycler.deleteAll() operation.  This should be called before
     * the PurgeManager instance is disposed.
     */
    deleteAll() {
        this.commonTempFolderRecycler.deleteAll();
        this._rushUserFolderRecycler.deleteAll();
    }
    /**
     * Delete everything from the common/temp folder
     */
    purgeNormal() {
        // Delete everything under common\temp except for the recycler folder itself
        // eslint-disable-next-line no-console
        console.log('Purging ' + this._rushConfiguration.commonTempFolder);
        this.commonTempFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.commonTempFolder, this._getMembersToExclude(this._rushConfiguration.commonTempFolder, true));
    }
    /**
     * In addition to performing the purgeNormal() operation, this method also cleans the
     * .rush folder in the user's home directory.
     */
    purgeUnsafe() {
        this.purgeNormal();
        // We will delete everything under ~/.rush/ except for the recycler folder itself
        // eslint-disable-next-line no-console
        console.log('Purging ' + this._rushGlobalFolder.path);
        // If Rush itself is running under a folder such as  ~/.rush/node-v4.5.6/rush-1.2.3,
        // we cannot delete that folder.
        // First purge the node-specific folder, e.g. ~/.rush/node-v4.5.6/* except for rush-1.2.3:
        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.nodeSpecificPath, this._getMembersToExclude(this._rushGlobalFolder.nodeSpecificPath, true));
        // Then purge the the global folder, e.g. ~/.rush/* except for node-v4.5.6
        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.path, this._getMembersToExclude(this._rushGlobalFolder.path, false));
        if (this._rushConfiguration.packageManager === 'pnpm' &&
            this._rushConfiguration.pnpmOptions.pnpmStore === 'global' &&
            this._rushConfiguration.pnpmOptions.pnpmStorePath) {
            // eslint-disable-next-line no-console
            console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Purging the global pnpm-store`));
            this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.pnpmOptions.pnpmStorePath);
        }
    }
    _getMembersToExclude(folderToRecycle, showWarning) {
        // Don't recycle the recycler
        const membersToExclude = [_logic_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.rushRecyclerFolderName];
        // If the current process is running inside one of the folders, don't recycle that either
        // Example: "/home/user/.rush/rush-1.2.3/lib/example.js"
        const currentFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(__dirname);
        // Example:
        // folderToRecycle = "/home/user/.rush/node-v4.5.6"
        // relative =  "rush-1.2.3/lib/example.js"
        const relative = path__WEBPACK_IMPORTED_MODULE_1__.relative(folderToRecycle, currentFolderPath);
        // (The result can be an absolute path if the two folders are on different drive letters)
        if (!path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute(relative)) {
            // Get the first path segment:
            const firstPart = relative.split(/[\\\/]/)[0];
            if (firstPart.length > 0 && firstPart !== '..') {
                membersToExclude.push(firstPart);
                if (showWarning) {
                    // Warn that we won't dispose this folder
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow("The active process's folder will not be deleted: " + path__WEBPACK_IMPORTED_MODULE_1__.join(folderToRecycle, firstPart)));
                }
            }
        }
        return membersToExclude;
    }
}
//# sourceMappingURL=PurgeManager.js.map

/***/ }),

/***/ 880175:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/RepoStateFile.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RepoStateFile": () => (/* binding */ RepoStateFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pnpm/PnpmShrinkwrapFile */ 930997);
/* harmony import */ var _schemas_repo_state_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../schemas/repo-state.schema.json */ 81360);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * This file is used to track the state of various Rush-related features. It is generated
 * and updated by Rush.
 *
 * @public
 */
class RepoStateFile {
    constructor(repoStateJson, isValid, filePath, variant) {
        this._modified = false;
        this.filePath = filePath;
        this._variant = variant;
        this._isValid = isValid;
        if (repoStateJson) {
            this._pnpmShrinkwrapHash = repoStateJson.pnpmShrinkwrapHash;
            this._preferredVersionsHash = repoStateJson.preferredVersionsHash;
        }
    }
    /**
     * The hash of the pnpm shrinkwrap file at the end of the last update.
     */
    get pnpmShrinkwrapHash() {
        return this._pnpmShrinkwrapHash;
    }
    /**
     * The hash of all preferred versions at the end of the last update.
     */
    get preferredVersionsHash() {
        return this._preferredVersionsHash;
    }
    /**
     * If false, the repo-state.json file is not valid and its values cannot be relied upon
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * Loads the repo-state.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     *
     * @param jsonFilename - The path to the repo-state.json file.
     * @param variant - The variant currently being used by Rush.
     */
    static loadFromFile(jsonFilename, variant) {
        let fileContents;
        try {
            fileContents = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFile(jsonFilename);
        }
        catch (error) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
                throw error;
            }
        }
        let foundMergeConflictMarker = false;
        let repoStateJson = undefined;
        if (fileContents) {
            try {
                repoStateJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.parseString(fileContents);
            }
            catch (error) {
                // Look for a Git merge conflict marker. PNPM gracefully handles merge conflicts in pnpm-lock.yaml,
                // so a user should be able to just run "rush update" if they get conflicts in pnpm-lock.yaml
                // and repo-state.json and have Rush update both.
                for (let nextNewlineIndex = 0; nextNewlineIndex > -1; nextNewlineIndex = fileContents.indexOf('\n', nextNewlineIndex + 1)) {
                    if (fileContents.substr(nextNewlineIndex + 1, 7) === '<<<<<<<') {
                        foundMergeConflictMarker = true;
                        repoStateJson = {
                            preferredVersionsHash: 'INVALID',
                            pnpmShrinkwrapHash: 'INVALID'
                        };
                        break;
                    }
                }
            }
            if (repoStateJson) {
                this._jsonSchema.validateObject(repoStateJson, jsonFilename);
            }
        }
        return new RepoStateFile(repoStateJson, !foundMergeConflictMarker, jsonFilename, variant);
    }
    /**
     * Refresh the data contained in repo-state.json using the current state
     * of the Rush repo, and save the file if changes were made.
     *
     * @param rushConfiguration - The Rush configuration for the repo.
     *
     * @returns true if the file was modified, otherwise false.
     */
    refreshState(rushConfiguration) {
        // Only support saving the pnpm shrinkwrap hash if it was enabled
        const preventShrinkwrapChanges = rushConfiguration.packageManager === 'pnpm' &&
            rushConfiguration.pnpmOptions &&
            rushConfiguration.pnpmOptions.preventManualShrinkwrapChanges;
        if (preventShrinkwrapChanges) {
            const pnpmShrinkwrapFile = _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__.PnpmShrinkwrapFile.loadFromFile(rushConfiguration.getCommittedShrinkwrapFilename(this._variant));
            if (pnpmShrinkwrapFile) {
                const shrinkwrapFileHash = pnpmShrinkwrapFile.getShrinkwrapHash(rushConfiguration.experimentsConfiguration.configuration);
                if (this._pnpmShrinkwrapHash !== shrinkwrapFileHash) {
                    this._pnpmShrinkwrapHash = shrinkwrapFileHash;
                    this._modified = true;
                }
            }
        }
        else if (this._pnpmShrinkwrapHash !== undefined) {
            this._pnpmShrinkwrapHash = undefined;
            this._modified = true;
        }
        // Currently, only support saving the preferred versions hash if using workspaces
        const useWorkspaces = rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.useWorkspaces;
        if (useWorkspaces) {
            const commonVersions = rushConfiguration.getCommonVersions(this._variant);
            const preferredVersionsHash = commonVersions.getPreferredVersionsHash();
            if (this._preferredVersionsHash !== preferredVersionsHash) {
                this._preferredVersionsHash = preferredVersionsHash;
                this._modified = true;
            }
        }
        else if (this._preferredVersionsHash !== undefined) {
            this._preferredVersionsHash = undefined;
            this._modified = true;
        }
        // Now that the file has been refreshed, we know its contents are valid
        this._isValid = true;
        return this._saveIfModified();
    }
    /**
     * Writes the "repo-state.json" file to disk, using the filename that was passed to loadFromFile().
     */
    _saveIfModified() {
        if (this._modified) {
            const content = '// DO NOT MODIFY THIS FILE MANUALLY BUT DO COMMIT IT. It is generated and used by Rush.' +
                `${_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.NewlineKind.Lf}${this._serialize()}`;
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFile(this.filePath, content);
            this._modified = false;
            return true;
        }
        return false;
    }
    _serialize() {
        // We need to set these one-by-one, since JsonFile.stringify does not like undefined values
        const repoStateJson = {};
        if (this._pnpmShrinkwrapHash) {
            repoStateJson.pnpmShrinkwrapHash = this._pnpmShrinkwrapHash;
        }
        if (this._preferredVersionsHash) {
            repoStateJson.preferredVersionsHash = this._preferredVersionsHash;
        }
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.stringify(repoStateJson, { newlineConversion: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.NewlineKind.Lf });
    }
}
RepoStateFile._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_repo_state_schema_json__WEBPACK_IMPORTED_MODULE_2__);

//# sourceMappingURL=RepoStateFile.js.map

/***/ }),

/***/ 951904:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/RushConstants.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushConstants": () => (/* binding */ RushConstants)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Constants used by the Rush tool.
 * @beta
 *
 * @remarks
 *
 * These are NOT part of the public API surface for rush-lib.
 * The rationale is that we don't want people implementing custom parsers for
 * the Rush config files; instead, they should rely on the official APIs from rush-lib.
 */
class RushConstants {
}
/**
 * The filename ("browser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';
/**
 * The folder name ("changes") where change files will be stored.
 */
RushConstants.changeFilesFolderName = 'changes';
/**
 * The filename ("nonbrowser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';
/**
 * The folder name ("common") where Rush's common data will be stored.
 */
RushConstants.commonFolderName = 'common';
/**
 * The NPM scope ("\@rush-temp") that is used for Rush's temporary projects.
 */
RushConstants.rushTempNpmScope = '@rush-temp';
/**
 * The folder name ("temp") under the common folder, or under the .rush folder in each project's directory where
 * temporary files will be stored.
 * Example: `C:\MyRepo\common\temp`
 */
RushConstants.rushTempFolderName = 'temp';
/**
 * The folder name ("projects") where temporary projects will be stored.
 * Example: `C:\MyRepo\common\temp\projects`
 */
RushConstants.rushTempProjectsFolderName = 'projects';
/**
 * The folder name ("variants") under which named variant configurations for
 * alternate dependency sets may be found.
 * Example: `C:\MyRepo\common\config\rush\variants`
 */
RushConstants.rushVariantsFolderName = 'variants';
/**
 * The filename ("npm-shrinkwrap.json") used to store an installation plan for the NPM package manger.
 */
RushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';
/**
 * Number of installation attempts
 */
RushConstants.defaultMaxInstallAttempts = 1;
/**
 * The filename ("pnpm-lock.yaml") used to store an installation plan for the PNPM package manger
 * (PNPM version 3.x and later).
 */
RushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';
/**
 * The filename ("pnpmfile.js") used to add custom configuration to PNPM (PNPM version 1.x and later).
 */
RushConstants.pnpmfileV1Filename = 'pnpmfile.js';
/**
 * The filename (".pnpmfile.cjs") used to add custom configuration to PNPM (PNPM version 6.x and later).
 */
RushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';
/**
 * The folder name used to store patch files for pnpm
 * Example: `C:\MyRepo\common\config\pnpm-patches`
 * Example: `C:\MyRepo\common\temp\patches`
 */
RushConstants.pnpmPatchesFolderName = 'patches';
/**
 * The filename ("shrinkwrap.yaml") used to store state for pnpm
 */
RushConstants.yarnShrinkwrapFilename = 'yarn.lock';
/**
 * The folder name ("node_modules") where NPM installs its packages.
 */
RushConstants.nodeModulesFolderName = 'node_modules';
/**
 * The filename ("pinned-versions.json") for an old configuration file that
 * that is no longer supported.
 *
 * @deprecated This feature has been superseded by the "preferredVersions" setting
 * in common-versions.json
 */
// NOTE: Although this is marked as "deprecated", we will probably never retire it,
// since we always want to report the warning when someone upgrades an old repo.
RushConstants.pinnedVersionsFilename = 'pinned-versions.json';
/**
 * The filename ("common-versions.json") for an optional configuration file
 * that stores dependency version information that affects all projects in the repo.
 * This configuration file should go in the "common/config/rush" folder.
 */
RushConstants.commonVersionsFilename = 'common-versions.json';
/**
 * The filename ("repo-state.json") for a file used by Rush to
 * store the state of various features as they stand in the repo.
 */
RushConstants.repoStateFilename = 'repo-state.json';
/**
 * The filename ("custom-tips.json") for the file used by Rush to
 * print user-customized messages.
 * This configuration file should go in the "common/config/rush" folder.
 */
RushConstants.customTipsFilename = 'custom-tips.json';
/**
 * The name of the per-project folder where project-specific Rush files are stored. For example,
 * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.
 */
RushConstants.projectRushFolderName = '.rush';
/**
 * Custom command line configuration file, which is used by rush for implementing
 * custom command and options.
 */
RushConstants.commandLineFilename = 'command-line.json';
RushConstants.versionPoliciesFilename = 'version-policies.json';
/**
 * Experiments configuration file.
 */
RushConstants.experimentsFilename = 'experiments.json';
/**
 * Pnpm configuration file
 */
RushConstants.pnpmConfigFilename = 'pnpm-config.json';
/**
 * Rush plugins configuration file name.
 */
RushConstants.rushPluginsConfigFilename = 'rush-plugins.json';
/**
 * Rush plugin manifest file name.
 */
RushConstants.rushPluginManifestFilename = 'rush-plugin-manifest.json';
/**
 * The artifactory.json configuration file name.
 */
RushConstants.artifactoryFilename = 'artifactory.json';
/**
 * Build cache configuration file.
 */
RushConstants.buildCacheFilename = 'build-cache.json';
/**
 * Build cache version number, incremented when the logic to create cache entries changes.
 * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.
 */
RushConstants.buildCacheVersion = 1;
/**
 * Cobuild configuration file.
 */
RushConstants.cobuildFilename = 'cobuild.json';
/**
 * Per-project configuration filename.
 */
RushConstants.rushProjectConfigFilename = 'rush-project.json';
/**
 * The URL ("http://rushjs.io") for the Rush web site.
 */
RushConstants.rushWebSiteUrl = 'https://rushjs.io';
/**
 * The name of the NPM package for the Rush tool ("\@microsoft/rush").
 */
RushConstants.rushPackageName = '@microsoft/rush';
/**
 * The folder name ("rush-recycler") where Rush moves large folder trees
 * before asynchronously deleting them.
 */
RushConstants.rushRecyclerFolderName = 'rush-recycler';
/**
 * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct
 * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.
 */
RushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';
/**
 * The value of the "commandKind" property for a bulk command in command-line.json
 */
RushConstants.bulkCommandKind = 'bulk';
/**
 * The value of the "commandKind" property for a global command in command-line.json
 */
RushConstants.globalCommandKind = 'global';
/**
 * The value of the "commandKind" property for a phased command in command-line.json
 */
RushConstants.phasedCommandKind = 'phased';
/**
 * The name of the incremental build command.
 */
RushConstants.buildCommandName = 'build';
/**
 * The name of the non-incremental build command.
 */
RushConstants.rebuildCommandName = 'rebuild';
RushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';
/**
 * When a hash generated that contains multiple input segments, this character may be used
 * to separate them to avoid issues like
 * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')
 */
RushConstants.hashDelimiter = '|';
/**
 * The name of the per-user Rush configuration data folder.
 */
RushConstants.rushUserConfigurationFolderName = '.rush-user';
/**
 * The name of the project `rush-logs` folder.
 */
RushConstants.rushLogsFolderName = 'rush-logs';
/**
 * The expected prefix for phase names in "common/config/rush/command-line.json"
 */
RushConstants.phaseNamePrefix = '_phase:';
/**
 * The default debounce value for Rush multi-project watch mode. When watching, controls
 * how long to wait after the last encountered file system event before execution. If another
 * file system event occurs in this interval, the timeout will reset.
 */
RushConstants.defaultWatchDebounceMs = 1000;
/**
 * The name of the parameter that can be used to bypass policies.
 */
RushConstants.bypassPolicyFlagLongName = '--bypass-policy';

//# sourceMappingURL=RushConstants.js.map

/***/ }),

/***/ 138705:
/*!***************************************!*\
  !*** ./lib-esnext/logic/Selection.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Selection": () => (/* binding */ Selection)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This namespace contains functions for manipulating sets of projects
 */
class Selection {
    /**
     * Computes the intersection of two or more sets.
     */
    static intersection(first, ...rest) {
        return new Set(generateIntersection(first, ...rest));
    }
    /**
     * Computes the union of two or more sets.
     */
    static union(...sets) {
        return new Set(generateConcatenation(...sets));
    }
    /**
     * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.
     */
    static expandAllDependencies(input) {
        return expandAll(input, expandDependenciesStep);
    }
    /**
     * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.
     */
    static expandAllConsumers(input) {
        return expandAll(input, expandConsumers);
    }
    /**
     * Iterates the direct dependencies of the listed projects. May contain duplicates.
     */
    static *directDependenciesOf(input) {
        for (const item of input) {
            yield* item.dependencyProjects;
        }
    }
    /**
     * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.
     */
    static *directConsumersOf(input) {
        for (const item of input) {
            yield* item.consumingProjects;
        }
    }
}
function* generateIntersection(first, ...rest) {
    for (const item of first) {
        if (rest.every((set) => set.has(item))) {
            yield item;
        }
    }
}
function* generateConcatenation(...sets) {
    for (const set of sets) {
        yield* set;
    }
}
/**
 * Adds all dependencies of the specified project to the target set.
 */
function expandDependenciesStep(project, targetSet) {
    for (const dep of project.dependencyProjects) {
        targetSet.add(dep);
    }
}
/**
 * Adds all projects that declare the specified project as a dependency to the target set.
 */
function expandConsumers(project, targetSet) {
    for (const dep of project.consumingProjects) {
        targetSet.add(dep);
    }
}
/**
 * Computes a set derived from the input by cloning it, then iterating over every member of the new set and
 * calling a step function that may add more elements to the set.
 */
function expandAll(input, expandStep) {
    const result = new Set(input);
    for (const item of result) {
        expandStep(item, result);
    }
    return result;
}
//# sourceMappingURL=Selection.js.map

/***/ }),

/***/ 60296:
/*!*****************************************!*\
  !*** ./lib-esnext/logic/SetupChecks.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetupChecks": () => (/* binding */ SetupChecks)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logic/RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






// Refuses to run at all if the PNPM version is older than this, because there
// are known bugs or missing features in earlier releases.
const MINIMUM_SUPPORTED_NPM_VERSION = '4.5.0';
// Refuses to run at all if the PNPM version is older than this, because there
// are known bugs or missing features in earlier releases.
const MINIMUM_SUPPORTED_PNPM_VERSION = '5.0.0';
/**
 * Validate that the developer's setup is good.
 *
 * These checks are invoked prior to the following commands:
 * - rush install
 * - rush update
 * - rush build
 * - rush rebuild
 */
class SetupChecks {
    static validate(rushConfiguration) {
        // NOTE: The Node.js version is also checked in rush/src/start.ts
        const errorMessage = SetupChecks._validate(rushConfiguration);
        if (errorMessage) {
            // eslint-disable-next-line no-console
            console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.PrintUtilities.wrapWords(errorMessage)));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
        }
    }
    static _validate(rushConfiguration) {
        // Check for outdated tools
        if (rushConfiguration.packageManager === 'pnpm') {
            if (semver__WEBPACK_IMPORTED_MODULE_2__.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_PNPM_VERSION)) {
                return (`The rush.json file requests PNPM version ` +
                    rushConfiguration.packageManagerToolVersion +
                    `, but PNPM ${MINIMUM_SUPPORTED_PNPM_VERSION} is the minimum supported by Rush.`);
            }
        }
        else if (rushConfiguration.packageManager === 'npm') {
            if (semver__WEBPACK_IMPORTED_MODULE_2__.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_NPM_VERSION)) {
                return (`The rush.json file requests NPM version ` +
                    rushConfiguration.packageManagerToolVersion +
                    `, but NPM ${MINIMUM_SUPPORTED_NPM_VERSION} is the minimum supported by Rush.`);
            }
        }
        SetupChecks._checkForPhantomFolders(rushConfiguration);
    }
    static _checkForPhantomFolders(rushConfiguration) {
        const phantomFolders = [];
        const seenFolders = new Set();
        // Check from the real parent of the common/temp folder
        const commonTempParent = path__WEBPACK_IMPORTED_MODULE_1__.dirname(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.getRealPath(rushConfiguration.commonTempFolder));
        SetupChecks._collectPhantomFoldersUpwards(commonTempParent, phantomFolders, seenFolders);
        // Check from the real folder containing rush.json
        const realRushJsonFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.getRealPath(rushConfiguration.rushJsonFolder);
        SetupChecks._collectPhantomFoldersUpwards(realRushJsonFolder, phantomFolders, seenFolders);
        if (phantomFolders.length > 0) {
            if (phantomFolders.length === 1) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.PrintUtilities.wrapWords('Warning: A phantom "node_modules" folder was found. This defeats Rush\'s protection against' +
                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +
                    ' delete this folder:')));
            }
            else {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_4__.PrintUtilities.wrapWords('Warning: Phantom "node_modules" folders were found. This defeats Rush\'s protection against' +
                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +
                    ' delete these folders:')));
            }
            for (const folder of phantomFolders) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`"${folder}"`));
            }
            // eslint-disable-next-line no-console
            console.log(); // add a newline
        }
    }
    /**
     * Checks "folder" and each of its parents to see if it contains a node_modules folder.
     * The bad folders will be added to phantomFolders.
     * The seenFolders set is used to avoid duplicates.
     */
    static _collectPhantomFoldersUpwards(folder, phantomFolders, seenFolders) {
        // Stop if we reached a folder that we already analyzed
        while (!seenFolders.has(folder)) {
            seenFolders.add(folder);
            // If there is a node_modules folder under this folder, add it to the list of bad folders
            const nodeModulesFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(folder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.nodeModulesFolderName);
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(nodeModulesFolder)) {
                // Collect the names of files/folders in that node_modules folder
                const filenames = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.readFolderItemNames(nodeModulesFolder).filter((x) => !x.startsWith('.'));
                let ignore = false;
                if (filenames.length === 0) {
                    // If the node_modules folder is completely empty, then it's not a concern
                    ignore = true;
                }
                else if (filenames.length === 1 && filenames[0] === 'vso-task-lib') {
                    // Special case:  The Azure DevOps build agent installs the "vso-task-lib" NPM package
                    // in a top-level path such as:
                    //
                    //   /home/vsts/work/node_modules/vso-task-lib
                    //
                    // It is always the only package in that node_modules folder.  The "vso-task-lib" package
                    // is now deprecated, so it is unlikely to be a real dependency of any modern project.
                    // To avoid false alarms, we ignore this specific case.
                    ignore = true;
                }
                if (!ignore) {
                    phantomFolders.push(nodeModulesFolder);
                }
            }
            // Walk upwards
            const parentFolder = path__WEBPACK_IMPORTED_MODULE_1__.dirname(folder);
            if (!parentFolder || parentFolder === folder) {
                // If path.dirname() returns its own input, then means we reached the root
                break;
            }
            folder = parentFolder;
        }
    }
}
//# sourceMappingURL=SetupChecks.js.map

/***/ }),

/***/ 819779:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/ShrinkwrapFileFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShrinkwrapFileFactory": () => (/* binding */ ShrinkwrapFileFactory)
/* harmony export */ });
/* harmony import */ var _npm_NpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./npm/NpmShrinkwrapFile */ 899403);
/* harmony import */ var _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pnpm/PnpmShrinkwrapFile */ 930997);
/* harmony import */ var _yarn_YarnShrinkwrapFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./yarn/YarnShrinkwrapFile */ 362701);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class ShrinkwrapFileFactory {
    static getShrinkwrapFile(packageManager, packageManagerOptions, shrinkwrapFilename) {
        switch (packageManager) {
            case 'npm':
                return _npm_NpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_0__.NpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);
            case 'pnpm':
                return _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__.PnpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);
            case 'yarn':
                return _yarn_YarnShrinkwrapFile__WEBPACK_IMPORTED_MODULE_2__.YarnShrinkwrapFile.loadFromFile(shrinkwrapFilename);
            default:
                throw new Error(`Invalid package manager: ${packageManager}`);
        }
    }
    static parseShrinkwrapFile(packageManager, packageManagerOptions, shrinkwrapContent) {
        switch (packageManager) {
            case 'npm':
                return _npm_NpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_0__.NpmShrinkwrapFile.loadFromString(shrinkwrapContent);
            case 'pnpm':
                return _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__.PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);
            case 'yarn':
                return _yarn_YarnShrinkwrapFile__WEBPACK_IMPORTED_MODULE_2__.YarnShrinkwrapFile.loadFromString(shrinkwrapContent);
            default:
                throw new Error(`Invalid package manager: ${packageManager}`);
        }
    }
}
//# sourceMappingURL=ShrinkwrapFileFactory.js.map

/***/ }),

/***/ 427424:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/StandardScriptUpdater.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StandardScriptUpdater": () => (/* binding */ StandardScriptUpdater)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/PathConstants */ 287644);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


const HEADER_LINES_PREFIX = [
    '// THIS FILE WAS GENERATED BY A TOOL. ANY MANUAL MODIFICATIONS WILL GET OVERWRITTEN WHENEVER RUSH IS UPGRADED.',
    '//'
];
const HEADER_LINES_SUFFIX = [
    '//',
    '// For more information, see: https://rushjs.io/pages/maintainer/setup_new_repo/',
    ''
];
const _scripts = [
    {
        scriptName: _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunScriptFilename,
        headerLines: [
            '// This script is intended for usage in an automated build environment where a Node tool may not have',
            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the specified',
            '// version of the specified tool (if not already installed), and then pass a command-line to it.',
            '// An example usage would be:',
            '//',
            `//    node common/scripts/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunScriptFilename} qrcode@1.2.2 qrcode https://rushjs.io`
        ]
    },
    {
        scriptName: _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushScriptFilename,
        headerLines: [
            '// This script is intended for usage in an automated build environment where the Rush command may not have',
            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',
            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to it.',
            '// An example usage would be:',
            '//',
            `//    node common/scripts/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushScriptFilename} install`
        ]
    },
    {
        scriptName: _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushxScriptFilename,
        headerLines: [
            '// This script is intended for usage in an automated build environment where the Rush command may not have',
            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',
            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to the',
            '// rushx command.',
            '//',
            '// An example usage would be:',
            '//',
            `//    node common/scripts/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushxScriptFilename} custom-command`
        ]
    }
];
const _pnpmOnlyScripts = [
    {
        scriptName: _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushPnpmScriptFilename,
        headerLines: [
            '// This script is intended for usage in an automated build environment where the Rush command may not have',
            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',
            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to the',
            '// rush-pnpm command.',
            '//',
            '// An example usage would be:',
            '//',
            `//    node common/scripts/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.installRunRushPnpmScriptFilename} pnpm-command`
        ]
    }
];
const getScripts = (rushConfiguration) => {
    if (rushConfiguration.packageManager === 'pnpm') {
        return _scripts.concat(_pnpmOnlyScripts);
    }
    return _scripts;
};
/**
 * Checks whether the common/scripts files are up to date, and recopies them if needed.
 * This is used by the "rush install" and "rush update" commands.
 */
class StandardScriptUpdater {
    /**
     * Recopy the scripts if the scripts are out of date.
     * Used by "rush update".
     */
    static async updateAsync(rushConfiguration) {
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.ensureFolderAsync(rushConfiguration.commonScriptsFolder);
        let anyChanges = false;
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(getScripts(rushConfiguration), async (script) => {
            const changed = await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, false);
            anyChanges || (anyChanges = changed);
        }, { concurrency: 10 });
        if (anyChanges) {
            // eslint-disable-next-line no-console
            console.log(); // print a newline after the notices
        }
        return anyChanges;
    }
    /**
     * Throw an exception if the scripts are out of date.
     * Used by "rush install".
     */
    static async validateAsync(rushConfiguration) {
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(getScripts(rushConfiguration), async (script) => {
            await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, true);
        }, { concurrency: 10 });
    }
    /**
     * Compares a single script in the common/script folder to see if it needs to be updated.
     * If throwInsteadOfCopy=false, then an outdated or missing script will be recopied;
     * otherwise, an exception is thrown.
     */
    static async _updateScriptOrThrowAsync(script, rushConfiguration, throwInsteadOfCopy) {
        const targetFilePath = `${rushConfiguration.commonScriptsFolder}/${script.scriptName}`;
        // Are the files the same?
        let filesAreSame = false;
        let targetContent;
        try {
            targetContent = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileAsync(targetFilePath);
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        const targetNormalized = targetContent
            ? StandardScriptUpdater._normalize(targetContent)
            : undefined;
        let sourceNormalized;
        if (targetNormalized) {
            sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script);
            if (sourceNormalized === targetNormalized) {
                filesAreSame = true;
            }
        }
        if (!filesAreSame) {
            if (throwInsteadOfCopy) {
                throw new Error('The standard files in the "common/scripts" folders need to be updated' +
                    ' for this Rush version.  Please run "rush update" and commit the changes.');
            }
            else {
                // eslint-disable-next-line no-console
                console.log(`Script is out of date; updating "${targetFilePath}"`);
                sourceNormalized || (sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script));
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFileAsync(targetFilePath, sourceNormalized);
            }
        }
        return !filesAreSame;
    }
    static _normalize(content) {
        // Ignore newline differences from .gitattributes
        return (content
            .split('\n')
            // Ignore trailing whitespace
            .map((x) => x.trimRight())
            .join('\n'));
    }
    static async _getExpectedFileDataAsync({ scriptName, headerLines }) {
        const sourceFilePath = `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_1__.scriptsFolderPath}/${scriptName}`;
        let sourceContent = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileAsync(sourceFilePath);
        sourceContent = [...HEADER_LINES_PREFIX, ...headerLines, ...HEADER_LINES_SUFFIX, sourceContent].join('\n');
        const sourceNormalized = StandardScriptUpdater._normalize(sourceContent);
        return sourceNormalized;
    }
}
//# sourceMappingURL=StandardScriptUpdater.js.map

/***/ }),

/***/ 827933:
/*!***************************************!*\
  !*** ./lib-esnext/logic/Telemetry.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Telemetry": () => (/* binding */ Telemetry)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/Rush */ 465002);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const MAX_FILE_COUNT = 100;
const ONE_MEGABYTE_IN_BYTES = 1048576;
class Telemetry {
    constructor(rushConfiguration, rushSession) {
        this._flushAsyncTasks = new Set();
        this._rushConfiguration = rushConfiguration;
        this._rushSession = rushSession;
        this._enabled = this._rushConfiguration.telemetryEnabled;
        this._store = [];
        const folderName = 'telemetry';
        this._dataFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, folderName);
    }
    log(telemetryData) {
        if (!this._enabled) {
            return;
        }
        const data = Object.assign(Object.assign({}, telemetryData), { machineInfo: telemetryData.machineInfo || {
                machineArchitecture: os__WEBPACK_IMPORTED_MODULE_0__.arch(),
                // The Node.js model is sometimes padded, for example:
                // "AMD Ryzen 7 3700X 8-Core Processor             "
                machineCpu: os__WEBPACK_IMPORTED_MODULE_0__.cpus()[0].model.trim(),
                machineCores: os__WEBPACK_IMPORTED_MODULE_0__.cpus().length,
                machineTotalMemoryMiB: Math.round(os__WEBPACK_IMPORTED_MODULE_0__.totalmem() / ONE_MEGABYTE_IN_BYTES),
                machineFreeMemoryMiB: Math.round(os__WEBPACK_IMPORTED_MODULE_0__.freemem() / ONE_MEGABYTE_IN_BYTES)
            }, timestampMs: telemetryData.timestampMs || new Date().getTime(), platform: telemetryData.platform || process.platform, rushVersion: telemetryData.rushVersion || _api_Rush__WEBPACK_IMPORTED_MODULE_3__.Rush.version });
        this._store.push(data);
    }
    flush() {
        if (!this._enabled || this._store.length === 0) {
            return;
        }
        const fullPath = this._getFilePath();
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.save(this._store, fullPath, { ensureFolderExists: true, ignoreUndefinedValues: true });
        if (this._rushSession.hooks.flushTelemetry.isUsed()) {
            /**
             * User defined flushTelemetry should not block anything, so we don't await here,
             * and store the promise into a list so that we can await it later.
             */
            const asyncTaskPromise = this._rushSession.hooks.flushTelemetry.promise(this._store);
            this._flushAsyncTasks.add(asyncTaskPromise);
            asyncTaskPromise.then(() => {
                this._flushAsyncTasks.delete(asyncTaskPromise);
            }, () => {
                this._flushAsyncTasks.delete(asyncTaskPromise);
            });
        }
        this._store = [];
        this._cleanUp();
    }
    /**
     * There are some async tasks that are not finished when the process is exiting.
     */
    async ensureFlushedAsync() {
        await Promise.all(this._flushAsyncTasks);
    }
    get store() {
        return this._store;
    }
    /**
     * When there are too many log files, delete the old ones.
     */
    _cleanUp() {
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(this._dataFolder)) {
            const files = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemNames(this._dataFolder);
            if (files.length > MAX_FILE_COUNT) {
                const sortedFiles = files
                    .map((fileName) => {
                    const filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._dataFolder, fileName);
                    const stats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getStatistics(filePath);
                    return {
                        filePath: filePath,
                        modifiedTime: stats.mtime.getTime(),
                        isFile: stats.isFile()
                    };
                })
                    .filter((value) => {
                    // Only delete files
                    return value.isFile;
                })
                    .sort((a, b) => {
                    return a.modifiedTime - b.modifiedTime;
                })
                    .map((s) => {
                    return s.filePath;
                });
                const filesToDelete = sortedFiles.length - MAX_FILE_COUNT;
                for (let i = 0; i < filesToDelete; i++) {
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFile(sortedFiles[i]);
                }
            }
        }
    }
    _getFilePath() {
        let fileName = `telemetry_${new Date().toISOString()}`;
        fileName = fileName.replace(/[\-\:\.]/g, '_') + '.json';
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this._dataFolder, fileName);
    }
}
//# sourceMappingURL=Telemetry.js.map

/***/ }),

/***/ 645421:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/UnlinkManager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnlinkManager": () => (/* binding */ UnlinkManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/Utilities */ 827501);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/BaseProjectShrinkwrapFile */ 894306);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/LastLinkFlag */ 986208);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






/**
 * This class implements the logic for "rush unlink"
 */
class UnlinkManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Delete flag file and all the existing node_modules symlinks and all
     * project/.rush/temp/shrinkwrap-deps.json files
     *
     * Returns true if anything was deleted.
     */
    unlink(force = false) {
        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;
        if (!force && useWorkspaces) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('Unlinking is not supported when using workspaces. Run "rush purge" to remove ' +
                'project node_modules folders.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.AlreadyReportedError();
        }
        _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_3__.LastLinkFlagFactory.getCommonTempFlag(this._rushConfiguration).clear();
        return this._deleteProjectFiles();
    }
    /**
     * Delete:
     *  - all the node_modules symlinks of configured Rush projects
     *  - all of the project/.rush/temp/shrinkwrap-deps.json files of configured Rush projects
     *
     * Returns true if anything was deleted
     * */
    _deleteProjectFiles() {
        let didDeleteAnything = false;
        for (const rushProject of this._rushConfiguration.projects) {
            const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(rushProject.projectFolder, 'node_modules');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(localModuleFolder)) {
                // eslint-disable-next-line no-console
                console.log(`Purging ${localModuleFolder}`);
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.dangerouslyDeletePath(localModuleFolder);
                didDeleteAnything = true;
            }
            const projectShrinkwrapFilePath = _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_5__.BaseProjectShrinkwrapFile.getFilePathForProject(rushProject);
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(projectShrinkwrapFilePath)) {
                // eslint-disable-next-line no-console
                console.log(`Deleting ${projectShrinkwrapFilePath}`);
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFile(projectShrinkwrapFilePath);
                didDeleteAnything = true;
            }
        }
        return didDeleteAnything;
    }
}
//# sourceMappingURL=UnlinkManager.js.map

/***/ }),

/***/ 573404:
/*!*************************************************************************!*\
  !*** ./lib-esnext/logic/base/BasePackageManagerOptionsConfiguration.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackageManagerOptionsConfigurationBase": () => (/* binding */ PackageManagerOptionsConfigurationBase)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Options that all package managers share.
 *
 * @public
 */
class PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        this.environmentVariables = json.environmentVariables;
    }
}
//# sourceMappingURL=BasePackageManagerOptionsConfiguration.js.map

/***/ }),

/***/ 894306:
/*!************************************************************!*\
  !*** ./lib-esnext/logic/base/BaseProjectShrinkwrapFile.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseProjectShrinkwrapFile": () => (/* binding */ BaseProjectShrinkwrapFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file
 * which tracks the direct and indirect dependencies that a project consumes. This is used
 * to better determine which projects should be rebuilt when dependencies are updated.
 */
class BaseProjectShrinkwrapFile {
    constructor(shrinkwrapFile, project) {
        this.project = project;
        this.projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(this.project);
        this.shrinkwrapFile = shrinkwrapFile;
    }
    /**
     * Save an empty project shrinkwrap file. This is used in repos with no dependencies.
     */
    static async saveEmptyProjectShrinkwrapFileAsync(project) {
        const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.saveAsync({}, projectShrinkwrapFilePath, { ensureFolderExists: true });
    }
    /**
     * Get the fully-qualified path to the <project>/.rush/temp/shrinkwrap-deps.json
     * for the specified project.
     */
    static getFilePathForProject(project) {
        return `${project.projectRushTempFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.projectShrinkwrapFilename}`;
    }
    /**
     * If the <project>/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.
     */
    async deleteIfExistsAsync() {
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFileAsync(this.projectShrinkwrapFilePath, { throwIfNotExists: false });
    }
}
//# sourceMappingURL=BaseProjectShrinkwrapFile.js.map

/***/ }),

/***/ 411534:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseShrinkwrapFile.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseShrinkwrapFile": () => (/* binding */ BaseShrinkwrapFile)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DependencySpecifier */ 68654);
/* harmony import */ var _api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/PackageNameParsers */ 644443);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * This class is a parser for both npm's npm-shrinkwrap.json and pnpm's pnpm-lock.yaml file formats.
 */
class BaseShrinkwrapFile {
    constructor() {
        this._alreadyWarnedSpecs = new Set();
    }
    static tryGetValue(dictionary, key) {
        if (dictionary.hasOwnProperty(key)) {
            return dictionary[key];
        }
        return undefined;
    }
    /**
     * Validate the shrinkwrap using the provided policy options.
     *
     * @virtual
     */
    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) { }
    /**
     * Returns true if the shrinkwrap file includes a top-level package that would satisfy the specified
     * package name and SemVer version range
     *
     * @virtual
     */
    hasCompatibleTopLevelDependency(dependencySpecifier) {
        const shrinkwrapDependency = this.getTopLevelDependencyVersion(dependencySpecifier.packageName);
        if (!shrinkwrapDependency) {
            return false;
        }
        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);
    }
    /**
     * Returns true if the shrinkwrap file includes a package that would satisfying the specified
     * package name and SemVer version range.  By default, the dependencies are resolved by looking
     * at the root of the node_modules folder described by the shrinkwrap file.  However, if
     * tempProjectName is specified, then the resolution will start in that subfolder.
     *
     * Consider this example:
     *
     * - node_modules\
     *   - temp-project\
     *     - lib-a@1.2.3
     *     - lib-b@1.0.0
     *   - lib-b@2.0.0
     *
     * In this example, hasCompatibleDependency("lib-b", ">= 1.1.0", "temp-project") would fail
     * because it finds lib-b@1.0.0 which does not satisfy the pattern ">= 1.1.0".
     *
     * @virtual
     */
    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {
        const shrinkwrapDependency = this.tryEnsureDependencyVersion(dependencySpecifier, tempProjectName);
        if (!shrinkwrapDependency) {
            return false;
        }
        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);
    }
    /**
     * Check for projects that exist in the shrinkwrap file, but don't exist
     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.
     *
     * @returns a list of orphaned projects.
     */
    findOrphanedProjects(rushConfiguration) {
        const orphanedProjectNames = [];
        // We can recognize temp projects because they are under the "@rush-temp" NPM scope.
        for (const tempProjectName of this.getTempProjectNames()) {
            if (!rushConfiguration.findProjectByTempName(tempProjectName)) {
                orphanedProjectNames.push(tempProjectName);
            }
        }
        return orphanedProjectNames;
    }
    _getTempProjectNames(dependencies) {
        const result = [];
        for (const key of Object.keys(dependencies)) {
            // If it starts with @rush-temp, then include it:
            if (_api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__.PackageNameParsers.permissive.getScope(key) === _logic_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushTempNpmScope) {
                result.push(key);
            }
        }
        result.sort(); // make the result deterministic
        return result;
    }
    _checkDependencyVersion(projectDependency, shrinkwrapDependency) {
        let normalizedProjectDependency = projectDependency;
        let normalizedShrinkwrapDependency = shrinkwrapDependency;
        // Special handling for NPM package aliases such as this:
        //
        // "dependencies": {
        //   "alias-name": "npm:target-name@^1.2.3"
        // }
        //
        // In this case, the shrinkwrap file will have a key equivalent to "npm:target-name@1.2.5",
        // and so we need to unwrap the target and compare "1.2.5" with "^1.2.3".
        if (projectDependency.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_4__.DependencySpecifierType.Alias) {
            // Does the shrinkwrap install it as an alias?
            if (shrinkwrapDependency.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_4__.DependencySpecifierType.Alias) {
                // Does the shrinkwrap have the right package name?
                if (projectDependency.packageName === shrinkwrapDependency.packageName) {
                    // Yes, the aliases match, so let's compare their targets in the logic below
                    normalizedProjectDependency = projectDependency.aliasTarget;
                    normalizedShrinkwrapDependency = shrinkwrapDependency.aliasTarget;
                }
                else {
                    // If the names are different, then it's a mismatch
                    return false;
                }
            }
            else {
                // A non-alias cannot satisfy an alias dependency; at least, let's avoid that idea
                return false;
            }
        }
        switch (normalizedProjectDependency.specifierType) {
            case _DependencySpecifier__WEBPACK_IMPORTED_MODULE_4__.DependencySpecifierType.Version:
            case _DependencySpecifier__WEBPACK_IMPORTED_MODULE_4__.DependencySpecifierType.Range:
                return semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(normalizedShrinkwrapDependency.versionSpecifier, normalizedProjectDependency.versionSpecifier);
            default:
                // For other version specifier types like "file:./blah.tgz" or "git://github.com/npm/cli.git#v1.0.27"
                // we allow the installation to continue but issue a warning.  The "rush install" checks will not work
                // correctly.
                // Only warn once for each versionSpecifier
                if (!this._alreadyWarnedSpecs.has(projectDependency.versionSpecifier)) {
                    this._alreadyWarnedSpecs.add(projectDependency.versionSpecifier);
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`WARNING: Not validating ${projectDependency.specifierType}-based` +
                        ` specifier: "${projectDependency.versionSpecifier}"`));
                }
                return true;
        }
    }
}
//# sourceMappingURL=BaseShrinkwrapFile.js.map

/***/ }),

/***/ 574471:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/buildCache/CacheEntryId.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheEntryId": () => (/* binding */ CacheEntryId)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
const OPTIONS_ARGUMENT_NAME = 'options';
const HASH_TOKEN_NAME = 'hash';
const PROJECT_NAME_TOKEN_NAME = 'projectName';
const PHASE_NAME_TOKEN_NAME = 'phaseName';
// This regex matches substrings that look like [token]
const TOKEN_REGEX = /\[[^\]]*\]/g;
class CacheEntryId {
    constructor() { }
    static parsePattern(pattern) {
        if (!pattern) {
            return ({ projectStateHash }) => projectStateHash;
        }
        else {
            pattern = pattern.trim();
            if (pattern.startsWith('/')) {
                throw new Error('Cache entry name patterns may not start with a slash.');
            }
            const patternWithoutTokens = pattern.replace(TOKEN_REGEX, '');
            if (patternWithoutTokens.match(/\]/)) {
                throw new Error(`Unexpected "]" character in cache entry name pattern.`);
            }
            if (patternWithoutTokens.match(/\[/)) {
                throw new Error('Unclosed token in cache entry name pattern.');
            }
            if (!patternWithoutTokens.match(/^[A-z0-9-_\/]*$/)) {
                throw new Error('Cache entry name pattern contains an invalid character. ' +
                    'Only alphanumeric characters, slashes, underscores, and hyphens are allowed.');
            }
            let foundHashToken = false;
            const templateString = pattern.trim().replace(TOKEN_REGEX, (token) => {
                token = token.substring(1, token.length - 1);
                let tokenName;
                let tokenAttribute;
                const tokenSplitIndex = token.indexOf(':');
                if (tokenSplitIndex === -1) {
                    tokenName = token;
                }
                else {
                    tokenName = token.substr(0, tokenSplitIndex);
                    tokenAttribute = token.substr(tokenSplitIndex + 1);
                }
                switch (tokenName) {
                    case HASH_TOKEN_NAME: {
                        if (tokenAttribute !== undefined) {
                            throw new Error(`An attribute isn\'t supported for the "${tokenName}" token.`);
                        }
                        foundHashToken = true;
                        return `\${${OPTIONS_ARGUMENT_NAME}.projectStateHash}`;
                    }
                    case PROJECT_NAME_TOKEN_NAME: {
                        switch (tokenAttribute) {
                            case undefined: {
                                return `\${${OPTIONS_ARGUMENT_NAME}.projectName}`;
                            }
                            case 'normalize': {
                                return `\${${OPTIONS_ARGUMENT_NAME}.projectName.replace('@','').replace(/\\+/g, '++').replace(/\\/\/g, '+')}`;
                            }
                            default: {
                                throw new Error(`Unexpected attribute "${tokenAttribute}" for the "${tokenName}" token.`);
                            }
                        }
                    }
                    case PHASE_NAME_TOKEN_NAME: {
                        switch (tokenAttribute) {
                            case undefined: {
                                throw new Error('Either the "normalize" or the "trimPrefix" attribute is required ' +
                                    `for the "${tokenName}" token.`);
                            }
                            case 'normalize': {
                                // Replace colons with underscores.
                                return `\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/:/g, '_')}`;
                            }
                            case 'trimPrefix': {
                                // Trim the "_phase:" prefix from the phase name.
                                return `\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/^_phase:/, '')}`;
                            }
                            default: {
                                throw new Error(`Unexpected attribute "${tokenAttribute}" for the "${tokenName}" token.`);
                            }
                        }
                    }
                    default: {
                        throw new Error(`Unexpected token name "${tokenName}".`);
                    }
                }
            });
            if (!foundHashToken) {
                throw new Error(`Cache entry name pattern is missing a [${HASH_TOKEN_NAME}] token.`);
            }
            // eslint-disable-next-line no-new-func
            return new Function(OPTIONS_ARGUMENT_NAME, `"use strict"\nreturn \`${templateString}\`;`);
        }
    }
}
//# sourceMappingURL=CacheEntryId.js.map

/***/ }),

/***/ 339043:
/*!*********************************************************************!*\
  !*** ./lib-esnext/logic/buildCache/FileSystemBuildCacheProvider.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileSystemBuildCacheProvider": () => (/* binding */ FileSystemBuildCacheProvider)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


const DEFAULT_BUILD_CACHE_FOLDER_NAME = 'build-cache';
/**
 * A build cache provider using the local file system.
 * Required by all cloud cache providers.
 * @beta
 */
class FileSystemBuildCacheProvider {
    constructor(options) {
        this._cacheFolderPath =
            options.rushUserConfiguration.buildCacheFolder ||
                path__WEBPACK_IMPORTED_MODULE_0__.join(options.rushConfiguration.commonTempFolder, DEFAULT_BUILD_CACHE_FOLDER_NAME);
    }
    /**
     * Returns the absolute disk path for the specified cache id.
     */
    getCacheEntryPath(cacheId) {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(this._cacheFolderPath, cacheId);
    }
    /**
     * Validates that the specified cache id exists on disk, and returns the path if it does.
     */
    async tryGetCacheEntryPathByIdAsync(terminal, cacheId) {
        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);
        if (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.existsAsync(cacheEntryFilePath)) {
            return cacheEntryFilePath;
        }
        else {
            return undefined;
        }
    }
    /**
     * Writes the specified buffer to the corresponding file system path for the cache id.
     */
    async trySetCacheEntryBufferAsync(terminal, cacheId, entryBuffer) {
        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.writeFileAsync(cacheEntryFilePath, entryBuffer, { ensureFolderExists: true });
        terminal.writeVerboseLine(`Wrote cache entry to "${cacheEntryFilePath}".`);
        return cacheEntryFilePath;
    }
}
//# sourceMappingURL=FileSystemBuildCacheProvider.js.map

/***/ }),

/***/ 700587:
/*!**********************************************************!*\
  !*** ./lib-esnext/logic/buildCache/ProjectBuildCache.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectBuildCache": () => (/* binding */ ProjectBuildCache)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _utilities_TarExecutable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/TarExecutable */ 555368);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






class ProjectBuildCache {
    constructor(cacheId, options) {
        const { buildCacheConfiguration, project, projectOutputFolderNames, additionalProjectOutputFilePaths } = options;
        this._project = project;
        this._localBuildCacheProvider = buildCacheConfiguration.localCacheProvider;
        this._cloudBuildCacheProvider = buildCacheConfiguration.cloudCacheProvider;
        this._buildCacheEnabled = buildCacheConfiguration.buildCacheEnabled;
        this._cacheWriteEnabled = buildCacheConfiguration.cacheWriteEnabled;
        this._projectOutputFolderNames = projectOutputFolderNames || [];
        this._additionalProjectOutputFilePaths = additionalProjectOutputFilePaths || [];
        this._cacheId = cacheId;
    }
    static _tryGetTarUtility(terminal) {
        if (ProjectBuildCache._tarUtilityPromise === null) {
            ProjectBuildCache._tarUtilityPromise = _utilities_TarExecutable__WEBPACK_IMPORTED_MODULE_3__.TarExecutable.tryInitializeAsync(terminal);
        }
        return ProjectBuildCache._tarUtilityPromise;
    }
    get cacheId() {
        return this._cacheId;
    }
    static async tryGetProjectBuildCache(options) {
        const cacheId = await ProjectBuildCache._getCacheId(options);
        return new ProjectBuildCache(cacheId, options);
    }
    async tryRestoreFromCacheAsync(terminal, specifiedCacheId) {
        const cacheId = specifiedCacheId || this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        if (!this._buildCacheEnabled) {
            // Skip reading local and cloud build caches, without any noise
            return false;
        }
        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);
        let cacheEntryBuffer;
        let updateLocalCacheSuccess;
        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {
            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');
            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);
            if (cacheEntryBuffer) {
                try {
                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
                    updateLocalCacheSuccess = true;
                }
                catch (e) {
                    updateLocalCacheSuccess = false;
                }
            }
        }
        if (!localCacheEntryPath && !cacheEntryBuffer) {
            terminal.writeVerboseLine('This project was not found in the build cache.');
            return false;
        }
        terminal.writeLine('Build cache hit.');
        const projectFolderPath = this._project.projectFolder;
        // Purge output folders
        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);
        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        let restoreSuccess = false;
        if (tarUtility && localCacheEntryPath) {
            const logFilePath = this._getTarLogFilePath('untar');
            const tarExitCode = await tarUtility.tryUntarAsync({
                archivePath: localCacheEntryPath,
                outputFolderPath: projectFolderPath,
                logFilePath
            });
            if (tarExitCode === 0) {
                restoreSuccess = true;
                terminal.writeLine('Successfully restored output from the build cache.');
            }
            else {
                terminal.writeWarningLine('Unable to restore output from the build cache. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        if (updateLocalCacheSuccess === false) {
            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');
        }
        return restoreSuccess;
    }
    async trySetCacheEntryAsync(terminal, specifiedCacheId) {
        var _a, _b, _c;
        if (!this._cacheWriteEnabled) {
            // Skip writing local and cloud build caches, without any noise
            return true;
        }
        const cacheId = specifiedCacheId || this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);
        if (!filesToCache) {
            return false;
        }
        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);
        let localCacheEntryPath;
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        if (tarUtility) {
            const finalLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);
            // Derive the temp file from the destination path to ensure they are on the same volume
            // In the case of a shared network drive containing the build cache, we also need to make
            // sure the the temp path won't be shared by two parallel rush builds.
            const randomSuffix = crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(8).toString('hex');
            const tempLocalCacheEntryPath = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;
            const logFilePath = this._getTarLogFilePath('tar');
            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({
                archivePath: tempLocalCacheEntryPath,
                paths: filesToCache.outputFilePaths,
                project: this._project,
                logFilePath
            });
            if (tarExitCode === 0) {
                // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file
                try {
                    await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Async.runWithRetriesAsync({
                        action: () => _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.moveAsync({
                            sourcePath: tempLocalCacheEntryPath,
                            destinationPath: finalLocalCacheEntryPath,
                            overwrite: true
                        }),
                        maxRetries: 2,
                        retryDelayMs: 500
                    });
                }
                catch (moveError) {
                    try {
                        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFileAsync(tempLocalCacheEntryPath);
                    }
                    catch (deleteError) {
                        // Ignored
                    }
                    throw moveError;
                }
                localCacheEntryPath = finalLocalCacheEntryPath;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to create the cache entry. ` +
                    `See "${logFilePath}" for logs from the tar process.`);
                return false;
            }
        }
        else {
            terminal.writeWarningLine(`Unable to locate "tar". Please ensure that "tar" is on your PATH environment variable, or set the ` +
                `${_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_4__.EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the "tar" binary.`);
            return false;
        }
        let cacheEntryBuffer;
        let setCloudCacheEntryPromise;
        // Note that "writeAllowed" settings (whether in config or environment) always apply to
        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and
        // write to the local build cache.
        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {
            if (localCacheEntryPath) {
                cacheEntryBuffer = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFileToBufferAsync(localCacheEntryPath);
            }
            else {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError('Expected the local cache entry path to be set.');
            }
            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        const updateCloudCacheSuccess = (_c = (await setCloudCacheEntryPromise)) !== null && _c !== void 0 ? _c : true;
        const success = updateCloudCacheSuccess && !!localCacheEntryPath;
        if (success) {
            terminal.writeLine('Successfully set cache entry.');
        }
        else if (!localCacheEntryPath && updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set local cache entry.');
        }
        else if (localCacheEntryPath && !updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set cloud cache entry.');
        }
        else {
            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');
        }
        return success;
    }
    /**
     * Walks the declared output folders of the project and collects a list of files.
     * @returns The list of output files as project-relative paths, or `undefined` if a
     *   symbolic link was encountered.
     */
    async _tryCollectPathsToCacheAsync(terminal) {
        const projectFolderPath = this._project.projectFolder;
        const outputFilePaths = [];
        const queue = [];
        const filteredOutputFolderNames = [];
        let hasSymbolicLinks = false;
        // Adds child directories to the queue, files to the path list, and bails on symlinks
        function processChildren(relativePath, diskPath, children) {
            for (const child of children) {
                const childRelativePath = `${relativePath}/${child.name}`;
                if (child.isSymbolicLink()) {
                    terminal.writeError(`Unable to include "${childRelativePath}" in build cache. It is a symbolic link.`);
                    hasSymbolicLinks = true;
                }
                else if (child.isDirectory()) {
                    queue.push([childRelativePath, `${diskPath}/${child.name}`]);
                }
                else {
                    outputFilePaths.push(childRelativePath);
                }
            }
        }
        // Handle declared output folders.
        for (const outputFolder of this._projectOutputFolderNames) {
            const diskPath = `${projectFolderPath}/${outputFolder}`;
            try {
                const children = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemsAsync(diskPath);
                processChildren(outputFolder, diskPath, children);
                // The folder exists, record it
                filteredOutputFolderNames.push(outputFolder);
            }
            catch (error) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.isNotExistError(error)) {
                    throw error;
                }
                // If the folder does not exist, ignore it.
            }
        }
        for (const [relativePath, diskPath] of queue) {
            const children = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemsAsync(diskPath);
            processChildren(relativePath, diskPath, children);
        }
        if (hasSymbolicLinks) {
            // Symbolic links do not round-trip safely.
            return undefined;
        }
        // Add additional output file paths
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Async.forEachAsync(this._additionalProjectOutputFilePaths, async (additionalProjectOutputFilePath) => {
            const fullPath = `${projectFolderPath}/${additionalProjectOutputFilePath}`;
            const pathExists = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.existsAsync(fullPath);
            if (pathExists) {
                outputFilePaths.push(additionalProjectOutputFilePath);
            }
        }, { concurrency: 10 });
        // Ensure stable output path order.
        outputFilePaths.sort();
        return {
            outputFilePaths,
            filteredOutputFolderNames
        };
    }
    _getTarLogFilePath(mode) {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(this._project.projectRushTempFolder, `${this._cacheId}.${mode}.log`);
    }
    static async _getCacheId(options) {
        // The project state hash is calculated in the following method:
        // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is
        //   calculated and appended to an array
        // - The current project's recursive dependency projects' hashes are calculated
        //   and appended to the array
        // - A SHA1 hash is created and the following data is fed into it, in order:
        //   1. The JSON-serialized list of output folder names for this
        //      project (see ProjectBuildCache._projectOutputFolderNames)
        //   2. The configHash from the operation's runner
        //   3. Each dependency project hash (from the array constructed in previous steps),
        //      in sorted alphanumerical-sorted order
        // - A hex digest of the hash is returned
        const projectChangeAnalyzer = options.projectChangeAnalyzer;
        const projectStates = [];
        const projectsToProcess = new Set();
        projectsToProcess.add(options.project);
        for (const projectToProcess of projectsToProcess) {
            const projectState = await projectChangeAnalyzer._tryGetProjectStateHashAsync(projectToProcess, options.terminal);
            if (!projectState) {
                // If we hit any projects with unknown state, return unknown cache ID
                return undefined;
            }
            else {
                projectStates.push(projectState);
                for (const dependency of projectToProcess.dependencyProjects) {
                    projectsToProcess.add(dependency);
                }
            }
        }
        const sortedProjectStates = projectStates.sort();
        const hash = crypto__WEBPACK_IMPORTED_MODULE_1__.createHash('sha1');
        // This value is used to force cache bust when the build cache algorithm changes
        hash.update(`${_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.buildCacheVersion}`);
        hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
        const serializedOutputFolders = JSON.stringify(options.projectOutputFolderNames);
        hash.update(serializedOutputFolders);
        hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
        hash.update(options.configHash);
        hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
        if (options.additionalContext) {
            for (const key of Object.keys(options.additionalContext).sort()) {
                // Add additional context keys and values.
                //
                // This choice (to modify the hash for every key regardless of whether a value is set) implies
                // that just _adding_ an env var to the list of dependsOnEnvVars will modify its hash. This
                // seems appropriate, because this behavior is consistent whether or not the env var happens
                // to have a value.
                hash.update(`${key}=${options.additionalContext[key]}`);
                hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
            }
        }
        for (const projectHash of sortedProjectStates) {
            hash.update(projectHash);
            hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
        }
        const projectStateHash = hash.digest('hex');
        return options.buildCacheConfiguration.getCacheEntryId({
            projectName: options.project.packageName,
            projectStateHash,
            phaseName: options.phaseName
        });
    }
}
/**
 * null === we haven't tried to initialize yet
 * undefined === unable to initialize
 */
ProjectBuildCache._tarUtilityPromise = null;

//# sourceMappingURL=ProjectBuildCache.js.map

/***/ }),

/***/ 653062:
/*!***************************************************************!*\
  !*** ./lib-esnext/logic/buildCache/getHashesForGlobsAsync.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getHashesForGlobsAsync": () => (/* binding */ getHashesForGlobsAsync)
/* harmony export */ });
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/package-deps-hash */ 717642);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


async function expandGlobPatternsAsync(globPatterns, packagePath) {
    const { default: glob } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fast-glob */ 142479, 23));
    const matches = await glob(Array.from(globPatterns), {
        cwd: packagePath,
        onlyFiles: true,
        // We want to keep path's type unchanged,
        // i.e. if the pattern was a  relative path, then matched paths should also be relative paths
        //      if the pattern was an absolute path, then matched paths should also be absolute paths
        //
        // We are doing this because these paths are going to be used to calculate a hash for the build cache and some users
        // might choose to depend on global files (e.g. `/etc/os-release`) and some might choose to depend on local files
        // (e.g. `../path/to/workspace/file`)
        //
        // In both cases we want that path to the resource would be the same on all machines,
        // regardless of what is the current working directory.
        //
        // That being said, we want to keep `absolute` option here as false:
        absolute: false
    });
    if (matches.length === 0) {
        throw new Error(`Couldn't find any files matching provided glob patterns: ["${Array.from(globPatterns).join('", "')}"].`);
    }
    return matches;
}
function getKnownHashes(filePaths, packagePath, repoState) {
    const missingPaths = [];
    const foundPaths = new Map();
    for (const filePath of filePaths) {
        const absolutePath = path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute(filePath) ? filePath : path__WEBPACK_IMPORTED_MODULE_1__.join(packagePath, filePath);
        /**
         * We are using RegExp here to prevent false positives in the following string.replace function
         * - `^` anchor makes sure that we are replacing only the beginning of the string
         * - extra `/` makes sure that we are remove extra slash from the relative path
         */
        const gitFilePath = absolutePath.replace(new RegExp('^' + repoState.rootDir + '/'), '');
        const foundHash = repoState.rawHashes.get(gitFilePath);
        if (foundHash) {
            foundPaths.set(filePath, foundHash);
        }
        else {
            missingPaths.push(filePath);
        }
    }
    return { foundPaths, missingPaths };
}
async function getHashesForGlobsAsync(globPatterns, packagePath, repoState) {
    const filePaths = await expandGlobPatternsAsync(globPatterns, packagePath);
    if (!repoState) {
        return (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_0__.getGitHashForFiles)(filePaths, packagePath);
    }
    const { foundPaths, missingPaths } = getKnownHashes(filePaths, packagePath, repoState);
    const calculatedHashes = (0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_0__.getGitHashForFiles)(missingPaths, packagePath);
    /**
     * We want to keep the order of the output the same regardless whether the file was already
     * hashed by git or not (as this can change, e.g. due to .gitignore).
     * Therefore we will populate our final hashes map in the same order as `filePaths`.
     */
    const result = new Map();
    for (const filePath of filePaths) {
        const hash = foundPaths.get(filePath) || calculatedHashes.get(filePath);
        if (!hash) {
            // Sanity check -- this should never happen
            throw new Error(`Failed to calculate hash of file: "${filePath}"`);
        }
        result.set(filePath, hash);
    }
    return result;
}
//# sourceMappingURL=getHashesForGlobsAsync.js.map

/***/ }),

/***/ 676896:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/cobuild/CobuildLock.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CobuildLock": () => (/* binding */ CobuildLock)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

const KEY_SEPARATOR = ':';
class CobuildLock {
    constructor(options) {
        const { cobuildConfiguration, projectBuildCache, cobuildClusterId: clusterId, lockExpireTimeInSeconds, packageName, phaseName } = options;
        const { cobuildContextId: contextId, cobuildRunnerId: runnerId } = cobuildConfiguration;
        const { cacheId } = projectBuildCache;
        this.cobuildConfiguration = cobuildConfiguration;
        this.projectBuildCache = projectBuildCache;
        if (!cacheId) {
            // This should never happen
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Cache id is require for cobuild lock`);
        }
        if (!contextId) {
            // This should never happen
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Cobuild context id is require for cobuild lock`);
        }
        // Example: cobuild:lock:<contextId>:<clusterId>
        const lockKey = ['cobuild', 'lock', contextId, clusterId].join(KEY_SEPARATOR);
        // Example: cobuild:completed:<contextId>:<cacheId>
        const completedStateKey = ['cobuild', 'completed', contextId, cacheId].join(KEY_SEPARATOR);
        this._cobuildContext = {
            contextId,
            clusterId,
            runnerId,
            lockKey,
            completedStateKey,
            packageName,
            phaseName,
            lockExpireTimeInSeconds: lockExpireTimeInSeconds,
            cacheId
        };
    }
    async setCompletedStateAsync(state) {
        await this.cobuildConfiguration
            .getCobuildLockProvider()
            .setCompletedStateAsync(this._cobuildContext, state);
    }
    async getCompletedStateAsync() {
        const state = await this.cobuildConfiguration
            .getCobuildLockProvider()
            .getCompletedStateAsync(this._cobuildContext);
        return state;
    }
    async tryAcquireLockAsync() {
        const acquireLockResult = await this.cobuildConfiguration
            .getCobuildLockProvider()
            .acquireLockAsync(this._cobuildContext);
        if (acquireLockResult) {
            // renew the lock in a redundant way in case of losing the lock
            await this.renewLockAsync();
        }
        return acquireLockResult;
    }
    async renewLockAsync() {
        await this.cobuildConfiguration.getCobuildLockProvider().renewLockAsync(this._cobuildContext);
    }
    get cobuildContext() {
        return this._cobuildContext;
    }
}
//# sourceMappingURL=CobuildLock.js.map

/***/ }),

/***/ 799623:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/cobuild/DisjointSet.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisjointSet": () => (/* binding */ DisjointSet)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * A disjoint set data structure
 */
class DisjointSet {
    constructor() {
        this._forest = new Set();
        this._parentMap = new Map();
        this._sizeMap = new Map();
        this._setByElement = new Map();
    }
    destroy() {
        var _a;
        this._forest.clear();
        this._parentMap.clear();
        this._sizeMap.clear();
        (_a = this._setByElement) === null || _a === void 0 ? void 0 : _a.clear();
    }
    /**
     * Adds a new set containing specific object
     */
    add(x) {
        if (this._forest.has(x)) {
            return;
        }
        this._forest.add(x);
        this._parentMap.set(x, x);
        this._sizeMap.set(x, 1);
        this._setByElement = undefined;
    }
    /**
     * Unions the sets that contain two objects
     */
    union(a, b) {
        let x = this._find(a);
        let y = this._find(b);
        if (x === y) {
            // x and y are already in the same set
            return;
        }
        const xSize = this._getSize(x);
        const ySize = this._getSize(y);
        if (xSize < ySize) {
            const t = x;
            x = y;
            y = t;
        }
        this._parentMap.set(y, x);
        this._sizeMap.set(x, xSize + ySize);
        this._setByElement = undefined;
    }
    getAllSets() {
        if (this._setByElement === undefined) {
            this._setByElement = new Map();
            for (const element of this._forest) {
                const root = this._find(element);
                let set = this._setByElement.get(root);
                if (set === undefined) {
                    set = new Set();
                    this._setByElement.set(root, set);
                }
                set.add(element);
            }
        }
        return this._setByElement.values();
    }
    /**
     * Returns true if x and y are in the same set
     */
    isConnected(x, y) {
        return this._find(x) === this._find(y);
    }
    _find(a) {
        let x = a;
        let parent = this._getParent(x);
        while (parent !== x) {
            parent = this._getParent(parent);
            this._parentMap.set(x, parent);
            x = parent;
            parent = this._getParent(x);
        }
        return x;
    }
    _getParent(x) {
        const parent = this._parentMap.get(x);
        if (parent === undefined) {
            // This should not happen
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Can not find parent`);
        }
        return parent;
    }
    _getSize(x) {
        const size = this._sizeMap.get(x);
        if (size === undefined) {
            // This should not happen
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Can not get size`);
        }
        return size;
    }
}
//# sourceMappingURL=DisjointSet.js.map

/***/ }),

/***/ 544987:
/*!****************************************************************!*\
  !*** ./lib-esnext/logic/deploy/DeployScenarioConfiguration.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeployScenarioConfiguration": () => (/* binding */ DeployScenarioConfiguration)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _schemas_deploy_scenario_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../schemas/deploy-scenario.schema.json */ 173533);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class DeployScenarioConfiguration {
    constructor(json, projectJsonsByName) {
        this.json = json;
        this.projectJsonsByName = projectJsonsByName;
    }
    /**
     * Validates that the input string conforms to the naming rules for a "rush deploy" scenario name.
     */
    static validateScenarioName(scenarioName) {
        if (!scenarioName) {
            throw new Error('The scenario name cannot be an empty string');
        }
        if (!this._scenarioNameRegExp.test(scenarioName)) {
            throw new Error(`"${scenarioName}" is not a valid scenario name. The name must be comprised of` +
                ' lowercase letters and numbers, separated by single hyphens. Example: "my-scenario"');
        }
    }
    /**
     * Given the --scenarioName value, return the full path of the filename.
     *
     * Example: "ftp-site" --> "...common/config/rush/deploy-ftp-site.json"
     * Example: undefined --> "...common/config/rush/deploy.json"
     */
    static getConfigFilePath(scenarioName, rushConfiguration) {
        let scenarioFileName;
        if (scenarioName) {
            DeployScenarioConfiguration.validateScenarioName(scenarioName);
            scenarioFileName = `deploy-${scenarioName}.json`;
        }
        else {
            scenarioFileName = `deploy.json`;
        }
        return path__WEBPACK_IMPORTED_MODULE_0__.join(rushConfiguration.commonRushConfigFolder, scenarioFileName);
    }
    static loadFromFile(terminal, scenarioFilePath, rushConfiguration) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(scenarioFilePath)) {
            throw new Error('The scenario config file was not found: ' + scenarioFilePath);
        }
        terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(`Loading deployment scenario: ${scenarioFilePath}`));
        const deployScenarioJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.loadAndValidate(scenarioFilePath, DeployScenarioConfiguration._jsonSchema);
        // Apply the defaults
        if (!deployScenarioJson.linkCreation) {
            deployScenarioJson.linkCreation = 'default';
        }
        const deployScenarioProjectJsonsByName = new Map();
        for (const projectSetting of deployScenarioJson.projectSettings || []) {
            // Validate projectSetting.projectName
            if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {
                throw new Error(`The "projectSettings" section refers to the project name "${projectSetting.projectName}"` +
                    ` which was not found in rush.json`);
            }
            for (const additionalProjectsToInclude of projectSetting.additionalProjectsToInclude || []) {
                if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {
                    throw new Error(`The "additionalProjectsToInclude" setting refers to the` +
                        ` project name "${additionalProjectsToInclude}" which was not found in rush.json`);
                }
            }
            deployScenarioProjectJsonsByName.set(projectSetting.projectName, projectSetting);
        }
        return new DeployScenarioConfiguration(deployScenarioJson, deployScenarioProjectJsonsByName);
    }
}
// Used by validateScenarioName()
// Matches lowercase words separated by dashes.
// Example: "deploy-the-thing123"
DeployScenarioConfiguration._scenarioNameRegExp = /^[a-z0-9]+(-[a-z0-9]+)*$/;
DeployScenarioConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonSchema.fromLoadedObject(_schemas_deploy_scenario_schema_json__WEBPACK_IMPORTED_MODULE_2__);

//# sourceMappingURL=DeployScenarioConfiguration.js.map

/***/ }),

/***/ 741340:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/installManager/InstallHelpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstallHelpers": () => (/* binding */ InstallHelpers)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../api/LastInstallFlag */ 919846);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/objectUtilities */ 569609);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






class InstallHelpers {
    static generateCommonPackageJson(rushConfiguration, dependencies = new Map()) {
        const commonPackageJson = {
            dependencies: {},
            description: 'Temporary file generated by the Rush tool',
            name: 'rush-common',
            private: true,
            version: '0.0.0'
        };
        if (rushConfiguration.packageManager === 'pnpm') {
            const { pnpmOptions } = rushConfiguration;
            if (!commonPackageJson.pnpm) {
                commonPackageJson.pnpm = {};
            }
            if (pnpmOptions.globalOverrides) {
                commonPackageJson.pnpm.overrides = pnpmOptions.globalOverrides;
            }
            if (pnpmOptions.globalPackageExtensions) {
                commonPackageJson.pnpm.packageExtensions = pnpmOptions.globalPackageExtensions;
            }
            if (pnpmOptions.globalPeerDependencyRules) {
                commonPackageJson.pnpm.peerDependencyRules = pnpmOptions.globalPeerDependencyRules;
            }
            if (pnpmOptions.globalNeverBuiltDependencies) {
                commonPackageJson.pnpm.neverBuiltDependencies = pnpmOptions.globalNeverBuiltDependencies;
            }
            if (pnpmOptions.globalAllowedDeprecatedVersions) {
                commonPackageJson.pnpm.allowedDeprecatedVersions = pnpmOptions.globalAllowedDeprecatedVersions;
            }
            if (pnpmOptions.globalPatchedDependencies) {
                commonPackageJson.pnpm.patchedDependencies = pnpmOptions.globalPatchedDependencies;
            }
            if (pnpmOptions.unsupportedPackageJsonSettings) {
                (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_3__.merge)(commonPackageJson, pnpmOptions.unsupportedPackageJsonSettings);
            }
        }
        // Add any preferred versions to the top of the commonPackageJson
        // do this in alphabetical order for simpler debugging
        for (const dependency of Array.from(dependencies.keys()).sort()) {
            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);
        }
        // Example: "C:\MyRepo\common\temp\package.json"
        const commonPackageJsonFilename = path__WEBPACK_IMPORTED_MODULE_1__.join(rushConfiguration.commonTempFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileConstants.PackageJson);
        // Don't update the file timestamp unless the content has changed, since "rush install"
        // will consider this timestamp
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });
    }
    static getPackageManagerEnvironment(rushConfiguration, options = {}) {
        let configurationEnvironment = undefined;
        if (rushConfiguration.packageManager === 'npm') {
            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'pnpm') {
            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'yarn') {
            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;
            }
        }
        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);
    }
    /**
     * If the "(p)npm-local" symlink hasn't been set up yet, this creates it, installing the
     * specified (P)npm version in the user's home directory if needed.
     */
    static async ensureLocalPackageManager(rushConfiguration, rushGlobalFolder, maxInstallAttempts, restrictConsoleOutput) {
        let logIfConsoleOutputIsNotRestricted;
        if (restrictConsoleOutput) {
            logIfConsoleOutputIsNotRestricted = () => {
                /* noop */
            };
        }
        else {
            logIfConsoleOutputIsNotRestricted = (message) => {
                // eslint-disable-next-line no-console
                console.log(message);
            };
        }
        // Example: "C:\Users\YourName\.rush"
        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(rushUserFolder)) {
            logIfConsoleOutputIsNotRestricted('Creating ' + rushUserFolder);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolder(rushUserFolder);
        }
        const packageManager = rushConfiguration.packageManager;
        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;
        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;
        // Example: "C:\Users\YourName\.rush\pnpm-1.2.3"
        const packageManagerToolFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(rushUserFolder, packageManagerAndVersion);
        const packageManagerMarker = new _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_4__.LastInstallFlag(packageManagerToolFolder, {
            node: process.versions.node
        });
        logIfConsoleOutputIsNotRestricted(`Trying to acquire lock for ${packageManagerAndVersion}`);
        const lock = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.LockFile.acquire(rushUserFolder, packageManagerAndVersion);
        logIfConsoleOutputIsNotRestricted(`Acquired lock for ${packageManagerAndVersion}`);
        if (!packageManagerMarker.isValid() || lock.dirtyWhenAcquired) {
            logIfConsoleOutputIsNotRestricted(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Installing ${packageManager} version ${packageManagerVersion}\n`));
            // note that this will remove the last-install flag from the directory
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_5__.Utilities.installPackageInDirectory({
                directory: packageManagerToolFolder,
                packageName: packageManager,
                version: rushConfiguration.packageManagerToolVersion,
                tempPackageTitle: `${packageManager}-local-install`,
                maxInstallAttempts: maxInstallAttempts,
                // This is using a local configuration to install a package in a shared global location.
                // Generally that's a bad practice, but in this case if we can successfully install
                // the package at all, we can reasonably assume it's good for all the repositories.
                // In particular, we'll assume that two different NPM registries cannot have two
                // different implementations of the same version of the same package.
                // This was needed for: https://github.com/microsoft/rushstack/issues/691
                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder
            });
            logIfConsoleOutputIsNotRestricted(`Successfully installed ${packageManager} version ${packageManagerVersion}`);
        }
        else {
            logIfConsoleOutputIsNotRestricted(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);
        }
        packageManagerMarker.create();
        // Example: "C:\MyRepo\common\temp"
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolder(rushConfiguration.commonTempFolder);
        // Example: "C:\MyRepo\common\temp\pnpm-local"
        const localPackageManagerToolFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);
        logIfConsoleOutputIsNotRestricted(`\nSymlinking "${localPackageManagerToolFolder}"`);
        logIfConsoleOutputIsNotRestricted(`  --> "${packageManagerToolFolder}"`);
        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will
        // return false for broken symlinks.  There is no way to test without catching an exception.
        try {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.deleteFolder(localPackageManagerToolFolder);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.createSymbolicLinkJunction({
            linkTargetPath: packageManagerToolFolder,
            newLinkPath: localPackageManagerToolFolder
        });
        lock.release();
    }
    // Helper for getPackageManagerEnvironment
    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {
        const packageManagerEnv = baseEnv;
        if (environmentVariables) {
            // eslint-disable-next-line guard-for-in
            for (const envVar in environmentVariables) {
                let setEnvironmentVariable = true;
                // eslint-disable-next-line no-console
                console.log(`\nProcessing definition for environment variable: ${envVar}`);
                if (baseEnv.hasOwnProperty(envVar)) {
                    setEnvironmentVariable = false;
                    // eslint-disable-next-line no-console
                    console.log(`Environment variable already defined:`);
                    // eslint-disable-next-line no-console
                    console.log(`  Name: ${envVar}`);
                    // eslint-disable-next-line no-console
                    console.log(`  Existing value: ${baseEnv[envVar]}`);
                    // eslint-disable-next-line no-console
                    console.log(`  Value set in rush.json: ${environmentVariables[envVar].value}`);
                    if (environmentVariables[envVar].override) {
                        setEnvironmentVariable = true;
                        // eslint-disable-next-line no-console
                        console.log(`Overriding the environment variable with the value set in rush.json.`);
                    }
                    else {
                        // eslint-disable-next-line no-console
                        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`WARNING: Not overriding the value of the environment variable.`));
                    }
                }
                if (setEnvironmentVariable) {
                    if (options.debug) {
                        // eslint-disable-next-line no-console
                        console.log(`Setting environment variable for package manager.`);
                        // eslint-disable-next-line no-console
                        console.log(`  Name: ${envVar}`);
                        // eslint-disable-next-line no-console
                        console.log(`  Value: ${environmentVariables[envVar].value}`);
                    }
                    packageManagerEnv[envVar] = environmentVariables[envVar].value;
                }
            }
        }
        return packageManagerEnv;
    }
}
//# sourceMappingURL=InstallHelpers.js.map

/***/ }),

/***/ 459476:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/npm/NpmOptionsConfiguration.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmOptionsConfiguration": () => (/* binding */ NpmOptionsConfiguration)
/* harmony export */ });
/* harmony import */ var _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/BasePackageManagerOptionsConfiguration */ 573404);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Options that are only used when the NPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the NPM package manager
 * is not being used.
 *
 * @public
 */
class NpmOptionsConfiguration extends _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_0__.PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        super(json);
    }
}
//# sourceMappingURL=NpmOptionsConfiguration.js.map

/***/ }),

/***/ 899403:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/npm/NpmShrinkwrapFile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmShrinkwrapFile": () => (/* binding */ NpmShrinkwrapFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/BaseShrinkwrapFile */ 411534);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DependencySpecifier */ 68654);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class NpmShrinkwrapFile extends _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__.BaseShrinkwrapFile {
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        // Normalize the data
        if (!this._shrinkwrapJson.version) {
            this._shrinkwrapJson.version = '';
        }
        if (!this._shrinkwrapJson.name) {
            this._shrinkwrapJson.name = '';
        }
        if (!this._shrinkwrapJson.dependencies) {
            this._shrinkwrapJson.dependencies = {};
        }
        // Workspaces not supported in NPM
        this.isWorkspaceCompatible = false;
    }
    static loadFromFile(shrinkwrapJsonFilename) {
        try {
            const shrinkwrapContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFile(shrinkwrapJsonFilename);
            return NpmShrinkwrapFile.loadFromString(shrinkwrapContent);
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
                return undefined; // file does not exist
            }
            throw new Error(`Error reading "${shrinkwrapJsonFilename}":\n  ${error.message}`);
        }
    }
    static loadFromString(shrinkwrapContent) {
        // strip BOM
        const data = shrinkwrapContent.charCodeAt(0) === 0xfeff ? shrinkwrapContent.slice(1) : shrinkwrapContent;
        // We don't use JsonFile/jju here because shrinkwrap.json is a special NPM file format
        // and typically very large, so we want to load it the same way that NPM does.
        return new NpmShrinkwrapFile(JSON.parse(data));
    }
    /** @override */
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);
    }
    /** @override */
    serialize() {
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.stringify(this._shrinkwrapJson);
    }
    /** @override */
    getTopLevelDependencyVersion(dependencyName) {
        // First, check under tempProjectName, as this is the first place we look during linking.
        const dependencyJson = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);
        if (!dependencyJson) {
            return undefined;
        }
        return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_2__.DependencySpecifier(dependencyName, dependencyJson.version);
    }
    /**
     * @param dependencyName the name of the dependency to get a version for
     * @param tempProjectName the name of the temp project to check for this dependency
     * @param versionRange Not used, just exists to satisfy abstract API contract
     * @override
     */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        // First, check under tempProjectName, as this is the first place we look during linking.
        let dependencyJson = undefined;
        const tempDependency = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, tempProjectName);
        if (tempDependency && tempDependency.dependencies) {
            dependencyJson = NpmShrinkwrapFile.tryGetValue(tempDependency.dependencies, dependencySpecifier.packageName);
        }
        // Otherwise look at the root of the shrinkwrap file
        if (!dependencyJson) {
            return this.getTopLevelDependencyVersion(dependencySpecifier.packageName);
        }
        return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_2__.DependencySpecifier(dependencySpecifier.packageName, dependencyJson.version);
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return undefined;
    }
    /** @override */
    async isWorkspaceProjectModifiedAsync(project, variant) {
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Not implemented');
    }
}
//# sourceMappingURL=NpmShrinkwrapFile.js.map

/***/ }),

/***/ 546617:
/*!************************************************************!*\
  !*** ./lib-esnext/logic/operations/AsyncOperationQueue.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncOperationQueue": () => (/* binding */ AsyncOperationQueue),
/* harmony export */   "UNASSIGNED_OPERATION": () => (/* binding */ UNASSIGNED_OPERATION)
/* harmony export */ });
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OperationStatus */ 476597);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * When the queue returns an unassigned operation, it means there is at least one remote executing operation,
 * at this time, the caller has a chance to make a decision:
 * 1. Manually invoke `tryGetRemoteExecutingOperation()` to get the remote executing operation.
 * 2. If there is no remote executing operation available, wait for some time and return in callback, which
 * internally invoke `assignOperations()` to assign new operations.
 * NOTE: the caller must wait for some time to avoid busy loop and burn CPU cycles.
 */
const UNASSIGNED_OPERATION = 'UNASSIGNED_OPERATION';
/**
 * Implementation of the async iteration protocol for a collection of IOperation objects.
 * The async iterator will wait for an operation to be ready for execution, or terminate if there are no more operations.
 *
 * @remarks
 * If the caller does not update dependencies prior to invoking `next()` on the iterator again,
 * it must manually invoke `assignOperations()` after performing the updates, otherwise iterators will
 * stall until another operations completes.
 */
class AsyncOperationQueue {
    /**
     * @param operations - The set of operations to be executed
     * @param sortFn - A function that sorts operations in reverse priority order:
     *   - Returning a positive value indicates that `a` should execute before `b`.
     *   - Returning a negative value indicates that `b` should execute before `a`.
     *   - Returning 0 indicates no preference.
     */
    constructor(operations, sortFn) {
        this._queue = computeTopologyAndSort(operations, sortFn);
        this._pendingIterators = [];
        this._totalOperations = this._queue.length;
        this._isDone = false;
        this._completedOperations = new Set();
    }
    /**
     * For use with `for await (const operation of taskQueue)`
     * @see {AsyncIterator}
     */
    next() {
        const { _pendingIterators: waitingIterators } = this;
        const promise = new Promise((resolve) => {
            waitingIterators.push(resolve);
        });
        this.assignOperations();
        return promise;
    }
    /**
     * Set a callback to be invoked when one operation is completed.
     * If all operations are completed, set the queue to done, resolve all pending iterators in next cycle.
     */
    complete(record) {
        this._completedOperations.add(record);
        // Apply status changes to direct dependents
        if (record.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Failure && record.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Blocked) {
            // Only do so if the operation did not fail or get blocked
            for (const item of record.consumers) {
                // Remove this operation from the dependencies, to unblock the scheduler
                if (item.dependencies.delete(record) &&
                    item.dependencies.size === 0 &&
                    item.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Waiting) {
                    item.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Ready;
                }
            }
        }
        if (this._completedOperations.size === this._totalOperations) {
            this._isDone = true;
        }
    }
    /**
     * Routes ready operations with 0 dependencies to waiting iterators. Normally invoked as part of `next()`, but
     * if the caller does not update operation dependencies prior to calling `next()`, may need to be invoked manually.
     */
    assignOperations() {
        const { _queue: queue, _pendingIterators: waitingIterators } = this;
        // By iterating in reverse order we do less array shuffling when removing operations
        for (let i = queue.length - 1; waitingIterators.length > 0 && i >= 0; i--) {
            const record = queue[i];
            if (record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Blocked ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Skipped ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Success ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.SuccessWithWarning ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.FromCache ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.NoOp ||
                record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Failure) {
                // It shouldn't be on the queue, remove it
                queue.splice(i, 1);
            }
            else if (record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Queued || record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Executing) {
                // This operation is currently executing
                // next one plz :)
            }
            else if (record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Waiting) {
                // This operation is not yet ready to be executed
                // next one plz :)
                continue;
            }
            else if (record.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.RemoteExecuting) {
                // This operation is not ready to execute yet, but it may become ready later
                // next one plz :)
                continue;
            }
            else if (record.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Ready) {
                // Sanity check
                throw new Error(`Unexpected status "${record.status}" for queued operation: ${record.name}`);
            }
            else {
                // This task is ready to process, hand it to the iterator.
                // Needs to have queue semantics, otherwise tools that iterate it get confused
                record.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.Queued;
                waitingIterators.shift()({
                    value: record,
                    done: false
                });
            }
            // Otherwise operation is still waiting
        }
        // Since items only get removed from the queue when they have a final status, this should be safe.
        if (queue.length === 0) {
            this._isDone = true;
        }
        if (this._isDone) {
            for (const resolveAsyncIterator of waitingIterators.splice(0)) {
                resolveAsyncIterator({
                    value: undefined,
                    done: true
                });
            }
            return;
        }
        if (waitingIterators.length > 0) {
            // returns an unassigned operation to let caller decide when there is at least one
            // remote executing operation which is not ready to process.
            if (queue.some((operation) => operation.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.RemoteExecuting)) {
                waitingIterators.shift()({
                    value: UNASSIGNED_OPERATION,
                    done: false
                });
            }
        }
    }
    tryGetRemoteExecutingOperation() {
        const { _queue: queue } = this;
        // cycle through the queue to find the next operation that is executed remotely
        for (let i = queue.length - 1; i >= 0; i--) {
            const operation = queue[i];
            if (operation.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_0__.OperationStatus.RemoteExecuting) {
                return operation;
            }
        }
        return undefined;
    }
    /**
     * Returns this queue as an async iterator, such that multiple functions iterating this object concurrently
     * receive distinct iteration results.
     */
    [Symbol.asyncIterator]() {
        return this;
    }
}
/**
 * Performs a depth-first search to topologically sort the operations, subject to override via sortFn
 */
function computeTopologyAndSort(operations, sortFn) {
    // Clone the set of operations as an array, so that we can sort it.
    const queue = Array.from(operations);
    // Create a collection for detecting visited nodes
    const cycleDetectorStack = new Set();
    for (const operation of queue) {
        calculateCriticalPathLength(operation, cycleDetectorStack);
    }
    return queue.sort(sortFn);
}
/**
 * Perform a depth-first search to find critical path length.
 * Cycle detection comes at minimal additional cost.
 */
function calculateCriticalPathLength(operation, dependencyChain) {
    if (dependencyChain.has(operation)) {
        throw new Error('A cyclic dependency was encountered:\n  ' +
            [...dependencyChain, operation]
                .map((visitedTask) => visitedTask.name)
                .reverse()
                .join('\n  -> ') +
            '\nConsider using the decoupledLocalDependencies option for rush.json.');
    }
    let { criticalPathLength } = operation;
    if (criticalPathLength !== undefined) {
        // This has been visited already
        return criticalPathLength;
    }
    criticalPathLength = 0;
    if (operation.consumers.size) {
        dependencyChain.add(operation);
        for (const consumer of operation.consumers) {
            criticalPathLength = Math.max(criticalPathLength, calculateCriticalPathLength(consumer, dependencyChain));
        }
        dependencyChain.delete(operation);
    }
    // Include the contribution from the current operation
    operation.criticalPathLength = criticalPathLength + operation.weight;
    // Directly writing operations to an output collection here would yield a topological sorted set
    // However, we want a bit more fine-tuning of the output than just the raw topology
    return criticalPathLength;
}
//# sourceMappingURL=AsyncOperationQueue.js.map

/***/ }),

/***/ 223875:
/*!*****************************************************************!*\
  !*** ./lib-esnext/logic/operations/CacheableOperationPlugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheableOperationPlugin": () => (/* binding */ CacheableOperationPlugin)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/stream-collator */ 121452);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utilities_CollatedTerminalProvider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/CollatedTerminalProvider */ 782038);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./OperationStatus */ 476597);
/* harmony import */ var _cobuild_CobuildLock__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../cobuild/CobuildLock */ 676896);
/* harmony import */ var _buildCache_ProjectBuildCache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../buildCache/ProjectBuildCache */ 700587);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _buildCache_getHashesForGlobsAsync__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../buildCache/getHashesForGlobsAsync */ 653062);
/* harmony import */ var _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ProjectLogWritable */ 471311);
/* harmony import */ var _cobuild_DisjointSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cobuild/DisjointSet */ 799623);
/* harmony import */ var _PeriodicCallback__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PeriodicCallback */ 476093);
/* harmony import */ var _utilities_NullTerminalProvider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/NullTerminalProvider */ 946979);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.















const PLUGIN_NAME = 'CacheablePhasedOperationPlugin';
const PERIODIC_CALLBACK_INTERVAL_IN_SECONDS = 10;
class CacheableOperationPlugin {
    constructor(options) {
        this._buildCacheContextByOperation = new Map();
        this._options = options;
    }
    apply(hooks) {
        const { allowWarningsInSuccessfulBuild, buildCacheConfiguration, cobuildConfiguration, terminal } = this._options;
        hooks.beforeExecuteOperations.tapPromise(PLUGIN_NAME, async (recordByOperation, context) => {
            const { isIncrementalBuildAllowed, projectChangeAnalyzer, projectConfigurations, isInitial } = context;
            const disjointSet = (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)
                ? new _cobuild_DisjointSet__WEBPACK_IMPORTED_MODULE_4__.DisjointSet()
                : undefined;
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Async.forEachAsync(recordByOperation.keys(), async (operation) => {
                const { associatedProject, associatedPhase, runner } = operation;
                if (!associatedProject || !associatedPhase || !runner) {
                    return;
                }
                const { name: phaseName } = associatedPhase;
                const projectConfiguration = projectConfigurations.get(associatedProject);
                // This value can *currently* be cached per-project, but in the future the list of files will vary
                // depending on the selected phase.
                const fileHashes = await projectChangeAnalyzer._tryGetProjectDependenciesAsync(associatedProject, terminal);
                if (!fileHashes) {
                    throw new Error(`Build cache is only supported if running in a Git repository. Either disable the build cache or run Rush in a Git repository.`);
                }
                const operationSettings = projectConfiguration === null || projectConfiguration === void 0 ? void 0 : projectConfiguration.operationSettingsByOperationName.get(phaseName);
                const cacheDisabledReason = projectConfiguration
                    ? projectConfiguration.getCacheDisabledReason(fileHashes.keys(), phaseName)
                    : `Project does not have a ${_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.rushProjectConfigFilename} configuration file, ` +
                        'or one provided by a rig, so it does not support caching.';
                disjointSet === null || disjointSet === void 0 ? void 0 : disjointSet.add(operation);
                const buildCacheContext = {
                    // Supports cache writes by default for initial operations.
                    // Don't write during watch runs for performance reasons (and to avoid flooding the cache)
                    isCacheWriteAllowed: isInitial,
                    isCacheReadAllowed: isIncrementalBuildAllowed,
                    projectBuildCache: undefined,
                    projectChangeAnalyzer,
                    operationSettings,
                    cacheDisabledReason,
                    cobuildLock: undefined,
                    cobuildClusterId: undefined,
                    buildCacheTerminal: undefined,
                    buildCacheProjectLogWritable: undefined,
                    periodicCallback: new _PeriodicCallback__WEBPACK_IMPORTED_MODULE_6__.PeriodicCallback({
                        interval: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 1000
                    }),
                    cacheRestored: false,
                    isCacheReadAttempted: false
                };
                // Upstream runners may mutate the property of build cache context for downstream runners
                this._buildCacheContextByOperation.set(operation, buildCacheContext);
            }, {
                concurrency: 10
            });
            if (disjointSet) {
                // If disjoint set exists, connect build cache disabled project with its consumers
                for (const [operation, { cacheDisabledReason }] of this._buildCacheContextByOperation) {
                    const { associatedProject: project, associatedPhase: phase } = operation;
                    if (project && phase) {
                        if (cacheDisabledReason) {
                            /**
                             * Group the project build cache disabled with its consumers. This won't affect too much in
                             * a monorepo with high build cache coverage.
                             *
                             * The mental model is that if X disables the cache, and Y depends on X, then:
                             *   1. Y must be built by the same VM that build X;
                             *   2. OR, Y must be rebuilt on each VM that needs it.
                             * Approach 1 is probably the better choice.
                             */
                            for (const consumer of operation.consumers) {
                                disjointSet === null || disjointSet === void 0 ? void 0 : disjointSet.union(operation, consumer);
                            }
                        }
                    }
                }
                for (const operationSet of disjointSet.getAllSets()) {
                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) && cobuildConfiguration.cobuildContextId) {
                        // Get a deterministic ordered array of operations, which is important to get a deterministic cluster id.
                        const groupedOperations = Array.from(operationSet);
                        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortBy(groupedOperations, (operation) => {
                            return operation.name;
                        });
                        // Generates cluster id, cluster id comes from the project folder and phase name of all operations in the same cluster.
                        const hash = crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha1');
                        for (const operation of groupedOperations) {
                            const { associatedPhase: phase, associatedProject: project } = operation;
                            if (project && phase) {
                                hash.update(project.projectRelativeFolder);
                                hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
                                hash.update(phase.name);
                                hash.update(_RushConstants__WEBPACK_IMPORTED_MODULE_5__.RushConstants.hashDelimiter);
                            }
                        }
                        const cobuildClusterId = hash.digest('hex');
                        // Assign same cluster id to all operations in the same cluster.
                        for (const record of groupedOperations) {
                            const buildCacheContext = this._getBuildCacheContextByOperationOrThrow(record);
                            buildCacheContext.cobuildClusterId = cobuildClusterId;
                        }
                    }
                }
            }
        });
        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {
            var _a;
            if (this._buildCacheContextByOperation.size === 0) {
                return;
            }
            const buildCacheContext = this._getBuildCacheContextByOperation(runnerContext.operation);
            if (!buildCacheContext) {
                return;
            }
            const record = runnerContext;
            const { associatedProject: project, associatedPhase: phase, runner, _operationMetadataManager: operationMetadataManager } = record;
            if (!project || !phase || !(runner === null || runner === void 0 ? void 0 : runner.cacheable)) {
                return;
            }
            const runBeforeExecute = async () => {
                const buildCacheTerminal = this._getBuildCacheTerminal({
                    record,
                    buildCacheContext,
                    buildCacheEnabled: buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled,
                    rushProject: project,
                    logFilenameIdentifier: phase.logFilenameIdentifier,
                    quietMode: record.quietMode,
                    debugMode: record.debugMode
                });
                buildCacheContext.buildCacheTerminal = buildCacheTerminal;
                const configHash = runner.getConfigHash() || '';
                let projectBuildCache = await this._tryGetProjectBuildCacheAsync({
                    buildCacheContext,
                    buildCacheConfiguration,
                    rushProject: project,
                    phase,
                    configHash,
                    terminal: buildCacheTerminal,
                    operationMetadataManager
                });
                // Try to acquire the cobuild lock
                let cobuildLock;
                if (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) {
                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildLeafProjectLogOnlyAllowed) &&
                        record.operation.consumers.size === 0 &&
                        !projectBuildCache) {
                        // When the leaf project log only is allowed and the leaf project is build cache "disabled", try to get
                        // a log files only project build cache
                        projectBuildCache = await this._tryGetLogOnlyProjectBuildCacheAsync({
                            buildCacheConfiguration,
                            cobuildConfiguration,
                            buildCacheContext,
                            rushProject: project,
                            phase,
                            configHash,
                            terminal: buildCacheTerminal,
                            operationMetadataManager
                        });
                        if (projectBuildCache) {
                            buildCacheTerminal.writeVerboseLine(`Log files only build cache is enabled for the project "${project.packageName}" because the cobuild leaf project log only is allowed`);
                        }
                        else {
                            buildCacheTerminal.writeWarningLine(`Failed to get log files only build cache for the project "${project.packageName}"`);
                        }
                    }
                    cobuildLock = await this._tryGetCobuildLockAsync({
                        buildCacheContext,
                        projectBuildCache,
                        cobuildConfiguration,
                        packageName: project.packageName,
                        phaseName: phase.name
                    });
                }
                // eslint-disable-next-line require-atomic-updates -- we are mutating the build cache context intentionally
                buildCacheContext.cobuildLock = cobuildLock;
                // If possible, we want to skip this operation -- either by restoring it from the
                // cache, if caching is enabled, or determining that the project
                // is unchanged (using the older incremental execution logic). These two approaches,
                // "caching" and "skipping", are incompatible, so only one applies.
                //
                // Note that "caching" and "skipping" take two different approaches
                // to tracking dependents:
                //
                //   - For caching, "isCacheReadAllowed" is set if a project supports
                //     incremental builds, and determining whether this project or a dependent
                //     has changed happens inside the hashing logic.
                //
                const { logPath, errorLogPath } = _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_7__.ProjectLogWritable.getLogFilePaths({
                    project,
                    logFilenameIdentifier: phase.logFilenameIdentifier
                });
                const restoreCacheAsync = async (
                // TODO: Investigate if `projectBuildCacheForRestore` is always the same instance as `projectBuildCache`
                // above, and if it is, remove this parameter
                projectBuildCacheForRestore, specifiedCacheId) => {
                    buildCacheContext.isCacheReadAttempted = true;
                    const restoreFromCacheSuccess = await (projectBuildCacheForRestore === null || projectBuildCacheForRestore === void 0 ? void 0 : projectBuildCacheForRestore.tryRestoreFromCacheAsync(buildCacheTerminal, specifiedCacheId));
                    if (restoreFromCacheSuccess) {
                        buildCacheContext.cacheRestored = true;
                        // Restore the original state of the operation without cache
                        await (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.tryRestoreAsync({
                            terminal: buildCacheTerminal,
                            logPath,
                            errorLogPath
                        }));
                    }
                    return !!restoreFromCacheSuccess;
                };
                if (cobuildLock) {
                    // handling rebuilds. "rush rebuild" or "rush retest" command will save operations to
                    // the build cache once completed, but does not retrieve them (since the "incremental"
                    // flag is disabled). However, we still need a cobuild to be able to retrieve a finished
                    // build from another cobuild in this case.
                    const cobuildCompletedState = await cobuildLock.getCompletedStateAsync();
                    if (cobuildCompletedState) {
                        const { status, cacheId } = cobuildCompletedState;
                        const restoreFromCacheSuccess = await restoreCacheAsync(cobuildLock.projectBuildCache, cacheId);
                        if (restoreFromCacheSuccess) {
                            if (cobuildCompletedState) {
                                return cobuildCompletedState.status;
                            }
                            return status;
                        }
                    }
                    else if (!buildCacheContext.isCacheReadAttempted && buildCacheContext.isCacheReadAllowed) {
                        const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);
                        if (restoreFromCacheSuccess) {
                            return _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.FromCache;
                        }
                    }
                }
                else if (buildCacheContext.isCacheReadAllowed) {
                    const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);
                    if (restoreFromCacheSuccess) {
                        return _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.FromCache;
                    }
                }
                if (buildCacheContext.isCacheWriteAllowed && cobuildLock) {
                    const acquireSuccess = await cobuildLock.tryAcquireLockAsync();
                    if (acquireSuccess) {
                        const { periodicCallback } = buildCacheContext;
                        periodicCallback.addCallback(async () => {
                            await (cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.renewLockAsync());
                        });
                        periodicCallback.start();
                    }
                    else {
                        // failed to acquire the lock, mark current operation to remote executing
                        return _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.RemoteExecuting;
                    }
                }
            };
            try {
                const earlyReturnStatus = await runBeforeExecute();
                return earlyReturnStatus;
            }
            catch (e) {
                (_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.close();
                throw e;
            }
        });
        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {
            var _a;
            const record = runnerContext;
            const { status, stopwatch, _operationMetadataManager: operationMetadataManager, operation } = record;
            const { associatedProject: project, associatedPhase: phase, runner } = operation;
            if (!project || !phase || !(runner === null || runner === void 0 ? void 0 : runner.cacheable)) {
                return;
            }
            const buildCacheContext = this._getBuildCacheContextByOperation(operation);
            if (!buildCacheContext) {
                return;
            }
            // No need to run for the following operation status
            switch (record.status) {
                case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.NoOp:
                case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.RemoteExecuting: {
                    return;
                }
                default: {
                    break;
                }
            }
            const { cobuildLock, projectBuildCache, isCacheWriteAllowed, buildCacheTerminal, cacheRestored } = buildCacheContext;
            try {
                if (!cacheRestored) {
                    // Save the metadata to disk
                    const { logFilenameIdentifier } = phase;
                    const { duration: durationInSeconds } = stopwatch;
                    const { logPath, errorLogPath } = _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_7__.ProjectLogWritable.getLogFilePaths({
                        project,
                        logFilenameIdentifier
                    });
                    await (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.saveAsync({
                        durationInSeconds,
                        cobuildContextId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildContextId,
                        cobuildRunnerId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildRunnerId,
                        logPath,
                        errorLogPath
                    }));
                }
                if (!buildCacheTerminal) {
                    // This should not happen
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Build Cache Terminal is not created`);
                }
                let setCompletedStatePromiseFunction;
                let setCacheEntryPromise;
                if (cobuildLock && isCacheWriteAllowed) {
                    const { cacheId, contextId } = cobuildLock.cobuildContext;
                    const finalCacheId = status === _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Failure ? `${cacheId}-${contextId}-failed` : cacheId;
                    switch (status) {
                        case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.SuccessWithWarning:
                        case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Success:
                        case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Failure: {
                            const currentStatus = status;
                            setCompletedStatePromiseFunction = () => {
                                return cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.setCompletedStateAsync({
                                    status: currentStatus,
                                    cacheId: finalCacheId
                                });
                            };
                            setCacheEntryPromise = () => cobuildLock.projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal, finalCacheId);
                        }
                    }
                }
                const taskIsSuccessful = status === _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Success ||
                    (status === _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.SuccessWithWarning &&
                        record.runner.warningsAreAllowed &&
                        allowWarningsInSuccessfulBuild);
                // If the command is successful, we can calculate project hash, and no dependencies were skipped,
                // write a new cache entry.
                if (!setCacheEntryPromise && taskIsSuccessful && isCacheWriteAllowed && projectBuildCache) {
                    setCacheEntryPromise = () => projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal);
                }
                if (!cacheRestored) {
                    const cacheWriteSuccess = await (setCacheEntryPromise === null || setCacheEntryPromise === void 0 ? void 0 : setCacheEntryPromise());
                    await (setCompletedStatePromiseFunction === null || setCompletedStatePromiseFunction === void 0 ? void 0 : setCompletedStatePromiseFunction());
                    if (cacheWriteSuccess === false && status === _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Success) {
                        record.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.SuccessWithWarning;
                    }
                }
            }
            finally {
                (_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.close();
                buildCacheContext.periodicCallback.stop();
            }
        });
        hooks.afterExecuteOperation.tap(PLUGIN_NAME, (record) => {
            const { operation } = record;
            const buildCacheContext = this._buildCacheContextByOperation.get(operation);
            // Status changes to direct dependents
            let blockCacheWrite = !(buildCacheContext === null || buildCacheContext === void 0 ? void 0 : buildCacheContext.isCacheWriteAllowed);
            switch (record.status) {
                case _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Skipped: {
                    // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.
                    blockCacheWrite = true;
                    break;
                }
            }
            // Apply status changes to direct dependents
            if (blockCacheWrite) {
                for (const consumer of operation.consumers) {
                    const consumerBuildCacheContext = this._getBuildCacheContextByOperation(consumer);
                    if (consumerBuildCacheContext) {
                        consumerBuildCacheContext.isCacheWriteAllowed = false;
                    }
                }
            }
        });
        hooks.afterExecuteOperations.tapPromise(PLUGIN_NAME, async () => {
            this._buildCacheContextByOperation.clear();
        });
    }
    _getBuildCacheContextByOperation(operation) {
        const buildCacheContext = this._buildCacheContextByOperation.get(operation);
        return buildCacheContext;
    }
    _getBuildCacheContextByOperationOrThrow(operation) {
        const buildCacheContext = this._getBuildCacheContextByOperation(operation);
        if (!buildCacheContext) {
            // This should not happen
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Build cache context for operation ${operation.name} should be defined`);
        }
        return buildCacheContext;
    }
    async _tryGetProjectBuildCacheAsync({ buildCacheConfiguration, buildCacheContext, rushProject, phase, configHash, terminal, operationMetadataManager }) {
        if (!buildCacheContext.projectBuildCache) {
            const { cacheDisabledReason } = buildCacheContext;
            if (cacheDisabledReason) {
                terminal.writeVerboseLine(cacheDisabledReason);
                return;
            }
            const { operationSettings, projectChangeAnalyzer } = buildCacheContext;
            if (!operationSettings || !buildCacheConfiguration) {
                // Unreachable, since this will have set `cacheDisabledReason`.
                return;
            }
            const projectOutputFolderNames = operationSettings.outputFolderNames || [];
            const additionalProjectOutputFilePaths = (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.relativeFilepaths) || [];
            const additionalContext = {};
            await updateAdditionalContextAsync({
                operationSettings,
                additionalContext,
                projectChangeAnalyzer,
                terminal,
                rushProject
            });
            // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent
            buildCacheContext.projectBuildCache = await _buildCache_ProjectBuildCache__WEBPACK_IMPORTED_MODULE_9__.ProjectBuildCache.tryGetProjectBuildCache({
                project: rushProject,
                projectOutputFolderNames,
                additionalProjectOutputFilePaths,
                additionalContext,
                buildCacheConfiguration,
                terminal,
                configHash,
                projectChangeAnalyzer,
                phaseName: phase.name
            });
        }
        return buildCacheContext.projectBuildCache;
    }
    // Get a ProjectBuildCache only cache/restore log files
    async _tryGetLogOnlyProjectBuildCacheAsync({ buildCacheContext, rushProject, terminal, configHash, buildCacheConfiguration, cobuildConfiguration, phase, operationMetadataManager }) {
        var _a;
        if (!(buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled)) {
            return;
        }
        const { operationSettings, projectChangeAnalyzer } = buildCacheContext;
        const projectOutputFolderNames = (_a = operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.outputFolderNames) !== null && _a !== void 0 ? _a : [];
        const additionalProjectOutputFilePaths = (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.relativeFilepaths) || [];
        const additionalContext = {
            // Force the cache to be a log files only cache
            logFilesOnly: '1'
        };
        if (cobuildConfiguration.cobuildContextId) {
            additionalContext.cobuildContextId = cobuildConfiguration.cobuildContextId;
        }
        if (operationSettings) {
            await updateAdditionalContextAsync({
                operationSettings,
                additionalContext,
                projectChangeAnalyzer,
                terminal,
                rushProject
            });
        }
        const projectBuildCache = await _buildCache_ProjectBuildCache__WEBPACK_IMPORTED_MODULE_9__.ProjectBuildCache.tryGetProjectBuildCache({
            project: rushProject,
            projectOutputFolderNames,
            additionalProjectOutputFilePaths,
            additionalContext,
            buildCacheConfiguration,
            terminal,
            configHash,
            projectChangeAnalyzer,
            phaseName: phase.name
        });
        // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent
        buildCacheContext.projectBuildCache = projectBuildCache;
        return projectBuildCache;
    }
    async _tryGetCobuildLockAsync({ cobuildConfiguration, buildCacheContext, projectBuildCache, packageName, phaseName }) {
        if (!buildCacheContext.cobuildLock) {
            if (projectBuildCache && (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)) {
                if (!buildCacheContext.cobuildClusterId) {
                    // This should not happen
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('Cobuild cluster id is not defined');
                }
                buildCacheContext.cobuildLock = new _cobuild_CobuildLock__WEBPACK_IMPORTED_MODULE_10__.CobuildLock({
                    cobuildConfiguration,
                    projectBuildCache,
                    cobuildClusterId: buildCacheContext.cobuildClusterId,
                    lockExpireTimeInSeconds: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 3,
                    packageName,
                    phaseName
                });
            }
        }
        return buildCacheContext.cobuildLock;
    }
    _getBuildCacheTerminal({ record, buildCacheContext, buildCacheEnabled: buildCacheEnabled, rushProject, logFilenameIdentifier, quietMode, debugMode }) {
        var _a;
        if (!buildCacheContext.buildCacheTerminal ||
            ((_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.isOpen) === false) {
            // The ProjectLogWritable is does not exist or is closed, re-create one
            buildCacheContext.buildCacheTerminal = this._createBuildCacheTerminal({
                record,
                buildCacheContext,
                buildCacheEnabled,
                rushProject,
                logFilenameIdentifier,
                quietMode,
                debugMode
            });
        }
        return buildCacheContext.buildCacheTerminal;
    }
    _createBuildCacheTerminal({ record, buildCacheContext, buildCacheEnabled, rushProject, logFilenameIdentifier, quietMode, debugMode }) {
        const silent = record.runner.silent;
        if (silent) {
            const nullTerminalProvider = new _utilities_NullTerminalProvider__WEBPACK_IMPORTED_MODULE_11__.NullTerminalProvider();
            return new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(nullTerminalProvider);
        }
        let cacheConsoleWritable;
        // This creates the writer, only do this if necessary.
        const collatedWriter = record.collatedWriter;
        const cacheProjectLogWritable = this._tryGetBuildCacheProjectLogWritable({
            buildCacheContext,
            buildCacheEnabled,
            rushProject,
            collatedTerminal: collatedWriter.terminal,
            logFilenameIdentifier
        });
        if (quietMode) {
            const discardTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__.DiscardStdoutTransform({
                destination: collatedWriter
            });
            const normalizeNewlineTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__.TextRewriterTransform({
                destination: discardTransform,
                normalizeNewlines: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.NewlineKind.Lf,
                ensureNewlineAtEnd: true
            });
            cacheConsoleWritable = normalizeNewlineTransform;
        }
        else {
            cacheConsoleWritable = collatedWriter;
        }
        let cacheCollatedTerminal;
        if (cacheProjectLogWritable) {
            const cacheSplitterTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_3__.SplitterTransform({
                destinations: [cacheConsoleWritable, cacheProjectLogWritable]
            });
            cacheCollatedTerminal = new _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__.CollatedTerminal(cacheSplitterTransform);
        }
        else {
            cacheCollatedTerminal = new _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__.CollatedTerminal(cacheConsoleWritable);
        }
        const buildCacheTerminalProvider = new _utilities_CollatedTerminalProvider__WEBPACK_IMPORTED_MODULE_12__.CollatedTerminalProvider(cacheCollatedTerminal, {
            debugEnabled: debugMode
        });
        return new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(buildCacheTerminalProvider);
    }
    _tryGetBuildCacheProjectLogWritable({ buildCacheEnabled, rushProject, buildCacheContext, collatedTerminal, logFilenameIdentifier }) {
        // Only open the *.cache.log file(s) if the cache is enabled.
        if (!buildCacheEnabled) {
            return;
        }
        buildCacheContext.buildCacheProjectLogWritable = new _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_7__.ProjectLogWritable(rushProject, collatedTerminal, `${logFilenameIdentifier}.cache`);
        return buildCacheContext.buildCacheProjectLogWritable;
    }
}
async function updateAdditionalContextAsync({ operationSettings, additionalContext, projectChangeAnalyzer, terminal, rushProject }) {
    if (operationSettings.dependsOnEnvVars) {
        for (const varName of operationSettings.dependsOnEnvVars) {
            additionalContext['$' + varName] = process.env[varName] || '';
        }
    }
    if (operationSettings.dependsOnAdditionalFiles) {
        const repoState = await projectChangeAnalyzer._ensureInitializedAsync(terminal);
        const additionalFiles = await (0,_buildCache_getHashesForGlobsAsync__WEBPACK_IMPORTED_MODULE_13__.getHashesForGlobsAsync)(operationSettings.dependsOnAdditionalFiles, rushProject.projectFolder, repoState);
        terminal.writeDebugLine(`Including additional files to calculate build cache hash:\n  ${Array.from(additionalFiles.keys()).join('\n  ')} `);
        for (const [filePath, fileHash] of additionalFiles) {
            additionalContext['file://' + filePath] = fileHash;
        }
    }
}
//# sourceMappingURL=CacheableOperationPlugin.js.map

/***/ }),

/***/ 74151:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/operations/LegacySkipPlugin.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegacySkipPlugin": () => (/* binding */ LegacySkipPlugin)
/* harmony export */ });
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ 149411);
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OperationStatus */ 476597);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const PLUGIN_NAME = 'LegacySkipPlugin';
function _areShallowEqual(object1, object2) {
    for (const n in object1) {
        if (!(n in object2) || object1[n] !== object2[n]) {
            return false;
        }
    }
    for (const n in object2) {
        if (!(n in object1)) {
            return false;
        }
    }
    return true;
}
/**
 * Core phased command plugin that implements the legacy skip detection logic, used when build cache is disabled.
 */
class LegacySkipPlugin {
    constructor(options) {
        this._options = options;
    }
    apply(hooks) {
        const stateMap = new WeakMap();
        let projectChangeAnalyzer;
        const { terminal, changedProjectsOnly, isIncrementalBuildAllowed } = this._options;
        hooks.createOperations.tap(PLUGIN_NAME, (operations, context) => {
            projectChangeAnalyzer = context.projectChangeAnalyzer;
            return operations;
        });
        hooks.beforeExecuteOperations.tapPromise(PLUGIN_NAME, async (operations) => {
            let logGitWarning = false;
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Async.forEachAsync(operations.values(), async (record) => {
                const { operation } = record;
                const { associatedProject, associatedPhase, runner } = operation;
                if (!associatedProject || !associatedPhase || !runner) {
                    return;
                }
                if (!runner.cacheable) {
                    stateMap.set(operation, {
                        allowSkip: true,
                        packageDeps: undefined,
                        packageDepsPath: ''
                    });
                    return;
                }
                const packageDepsFilename = `package-deps_${associatedPhase.logFilenameIdentifier}.json`;
                const packageDepsPath = node_path__WEBPACK_IMPORTED_MODULE_0___default().join(associatedProject.projectRushTempFolder, packageDepsFilename);
                let packageDeps;
                try {
                    const fileHashes = await projectChangeAnalyzer._tryGetProjectDependenciesAsync(associatedProject, terminal);
                    if (!fileHashes) {
                        logGitWarning = true;
                        return;
                    }
                    const files = {};
                    for (const [filePath, fileHash] of fileHashes) {
                        files[filePath] = fileHash;
                    }
                    packageDeps = {
                        files,
                        arguments: runner.getConfigHash()
                    };
                }
                catch (error) {
                    // To test this code path:
                    // Delete a project's ".rush/temp/shrinkwrap-deps.json" then run "rush build --verbose"
                    terminal.writeLine(`Unable to calculate incremental state for ${record.operation.name}: ` +
                        error.toString());
                    terminal.writeLine({
                        text: 'Rush will proceed without incremental execution and change detection.',
                        foregroundColor: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ColorValue.Cyan
                    });
                }
                stateMap.set(operation, {
                    packageDepsPath,
                    packageDeps,
                    allowSkip: isIncrementalBuildAllowed
                });
            });
            if (logGitWarning) {
                // To test this code path:
                // Remove the `.git` folder then run "rush build --verbose"
                terminal.writeLine({
                    text: _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords('This workspace does not appear to be tracked by Git. ' +
                        'Rush will proceed without incremental execution, caching, and change detection.'),
                    foregroundColor: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ColorValue.Cyan
                });
            }
        });
        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {
            const { operation } = record;
            const skipRecord = stateMap.get(operation);
            if (!skipRecord) {
                // This operation doesn't support skip detection.
                return;
            }
            if (!operation.runner.cacheable) {
                // This operation doesn't support skip detection.
                return;
            }
            const { associatedProject } = operation;
            const { packageDepsPath, packageDeps, allowSkip } = skipRecord;
            let lastProjectDeps = undefined;
            try {
                const lastDepsContents = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFileAsync(packageDepsPath);
                lastProjectDeps = JSON.parse(lastDepsContents);
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isNotExistError(e)) {
                    // Warn and ignore - treat failing to load the file as the operation being not built.
                    // TODO: Update this to be the terminal specific to the operation.
                    terminal.writeWarningLine(`Warning: error parsing ${packageDepsPath}: ${e}. Ignoring and treating this operation as not run.`);
                }
            }
            if (allowSkip) {
                const isPackageUnchanged = !!(lastProjectDeps &&
                    packageDeps &&
                    packageDeps.arguments === lastProjectDeps.arguments &&
                    _areShallowEqual(packageDeps.files, lastProjectDeps.files));
                if (isPackageUnchanged) {
                    return _OperationStatus__WEBPACK_IMPORTED_MODULE_3__.OperationStatus.Skipped;
                }
            }
            // TODO: Remove legacyDepsPath with the next major release of Rush
            const legacyDepsPath = node_path__WEBPACK_IMPORTED_MODULE_0___default().join(associatedProject.projectFolder, 'package-deps.json');
            await Promise.all([
                // Delete the legacy package-deps.json
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.deleteFileAsync(legacyDepsPath),
                // If the deps file exists, remove it before starting execution.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.deleteFileAsync(packageDepsPath)
            ]);
        });
        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {
            const { status, operation } = record;
            const skipRecord = stateMap.get(operation);
            if (!skipRecord) {
                return;
            }
            const blockSkip = !skipRecord.allowSkip ||
                (!changedProjectsOnly &&
                    (status === _OperationStatus__WEBPACK_IMPORTED_MODULE_3__.OperationStatus.Success || status === _OperationStatus__WEBPACK_IMPORTED_MODULE_3__.OperationStatus.SuccessWithWarning));
            if (blockSkip) {
                for (const consumer of operation.consumers) {
                    const consumerSkipRecord = stateMap.get(consumer);
                    if (consumerSkipRecord) {
                        consumerSkipRecord.allowSkip = false;
                    }
                }
            }
            if (!record.operation.runner.cacheable) {
                // This operation doesn't support skip detection.
                return;
            }
            const { packageDeps, packageDepsPath } = skipRecord;
            if ((packageDeps && status === _OperationStatus__WEBPACK_IMPORTED_MODULE_3__.OperationStatus.Success) || status === _OperationStatus__WEBPACK_IMPORTED_MODULE_3__.OperationStatus.NoOp) {
                // Write deps on success.
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.saveAsync(packageDeps, packageDepsPath, {
                    ensureFolderExists: true
                });
            }
        });
    }
}
//# sourceMappingURL=LegacySkipPlugin.js.map

/***/ }),

/***/ 969003:
/*!************************************************************!*\
  !*** ./lib-esnext/logic/operations/NullOperationRunner.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullOperationRunner": () => (/* binding */ NullOperationRunner)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Implementation of `IOperationRunner` for operations that require no work, such as empty scripts,
 * skipped operations, or blocked operations.
 */
class NullOperationRunner {
    constructor({ name, result, silent }) {
        // This operation does nothing, so timing is meaningless
        this.reportTiming = false;
        // The operation is a no-op, so it is faster to not cache it
        this.cacheable = false;
        // Nothing will get logged, no point allowing warnings
        this.warningsAreAllowed = false;
        this.isNoOp = true;
        this.name = name;
        this.result = result;
        this.silent = silent;
    }
    async executeAsync(context) {
        return this.result;
    }
    getConfigHash() {
        return '';
    }
}
//# sourceMappingURL=NullOperationRunner.js.map

/***/ }),

/***/ 768667:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/operations/Operation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Operation": () => (/* binding */ Operation)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the
 * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose
 * implementation manages the actual process of running a single operation.
 *
 * The graph of `Operation` instances will be cloned into a separate execution graph after processing.
 *
 * @alpha
 */
class Operation {
    constructor(options) {
        /**
         * A set of all operations which depend on this operation.
         */
        this.consumers = new Set();
        /**
         * A set of all dependencies which must be executed before this operation is complete.
         */
        this.dependencies = new Set();
        /**
         * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of
         * running the operation.
         */
        this.runner = undefined;
        /**
         * The weight for this operation. This scalar is the contribution of this operation to the
         * `criticalPathLength` calculation above. Modify to indicate the following:
         * - `weight` === 1: indicates that this operation has an average duration
         * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler
         *     should try to favor starting it over other, shorter operations. An example might be an operation that
         *     bundles an entire application and runs whole-program optimization.
         * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler
         *     should favor other, longer operations over it. An example might be an operation to unpack a cached
         *     output, or an operation using NullOperationRunner, which might use a value of 0.
         */
        this.weight = 1;
        this.associatedPhase = options === null || options === void 0 ? void 0 : options.phase;
        this.associatedProject = options === null || options === void 0 ? void 0 : options.project;
        this.runner = options === null || options === void 0 ? void 0 : options.runner;
    }
    /**
     * The name of this operation, for logging.
     */
    get name() {
        var _a;
        return (_a = this.runner) === null || _a === void 0 ? void 0 : _a.name;
    }
    /**
     * Adds the specified operation as a dependency and updates the consumer list.
     */
    addDependency(dependency) {
        // Cast internally to avoid adding the overhead of getters
        this.dependencies.add(dependency);
        dependency.consumers.add(this);
    }
    /**
     * Deletes the specified operation as a dependency and updates the consumer list.
     */
    deleteDependency(dependency) {
        // Cast internally to avoid adding the overhead of getters
        this.dependencies.delete(dependency);
        dependency.consumers.delete(this);
    }
}
//# sourceMappingURL=Operation.js.map

/***/ }),

/***/ 593956:
/*!*******************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationError.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationError": () => (/* binding */ OperationError)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Encapsulates information about an error
 * @alpha
 */
class OperationError extends Error {
    constructor(type, message) {
        super(message);
        this._type = type;
    }
    get message() {
        return `[${this._type}] '${super.message}'`;
    }
    toString() {
        return this.message;
    }
}
//# sourceMappingURL=OperationError.js.map

/***/ }),

/***/ 576472:
/*!******************************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationExecutionManager.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExecutionManager": () => (/* binding */ OperationExecutionManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/stream-collator */ 121452);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _AsyncOperationQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AsyncOperationQueue */ 546617);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./OperationStatus */ 476597);
/* harmony import */ var _OperationExecutionRecord__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OperationExecutionRecord */ 977529);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







/**
 * Format "======" lines for a shell window with classic 80 columns
 */
const ASCII_HEADER_WIDTH = 79;
const prioritySort = (a, b) => {
    return a.criticalPathLength - b.criticalPathLength;
};
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
class OperationExecutionManager {
    constructor(operations, options) {
        this._streamCollator_onWriterActive = (writer) => {
            if (writer) {
                this._completedOperations++;
                // Format a header like this
                //
                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==
                // leftPart: "==[ @rushstack/the-long-thing "
                const leftPart = colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray('==[') + ' ' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(writer.taskName) + ' ';
                const leftPartLength = 4 + writer.taskName.length + 1;
                // rightPart: " 1 of 1000 ]=="
                const completedOfTotal = `${this._completedOperations} of ${this._totalOperations}`;
                const rightPart = ' ' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().white(completedOfTotal) + ' ' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(']==');
                const rightPartLength = 1 + completedOfTotal.length + 4;
                // middlePart: "]=================["
                const twoBracketsLength = 2;
                const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
                const middlePart = colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');
                this._terminal.writeStdoutLine('\n' + leftPart + middlePart + rightPart);
                if (!this._quietMode) {
                    this._terminal.writeStdoutLine('');
                }
            }
        };
        const { quietMode, debugMode, parallelism, changedProjectsOnly, beforeExecuteOperation, afterExecuteOperation, onOperationStatusChanged, beforeExecuteOperations } = options;
        this._completedOperations = 0;
        this._quietMode = quietMode;
        this._hasAnyFailures = false;
        this._hasAnyNonAllowedWarnings = false;
        this._changedProjectsOnly = changedProjectsOnly;
        this._parallelism = parallelism;
        this._beforeExecuteOperation = beforeExecuteOperation;
        this._afterExecuteOperation = afterExecuteOperation;
        this._beforeExecuteOperations = beforeExecuteOperations;
        this._onOperationStatusChanged = onOperationStatusChanged;
        // TERMINAL PIPELINE:
        //
        // streamCollator --> colorsNewlinesTransform --> StdioWritable
        //
        this._outputWritable = options.destination || _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.StdioWritable.instance;
        this._colorsNewlinesTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TextRewriterTransform({
            destination: this._outputWritable,
            normalizeNewlines: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.NewlineKind.OsDefault,
            removeColors: !(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().enabled)
        });
        this._streamCollator = new _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__.StreamCollator({
            destination: this._colorsNewlinesTransform,
            onWriterActive: this._streamCollator_onWriterActive
        });
        this._terminal = this._streamCollator.terminal;
        // Convert the developer graph to the mutable execution graph
        const executionRecordContext = {
            streamCollator: this._streamCollator,
            onOperationStatusChanged,
            debugMode,
            quietMode,
            changedProjectsOnly
        };
        let totalOperations = 0;
        const executionRecords = (this._executionRecords = new Map());
        for (const operation of operations) {
            const executionRecord = new _OperationExecutionRecord__WEBPACK_IMPORTED_MODULE_4__.OperationExecutionRecord(operation, executionRecordContext);
            executionRecords.set(operation, executionRecord);
            if (!executionRecord.runner.silent) {
                // Only count non-silent operations
                totalOperations++;
            }
        }
        this._totalOperations = totalOperations;
        for (const [operation, consumer] of executionRecords) {
            for (const dependency of operation.dependencies) {
                const dependencyRecord = executionRecords.get(dependency);
                if (!dependencyRecord) {
                    throw new Error(`Operation "${consumer.name}" declares a dependency on operation "${dependency.name}" that is not in the set of operations to execute.`);
                }
                consumer.dependencies.add(dependencyRecord);
                dependencyRecord.consumers.add(consumer);
            }
        }
        const executionQueue = new _AsyncOperationQueue__WEBPACK_IMPORTED_MODULE_5__.AsyncOperationQueue(this._executionRecords.values(), prioritySort);
        this._executionQueue = executionQueue;
    }
    /**
     * Executes all operations which have been registered, returning a promise which is resolved when all the
     * operations are completed successfully, or rejects when any operation fails.
     */
    async executeAsync() {
        var _a;
        this._completedOperations = 0;
        const totalOperations = this._totalOperations;
        if (!this._quietMode) {
            const plural = totalOperations === 1 ? '' : 's';
            this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);
            const nonSilentOperations = [];
            for (const record of this._executionRecords.values()) {
                if (!record.runner.silent) {
                    nonSilentOperations.push(record.name);
                }
            }
            nonSilentOperations.sort();
            for (const name of nonSilentOperations) {
                this._terminal.writeStdoutLine(`  ${name}`);
            }
            this._terminal.writeStdoutLine('');
        }
        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);
        const maxParallelism = Math.min(totalOperations, this._parallelism);
        await ((_a = this._beforeExecuteOperations) === null || _a === void 0 ? void 0 : _a.call(this, this._executionRecords));
        // This function is a callback because it may write to the collatedWriter before
        // operation.executeAsync returns (and cleans up the writer)
        const onOperationCompleteAsync = async (record) => {
            var _a, _b;
            try {
                await ((_a = this._afterExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));
            }
            catch (e) {
                // Failed operations get reported here
                const message = (_b = record.error) === null || _b === void 0 ? void 0 : _b.message;
                if (message) {
                    this._terminal.writeStderrLine('Unhandled exception: ');
                    this._terminal.writeStderrLine(message);
                }
                throw e;
            }
            this._onOperationComplete(record);
        };
        const onOperationStartAsync = async (record) => {
            var _a;
            return await ((_a = this._beforeExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));
        };
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.forEachAsync(this._executionQueue, async (operation) => {
            let record;
            /**
             * If the operation is UNASSIGNED_OPERATION, it means that the queue is not able to assign a operation.
             * This happens when some operations run remotely. So, we should try to get a remote executing operation
             * from the queue manually here.
             */
            if (operation === _AsyncOperationQueue__WEBPACK_IMPORTED_MODULE_5__.UNASSIGNED_OPERATION) {
                // Pause for a few time
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.sleep(5000);
                record = this._executionQueue.tryGetRemoteExecutingOperation();
            }
            else {
                record = operation;
            }
            if (!record) {
                // Fail to assign a operation, start over again
                return;
            }
            else {
                await record.executeAsync({
                    onStart: onOperationStartAsync,
                    onResult: onOperationCompleteAsync
                });
            }
        }, {
            concurrency: maxParallelism
        });
        const status = this._hasAnyFailures
            ? _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Failure
            : this._hasAnyNonAllowedWarnings
                ? _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.SuccessWithWarning
                : _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Success;
        return {
            operationResults: this._executionRecords,
            status
        };
    }
    /**
     * Handles the result of the operation and propagates any relevant effects.
     */
    _onOperationComplete(record) {
        var _a;
        const { runner, name, status } = record;
        const silent = runner.silent;
        switch (status) {
            /**
             * This operation failed. Mark it as such and all reachable dependents as blocked.
             */
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Failure: {
                // Failed operations get reported, even if silent.
                // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.
                const message = (_a = record.error) === null || _a === void 0 ? void 0 : _a.message;
                // This creates the writer, so don't do this globally
                const { terminal } = record.collatedWriter;
                if (message) {
                    terminal.writeStderrLine(message);
                }
                terminal.writeStderrLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`"${name}" failed to build.`));
                const blockedQueue = new Set(record.consumers);
                for (const blockedRecord of blockedQueue) {
                    if (blockedRecord.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Waiting) {
                        // Now that we have the concept of architectural no-ops, we could implement this by replacing
                        // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking
                        // operations. However, the existing behavior is a bit simpler, so keeping that for now.
                        if (!blockedRecord.runner.silent) {
                            terminal.writeStdoutLine(`"${blockedRecord.name}" is blocked by "${name}".`);
                        }
                        blockedRecord.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Blocked;
                        this._executionQueue.complete(blockedRecord);
                        this._completedOperations++;
                        for (const dependent of blockedRecord.consumers) {
                            blockedQueue.add(dependent);
                        }
                    }
                    else if (blockedRecord.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Blocked) {
                        // It shouldn't be possible for operations to be in any state other than Waiting or Blocked
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.InternalError(`Blocked operation ${blockedRecord.name} is in an unexpected state: ${blockedRecord.status}`);
                    }
                }
                this._hasAnyFailures = true;
                break;
            }
            /**
             * This operation was restored from the build cache.
             */
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.FromCache: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`"${name}" was restored from the build cache.`));
                }
                break;
            }
            /**
             * This operation was skipped via legacy change detection.
             */
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Skipped: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`"${name}" was skipped.`));
                }
                break;
            }
            /**
             * This operation intentionally didn't do anything.
             */
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.NoOp: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(`"${name}" did not define any work.`));
                }
                break;
            }
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.Success: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`"${name}" completed successfully in ${record.stopwatch.toString()}.`));
                }
                break;
            }
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.SuccessWithWarning: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStderrLine(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`"${name}" completed with warnings in ${record.stopwatch.toString()}.`));
                }
                this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;
                break;
            }
        }
        if (record.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_6__.OperationStatus.RemoteExecuting) {
            // If the operation was not remote, then we can notify queue that it is complete
            this._executionQueue.complete(record);
        }
    }
}
//# sourceMappingURL=OperationExecutionManager.js.map

/***/ }),

/***/ 977529:
/*!*****************************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationExecutionRecord.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExecutionRecord": () => (/* binding */ OperationExecutionRecord)
/* harmony export */ });
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OperationStatus */ 476597);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _OperationMetadataManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OperationMetadataManager */ 441895);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * Internal class representing everything about executing an operation
 *
 * @internal
 */
class OperationExecutionRecord {
    constructor(operation, context) {
        /**
         * The error which occurred while executing this operation, this is stored in case we need
         * it later (for example to re-print errors at end of execution).
         */
        this.error = undefined;
        /**
         * This number represents how far away this Operation is from the furthest "root" operation (i.e.
         * an operation with no consumers). This helps us to calculate the critical path (i.e. the
         * longest chain of projects which must be executed in order, thereby limiting execution speed
         * of the entire operation tree.
         *
         * This number is calculated via a memoized depth-first search, and when choosing the next
         * operation to execute, the operation with the highest criticalPathLength is chosen.
         *
         * Example:
         * ```
         *        (0) A
         *             \
         *          (1) B     C (0)         (applications)
         *               \   /|\
         *                \ / | \
         *             (2) D  |  X (1)      (utilities)
         *                    | / \
         *                    |/   \
         *                (2) Y     Z (2)   (other utilities)
         *
         * All roots (A & C) have a criticalPathLength of 0.
         * B has a score of 1, since A depends on it.
         * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)
         * X has a score of 1, since the only package which depends on it is A
         * Z has a score of 2, since only X depends on it, and X has a score of 1
         * Y has a score of 2, since the chain Y->X->C is longer than Y->C
         * ```
         *
         * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()
         */
        this.criticalPathLength = undefined;
        /**
         * The set of operations that must complete before this operation executes.
         */
        this.dependencies = new Set();
        /**
         * The set of operations that depend on this operation.
         */
        this.consumers = new Set();
        this.stopwatch = new _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_2__.Stopwatch();
        this.stdioSummarizer = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_0__.StdioSummarizer();
        this._collatedWriter = undefined;
        const { runner, associatedPhase, associatedProject } = operation;
        if (!runner) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Operation for phase '${associatedPhase === null || associatedPhase === void 0 ? void 0 : associatedPhase.name}' and project '${associatedProject === null || associatedProject === void 0 ? void 0 : associatedProject.packageName}' has no runner.`);
        }
        this.operation = operation;
        this.runner = runner;
        this.weight = operation.weight;
        this.associatedPhase = associatedPhase;
        this.associatedProject = associatedProject;
        if (operation.associatedPhase && operation.associatedProject) {
            this._operationMetadataManager = new _OperationMetadataManager__WEBPACK_IMPORTED_MODULE_3__.OperationMetadataManager({
                phase: operation.associatedPhase,
                rushProject: operation.associatedProject
            });
        }
        this._context = context;
        this._status = operation.dependencies.size > 0 ? _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.Waiting : _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.Ready;
    }
    get name() {
        return this.runner.name;
    }
    get debugMode() {
        return this._context.debugMode;
    }
    get quietMode() {
        return this._context.quietMode;
    }
    get changedProjectsOnly() {
        return this._context.changedProjectsOnly;
    }
    get collatedWriter() {
        // Lazy instantiate because the registerTask() call affects display ordering
        if (!this._collatedWriter) {
            this._collatedWriter = this._context.streamCollator.registerTask(this.name);
        }
        return this._collatedWriter;
    }
    get nonCachedDurationMs() {
        var _a, _b;
        // Lazy calculated because the state file is created/restored later on
        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.nonCachedDurationMs;
    }
    get cobuildRunnerId() {
        var _a, _b;
        // Lazy calculated because the state file is created/restored later on
        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.cobuildRunnerId;
    }
    /**
     * The current execution status of an operation. Operations start in the 'ready' state,
     * but can be 'blocked' if an upstream operation failed. It is 'executing' when
     * the operation is executing. Once execution is complete, it is either 'success' or
     * 'failure'.
     */
    get status() {
        return this._status;
    }
    set status(newStatus) {
        var _a, _b;
        if (newStatus === this._status) {
            return;
        }
        this._status = newStatus;
        (_b = (_a = this._context).onOperationStatusChanged) === null || _b === void 0 ? void 0 : _b.call(_a, this);
    }
    async executeAsync({ onStart, onResult }) {
        var _a;
        if (this.status === _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.RemoteExecuting) {
            this.stopwatch.reset();
        }
        this.stopwatch.start();
        this.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.Executing;
        try {
            const earlyReturnStatus = await onStart(this);
            // When the operation status returns by the hook, bypass the runner execution.
            if (earlyReturnStatus) {
                this.status = earlyReturnStatus;
            }
            else {
                this.status = await this.runner.executeAsync(this);
            }
            // Delegate global state reporting
            await onResult(this);
        }
        catch (error) {
            this.status = _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.Failure;
            this.error = error;
            // Delegate global state reporting
            await onResult(this);
        }
        finally {
            if (this.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_4__.OperationStatus.RemoteExecuting) {
                (_a = this._collatedWriter) === null || _a === void 0 ? void 0 : _a.close();
                this.stdioSummarizer.close();
                this.stopwatch.stop();
            }
        }
    }
}
//# sourceMappingURL=OperationExecutionRecord.js.map

/***/ }),

/***/ 441895:
/*!*****************************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationMetadataManager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationMetadataManager": () => (/* binding */ OperationMetadataManager)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 657147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _OperationStateFile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OperationStateFile */ 600463);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __asyncValues = (undefined && undefined.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};




/**
 * A helper class for managing the meta files of a operation.
 *
 * @internal
 */
class OperationMetadataManager {
    constructor(options) {
        const { rushProject, phase } = options;
        const { projectFolder } = rushProject;
        const identifier = phase.logFilenameIdentifier;
        this._metadataFolder = `${_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.projectRushFolderName}/${_RushConstants__WEBPACK_IMPORTED_MODULE_2__.RushConstants.rushTempFolderName}/operation/${identifier}`;
        this.stateFile = new _OperationStateFile__WEBPACK_IMPORTED_MODULE_3__.OperationStateFile({
            projectFolder: projectFolder,
            metadataFolder: this._metadataFolder
        });
        this._relativeLogPath = `${this._metadataFolder}/all.log`;
        this._relativeErrorLogPath = `${this._metadataFolder}/error.log`;
        this._logPath = `${projectFolder}/${this._relativeLogPath}`;
        this._errorLogPath = `${projectFolder}/${this._relativeErrorLogPath}`;
    }
    /**
     * Returns the relative paths of the metadata files to project folder.
     *
     * Example: `.rush/temp/operation/_phase_build/state.json`
     * Example: `.rush/temp/operation/_phase_build/all.log`
     * Example: `.rush/temp/operation/_phase_build/error.log`
     */
    get relativeFilepaths() {
        return [this.stateFile.relativeFilepath, this._relativeLogPath, this._relativeErrorLogPath];
    }
    async saveAsync({ durationInSeconds, cobuildContextId, cobuildRunnerId, logPath, errorLogPath }) {
        const state = {
            nonCachedDurationMs: durationInSeconds * 1000,
            cobuildContextId,
            cobuildRunnerId
        };
        await this.stateFile.writeAsync(state);
        const copyFileOptions = [
            {
                sourcePath: logPath,
                destinationPath: this._logPath
            },
            {
                sourcePath: errorLogPath,
                destinationPath: this._errorLogPath
            }
        ];
        // Try to copy log files
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Async.forEachAsync(copyFileOptions, async (options) => {
            try {
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFileAsync(options);
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isNotExistError(e)) {
                    throw e;
                }
            }
        });
    }
    async tryRestoreAsync({ terminal, logPath, errorLogPath }) {
        var _a, e_1, _b, _c;
        await this.stateFile.tryRestoreAsync();
        // Append cached log into current log file
        terminal.writeLine(`Restoring cached log file at ${this._logPath}`);
        let logReadStream;
        try {
            logReadStream = fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream(this._logPath, {
                encoding: 'utf-8'
            });
            try {
                for (var _d = true, logReadStream_1 = __asyncValues(logReadStream), logReadStream_1_1; logReadStream_1_1 = await logReadStream_1.next(), _a = logReadStream_1_1.done, !_a;) {
                    _c = logReadStream_1_1.value;
                    _d = false;
                    try {
                        const data = _c;
                        terminal.write(data);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = logReadStream_1.return)) await _b.call(logReadStream_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        finally {
            // Clean up the read steam
            logReadStream === null || logReadStream === void 0 ? void 0 : logReadStream.close();
        }
        // Try to restore cached error log as error log file
        try {
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFileAsync({
                sourcePath: this._errorLogPath,
                destinationPath: errorLogPath
            });
        }
        catch (e) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
    }
}
//# sourceMappingURL=OperationMetadataManager.js.map

/***/ }),

/***/ 195183:
/*!************************************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationResultSummarizerPlugin.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationResultSummarizerPlugin": () => (/* binding */ OperationResultSummarizerPlugin),
/* harmony export */   "_printOperationStatus": () => (/* binding */ _printOperationStatus)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperationStatus */ 476597);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



const PLUGIN_NAME = 'OperationResultSummarizerPlugin';
/**
 * Format "======" lines for a shell window with classic 80 columns
 */
const ASCII_HEADER_WIDTH = 79;
/**
 * Phased command plugin that emits a summary of build results to the console.
 */
class OperationResultSummarizerPlugin {
    constructor(terminal) {
        this._terminal = terminal;
    }
    apply(hooks) {
        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {
            _printOperationStatus(this._terminal, result);
        });
    }
}
/**
 * Prints out a report of the status of each project
 * @internal
 */
function _printOperationStatus(terminal, result) {
    var _a;
    const { operationResults } = result;
    const operationsByStatus = new Map();
    for (const record of operationResults) {
        if ((_a = record[0].runner) === null || _a === void 0 ? void 0 : _a.silent) {
            // Don't report silenced operations
            continue;
        }
        const { status } = record[1];
        switch (status) {
            // These are the sections that we will report below
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Skipped:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.FromCache:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Success:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.SuccessWithWarning:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Blocked:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Failure:
            case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.NoOp:
                break;
            default:
                // This should never happen
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Unexpected operation status: ${status}`);
        }
        const collection = operationsByStatus.get(status);
        if (collection) {
            collection.push(record);
        }
        else {
            operationsByStatus.set(status, [record]);
        }
    }
    // Skip a few lines before we start the summary
    terminal.writeLine('\n\n');
    // These are ordered so that the most interesting statuses appear last:
    writeCondensedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Skipped, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green), 'These operations were already up to date:');
    writeCondensedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.NoOp, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray), 'These operations did not define any work:');
    writeCondensedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.FromCache, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green), 'These operations were restored from the build cache:');
    writeCondensedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Success, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green), 'These operations completed successfully:');
    writeDetailedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.SuccessWithWarning, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow), 'WARNING');
    writeCondensedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Blocked, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().white), 'These operations were blocked by dependencies that failed:');
    writeDetailedSummary(terminal, _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Failure, operationsByStatus, (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red));
    terminal.writeLine('');
    switch (result.status) {
        case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Failure:
            terminal.writeErrorLine('Operations failed.\n');
            break;
        case _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.SuccessWithWarning:
            terminal.writeWarningLine('Operations succeeded with warnings.\n');
            break;
    }
}
function writeCondensedSummary(terminal, status, operationsByStatus, headingColor, preamble) {
    // Example:
    //
    // ==[ BLOCKED: 4 projects ]==============================================================
    //
    // These projects were blocked by dependencies that failed:
    //   @scope/name
    //   e
    //   k
    const operations = operationsByStatus.get(status);
    if (!operations || operations.length === 0) {
        return;
    }
    writeSummaryHeader(terminal, status, operations, headingColor);
    terminal.writeLine(preamble);
    let longestTaskName = 0;
    for (const [operation] of operations) {
        const nameLength = (operation.name || '').length;
        if (nameLength > longestTaskName) {
            longestTaskName = nameLength;
        }
    }
    for (const [operation, operationResult] of operations) {
        if (operationResult.stopwatch.duration !== 0 &&
            operation.runner.reportTiming &&
            operationResult.status !== _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Skipped) {
            const time = operationResult.stopwatch.toString();
            const padding = ' '.repeat(longestTaskName - (operation.name || '').length);
            terminal.writeLine(`  ${operation.name}${padding}    ${time}`);
        }
        else {
            terminal.writeLine(`  ${operation.name}`);
        }
    }
    terminal.writeLine('');
}
function writeDetailedSummary(terminal, status, operationsByStatus, headingColor, shortStatusName) {
    // Example:
    //
    // ==[ SUCCESS WITH WARNINGS: 2 projects ]================================
    //
    // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
    //
    // [eslint] Warning: src/logic/operations/OperationsExecutionManager.ts:393:3 ...
    const operations = operationsByStatus.get(status);
    if (!operations || operations.length === 0) {
        return;
    }
    writeSummaryHeader(terminal, status, operations, headingColor);
    if (shortStatusName === undefined) {
        shortStatusName = status;
    }
    for (const [operation, operationResult] of operations) {
        // Format a header like this
        //
        // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
        // leftPart: "--[ WARNINGS: f "
        const subheadingText = `${shortStatusName}: ${operation.name}`;
        const leftPartLength = 4 + subheadingText.length + 1;
        // rightPart: " 5.07 seconds ]--"
        const time = operationResult.stopwatch.toString();
        const rightPartLength = 1 + time.length + 1 + 3;
        // middlePart: "]----------------------["
        const twoBracketsLength = 2;
        const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
        terminal.writeLine(`${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray('--[')} ${headingColor(subheadingText)} ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(`]${'-'.repeat(middlePartLengthMinusTwoBrackets)}[`)} ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().white(time)} ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(']--')}\n`);
        const details = operationResult.stdioSummarizer.getReport();
        if (details) {
            // Don't write a newline, because the report will always end with a newline
            terminal.write(details);
        }
        terminal.writeLine('');
    }
}
function writeSummaryHeader(terminal, status, operations, headingColor) {
    // Format a header like this
    //
    // ==[ FAILED: 2 operations ]================================================
    // "2 operations"
    const projectsText = `${operations.length}${operations.length === 1 ? ' operation' : ' operations'}`;
    const headingText = `${status}: ${projectsText}`;
    // leftPart: "==[ FAILED: 2 operations "
    const leftPartLength = 3 + 1 + headingText.length + 1;
    const rightPartLengthMinusBracket = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + 1), 0);
    // rightPart: "]======================"
    terminal.writeLine(`${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray('==[')} ${headingColor(headingText)} ${colors_safe__WEBPACK_IMPORTED_MODULE_0___default().gray(`]${'='.repeat(rightPartLengthMinusBracket)}`)}\n`);
}
//# sourceMappingURL=OperationResultSummarizerPlugin.js.map

/***/ }),

/***/ 600463:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationStateFile.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationStateFile": () => (/* binding */ OperationStateFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * A helper class for managing the state file of a operation.
 *
 * @internal
 */
class OperationStateFile {
    constructor(options) {
        const { projectFolder, metadataFolder } = options;
        this.relativeFilepath = `${metadataFolder}/${OperationStateFile.filename}`;
        this.filepath = `${projectFolder}/${this.relativeFilepath}`;
    }
    get state() {
        return this._state;
    }
    async writeAsync(json) {
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.saveAsync(json, this.filepath, { ensureFolderExists: true, ignoreUndefinedValues: true });
        this._state = json;
    }
    async tryRestoreAsync() {
        try {
            this._state = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAsync(this.filepath);
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
                this._state = undefined;
            }
            else {
                // This should not happen
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(error);
            }
        }
        return this._state;
    }
}
OperationStateFile.filename = 'state.json';

//# sourceMappingURL=OperationStateFile.js.map

/***/ }),

/***/ 476597:
/*!********************************************************!*\
  !*** ./lib-esnext/logic/operations/OperationStatus.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationStatus": () => (/* binding */ OperationStatus)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Enumeration defining potential states of an operation
 * @beta
 */
var OperationStatus;
(function (OperationStatus) {
    /**
     * The Operation is ready to execute. All its dependencies have succeeded.
     */
    OperationStatus["Ready"] = "READY";
    /**
     * The Operation is waiting for one or more dependencies to complete.
     */
    OperationStatus["Waiting"] = "WAITING";
    /**
     * The Operation is Queued
     */
    OperationStatus["Queued"] = "QUEUED";
    /**
     * The Operation is currently executing
     */
    OperationStatus["Executing"] = "EXECUTING";
    /**
     * The Operation is currently executing by a remote process
     */
    OperationStatus["RemoteExecuting"] = "REMOTE EXECUTING";
    /**
     * The Operation completed successfully and did not write to standard output
     */
    OperationStatus["Success"] = "SUCCESS";
    /**
     * The Operation completed successfully, but wrote to standard output
     */
    OperationStatus["SuccessWithWarning"] = "SUCCESS WITH WARNINGS";
    /**
     * The Operation was skipped via the legacy incremental build logic
     */
    OperationStatus["Skipped"] = "SKIPPED";
    /**
     * The Operation had its outputs restored from the build cache
     */
    OperationStatus["FromCache"] = "FROM CACHE";
    /**
     * The Operation failed
     */
    OperationStatus["Failure"] = "FAILURE";
    /**
     * The Operation could not be executed because one or more of its dependencies failed
     */
    OperationStatus["Blocked"] = "BLOCKED";
    /**
     * The Operation was a no-op (for example, it had an empty script)
     */
    OperationStatus["NoOp"] = "NO OP";
})(OperationStatus || (OperationStatus = {}));
//# sourceMappingURL=OperationStatus.js.map

/***/ }),

/***/ 476093:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/operations/PeriodicCallback.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PeriodicCallback": () => (/* binding */ PeriodicCallback)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * A help class to run callbacks in a loop with a specified interval.
 *
 * @beta
 */
class PeriodicCallback {
    constructor(options) {
        this._callbacks = [];
        this._interval = options.interval;
        this._isRunning = false;
    }
    addCallback(callback) {
        if (this._isRunning) {
            throw new Error('Can not add callback while watcher is running');
        }
        this._callbacks.push(callback);
    }
    start() {
        if (this._intervalId) {
            throw new Error('Watcher already started');
        }
        if (this._callbacks.length === 0) {
            return;
        }
        this._isRunning = true;
        this._intervalId = setInterval(() => {
            this._callbacks.forEach((callback) => callback());
        }, this._interval);
    }
    stop() {
        if (this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = undefined;
            this._isRunning = false;
        }
    }
}
//# sourceMappingURL=PeriodicCallback.js.map

/***/ }),

/***/ 797379:
/*!**************************************************************!*\
  !*** ./lib-esnext/logic/operations/PhasedOperationPlugin.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhasedOperationPlugin": () => (/* binding */ PhasedOperationPlugin)
/* harmony export */ });
/* harmony import */ var _Operation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Operation */ 768667);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperationStatus */ 476597);
/* harmony import */ var _NullOperationRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NullOperationRunner */ 969003);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



const PLUGIN_NAME = 'PhasedOperationPlugin';
/**
 * Core phased command plugin that provides the functionality for generating a base operation graph
 * from the set of selected projects and phases.
 */
class PhasedOperationPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createOperations);
    }
}
function createOperations(existingOperations, context) {
    const { projectsInUnknownState: changedProjects, phaseOriginal, phaseSelection, projectSelection } = context;
    const operationsWithWork = new Set();
    const operations = new Map();
    // Create tasks for selected phases and projects
    for (const phase of phaseOriginal) {
        for (const project of projectSelection) {
            getOrCreateOperation(phase, project);
        }
    }
    // Recursively expand all consumers in the `operationsWithWork` set.
    for (const operation of operationsWithWork) {
        for (const consumer of operation.consumers) {
            operationsWithWork.add(consumer);
        }
    }
    for (const [key, operation] of operations) {
        if (!operationsWithWork.has(operation)) {
            // This operation is in scope, but did not change since it was last executed by the current command.
            // However, we have no state tracking across executions, so treat as unknown.
            operation.runner = new _NullOperationRunner__WEBPACK_IMPORTED_MODULE_0__.NullOperationRunner({
                name: key,
                result: _OperationStatus__WEBPACK_IMPORTED_MODULE_1__.OperationStatus.Skipped,
                silent: true
            });
        }
    }
    return existingOperations;
    // Binds phaseSelection, projectSelection, operations via closure
    function getOrCreateOperation(phase, project) {
        const key = getOperationKey(phase, project);
        let operation = operations.get(key);
        if (!operation) {
            operation = new _Operation__WEBPACK_IMPORTED_MODULE_2__.Operation({
                project,
                phase
            });
            if (!phaseSelection.has(phase) || !projectSelection.has(project)) {
                // Not in scope. Mark skipped because state is unknown.
                operation.runner = new _NullOperationRunner__WEBPACK_IMPORTED_MODULE_0__.NullOperationRunner({
                    name: key,
                    result: _OperationStatus__WEBPACK_IMPORTED_MODULE_1__.OperationStatus.Skipped,
                    silent: true
                });
            }
            else if (changedProjects.has(project)) {
                operationsWithWork.add(operation);
            }
            operations.set(key, operation);
            existingOperations.add(operation);
            const { dependencies: { self, upstream } } = phase;
            for (const depPhase of self) {
                operation.addDependency(getOrCreateOperation(depPhase, project));
            }
            if (upstream.size) {
                const { dependencyProjects } = project;
                if (dependencyProjects.size) {
                    for (const depPhase of upstream) {
                        for (const dependencyProject of dependencyProjects) {
                            operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));
                        }
                    }
                }
            }
        }
        return operation;
    }
}
// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key
function getOperationKey(phase, project) {
    return `${project.packageName};${phase.name}`;
}
//# sourceMappingURL=PhasedOperationPlugin.js.map

/***/ }),

/***/ 471311:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/operations/ProjectLogWritable.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectLogWritable": () => (/* binding */ ProjectLogWritable)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/PackageNameParsers */ 644443);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class ProjectLogWritable extends _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TerminalWritable {
    constructor(project, terminal, logFilenameIdentifier) {
        super();
        this._logWriter = undefined;
        this._errorLogWriter = undefined;
        this._project = project;
        this._terminal = terminal;
        // Delete the legacy logs
        const { logPath: legacyLogPath, errorLogPath: legacyErrorLogPath } = ProjectLogWritable.getLogFilePaths({
            project,
            logFilenameIdentifier: 'build',
            isLegacyLog: true
        });
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFile(legacyLogPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFile(legacyErrorLogPath);
        const { logPath, errorLogPath, relativeLogPath, relativeErrorLogPath } = ProjectLogWritable.getLogFilePaths({
            project,
            logFilenameIdentifier
        });
        this.logPath = logPath;
        this.errorLogPath = errorLogPath;
        this.relativeLogPath = relativeLogPath;
        this.relativeErrorLogPath = relativeErrorLogPath;
        if (legacyLogPath !== this.logPath) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFile(this.logPath);
        }
        if (legacyErrorLogPath !== this.errorLogPath) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.deleteFile(this.errorLogPath);
        }
        this._logWriter = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileWriter.open(this.logPath);
    }
    static getLogFilePaths({ project, logFilenameIdentifier, isLegacyLog = false }) {
        const unscopedProjectName = _api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__.PackageNameParsers.permissive.getUnscopedName(project.packageName);
        const logFileBaseName = `${unscopedProjectName}.${logFilenameIdentifier}`;
        const logFilename = `${logFileBaseName}.log`;
        const errorLogFilename = `${logFileBaseName}.error.log`;
        const { projectFolder } = project;
        // If the phased commands experiment is enabled, put logs under `rush-logs`
        let logFolder;
        if (!isLegacyLog && project.rushConfiguration.experimentsConfiguration.configuration.phasedCommands) {
            const logPathPrefix = `${projectFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushLogsFolderName}`;
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.ensureFolder(logPathPrefix);
            logFolder = _RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushLogsFolderName;
        }
        const relativeLogPath = logFolder ? `${logFolder}/${logFilename}` : logFilename;
        const relativeErrorLogPath = logFolder ? `${logFolder}/${errorLogFilename}` : errorLogFilename;
        const logPath = `${projectFolder}/${relativeLogPath}`;
        const errorLogPath = `${projectFolder}/${relativeErrorLogPath}`;
        return {
            logPath,
            errorLogPath,
            relativeLogPath,
            relativeErrorLogPath
        };
    }
    // Override writeChunk function to throw custom error
    writeChunk(chunk) {
        if (!this._logWriter) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Log writer was closed for ${this.logPath}`);
        }
        // Stderr can always get written to a error log writer
        super.writeChunk(chunk);
    }
    onWriteChunk(chunk) {
        if (!this._logWriter) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Output file was closed');
        }
        // Both stderr and stdout get written to *.<phaseName>.log
        this._logWriter.write(chunk.text);
        if (chunk.kind === "E" /* TerminalChunkKind.Stderr */) {
            // Only stderr gets written to *.<phaseName>.error.log
            if (!this._errorLogWriter) {
                this._errorLogWriter = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileWriter.open(this.errorLogPath);
            }
            this._errorLogWriter.write(chunk.text);
        }
    }
    onClose() {
        if (this._logWriter) {
            try {
                this._logWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._logWriter.filePath);
            }
            this._logWriter = undefined;
        }
        if (this._errorLogWriter) {
            try {
                this._errorLogWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._errorLogWriter.filePath);
            }
            this._errorLogWriter = undefined;
        }
    }
}
//# sourceMappingURL=ProjectLogWritable.js.map

/***/ }),

/***/ 953621:
/*!*************************************************************!*\
  !*** ./lib-esnext/logic/operations/ShellOperationRunner.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShellOperationRunner": () => (/* binding */ ShellOperationRunner),
/* harmony export */   "convertSlashesForWindows": () => (/* binding */ convertSlashesForWindows)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/stream-collator */ 121452);
/* harmony import */ var _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./OperationStatus */ 476597);
/* harmony import */ var _OperationError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OperationError */ 593956);
/* harmony import */ var _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ProjectLogWritable */ 471311);
/* harmony import */ var _utilities_CollatedTerminalProvider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/CollatedTerminalProvider */ 782038);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.









/**
 * An `IOperationRunner` subclass that performs an operation via a shell command.
 * Currently contains the build cache logic, pending extraction as separate operations.
 * Supports skipping an operation if allowed and it is already up-to-date.
 */
class ShellOperationRunner {
    constructor(options) {
        this.reportTiming = true;
        this.silent = false;
        this.cacheable = true;
        const { phase } = options;
        this.name = options.displayName;
        this._rushProject = options.rushProject;
        this._rushConfiguration = options.rushConfiguration;
        this._commandToRun = options.commandToRun;
        this.warningsAreAllowed =
            _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfiguration.allowWarningsInSuccessfulBuild || phase.allowWarningsOnSuccess || false;
        this._logFilenameIdentifier = phase.logFilenameIdentifier;
    }
    async executeAsync(context) {
        try {
            return await this._executeAsync(context);
        }
        catch (error) {
            throw new _OperationError__WEBPACK_IMPORTED_MODULE_4__.OperationError('executing', error.message);
        }
    }
    getConfigHash() {
        return this._commandToRun;
    }
    async _executeAsync(context) {
        const projectLogWritable = new _ProjectLogWritable__WEBPACK_IMPORTED_MODULE_5__.ProjectLogWritable(this._rushProject, context.collatedWriter.terminal, this._logFilenameIdentifier);
        try {
            //#region OPERATION LOGGING
            // TERMINAL PIPELINE:
            //
            //                             +--> quietModeTransform? --> collatedWriter
            //                             |
            // normalizeNewlineTransform --1--> stderrLineTransform --2--> removeColorsTransform --> projectLogWritable
            //                                                        |
            //                                                        +--> stdioSummarizer
            const removeColorsTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TextRewriterTransform({
                destination: projectLogWritable,
                removeColors: true,
                normalizeNewlines: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.NewlineKind.OsDefault
            });
            const splitterTransform2 = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.SplitterTransform({
                destinations: [removeColorsTransform, context.stdioSummarizer]
            });
            const stderrLineTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.StderrLineTransform({
                destination: splitterTransform2,
                newlineKind: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.NewlineKind.Lf // for StdioSummarizer
            });
            const discardTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.DiscardStdoutTransform({
                destination: context.collatedWriter
            });
            const splitterTransform1 = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.SplitterTransform({
                destinations: [context.quietMode ? discardTransform : context.collatedWriter, stderrLineTransform]
            });
            const normalizeNewlineTransform = new _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TextRewriterTransform({
                destination: splitterTransform1,
                normalizeNewlines: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.NewlineKind.Lf,
                ensureNewlineAtEnd: true
            });
            const collatedTerminal = new _rushstack_stream_collator__WEBPACK_IMPORTED_MODULE_2__.CollatedTerminal(normalizeNewlineTransform);
            const terminalProvider = new _utilities_CollatedTerminalProvider__WEBPACK_IMPORTED_MODULE_6__.CollatedTerminalProvider(collatedTerminal, {
                debugEnabled: context.debugMode
            });
            const terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(terminalProvider);
            //#endregion
            let hasWarningOrError = false;
            const projectFolder = this._rushProject.projectFolder;
            // Run the operation
            terminal.writeLine('Invoking: ' + this._commandToRun);
            const subProcess = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_7__.Utilities.executeLifecycleCommandAsync(this._commandToRun, {
                rushConfiguration: this._rushConfiguration,
                workingDirectory: projectFolder,
                initCwd: this._rushConfiguration.commonTempFolder,
                handleOutput: true,
                environmentPathOptions: {
                    includeProjectBin: true
                }
            });
            // Hook into events, in order to get live streaming of the log
            if (subProcess.stdout !== null) {
                subProcess.stdout.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "O" /* TerminalChunkKind.Stdout */ });
                });
            }
            if (subProcess.stderr !== null) {
                subProcess.stderr.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "E" /* TerminalChunkKind.Stderr */ });
                    hasWarningOrError = true;
                });
            }
            let status = await new Promise((resolve, reject) => {
                subProcess.on('close', (code) => {
                    try {
                        if (code !== 0) {
                            // Do NOT reject here immediately, give a chance for other logic to suppress the error
                            context.error = new _OperationError__WEBPACK_IMPORTED_MODULE_4__.OperationError('error', `Returned error code: ${code}`);
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Failure);
                        }
                        else if (hasWarningOrError) {
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.SuccessWithWarning);
                        }
                        else {
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Success);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
            // projectLogWritable should be closed before copy the logs to build cache
            normalizeNewlineTransform.close();
            // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should
            // have closed projectLogWritable.
            if (projectLogWritable.isOpen) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('The output file handle was not closed');
            }
            if (terminalProvider.hasErrors) {
                status = _OperationStatus__WEBPACK_IMPORTED_MODULE_8__.OperationStatus.Failure;
            }
            return status;
        }
        finally {
            projectLogWritable.close();
        }
    }
}
/**
 * When running a command from the "scripts" block in package.json, if the command
 * contains Unix-style path slashes and the OS is Windows, the package managers will
 * convert slashes to backslashes.  This is a complicated undertaking.  For example, they
 * need to convert "node_modules/bin/this && ./scripts/that --name keep/this"
 * to "node_modules\bin\this && .\scripts\that --name keep/this", and they don't want to
 * convert ANY of the slashes in "cmd.exe /c echo a/b".  NPM and PNPM use npm-lifecycle for this,
 * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a
 * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.
 *
 * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write
 * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).
 * It's very tricky for a developer to guess what's safe to do without testing every OS.
 * Even simple path separators are not portable, so NPM added heuristics to figure out which
 * slashes are part of a path or not, and convert them.  These workarounds end up having tons
 * of special cases.  They probably could have implemented their own entire minimal cross-platform
 * shell language with less code and less confusion than npm-lifecycle's approach.
 *
 * We've deprecated shell operators inside package.json.  Instead, we advise people to move their
 * scripts into conventional script files, and put only a file path in package.json.  So, for
 * Rush's workaround here, we really only care about supporting the small set of cases seen in the
 * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched
 * (i.e. err on the side of not breaking anything).  We could revisit this later if someone
 * complains about it, but so far nobody has.  :-)
 */
function convertSlashesForWindows(command) {
    // The first group will match everything up to the first space, "&", "|", "<", ">", or quote.
    // The second group matches the remainder.
    const commandRegExp = /^([^\s&|<>"]+)(.*)$/;
    const match = commandRegExp.exec(command);
    if (match) {
        // Example input: "bin/blarg --path ./config/blah.json && a/b"
        // commandPart="bin/blarg"
        // remainder=" --path ./config/blah.json && a/b"
        const commandPart = match[1];
        const remainder = match[2];
        // If the command part already contains a backslash, then leave it alone
        if (commandPart.indexOf('\\') < 0) {
            // Replace all the slashes with backslashes, e.g. to produce:
            // "bin\blarg --path ./config/blah.json && a/b"
            //
            // NOTE: we don't attempt to process the path parameter or stuff after "&&"
            return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Text.replaceAll(commandPart, '/', '\\') + remainder;
        }
    }
    // Don't change anything
    return command;
}
//# sourceMappingURL=ShellOperationRunner.js.map

/***/ }),

/***/ 658087:
/*!*******************************************************************!*\
  !*** ./lib-esnext/logic/operations/ShellOperationRunnerPlugin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShellOperationRunnerPlugin": () => (/* binding */ ShellOperationRunnerPlugin)
/* harmony export */ });
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _NullOperationRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NullOperationRunner */ 969003);
/* harmony import */ var _ShellOperationRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShellOperationRunner */ 953621);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperationStatus */ 476597);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const PLUGIN_NAME = 'ShellOperationRunnerPlugin';
/**
 * Core phased command plugin that provides the functionality for executing an operation via shell command.
 */
class ShellOperationRunnerPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createShellOperations);
    }
}
function createShellOperations(operations, context) {
    const { phaseSelection: selectedPhases, projectChangeAnalyzer, rushConfiguration } = context;
    const customParametersByPhase = new Map();
    function getCustomParameterValuesForPhase(phase) {
        let customParameterValues = customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const tsCommandLineParameter of phase.associatedParameters) {
                tsCommandLineParameter.appendToArgList(customParameterValues);
            }
            customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
    for (const operation of operations) {
        const { associatedPhase: phase, associatedProject: project } = operation;
        if (phase && project && !operation.runner) {
            // This is a shell command. In the future, may consider having a property on the initial operation
            // to specify a runner type requested in rush-project.json
            const customParameterValues = getCustomParameterValuesForPhase(phase);
            const commandToRun = getScriptToRun(project, phase.name, customParameterValues, phase.shellCommand);
            if (commandToRun === undefined && phase.missingScriptBehavior === 'error') {
                throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
            }
            const displayName = getDisplayName(phase, project);
            if (commandToRun) {
                const shellOperationRunner = new _ShellOperationRunner__WEBPACK_IMPORTED_MODULE_0__.ShellOperationRunner({
                    commandToRun: commandToRun || '',
                    displayName,
                    phase,
                    projectChangeAnalyzer,
                    rushConfiguration,
                    rushProject: project,
                    selectedPhases
                });
                operation.runner = shellOperationRunner;
            }
            else {
                // Empty build script indicates a no-op, so use a no-op runner
                operation.runner = new _NullOperationRunner__WEBPACK_IMPORTED_MODULE_1__.NullOperationRunner({
                    name: displayName,
                    result: _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.NoOp,
                    silent: phase.missingScriptBehavior === 'silent'
                });
            }
        }
    }
    return operations;
}
function getScriptToRun(rushProject, commandToRun, customParameterValues, shellCommand) {
    const { scripts } = rushProject.packageJson;
    const rawCommand = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];
    if (rawCommand === undefined || rawCommand === null) {
        return undefined;
    }
    if (!rawCommand) {
        return '';
    }
    else {
        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
        return process.platform === 'win32' ? (0,_ShellOperationRunner__WEBPACK_IMPORTED_MODULE_0__.convertSlashesForWindows)(fullCommand) : fullCommand;
    }
}
function getDisplayName(phase, project) {
    if (phase.isSynthetic) {
        // Because this is a synthetic phase, just use the project name because there aren't any other phases
        return project.packageName;
    }
    else {
        const phaseNameWithoutPrefix = phase.name.slice(_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.phaseNamePrefix.length);
        return `${project.packageName} (${phaseNameWithoutPrefix})`;
    }
}
//# sourceMappingURL=ShellOperationRunnerPlugin.js.map

/***/ }),

/***/ 524699:
/*!*****************************************************************!*\
  !*** ./lib-esnext/logic/operations/ValidateOperationsPlugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidateOperationsPlugin": () => (/* binding */ ValidateOperationsPlugin)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
const PLUGIN_NAME = 'ValidateOperationsPlugin';
/**
 * Core phased command plugin that provides the functionality for generating a base operation graph
 * from the set of selected projects and phases.
 */
class ValidateOperationsPlugin {
    constructor(terminal) {
        this._terminal = terminal;
    }
    apply(hooks) {
        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, this._validateOperations.bind(this));
    }
    _validateOperations(records, context) {
        const phasesByProject = new Map();
        for (const { associatedPhase, associatedProject, runner } of records.keys()) {
            if (associatedProject && associatedPhase && !(runner === null || runner === void 0 ? void 0 : runner.isNoOp)) {
                // Ignore operations that aren't associated with a project or phase, or that
                // use the NullOperationRunner (i.e. - the phase doesn't do anything)
                let projectPhases = phasesByProject.get(associatedProject);
                if (!projectPhases) {
                    projectPhases = new Set();
                    phasesByProject.set(associatedProject, projectPhases);
                }
                projectPhases.add(associatedPhase);
            }
        }
        for (const [project, phases] of phasesByProject) {
            const projectConfiguration = context.projectConfigurations.get(project);
            if (projectConfiguration) {
                projectConfiguration.validatePhaseConfiguration(phases, this._terminal);
            }
        }
    }
}
//# sourceMappingURL=ValidateOperationsPlugin.js.map

/***/ }),

/***/ 402835:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmOptionsConfiguration.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmOptionsConfiguration": () => (/* binding */ PnpmOptionsConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/BasePackageManagerOptionsConfiguration */ 573404);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _schemas_pnpm_config_schema_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../schemas/pnpm-config.schema.json */ 38317);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * Options that are only used when the PNPM package manager is selected.
 * Use this class to load "common/config/rush/pnpm-config.json" file,
 * or, load json from "pnpmOptions" field in "rush.json" for legacy support.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the PNPM package manager
 * is not being used.
 *
 * @public
 */
class PnpmOptionsConfiguration extends _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_1__.PackageManagerOptionsConfigurationBase {
    /**
     * (GENERATED BY RUSH-PNPM PATCH-COMMIT) When modifying this property, make sure you know what you are doing.
     *
     * The `globalPatchedDependencies` is added/updated automatically when you run pnpm patch-commit
     * command. It is a dictionary where the key should be the package name and exact version. The value
     * should be a relative path to a patch file.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmpatcheddependencies
     */
    get globalPatchedDependencies() {
        return this._globalPatchedDependencies;
    }
    constructor(json, commonTempFolder, jsonFilename) {
        super(json);
        this._json = json;
        this.jsonFilename = jsonFilename;
        this.pnpmStore = json.pnpmStore || 'local';
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.pnpmStorePathOverride) {
            this.pnpmStorePath = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.pnpmStorePathOverride;
        }
        else if (this.pnpmStore === 'global') {
            this.pnpmStorePath = '';
        }
        else {
            this.pnpmStorePath = `${commonTempFolder}/pnpm-store`;
        }
        this.strictPeerDependencies = !!json.strictPeerDependencies;
        this.preventManualShrinkwrapChanges = !!json.preventManualShrinkwrapChanges;
        this.useWorkspaces = !!json.useWorkspaces;
        this.globalOverrides = json.globalOverrides;
        this.globalPeerDependencyRules = json.globalPeerDependencyRules;
        this.globalPackageExtensions = json.globalPackageExtensions;
        this.globalNeverBuiltDependencies = json.globalNeverBuiltDependencies;
        this.globalAllowedDeprecatedVersions = json.globalAllowedDeprecatedVersions;
        this.unsupportedPackageJsonSettings = json.unsupportedPackageJsonSettings;
        this._globalPatchedDependencies = json.globalPatchedDependencies;
        this.resolutionMode = json.resolutionMode;
    }
    /** @internal */
    static loadFromJsonFileOrThrow(jsonFilename, commonTempFolder) {
        const pnpmOptionJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(jsonFilename, PnpmOptionsConfiguration._jsonSchema);
        return new PnpmOptionsConfiguration(pnpmOptionJson || {}, commonTempFolder, jsonFilename);
    }
    /** @internal */
    static loadFromJsonObject(json, commonTempFolder) {
        return new PnpmOptionsConfiguration(json, commonTempFolder);
    }
    /**
     * Updates patchedDependencies field of the PNPM options in the common/config/rush/pnpm-config.json file.
     */
    updateGlobalPatchedDependencies(patchedDependencies) {
        this._globalPatchedDependencies = patchedDependencies;
        this._json.globalPatchedDependencies = patchedDependencies;
        if (this.jsonFilename) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.save(this._json, this.jsonFilename, { updateExistingFile: true });
        }
    }
}
PnpmOptionsConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_pnpm_config_schema_json__WEBPACK_IMPORTED_MODULE_3__);

//# sourceMappingURL=PnpmOptionsConfiguration.js.map

/***/ }),

/***/ 390053:
/*!************************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmProjectShrinkwrapFile.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmProjectShrinkwrapFile": () => (/* binding */ PnpmProjectShrinkwrapFile)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/BaseProjectShrinkwrapFile */ 894306);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 *
 */
class PnpmProjectShrinkwrapFile extends _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_2__.BaseProjectShrinkwrapFile {
    /**
     * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.
     * @returns True if the project shrinkwrap was created or updated, false otherwise.
     */
    async updateProjectShrinkwrapAsync() {
        const projectShrinkwrapMap = this.generateProjectShrinkwrapMap();
        return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();
    }
    hasChanges(otherShrinkwrap) {
        if (!otherShrinkwrap.shrinkwrapFile.isWorkspaceCompatible &&
            !otherShrinkwrap.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName)) {
            // The project is new to the shrinkwrap file.
            return true;
        }
        const otherMap = otherShrinkwrap.generateProjectShrinkwrapMap();
        const thisMap = this.generateProjectShrinkwrapMap();
        if (!thisMap || !otherMap) {
            // Handle one or both being undefined.
            return !!(thisMap || otherMap);
        }
        if (thisMap.size !== otherMap.size) {
            // Entries added or removed
            return true;
        }
        for (const [key, value] of thisMap) {
            if (otherMap.get(key) !== value) {
                // A dependency changed or was added/removed
                return true;
            }
        }
        return false;
    }
    /**
     * Generate the project shrinkwrap file content
     */
    generateProjectShrinkwrapMap() {
        const projectShrinkwrapMap = this.shrinkwrapFile.isWorkspaceCompatible
            ? this.generateWorkspaceProjectShrinkwrapMap()
            : this.generateLegacyProjectShrinkwrapMap();
        return projectShrinkwrapMap;
    }
    generateWorkspaceProjectShrinkwrapMap() {
        // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies
        const importerKey = this.shrinkwrapFile.getImporterKeyByPath(this.project.rushConfiguration.commonTempFolder, this.project.projectFolder);
        const projectShrinkwrapMap = this.shrinkwrapFile.getIntegrityForImporter(importerKey);
        return projectShrinkwrapMap;
    }
    generateLegacyProjectShrinkwrapMap() {
        const tempProjectDependencyKey = this.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName);
        if (!tempProjectDependencyKey) {
            throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);
        }
        const parentShrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);
        const allDependencies = [
            ...Object.entries(parentShrinkwrapEntry.dependencies || {}),
            ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})
        ];
        const projectShrinkwrapMap = new Map();
        for (const [name, version] of allDependencies) {
            if (name.indexOf(`${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushTempNpmScope}/`) < 0) {
                // Only select the shrinkwrap dependencies that are non-local since we already handle local
                // project changes
                this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);
            }
        }
        // Since peer dependencies within on external packages may be hoisted up to the top-level package,
        // we need to resolve and add these dependencies directly
        this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);
        return projectShrinkwrapMap;
    }
    _addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {
        var _a;
        const specifier = `${name}@${version}`;
        if (projectShrinkwrapMap.has(specifier)) {
            // getShrinkwrapEntry is idempotent with respect to name and version
            return;
        }
        const shrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntry(name, version);
        if (!shrinkwrapEntry) {
            if (throwIfShrinkwrapEntryMissing) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);
            }
            return;
        }
        let integrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;
        if (!integrity) {
            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.
            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.
            // Ex:
            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:
            //   ...
            //   resolution:
            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'
            const sha256Digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha256')
                .update(JSON.stringify(shrinkwrapEntry))
                .digest('hex');
            integrity = `${name}@${version}:${sha256Digest}:`;
        }
        // Add the current dependency
        projectShrinkwrapMap.set(specifier, integrity);
        // Add the dependencies of the dependency
        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.dependencies || {})) {
            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry);
        }
        // Add the optional dependencies of the dependency, and don't blow up if they don't exist
        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {
            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry, 
            /* throwIfShrinkwrapEntryMissing */ false);
        }
        // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.
        // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there
        // is no need to look for peer dependencies, since it is simply a constraint to be validated by the
        // package manager.
        if (!this.shrinkwrapFile.isWorkspaceCompatible) {
            this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);
        }
    }
    _resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry) {
        var _a, _b, _c;
        for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {
            // Skip peer dependency resolution of local package peer dependencies
            if (peerDependencyName.indexOf(_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushTempNpmScope) !== -1) {
                continue;
            }
            // Check to see if the peer dependency is satisfied with the current shrinkwrap
            // entry. If not, check the parent shrinkwrap entry. Finally, if neither have
            // the specified dependency, check that the parent mentions the dependency in
            // it's own peer dependencies. If it is, we can rely on the package manager and
            // make the assumption that we've already found it further up the stack.
            if (((_a = shrinkwrapEntry.dependencies) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(peerDependencyName)) ||
                ((_b = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.dependencies) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(peerDependencyName)) ||
                ((_c = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.peerDependencies) === null || _c === void 0 ? void 0 : _c.hasOwnProperty(peerDependencyName))) {
                continue;
            }
            // As a last attempt, check if it's been hoisted up as a top-level dependency. If
            // we can't find it, we can assume that it's already been provided somewhere up the
            // dependency tree.
            const topLevelDependencySpecifier = this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);
            if (topLevelDependencySpecifier) {
                this._addDependencyRecursive(projectShrinkwrapMap, peerDependencyName, this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);
            }
        }
    }
    /**
     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json
     */
    async saveAsync(projectShrinkwrapMap) {
        const file = {};
        const keys = Array.from(projectShrinkwrapMap.keys()).sort();
        for (const key of keys) {
            file[key] = projectShrinkwrapMap.get(key);
        }
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });
    }
}
//# sourceMappingURL=PnpmProjectShrinkwrapFile.js.map

/***/ }),

/***/ 930997:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmShrinkwrapFile.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmShrinkwrapFile": () => (/* binding */ PnpmShrinkwrapFile),
/* harmony export */   "normalizePnpmVersionSpecifier": () => (/* binding */ normalizePnpmVersionSpecifier),
/* harmony export */   "parsePnpmDependencyKey": () => (/* binding */ parsePnpmDependencyKey)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/BaseShrinkwrapFile */ 411534);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DependencySpecifier */ 68654);
/* harmony import */ var _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PnpmYamlCommon */ 730862);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 73666);
/* harmony import */ var _PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PnpmfileConfiguration */ 238032);
/* harmony import */ var _PnpmProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PnpmProjectShrinkwrapFile */ 390053);
/* harmony import */ var _PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PnpmOptionsConfiguration */ 402835);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.













const yamlModule = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Import.lazy('js-yaml', require);
/**
 * Given an encoded "dependency key" from the PNPM shrinkwrap file, this parses it into an equivalent
 * DependencySpecifier.
 *
 * @returns a SemVer string, or undefined if the version specifier cannot be parsed
 */
function parsePnpmDependencyKey(dependencyName, versionSpecifier) {
    if (!versionSpecifier) {
        return undefined;
    }
    const dependencyKey = normalizePnpmVersionSpecifier(versionSpecifier);
    if (/^\w+:/.test(dependencyKey)) {
        // If it starts with an NPM scheme such as "file:projects/my-app.tgz", we don't support that
        return undefined;
    }
    // The package name parsed from the dependency key, or dependencyName if it was omitted.
    // Example: "@scope/depame"
    let parsedPackageName;
    // The trailing portion of the dependency key that includes the version and optional peer dependency path.
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7"
    let parsedInstallPath;
    // Example: "path.pkgs.visualstudio.com/@scope/depame/1.4.0"  --> 0="@scope/depame" 1="1.4.0"
    // Example: "/isarray/2.0.1"                                  --> 0="isarray"       1="2.0.1"
    // Example: "/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7"       --> 0="sinon-chai"    1="2.8.0/chai@3.5.0+sinon@1.17.7"
    // Example: "/typescript@5.1.6"                               --> 0=typescript      1="5.1.6"
    // Example: 1.2.3_peer-dependency@.4.5.6                      --> no match
    // Example: 1.2.3_@scope+peer-dependency@.4.5.6               --> no match
    // Example: 1.2.3(peer-dependency@.4.5.6)                     --> no match
    // Example: 1.2.3(@scope/peer-dependency@.4.5.6)              --> no match
    const packageNameMatch = /^[^\/(]*\/((?:@[^\/(]+\/)?[^\/(]+)[\/@](.*)$/.exec(dependencyKey);
    if (packageNameMatch) {
        parsedPackageName = packageNameMatch[1];
        parsedInstallPath = packageNameMatch[2];
    }
    else {
        parsedPackageName = dependencyName;
        // Example: "23.6.0_babel-core@6.26.3"
        // Example: "23.6.0"
        parsedInstallPath = dependencyKey;
    }
    // The SemVer value
    // Example: "2.8.0"
    let parsedVersionPart;
    // Example: "23.6.0_babel-core@6.26.3" --> "23.6.0"
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7" --> "2.8.0"
    // Example: "0.53.1(@types/node@14.18.36)" --> "0.53.1"
    const versionMatch = /^([^\(\/_]+)[(\/_]/.exec(parsedInstallPath);
    if (versionMatch) {
        parsedVersionPart = versionMatch[1];
    }
    else {
        // Example: "2.8.0"
        parsedVersionPart = parsedInstallPath;
    }
    // By this point, we expect parsedVersionPart to be a valid SemVer range
    if (!parsedVersionPart) {
        return undefined;
    }
    if (!semver__WEBPACK_IMPORTED_MODULE_1__.valid(parsedVersionPart)) {
        const urlRegex = /^(git@|@)?([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}(\/|\+)([^\/\\]+\/?)*([^\/\\]+)$/i;
        // Test for urls:
        // Examples:
        //     @github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com.au/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     git@bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.co.in/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        if (urlRegex.test(dependencyKey)) {
            const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__.DependencySpecifier(dependencyName, dependencyKey);
            return dependencySpecifier;
        }
        else {
            return undefined;
        }
    }
    // Is it an alias for a different package?
    if (parsedPackageName === dependencyName) {
        // No, it's a regular dependency
        return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__.DependencySpecifier(parsedPackageName, parsedVersionPart);
    }
    else {
        // If the parsed package name is different from the dependencyName, then this is an NPM package alias
        return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__.DependencySpecifier(dependencyName, `npm:${parsedPackageName}@${parsedVersionPart}`);
    }
}
function normalizePnpmVersionSpecifier(versionSpecifier) {
    if (typeof versionSpecifier === 'string') {
        return versionSpecifier;
    }
    else {
        return versionSpecifier.version;
    }
}
class PnpmShrinkwrapFile extends _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_6__.BaseShrinkwrapFile {
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        // Normalize the data
        const lockfileVersion = shrinkwrapJson.lockfileVersion;
        if (typeof lockfileVersion === 'string') {
            this.shrinkwrapFileMajorVersion = parseInt(lockfileVersion.substring(0, lockfileVersion.indexOf('.')), 10);
        }
        else if (typeof lockfileVersion === 'number') {
            this.shrinkwrapFileMajorVersion = lockfileVersion;
        }
        else {
            this.shrinkwrapFileMajorVersion = 0;
        }
        this.registry = shrinkwrapJson.registry || '';
        this.dependencies = new Map(Object.entries(shrinkwrapJson.dependencies || {}));
        this.importers = new Map(Object.entries(shrinkwrapJson.importers || {}));
        this.specifiers = new Map(Object.entries(shrinkwrapJson.specifiers || {}));
        this.packages = new Map(Object.entries(shrinkwrapJson.packages || {}));
        this.overrides = new Map(Object.entries(shrinkwrapJson.overrides || {}));
        // Importers only exist in workspaces
        this.isWorkspaceCompatible = this.importers.size > 0;
        this._integrities = new Map();
    }
    static loadFromFile(shrinkwrapYamlFilename) {
        try {
            const shrinkwrapContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFile(shrinkwrapYamlFilename);
            return PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.isNotExistError(error)) {
                return undefined; // file does not exist
            }
            throw new Error(`Error reading "${shrinkwrapYamlFilename}":\n  ${error.message}`);
        }
    }
    static loadFromString(shrinkwrapContent) {
        const parsedData = yamlModule.safeLoad(shrinkwrapContent);
        return new PnpmShrinkwrapFile(parsedData);
    }
    getShrinkwrapHash(experimentsConfig) {
        // The 'omitImportersFromPreventManualShrinkwrapChanges' experiment skips the 'importers' section
        // when computing the hash, since the main concern is changes to the overall external dependency footprint
        const { omitImportersFromPreventManualShrinkwrapChanges } = experimentsConfig || {};
        const shrinkwrapContent = this._serializeInternal(omitImportersFromPreventManualShrinkwrapChanges);
        return crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash('sha1').update(shrinkwrapContent).digest('hex');
    }
    /** @override */
    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) {
        super.validate(packageManagerOptionsConfig, policyOptions);
        if (!(packageManagerOptionsConfig instanceof _PnpmOptionsConfiguration__WEBPACK_IMPORTED_MODULE_7__.PnpmOptionsConfiguration)) {
            throw new Error('The provided package manager options are not valid for PNPM shrinkwrap files.');
        }
        if (!policyOptions.allowShrinkwrapUpdates) {
            if (!policyOptions.repoState.isValid) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_3___default().red(`The ${_RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker ` +
                    'in the file. You may need to run "rush update" to refresh its contents.') + '\n');
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
            }
            // Only check the hash if allowShrinkwrapUpdates is false. If true, the shrinkwrap file
            // may have changed and the hash could be invalid.
            if (packageManagerOptionsConfig.preventManualShrinkwrapChanges) {
                if (!policyOptions.repoState.pnpmShrinkwrapHash) {
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_3___default().red('The existing shrinkwrap file hash could not be found. You may need to run "rush update" to ' +
                        'populate the hash. See the "preventManualShrinkwrapChanges" setting documentation for details.') + '\n');
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
                if (this.getShrinkwrapHash(experimentsConfig) !== policyOptions.repoState.pnpmShrinkwrapHash) {
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_3___default().red('The shrinkwrap file hash does not match the expected hash. Please run "rush update" to ensure the ' +
                        'shrinkwrap file is up to date. See the "preventManualShrinkwrapChanges" setting documentation for ' +
                        'details.') + '\n');
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
            }
        }
    }
    /** @override */
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies || {});
    }
    /**
     * Gets the path to the tarball file if the package is a tarball.
     * Returns undefined if the package entry doesn't exist or the package isn't a tarball.
     * Example of return value: file:projects/build-tools.tgz
     */
    getTarballPath(packageName) {
        var _a;
        const dependency = this.packages.get(packageName);
        return (_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball;
    }
    getTopLevelDependencyKey(dependencyName) {
        return this.dependencies.get(dependencyName);
    }
    /**
     * Gets the version number from the list of top-level dependencies in the "dependencies" section
     * of the shrinkwrap file. Sample return values:
     *   '2.1.113'
     *   '1.9.0-dev.27'
     *   'file:projects/empty-webpart-project.tgz'
     *   undefined
     *
     * @override
     */
    getTopLevelDependencyVersion(dependencyName) {
        var _a;
        let value = this.dependencies.get(dependencyName);
        if (value) {
            value = normalizePnpmVersionSpecifier(value);
            // Getting the top level dependency version from a PNPM lockfile version 5.x or 6.1
            // --------------------------------------------------------------------------
            //
            // 1) Top-level tarball dependency entries in pnpm-lock.yaml look like in 5.x:
            //    ```
            //    '@rush-temp/sp-filepicker': 'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5'
            //    ```
            //    And in version 6.1, they look like:
            //    ```
            //    '@rush-temp/sp-filepicker':
            //      specifier: file:./projects/generate-api-docs.tgz
            //      version: file:projects/generate-api-docs.tgz
            //    ```
            //    Then, it would be defined below (version 5.x):
            //    ```
            //    'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5':
            //      dependencies:
            //       '@microsoft/load-themed-styles': 1.10.7
            //       ...
            //      resolution:
            //       integrity: sha512-guuoFIc**==
            //       tarball: 'file:projects/sp-filepicker.tgz'
            //    ```
            //    Or in version 6.1:
            //    ```
            //    file:projects/sp-filepicker.tgz:
            //      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}
            //      name: '@rush-temp/sp-filepicker'
            //      version: 0.0.0
            //      dependencies:
            //        '@microsoft/load-themed-styles': 1.10.7
            //        ...
            //      dev: false
            //    ```
            //    Here, we are interested in the part 'file:projects/sp-filepicker.tgz'. Splitting by underscores is not the
            //    best way to get this because file names could have underscores in them. Instead, we could use the tarball
            //    field in the resolution section.
            // 2) Top-level non-tarball dependency entries in pnpm-lock.yaml would look like in 5.x:
            //    ```
            //    '@rushstack/set-webpack-public-path-plugin': 2.1.133
            //    @microsoft/sp-build-node': 1.9.0-dev.27_typescript@2.9.2
            //    ```
            //    And in version 6.1, they look like:
            //    ```
            //    '@rushstack/set-webpack-public-path-plugin':
            //      specifier: ^2.1.133
            //      version: 2.1.133
            //    '@microsoft/sp-build-node':
            //      specifier: 1.9.0-dev.27
            //      version: 1.9.0-dev.27(typescript@2.9.2)
            //    ```
            //    Here, we could either just split by underscores and take the first part (5.x) or use the specifier field
            //    (6.1).
            // The below code is also compatible with lockfile versions < 5.1
            const dependency = this.packages.get(value);
            if (((_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball) && value.startsWith(dependency.resolution.tarball)) {
                return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__.DependencySpecifier(dependencyName, dependency.resolution.tarball);
            }
            else {
                let underscoreOrParenthesisIndex = value.indexOf('_');
                if (underscoreOrParenthesisIndex < 0) {
                    underscoreOrParenthesisIndex = value.indexOf('(');
                }
                if (underscoreOrParenthesisIndex >= 0) {
                    value = value.substring(0, underscoreOrParenthesisIndex);
                }
            }
            return new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_5__.DependencySpecifier(dependencyName, value);
        }
        return undefined;
    }
    /**
     * The PNPM shrinkwrap file has top-level dependencies on the temp projects like this (version 5.x):
     *
     * ```
     * dependencies:
     *   '@rush-temp/my-app': 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0'
     * packages:
     *   /@types/node/10.14.15:
     *     dev: false
     *   'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0':
     *     dev: false
     *     name: '@rush-temp/my-app'
     *     version: 0.0.0
     * ```
     *
     * or in version 6.1, like this:
     * ```
     * dependencies:
     *  '@rush-temp/my-app':
     *    specifier: file:./projects/my-app.tgz
     *    version: file:projects/my-app.tgz
     *  packages:
     *    /@types/node@10.14.15:
     *      resolution: {integrity: sha512-iAB+**==}
     *      dev: false
     *    file:projects/my-app.tgz
     *      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}
     *      name: '@rush-temp/my-app'
     *      version: 0.0.0
     *      dependencies:
     *        '@microsoft/load-themed-styles': 1.10.7
     *        ...
     *      dev: false
     * ```
     *
     * We refer to 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0' or 'file:projects/my-app.tgz' as
     * the temp project dependency key of the temp project '@rush-temp/my-app'.
     */
    getTempProjectDependencyKey(tempProjectName) {
        const tempProjectDependencyKey = this.dependencies.get(tempProjectName);
        return tempProjectDependencyKey ? normalizePnpmVersionSpecifier(tempProjectDependencyKey) : undefined;
    }
    getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey) {
        return this.packages.get(tempProjectDependencyKey);
    }
    getShrinkwrapEntry(name, version) {
        const packageId = this._getPackageId(name, version);
        return this.packages.get(packageId);
    }
    /**
     * Serializes the PNPM Shrinkwrap file
     *
     * @override
     */
    serialize() {
        return this._serializeInternal(false);
    }
    /**
     * Gets the resolved version number of a dependency for a specific temp project.
     * For PNPM, we can reuse the version that another project is using.
     * Note that this function modifies the shrinkwrap data if tryReusingPackageVersionsFromShrinkwrap is set to true.
     *
     * @override
     */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the
        // shrinkwrap file puts our dependency in either the top of the node_modules folder
        // or underneath the package we are looking at.
        // This is because the PNPM shrinkwrap file describes the exact links that need to be created
        // to recreate the graph..
        // Because of this, we actually need to check for a version that this package is directly
        // linked to.
        const packageName = dependencySpecifier.packageName;
        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);
        if (!tempProjectDependencyKey) {
            return undefined;
        }
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription ||
            !packageDescription.dependencies ||
            !packageDescription.dependencies.hasOwnProperty(packageName)) {
            return undefined;
        }
        const dependencyKey = packageDescription.dependencies[packageName];
        return this._parsePnpmDependencyKey(packageName, dependencyKey);
    }
    /** @override */
    findOrphanedProjects(rushConfiguration) {
        // The base shrinkwrap handles orphaned projects the same across all package managers,
        // but this is only valid for non-workspace installs
        if (!this.isWorkspaceCompatible) {
            return super.findOrphanedProjects(rushConfiguration);
        }
        const orphanedProjectPaths = [];
        for (const importerKey of this.getImporterKeys()) {
            // PNPM importer keys are relative paths from the workspace root, which is the common temp folder
            const rushProjectPath = path__WEBPACK_IMPORTED_MODULE_0__.resolve(rushConfiguration.commonTempFolder, importerKey);
            if (!rushConfiguration.tryGetProjectForPath(rushProjectPath)) {
                orphanedProjectPaths.push(rushProjectPath);
            }
        }
        return orphanedProjectPaths;
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return new _PnpmProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_9__.PnpmProjectShrinkwrapFile(this, project);
    }
    *getImporterKeys() {
        // Filter out the root importer used for the generated package.json in the root
        // of the install, since we do not use this.
        for (const key of this.importers.keys()) {
            if (key !== '.') {
                yield key;
            }
        }
    }
    getImporterKeyByPath(workspaceRoot, projectFolder) {
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_0__.relative(workspaceRoot, projectFolder));
    }
    getImporter(importerKey) {
        return this.importers.get(importerKey);
    }
    getIntegrityForImporter(importerKey) {
        // This logic formerly lived in PnpmProjectShrinkwrapFile. Moving it here allows caching of the external
        // dependency integrity relationships across projects
        let integrityMap = this._integrities.get(importerKey);
        if (!integrityMap) {
            const importer = this.getImporter(importerKey);
            if (importer) {
                integrityMap = new Map();
                this._integrities.set(importerKey, integrityMap);
                const sha256Digest = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash('sha256')
                    .update(JSON.stringify(importer))
                    .digest('base64');
                const selfIntegrity = `${importerKey}:${sha256Digest}:`;
                integrityMap.set(importerKey, selfIntegrity);
                const { dependencies, devDependencies, optionalDependencies } = importer;
                const externalFilter = (name, versionSpecifier) => {
                    const version = normalizePnpmVersionSpecifier(versionSpecifier);
                    return !version.includes('link:');
                };
                if (dependencies) {
                    this._addIntegrities(integrityMap, dependencies, false, externalFilter);
                }
                if (devDependencies) {
                    this._addIntegrities(integrityMap, devDependencies, false, externalFilter);
                }
                if (optionalDependencies) {
                    this._addIntegrities(integrityMap, optionalDependencies, true, externalFilter);
                }
            }
        }
        return integrityMap;
    }
    /** @override */
    async isWorkspaceProjectModifiedAsync(project, variant) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const importerKey = this.getImporterKeyByPath(project.rushConfiguration.commonTempFolder, project.projectFolder);
        const importer = this.getImporter(importerKey);
        if (!importer) {
            return true;
        }
        // First, let's transform the package.json using the pnpmfile
        const packageJson = project.packageJsonEditor.saveToObject();
        // Initialize the pnpmfile if it doesn't exist
        if (!this._pnpmfileConfiguration) {
            this._pnpmfileConfiguration = await _PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_10__.PnpmfileConfiguration.initializeAsync(project.rushConfiguration, {
                variant
            });
        }
        // Use a new PackageJsonEditor since it will classify each dependency type, making tracking the
        // found versions much simpler.
        const { dependencyList, devDependencyList } = _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.PackageJsonEditor.fromObject(this._pnpmfileConfiguration.transform(packageJson), project.packageJsonEditor.filePath);
        const allDependencies = [...dependencyList, ...devDependencyList];
        if (this.shrinkwrapFileMajorVersion < 6) {
            // PNPM <= v7
            // Then get the unique package names and map them to package versions.
            const dependencyVersions = new Map();
            for (const packageDependency of allDependencies) {
                // We will also filter out peer dependencies since these are not installed at development time.
                if (packageDependency.dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Peer) {
                    continue;
                }
                const foundDependency = dependencyVersions.get(packageDependency.name);
                if (!foundDependency) {
                    dependencyVersions.set(packageDependency.name, packageDependency);
                }
                else {
                    // Shrinkwrap will prioritize optional dependencies, followed by regular dependencies, with dev being
                    // the least prioritized. We will only keep the most prioritized option.
                    // See: https://github.com/pnpm/pnpm/blob/main/packages/lockfile-utils/src/satisfiesPackageManifest.ts
                    switch (foundDependency.dependencyType) {
                        case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Optional:
                            break;
                        case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Regular:
                            if (packageDependency.dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Optional) {
                                dependencyVersions.set(packageDependency.name, packageDependency);
                            }
                            break;
                        case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Dev:
                            dependencyVersions.set(packageDependency.name, packageDependency);
                            break;
                    }
                }
            }
            // Then validate that the dependency fields are as expected in the shrinkwrap to avoid false-negatives
            // when moving a package from one field to the other.
            for (const { dependencyType, name } of dependencyVersions.values()) {
                switch (dependencyType) {
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Optional:
                        if (!((_a = importer.optionalDependencies) === null || _a === void 0 ? void 0 : _a[name]))
                            return true;
                        break;
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Regular:
                        if (!((_b = importer.dependencies) === null || _b === void 0 ? void 0 : _b[name]))
                            return true;
                        break;
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Dev:
                        if (!((_c = importer.devDependencies) === null || _c === void 0 ? void 0 : _c[name]))
                            return true;
                        break;
                }
            }
            const specifiers = importer.specifiers;
            if (!specifiers) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.InternalError('Expected specifiers to be defined, but is expected in lockfile version 5');
            }
            // Then validate the length matches between the importer and the dependency list, since duplicates are
            // a valid use-case. Importers will only take one of these values, so no need to do more work here.
            if (dependencyVersions.size !== Object.keys(specifiers).length) {
                return true;
            }
            // Finally, validate that all values in the importer are also present in the dependency list.
            for (const [importerPackageName, importerVersionSpecifier] of Object.entries(specifiers)) {
                const foundDependency = dependencyVersions.get(importerPackageName);
                if (!foundDependency) {
                    return true;
                }
                const resolvedVersion = (_d = this.overrides.get(importerPackageName)) !== null && _d !== void 0 ? _d : foundDependency.version;
                if (resolvedVersion !== importerVersionSpecifier) {
                    return true;
                }
            }
        }
        else {
            // PNPM v8
            const importerOptionalDependencies = new Set(Object.keys((_e = importer.optionalDependencies) !== null && _e !== void 0 ? _e : {}));
            const importerDependencies = new Set(Object.keys((_f = importer.dependencies) !== null && _f !== void 0 ? _f : {}));
            const importerDevDependencies = new Set(Object.keys((_g = importer.devDependencies) !== null && _g !== void 0 ? _g : {}));
            for (const { dependencyType, name, version } of allDependencies) {
                let isOptional = false;
                let specifierFromLockfile;
                let isDevDepFallThrough = false;
                switch (dependencyType) {
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Optional: {
                        specifierFromLockfile = (_h = importer.optionalDependencies) === null || _h === void 0 ? void 0 : _h[name];
                        importerOptionalDependencies.delete(name);
                        break;
                    }
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Peer: {
                        // Peer dependencies of workspace projects may be installed as regular dependencies
                        isOptional = true; // fall through
                    }
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Dev: {
                        specifierFromLockfile = (_j = importer.devDependencies) === null || _j === void 0 ? void 0 : _j[name];
                        if (specifierFromLockfile) {
                            // If the dev dependency is not found, it may be installed as a regular dependency,
                            // so fall through
                            importerDevDependencies.delete(name);
                            break;
                        }
                        // If fall through, there is a chance the package declares an inconsistent version, ignore it.
                        isDevDepFallThrough = true;
                    }
                    // eslint-disable-next-line no-fallthrough
                    case _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Regular:
                        specifierFromLockfile = (_k = importer.dependencies) === null || _k === void 0 ? void 0 : _k[name];
                        importerDependencies.delete(name);
                        break;
                }
                if (!specifierFromLockfile) {
                    if (!isOptional) {
                        return true;
                    }
                }
                else {
                    if (typeof specifierFromLockfile === 'string') {
                        throw new Error(`The PNPM lockfile is in an unexpected format. The "${name}" package is specified as ` +
                            `"${specifierFromLockfile}" instead of an object.`);
                    }
                    else {
                        // TODO: Emit an error message when someone tries to override a version of something in one of their
                        // local repo packages.
                        const resolvedVersion = (_l = this.overrides.get(name)) !== null && _l !== void 0 ? _l : version;
                        if (specifierFromLockfile.specifier !== resolvedVersion && !isDevDepFallThrough && !isOptional) {
                            return true;
                        }
                    }
                }
            }
            // Finally, validate that all values in the importer are also present in the dependency list.
            if (importerOptionalDependencies.size > 0 ||
                importerDependencies.size > 0 ||
                importerDevDependencies.size > 0) {
                return true;
            }
        }
        return false;
    }
    _getIntegrityForPackage(specifier, optional) {
        var _a;
        const integrities = this._integrities;
        let integrityMap = integrities.get(specifier);
        if (integrityMap) {
            return integrityMap;
        }
        integrityMap = new Map();
        integrities.set(specifier, integrityMap);
        const shrinkwrapEntry = this.packages.get(specifier);
        if (!shrinkwrapEntry) {
            if (!optional) {
                // This algorithm heeds to be robust against missing shrinkwrap entries, so we can't just throw
                // Instead set it to a value which will not match any valid shrinkwrap record
                integrityMap.set(specifier, 'Missing shrinkwrap entry!');
            }
            // Indicate an empty entry
            return integrityMap;
        }
        let selfIntegrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;
        if (!selfIntegrity) {
            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.
            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.
            // Ex:
            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:
            //   ...
            //   resolution:
            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'
            const sha256Digest = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash('sha256')
                .update(JSON.stringify(shrinkwrapEntry))
                .digest('base64');
            selfIntegrity = `${specifier}:${sha256Digest}:`;
        }
        integrityMap.set(specifier, selfIntegrity);
        const { dependencies, optionalDependencies } = shrinkwrapEntry;
        if (dependencies) {
            this._addIntegrities(integrityMap, dependencies, false);
        }
        if (optionalDependencies) {
            this._addIntegrities(integrityMap, optionalDependencies, true);
        }
        return integrityMap;
    }
    _addIntegrities(integrityMap, collection, optional, filter) {
        for (const [name, version] of Object.entries(collection)) {
            if (filter && !filter(name, version)) {
                continue;
            }
            const packageId = this._getPackageId(name, version);
            if (integrityMap.has(packageId)) {
                // The entry could already have been added as a nested dependency
                continue;
            }
            const contribution = this._getIntegrityForPackage(packageId, optional);
            for (const [dep, integrity] of contribution) {
                integrityMap.set(dep, integrity);
            }
        }
    }
    /**
     * Gets the package description for a tempProject from the shrinkwrap file.
     */
    _getPackageDescription(tempProjectDependencyKey) {
        const packageDescription = this.packages.get(tempProjectDependencyKey);
        return packageDescription && packageDescription.dependencies ? packageDescription : undefined;
    }
    _getPackageId(name, versionSpecifier) {
        const version = normalizePnpmVersionSpecifier(versionSpecifier);
        if (this.shrinkwrapFileMajorVersion >= 6) {
            if (version.startsWith('@github')) {
                // This is a github repo reference
                return version;
            }
            else {
                return version.startsWith('/') ? version : `/${name}@${version}`;
            }
        }
        else {
            // Version can sometimes be in the form of a path that's already in the /name/version format.
            return version.indexOf('/') !== -1 ? version : `/${name}/${version}`;
        }
    }
    _parsePnpmDependencyKey(dependencyName, pnpmDependencyKey) {
        if (pnpmDependencyKey) {
            const result = parsePnpmDependencyKey(dependencyName, pnpmDependencyKey);
            if (!result) {
                throw new Error(`Cannot parse PNPM shrinkwrap version specifier: "${pnpmDependencyKey}"` +
                    ` for "${dependencyName}"`);
            }
            return result;
        }
        else {
            return undefined;
        }
    }
    _serializeInternal(omitImporters = false) {
        // Ensure that if any of the top-level properties are provided but empty are removed. We populate the object
        // properties when we read the shrinkwrap but PNPM does not set these top-level properties unless they are present.
        const shrinkwrapToSerialize = {};
        for (const [key, value] of Object.entries(this._shrinkwrapJson)) {
            if (omitImporters && key === 'importers') {
                continue;
            }
            if (!value || typeof value !== 'object' || Object.keys(value).length > 0) {
                shrinkwrapToSerialize[key] = value;
            }
        }
        return yamlModule.safeDump(shrinkwrapToSerialize, _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_12__.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
}
//# sourceMappingURL=PnpmShrinkwrapFile.js.map

/***/ }),

/***/ 730862:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmYamlCommon.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PNPM_SHRINKWRAP_YAML_FORMAT": () => (/* binding */ PNPM_SHRINKWRAP_YAML_FORMAT)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
// This is based on PNPM's own configuration:
// https://github.com/pnpm/pnpm-shrinkwrap/blob/master/src/write.ts
const PNPM_SHRINKWRAP_YAML_FORMAT = {
    lineWidth: 1000,
    noCompatMode: true,
    noRefs: true,
    sortKeys: true
};
//# sourceMappingURL=PnpmYamlCommon.js.map

/***/ }),

/***/ 238032:
/*!********************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmfileConfiguration.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmfileConfiguration": () => (/* binding */ PnpmfileConfiguration)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _PnpmfileShim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PnpmfileShim */ 839570);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/PathConstants */ 287644);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




/**
 * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,
 * optionally utilizing a pnpmfile shim to inject preferred versions.
 */
class PnpmfileConfiguration {
    constructor(context) {
        this._context = context;
    }
    static async initializeAsync(rushConfiguration, pnpmfileShimOptions) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        // Set the context to swallow log output and store our settings
        const context = {
            log: (message) => { },
            pnpmfileShimSettings: await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, pnpmfileShimOptions)
        };
        return new PnpmfileConfiguration(context);
    }
    static async writeCommonTempPnpmfileShimAsync(rushConfiguration, options) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        const targetDir = rushConfiguration.commonTempFolder;
        const pnpmfilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(targetDir, rushConfiguration.packageManagerWrapper.pnpmfileFilename);
        // Write the shim itself
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFileAsync({
            sourcePath: `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_2__.scriptsFolderPath}/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_2__.pnpmfileShimFilename}`,
            destinationPath: pnpmfilePath
        });
        const pnpmfileShimSettings = await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, options);
        // Write the settings file used by the shim
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.saveAsync(pnpmfileShimSettings, path__WEBPACK_IMPORTED_MODULE_0__.join(targetDir, 'pnpmfileSettings.json'), {
            ensureFolderExists: true
        });
    }
    static async _getPnpmfileShimSettingsAsync(rushConfiguration, options) {
        let allPreferredVersions = {};
        let allowedAlternativeVersions = {};
        const workspaceVersions = {};
        // Only workspaces shims in the common versions using pnpmfile
        if (rushConfiguration.packageManagerOptions.useWorkspaces) {
            const commonVersionsConfiguration = rushConfiguration.getCommonVersions();
            const preferredVersions = new Map();
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.MapExtensions.mergeFromMap(preferredVersions, commonVersionsConfiguration.getAllPreferredVersions());
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.MapExtensions.mergeFromMap(preferredVersions, rushConfiguration.getImplicitlyPreferredVersions());
            allPreferredVersions = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.MapExtensions.toObject(preferredVersions);
            allowedAlternativeVersions = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.MapExtensions.toObject(commonVersionsConfiguration.allowedAlternativeVersions);
            for (const project of rushConfiguration.projects) {
                workspaceVersions[project.packageName] = project.packageJson.version;
            }
        }
        const settings = {
            allPreferredVersions,
            allowedAlternativeVersions,
            workspaceVersions,
            semverPath: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })
        };
        // Use the provided path if available. Otherwise, use the default path.
        const userPnpmfilePath = rushConfiguration.getPnpmfilePath(options === null || options === void 0 ? void 0 : options.variant);
        if (userPnpmfilePath && _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(userPnpmfilePath)) {
            settings.userPnpmfilePath = userPnpmfilePath;
        }
        return settings;
    }
    /**
     * Transform a package.json file using the pnpmfile.js hook.
     * @returns the transformed object, or the original input if pnpmfile.js was not found.
     */
    transform(packageJson) {
        var _a;
        if (!((_a = _PnpmfileShim__WEBPACK_IMPORTED_MODULE_3__.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) || !this._context) {
            return packageJson;
        }
        else {
            return _PnpmfileShim__WEBPACK_IMPORTED_MODULE_3__.hooks.readPackage(packageJson, this._context);
        }
    }
}
//# sourceMappingURL=PnpmfileConfiguration.js.map

/***/ }),

/***/ 839570:
/*!***********************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmfileShim.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hooks": () => (/* binding */ hooks)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var _a;
let settings;
let allPreferredVersions;
let allowedAlternativeVersions;
let userPnpmfile;
let semver;
// Initialize all external aspects of the pnpmfile shim. When using the shim, settings
// are always expected to be available. Init must be called before running any hook that
// depends on a resource obtained from or related to the settings, and will require modules
// once so they aren't repeatedly required in the hook functions.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function init(context) {
    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:
    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134
    // So we need to normalize the context format before we move on
    if (typeof context !== 'object' || Array.isArray(context)) {
        context = {
            log: (message) => { },
            originalContext: context
        };
    }
    if (!settings) {
        // Initialize the settings from file
        if (!context.pnpmfileShimSettings) {
            context.pnpmfileShimSettings = require('./pnpmfileSettings.json');
        }
        settings = context.pnpmfileShimSettings;
    }
    else if (!context.pnpmfileShimSettings) {
        // Reuse the already initialized settings
        context.pnpmfileShimSettings = settings;
    }
    if (!allPreferredVersions && settings.allPreferredVersions) {
        allPreferredVersions = new Map(Object.entries(settings.allPreferredVersions));
    }
    if (!allowedAlternativeVersions && settings.allowedAlternativeVersions) {
        allowedAlternativeVersions = new Map(Object.entries(settings.allowedAlternativeVersions).map(([packageName, versions]) => {
            return [packageName, new Set(versions)];
        }));
    }
    // If a userPnpmfilePath is provided, we expect it to exist
    if (!userPnpmfile && settings.userPnpmfilePath) {
        userPnpmfile = require(settings.userPnpmfilePath);
    }
    // If a semverPath is provided, we expect it to exist
    if (!semver && settings.semverPath) {
        semver = require(settings.semverPath);
    }
    // Return the normalized context
    return context;
}
// Set the preferred versions on the dependency map. If the version on the map is an allowedAlternativeVersion
// then skip it. Otherwise, check to ensure that the common version is a subset of the specified version. If
// it is, then replace the specified version with the preferredVersion
function setPreferredVersions(dependencies) {
    var _a;
    for (const [name, version] of Object.entries(dependencies || {})) {
        const preferredVersion = allPreferredVersions === null || allPreferredVersions === void 0 ? void 0 : allPreferredVersions.get(name);
        if (preferredVersion && !((_a = allowedAlternativeVersions === null || allowedAlternativeVersions === void 0 ? void 0 : allowedAlternativeVersions.get(name)) === null || _a === void 0 ? void 0 : _a.has(version))) {
            let preferredVersionRange;
            let versionRange;
            try {
                preferredVersionRange = new semver.Range(preferredVersion);
                versionRange = new semver.Range(version);
            }
            catch (_b) {
                // Swallow invalid range errors
            }
            if (preferredVersionRange &&
                versionRange &&
                semver.subset(preferredVersionRange, versionRange, { includePrerelease: true })) {
                dependencies[name] = preferredVersion;
            }
        }
    }
}
const hooks = {
    // Call the original pnpmfile (if it exists)
    afterAllResolved: (lockfile, context) => {
        var _a;
        context = init(context);
        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)
            ? userPnpmfile.hooks.afterAllResolved(lockfile, context)
            : lockfile;
    },
    // Set the preferred versions in the package, then call the original pnpmfile (if it exists)
    readPackage: (pkg, context) => {
        var _a;
        context = init(context);
        setPreferredVersions(pkg.dependencies);
        setPreferredVersions(pkg.devDependencies);
        setPreferredVersions(pkg.optionalDependencies);
        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;
    },
    // Call the original pnpmfile (if it exists)
    filterLog: (_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.filterLog
};
//# sourceMappingURL=PnpmfileShim.js.map

/***/ }),

/***/ 764917:
/*!******************************************************!*\
  !*** ./lib-esnext/logic/policy/EnvironmentPolicy.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "validateAsync": () => (/* binding */ validateAsync)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Ensures the environment where the Rush repo exists is valid
 */
async function validateAsync(rushConfiguration, options) {
    if (rushConfiguration.experimentsConfiguration.configuration.forbidPhantomResolvableNodeModulesFolders) {
        const pathParts = rushConfiguration.rushJsonFolder.split(/[\/\\]/);
        const existingNodeModulesPaths = [];
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.forEachAsync(pathParts, async (pathPart, index) => {
            const potentialNodeModulesPath = `${pathParts.slice(0, index + 1).join('/')}/node_modules`;
            const pathExists = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.existsAsync(potentialNodeModulesPath);
            if (pathExists) {
                existingNodeModulesPaths.push(potentialNodeModulesPath);
            }
        }, { concurrency: 5 });
        if (existingNodeModulesPaths.length > 0) {
            const paths = existingNodeModulesPaths.sort().join(', ');
            let errorMessage = `The following node_modules folders exist in the path to the Rush repo: ${paths}. ` +
                `This is not supported, and may cause issues.`;
            if (options.bypassPolicyAllowed) {
                errorMessage += ` To ignore, use the "${_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.bypassPolicyFlagLongName}" flag.`;
            }
            // eslint-disable-next-line no-console
            console.error(errorMessage);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
    }
}
//# sourceMappingURL=EnvironmentPolicy.js.map

/***/ }),

/***/ 613207:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/policy/GitEmailPolicy.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getEmailExampleLines": () => (/* binding */ getEmailExampleLines),
/* harmony export */   "validate": () => (/* binding */ validate)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Git */ 668229);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RushConstants */ 951904);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





function validate(rushConfiguration, options) {
    const git = new _Git__WEBPACK_IMPORTED_MODULE_2__.Git(rushConfiguration);
    if (!git.isGitPresent()) {
        // If Git isn't installed, or this Rush project is not under a Git working folder,
        // then we don't care about the Git email
        // eslint-disable-next-line no-console
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('Ignoring Git validation because the Git binary was not found in the shell path.') + '\n');
        return;
    }
    if (!git.isPathUnderGitWorkingTree()) {
        // If Git isn't installed, or this Rush project is not under a Git working folder,
        // then we don't care about the Git email
        // eslint-disable-next-line no-console
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('Ignoring Git validation because this is not a Git working folder.') + '\n');
        return;
    }
    // If there isn't a Git policy, then we don't care whether the person configured
    // a Git email address at all.  This helps people who don't
    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {
        if (git.tryGetGitEmail() === undefined) {
            return;
        }
        // Otherwise, if an email *is* configured at all, then we still perform the basic
        // sanity checks (e.g. no spaces in the address).
    }
    let userEmail;
    try {
        userEmail = git.getGitEmail();
        // sanity check; a valid email should not contain any whitespace
        // if this fails, then we have another issue to report
        if (!userEmail.match(/^\S+$/g)) {
            // eslint-disable-next-line no-console
            console.log([
                colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('Your Git email address is invalid: ' + JSON.stringify(userEmail)),
                '',
                `To configure your Git email address, try something like this:`,
                '',
                ...getEmailExampleLines(rushConfiguration),
                ''
            ].join('\n'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
    }
    catch (e) {
        if (e instanceof _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError) {
            let errorMessage = 'Aborting, so you can go fix your settings.';
            if (options.bypassPolicyAllowed) {
                errorMessage += ` (Or use "${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.bypassPolicyFlagLongName}" to skip.)`;
            }
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(errorMessage));
            throw e;
        }
        else {
            throw e;
        }
    }
    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {
        // If there is no policy, then we're good
        return;
    }
    // eslint-disable-next-line no-console
    console.log('Checking Git policy for this repository.\n');
    // If there is a policy, at least one of the RegExp's must match
    for (const pattern of rushConfiguration.gitAllowedEmailRegExps) {
        const regex = new RegExp(`^${pattern}$`, 'i');
        if (userEmail.match(regex)) {
            return;
        }
    }
    // Show the user's name as well.
    // Ex. "Example Name <name@example.com>"
    let fancyEmail = colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(userEmail);
    try {
        const userName = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.executeCommandAndCaptureOutput(git.gitPath, ['config', 'user.name'], '.').trim();
        if (userName) {
            fancyEmail = `${userName} <${fancyEmail}>`;
        }
    }
    catch (e) {
        // but if it fails, this isn't critical, so don't bother them about it
    }
    // eslint-disable-next-line no-console
    console.log([
        'Hey there!  To keep things tidy, this repo asks you to submit your Git commits using an email like ' +
            (rushConfiguration.gitAllowedEmailRegExps.length > 1 ? 'one of these patterns:' : 'this pattern:'),
        '',
        ...rushConfiguration.gitAllowedEmailRegExps.map((pattern) => '    ' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(pattern)),
        '',
        '...but yours is configured like this:',
        '',
        `    ${fancyEmail}`,
        '',
        'To fix it, you can use commands like this:',
        '',
        ...getEmailExampleLines(rushConfiguration),
        ''
    ].join('\n'));
    let errorMessage = 'Aborting, so you can go fix your settings.';
    if (options.bypassPolicyAllowed) {
        errorMessage += ` (Or use "${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.bypassPolicyFlagLongName}" to skip.)`;
    }
    // eslint-disable-next-line no-console
    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(errorMessage));
    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
}
function getEmailExampleLines(rushConfiguration) {
    return [
        colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('    git config --local user.name "Example Name"'),
        colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan(`    git config --local user.email "${rushConfiguration.gitSampleEmail || 'name@example.com'}"`)
    ];
}
//# sourceMappingURL=GitEmailPolicy.js.map

/***/ }),

/***/ 999291:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/policy/PolicyValidator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "validatePolicyAsync": () => (/* binding */ validatePolicyAsync)
/* harmony export */ });
/* harmony import */ var _GitEmailPolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GitEmailPolicy */ 613207);
/* harmony import */ var _ShrinkwrapFilePolicy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShrinkwrapFilePolicy */ 915640);
/* harmony import */ var _EnvironmentPolicy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnvironmentPolicy */ 764917);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



async function validatePolicyAsync(rushConfiguration, options) {
    if (!options.bypassPolicy) {
        _GitEmailPolicy__WEBPACK_IMPORTED_MODULE_0__.validate(rushConfiguration, options);
        await _EnvironmentPolicy__WEBPACK_IMPORTED_MODULE_1__.validateAsync(rushConfiguration, options);
        if (!options.allowShrinkwrapUpdates) {
            // Don't validate the shrinkwrap if updates are allowed, as it's likely to change
            // It also may have merge conflict markers, which PNPM can gracefully handle, but the validator cannot
            _ShrinkwrapFilePolicy__WEBPACK_IMPORTED_MODULE_2__.validate(rushConfiguration, options);
        }
    }
}
//# sourceMappingURL=PolicyValidator.js.map

/***/ }),

/***/ 915640:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/policy/ShrinkwrapFilePolicy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "validate": () => (/* binding */ validate)
/* harmony export */ });
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 819779);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 *  A policy that validates shrinkwrap files used by package managers.
 */
function validate(rushConfiguration, options) {
    // eslint-disable-next-line no-console
    console.log('Validating package manager shrinkwrap file.\n');
    const shrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_0__.ShrinkwrapFileFactory.getShrinkwrapFile(rushConfiguration.packageManager, rushConfiguration.packageManagerOptions, rushConfiguration.getCommittedShrinkwrapFilename(options.shrinkwrapVariant));
    if (!shrinkwrapFile) {
        // eslint-disable-next-line no-console
        console.log('Shrinkwrap file could not be found, skipping validation.\n');
        return;
    }
    // Run shrinkwrap-specific validation
    shrinkwrapFile.validate(rushConfiguration.packageManagerOptions, Object.assign(Object.assign({}, options), { repoState: rushConfiguration.getRepoState(options.shrinkwrapVariant) }), rushConfiguration.experimentsConfiguration.configuration);
}
//# sourceMappingURL=ShrinkwrapFilePolicy.js.map

/***/ }),

/***/ 920415:
/*!***********************************************************************!*\
  !*** ./lib-esnext/logic/selectors/GitChangedProjectSelectorParser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitChangedProjectSelectorParser": () => (/* binding */ GitChangedProjectSelectorParser)
/* harmony export */ });
/* harmony import */ var _ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ProjectChangeAnalyzer */ 311605);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class GitChangedProjectSelectorParser {
    constructor(rushConfiguration, options) {
        this._rushConfiguration = rushConfiguration;
        this._options = options;
    }
    async evaluateSelectorAsync({ unscopedSelector, terminal }) {
        const projectChangeAnalyzer = new _ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_0__.ProjectChangeAnalyzer(this._rushConfiguration);
        const options = Object.assign({ terminal, targetBranchName: unscopedSelector }, this._options);
        return await projectChangeAnalyzer.getChangedProjectsAsync(options);
    }
    getCompletions() {
        return [this._rushConfiguration.repositoryDefaultBranch, 'HEAD~1', 'HEAD'];
    }
}
//# sourceMappingURL=GitChangedProjectSelectorParser.js.map

/***/ }),

/***/ 92382:
/*!******************************************************************!*\
  !*** ./lib-esnext/logic/selectors/NamedProjectSelectorParser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NamedProjectSelectorParser": () => (/* binding */ NamedProjectSelectorParser)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class NamedProjectSelectorParser {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {
        const project = this._rushConfiguration.findProjectByShorthandName(unscopedSelector);
        if (!project) {
            terminal.writeErrorLine(`The project name "${unscopedSelector}" passed to "${parameterName}" does not exist in rush.json.`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
        return [project];
    }
    getCompletions() {
        const unscopedNamesMap = new Map();
        const scopedNames = new Set();
        for (const project of this._rushConfiguration.rushConfigurationJson.projects) {
            scopedNames.add(project.packageName);
            const unscopedName = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageName.getUnscopedName(project.packageName);
            const count = unscopedNamesMap.get(unscopedName) || 0;
            unscopedNamesMap.set(unscopedName, count + 1);
        }
        const unscopedNames = [];
        for (const [unscopedName, unscopedNameCount] of unscopedNamesMap) {
            // don't suggest ambiguous unscoped names
            if (unscopedNameCount === 1 && !scopedNames.has(unscopedName)) {
                unscopedNames.push(unscopedName);
            }
        }
        return unscopedNames.sort().concat([...scopedNames].sort());
    }
}
//# sourceMappingURL=NamedProjectSelectorParser.js.map

/***/ }),

/***/ 858595:
/*!****************************************************************!*\
  !*** ./lib-esnext/logic/selectors/TagProjectSelectorParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TagProjectSelectorParser": () => (/* binding */ TagProjectSelectorParser)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class TagProjectSelectorParser {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {
        const selection = this._rushConfiguration.projectsByTag.get(unscopedSelector);
        if (!selection) {
            terminal.writeErrorLine(`The tag "${unscopedSelector}" passed to "${parameterName}" is not specified for any projects in rush.json.`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
        return selection;
    }
    getCompletions() {
        return this._rushConfiguration.projectsByTag.keys();
    }
}
//# sourceMappingURL=TagProjectSelectorParser.js.map

/***/ }),

/***/ 71589:
/*!**************************************************************************!*\
  !*** ./lib-esnext/logic/selectors/VersionPolicyProjectSelectorParser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionPolicyProjectSelectorParser": () => (/* binding */ VersionPolicyProjectSelectorParser)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class VersionPolicyProjectSelectorParser {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {
        const selection = new Set();
        if (!this._rushConfiguration.versionPolicyConfiguration.versionPolicies.has(unscopedSelector)) {
            terminal.writeErrorLine(`The version policy "${unscopedSelector}" passed to "${parameterName}" does not exist in version-policies.json.`);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.AlreadyReportedError();
        }
        for (const project of this._rushConfiguration.projects) {
            if (project.versionPolicyName === unscopedSelector) {
                selection.add(project);
            }
        }
        return selection;
    }
    getCompletions() {
        return this._rushConfiguration.versionPolicyConfiguration.versionPolicies.keys();
    }
}
//# sourceMappingURL=VersionPolicyProjectSelectorParser.js.map

/***/ }),

/***/ 631243:
/*!************************************************************!*\
  !*** ./lib-esnext/logic/setup/ArtifactoryConfiguration.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArtifactoryConfiguration": () => (/* binding */ ArtifactoryConfiguration)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _schemas_artifactory_schema_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../schemas/artifactory.schema.json */ 364692);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


/**
 * Use this class to load the "common/config/rush/artifactory.json" config file.
 * It configures the "rush setup" command.
 */
class ArtifactoryConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this.configuration = {
            packageRegistry: {
                enabled: false,
                registryUrl: '',
                artifactoryWebsiteUrl: ''
            }
        };
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(this._jsonFileName)) {
            this.configuration = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(this._jsonFileName, ArtifactoryConfiguration._jsonSchema);
            if (!this.configuration.packageRegistry.credentialType) {
                this.configuration.packageRegistry.credentialType = 'password';
            }
        }
    }
}
ArtifactoryConfiguration._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_artifactory_schema_json__WEBPACK_IMPORTED_MODULE_1__);

//# sourceMappingURL=ArtifactoryConfiguration.js.map

/***/ }),

/***/ 223422:
/*!************************************************!*\
  !*** ./lib-esnext/logic/setup/KeyboardLoop.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyboardLoop": () => (/* binding */ KeyboardLoop)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readline */ 514521);
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readline__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! process */ 677282);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




// TODO: Integrate these into the AnsiEscape API in @rushstack/node-core-library
// As part of that work we should generalize the "Colors" API to support more general
// terminal escapes, and simplify the interface for that API.
const ANSI_ESCAPE_SHOW_CURSOR = '\u001B[?25l';
const ANSI_ESCAPE_HIDE_CURSOR = '\u001B[?25h';
class KeyboardLoop {
    constructor() {
        this._cursorHidden = false;
        this._onKeypress = (character, key) => {
            if (key.name === 'c' && key.ctrl && !key.meta && !key.shift) {
                // Intercept CTRL+C
                process__WEBPACK_IMPORTED_MODULE_2__.kill(process__WEBPACK_IMPORTED_MODULE_2__.pid, 'SIGINT');
                return;
            }
            try {
                this.onKeypress(character, key);
            }
            catch (error) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.InternalError('Uncaught exception in Prompter.onKeypress(): ' + error.toString());
            }
        };
        this.stdin = process__WEBPACK_IMPORTED_MODULE_2__.stdin;
        this.stderr = process__WEBPACK_IMPORTED_MODULE_2__.stderr;
    }
    get capturedInput() {
        return this._readlineInterface !== undefined;
    }
    _captureInput() {
        if (this._readlineInterface) {
            return;
        }
        this._checkForTTY();
        this._readlineInterface = readline__WEBPACK_IMPORTED_MODULE_1__.createInterface({ input: this.stdin });
        readline__WEBPACK_IMPORTED_MODULE_1__.emitKeypressEvents(process__WEBPACK_IMPORTED_MODULE_2__.stdin);
        this.stdin.setRawMode(true);
        this.stdin.addListener('keypress', this._onKeypress);
    }
    _checkForTTY() {
        var _a;
        // Typescript thinks setRawMode always extists, but we're testing that assumption here.
        if (this.stdin.isTTY && this.stdin.setRawMode) {
            return;
        }
        if (process__WEBPACK_IMPORTED_MODULE_2__.platform === 'win32') {
            const shell = (_a = process__WEBPACK_IMPORTED_MODULE_2__.env.SHELL) !== null && _a !== void 0 ? _a : '';
            if (shell.toUpperCase().endsWith('BASH.EXE')) {
                // Git Bash has a known problem where the Node.js TTY is lost when invoked via an NPM binary script.
                // eslint-disable-next-line no-console
                console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('ERROR: It appears that Rush was invoked from Git Bash shell, which does not support the\n' +
                    'TTY mode for interactive input that is required by this feature.') +
                    '\n\nKnown workarounds are:\n' +
                    '- Invoke Rush using "winpty rush.cmd" instead of "rush"\n' +
                    '- Or add this to your .bashrc:  alias rush="winpty rush.cmd"\n' +
                    '- Or create a Git Bash shortcut icon that launches\n' +
                    '  "C:\\Program Files\\Git\\bin\\bash.exe" instead of "git-bash.exe"\n\n' +
                    'For details, refer to https://github.com/microsoft/rushstack/issues/3217');
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
            }
        }
        // eslint-disable-next-line no-console
        console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('ERROR: Rush was invoked by a command whose STDIN does not support the TTY mode for\n' +
            'interactive input that is required by this feature.') + '\n\nTry invoking "rush" directly from your shell.');
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
    }
    _uncaptureInput() {
        if (!this._readlineInterface) {
            return;
        }
        this.stdin.removeListener('keypress', this._onKeypress);
        this.stdin.setRawMode(false);
        this._readlineInterface.close();
        this._readlineInterface = undefined;
    }
    hideCursor() {
        if (this._cursorHidden) {
            return;
        }
        this._cursorHidden = true;
        this.stderr.write(ANSI_ESCAPE_SHOW_CURSOR);
    }
    unhideCursor() {
        if (!this._cursorHidden) {
            return;
        }
        this._cursorHidden = false;
        this.stderr.write(ANSI_ESCAPE_HIDE_CURSOR);
    }
    async startAsync() {
        try {
            this._captureInput();
            this.onStart();
            await new Promise((resolve, reject) => {
                this._resolvePromise = resolve;
                this._rejectPromise = reject;
            });
        }
        finally {
            this._uncaptureInput();
            this.unhideCursor();
        }
    }
    resolveAsync() {
        if (!this._resolvePromise) {
            return;
        }
        this._resolvePromise();
        this._resolvePromise = undefined;
        this._rejectPromise = undefined;
    }
    rejectAsync(error) {
        if (!this._rejectPromise) {
            return;
        }
        this._rejectPromise(error);
        this._resolvePromise = undefined;
        this._rejectPromise = undefined;
    }
    /** @virtual */
    onStart() { }
    /** @virtual */
    onKeypress(character, key) { }
}
//# sourceMappingURL=KeyboardLoop.js.map

/***/ }),

/***/ 555992:
/*!********************************************************!*\
  !*** ./lib-esnext/logic/setup/SetupPackageRegistry.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetupPackageRegistry": () => (/* binding */ SetupPackageRegistry)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _ArtifactoryConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ArtifactoryConfiguration */ 631243);
/* harmony import */ var _utilities_WebClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/WebClient */ 618105);
/* harmony import */ var _TerminalInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TerminalInput */ 106622);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







const defaultMessages = {
    introduction: 'This monorepo consumes packages from an Artifactory private NPM registry.',
    obtainAnAccount: 'Please contact the repository maintainers for help with setting up an Artifactory user account.',
    visitWebsite: 'Please open this URL in your web browser:',
    locateUserName: 'Your user name appears in the upper-right corner of the JFrog website.',
    locateApiKey: 'Click "Edit Profile" on the JFrog website.  Click the "Generate API Key"' +
        " button if you haven't already done so previously.",
    userNamePrompt: 'What is your Artifactory user name?',
    apiKeyPrompt: 'What is your Artifactory API key?'
};
class SetupPackageRegistry {
    constructor(options) {
        this._options = options;
        this.rushConfiguration = options.rushConfiguration;
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Terminal(new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.ConsoleTerminalProvider({
            verboseEnabled: options.isDebug
        }));
        this._artifactoryConfiguration = new _ArtifactoryConfiguration__WEBPACK_IMPORTED_MODULE_3__.ArtifactoryConfiguration(path__WEBPACK_IMPORTED_MODULE_0__.join(this.rushConfiguration.commonRushConfigFolder, 'artifactory.json'));
        this._messages = Object.assign(Object.assign({}, defaultMessages), this._artifactoryConfiguration.configuration.packageRegistry.messageOverrides);
    }
    _writeInstructionBlock(message) {
        if (message === '') {
            return;
        }
        this._terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.PrintUtilities.wrapWords(message));
        this._terminal.writeLine();
    }
    /**
     * Test whether the NPM token is valid.
     *
     * @returns - `true` if valid, `false` if not valid
     */
    async checkOnly() {
        var _a;
        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;
        if (!packageRegistry.enabled) {
            this._terminal.writeVerbose('Skipping package registry setup because packageRegistry.enabled=false');
            return true;
        }
        const registryUrl = ((packageRegistry === null || packageRegistry === void 0 ? void 0 : packageRegistry.registryUrl) || '').trim();
        if (registryUrl.length === 0) {
            throw new Error('The "registryUrl" setting in artifactory.json is missing or empty');
        }
        if (!this._options.syncNpmrcAlreadyCalled) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this.rushConfiguration.commonTempFolder);
        }
        // Artifactory does not implement the "npm ping" protocol or any equivalent REST API.
        // But if we query a package that is known not to exist, Artifactory will only return
        // a 404 error if it is successfully authenticated.  We can use this negative query
        // to validate the credentials.
        const npmArgs = [
            'view',
            '@rushstack/nonexistent-package',
            '--json',
            '--registry=' + packageRegistry.registryUrl
        ];
        this._terminal.writeLine('Testing access to private NPM registry: ' + packageRegistry.registryUrl);
        const result = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Executable.spawnSync('npm', npmArgs, {
            currentWorkingDirectory: this.rushConfiguration.commonTempFolder,
            stdio: ['ignore', 'pipe', 'pipe'],
            // Wait at most 10 seconds for "npm view" to succeed
            timeoutMs: 10 * 1000
        });
        this._terminal.writeLine();
        // (This is not exactly correct, for example Node.js puts a string in error.errno instead of a string.)
        const error = result.error;
        if (error) {
            if (error.code === 'ETIMEDOUT') {
                // For example, an incorrect "https-proxy" setting can hang for a long time
                throw new Error('The "npm view" command timed out; check your .npmrc file for an incorrect setting');
            }
            throw new Error('Error invoking "npm view": ' + result.error);
        }
        if (result.status === 0) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('"npm view" unexpectedly succeeded');
        }
        // NPM 6.x writes to stdout
        let jsonContent = SetupPackageRegistry._tryFindJson(result.stdout);
        if (jsonContent === undefined) {
            // NPM 7.x writes dirty output to stderr; see https://github.com/npm/cli/issues/2740
            jsonContent = SetupPackageRegistry._tryFindJson(result.stderr);
        }
        if (jsonContent === undefined) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('The "npm view" command did not return a JSON structure');
        }
        let jsonOutput;
        try {
            jsonOutput = JSON.parse(jsonContent);
        }
        catch (e) {
            this._terminal.writeVerboseLine('NPM response:\n\n--------\n' + jsonContent + '\n--------\n\n');
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('The "npm view" command returned an invalid JSON structure');
        }
        const errorCode = (_a = jsonOutput === null || jsonOutput === void 0 ? void 0 : jsonOutput.error) === null || _a === void 0 ? void 0 : _a.code;
        if (typeof errorCode !== 'string') {
            this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('The "npm view" command returned unexpected output');
        }
        switch (errorCode) {
            case 'E404':
                this._terminal.writeLine('NPM credentials are working');
                this._terminal.writeLine();
                return true;
            case 'E401':
            case 'E403':
                this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
                // Credentials are missing or expired
                return false;
            default:
                this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
                throw new Error(`The "npm view" command returned an unexpected error code "${errorCode}"`);
        }
    }
    /**
     * Test whether the NPM token is valid.  If not, prompt to update it.
     */
    async checkAndSetup() {
        if (await this.checkOnly()) {
            return;
        }
        this._terminal.writeWarningLine('NPM credentials are missing or expired');
        this._terminal.writeLine();
        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;
        const fixThisProblem = await _TerminalInput__WEBPACK_IMPORTED_MODULE_5__.TerminalInput.promptYesNo({
            message: 'Fix this problem now?',
            defaultValue: false
        });
        this._terminal.writeLine();
        if (!fixThisProblem) {
            return;
        }
        this._writeInstructionBlock(this._messages.introduction);
        const hasArtifactoryAccount = await _TerminalInput__WEBPACK_IMPORTED_MODULE_5__.TerminalInput.promptYesNo({
            message: 'Do you already have an Artifactory user account?'
        });
        this._terminal.writeLine();
        if (!hasArtifactoryAccount) {
            this._writeInstructionBlock(this._messages.obtainAnAccount);
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        if (this._messages.visitWebsite) {
            this._writeInstructionBlock(this._messages.visitWebsite);
            const artifactoryWebsiteUrl = this._artifactoryConfiguration.configuration.packageRegistry.artifactoryWebsiteUrl;
            if (artifactoryWebsiteUrl) {
                this._terminal.writeLine('  ', _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.cyan(artifactoryWebsiteUrl));
                this._terminal.writeLine();
            }
        }
        this._writeInstructionBlock(this._messages.locateUserName);
        let artifactoryUser = await _TerminalInput__WEBPACK_IMPORTED_MODULE_5__.TerminalInput.promptLine({
            message: this._messages.userNamePrompt
        });
        this._terminal.writeLine();
        artifactoryUser = artifactoryUser.trim();
        if (artifactoryUser.length === 0) {
            this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.red('Operation aborted because the input was empty'));
            this._terminal.writeLine();
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        this._writeInstructionBlock(this._messages.locateApiKey);
        let artifactoryKey = await _TerminalInput__WEBPACK_IMPORTED_MODULE_5__.TerminalInput.promptPasswordLine({
            message: this._messages.apiKeyPrompt
        });
        this._terminal.writeLine();
        artifactoryKey = artifactoryKey.trim();
        if (artifactoryKey.length === 0) {
            this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.red('Operation aborted because the input was empty'));
            this._terminal.writeLine();
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
        }
        await this._fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry);
    }
    /**
     * Fetch a valid NPM token from the Artifactory service and add it to the `~/.npmrc` file,
     * preserving other settings in that file.
     */
    async _fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry) {
        this._terminal.writeLine('\nFetching an NPM token from the Artifactory service...');
        const webClient = new _utilities_WebClient__WEBPACK_IMPORTED_MODULE_6__.WebClient();
        webClient.addBasicAuthHeader(artifactoryUser, artifactoryKey);
        let queryUrl = packageRegistry.registryUrl;
        if (!queryUrl.endsWith('/')) {
            queryUrl += '/';
        }
        // There doesn't seem to be a way to invoke the "/auth" REST endpoint without a resource name.
        // Artifactory's NPM folders always seem to contain a ".npm" folder, so we can use that to obtain
        // our token.
        queryUrl += `auth/.npm`;
        let response;
        try {
            response = await webClient.fetchAsync(queryUrl);
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.log(e.toString());
            return;
        }
        if (!response.ok) {
            if (response.status === 401) {
                throw new Error('Authorization failed; the Artifactory user name or API key may be incorrect.');
            }
            throw new Error(`The Artifactory request failed:\n  (${response.status}) ${response.statusText}`);
        }
        // We expect a response like this:
        //
        //   @.npm:registry=https://your-company.jfrog.io/your-artifacts/api/npm/npm-private/
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:_password=dGhlIHRva2VuIGdvZXMgaGVyZQ==
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:username=your.name@your-company.com
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:email=your.name@your-company.com
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:always-auth=true
        const responseText = await response.text();
        const responseLines = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Text.convertToLf(responseText).trim().split('\n');
        if (responseLines.length < 2 || !responseLines[0].startsWith('@.npm:')) {
            throw new Error('Unexpected response from Artifactory');
        }
        responseLines.shift(); // Remove the @.npm line
        // If we are configured to use authToken for authentication, we still go through the above process
        // (both to ensure the user's credentials are valid, and to let Artifactory format the standard
        // npmrc boilerplate for us), but we'll discard the generated password and use the authToken instead.
        if (packageRegistry.credentialType === 'authToken') {
            for (let i = 0; i < responseLines.length; i++) {
                responseLines[i] = responseLines[i].replace(/_password=.+/, '_authToken=' + artifactoryKey);
            }
        }
        // These are the lines to be injected in ~/.npmrc
        const linesToAdd = [];
        // Start with userNpmrcLinesToAdd...
        if (packageRegistry.userNpmrcLinesToAdd) {
            linesToAdd.push(...packageRegistry.userNpmrcLinesToAdd);
        }
        // ...then append the stuff we got from the REST API, but discard any junk that isn't a proper key/value
        linesToAdd.push(...responseLines.filter((x) => SetupPackageRegistry._getNpmrcKey(x) !== undefined));
        const npmrcPath = path__WEBPACK_IMPORTED_MODULE_0__.join(_utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.getHomeFolder(), '.npmrc');
        this._mergeLinesIntoNpmrc(npmrcPath, linesToAdd);
    }
    /**
     * Update the `~/.npmrc` file by adding `linesToAdd` to it.
     * @remarks
     *
     * If the `.npmrc` file has existing content, it gets merged as follows:
     * - If `linesToAdd` contains key/value pairs and the key already appears in .npmrc,
     *   that line will be overwritten in place
     * - If `linesToAdd` contains non-key lines (e.g. a comment) and it exactly matches a
     *   line in .npmrc, then that line will be kept where it is
     * - The remaining `linesToAdd` that weren't handled by one of the two rules above
     *   are simply appended to the end of the file
     * - Under no circumstances is a duplicate key/value added to the file; in the case of
     *   duplicates, the earliest line in `linesToAdd` takes precedence
     */
    _mergeLinesIntoNpmrc(npmrcPath, linesToAdd) {
        // We'll replace entries with "undefined" if they get discarded
        const workingLinesToAdd = [...linesToAdd];
        // Now build a table of .npmrc keys that can be replaced if they already exist in the file.
        // For example, if we are adding "always-auth=false" then we should delete an existing line
        // that says "always-auth=true".
        const keysToReplace = new Map(); // key --> linesToAdd index
        for (let index = 0; index < workingLinesToAdd.length; ++index) {
            const lineToAdd = workingLinesToAdd[index];
            const key = SetupPackageRegistry._getNpmrcKey(lineToAdd);
            if (key !== undefined) {
                // If there are duplicate keys, the first one takes precedence.
                // In particular this means "userNpmrcLinesToAdd" takes precedence over the REST API response
                if (keysToReplace.has(key)) {
                    // Discard the duplicate key
                    workingLinesToAdd[index] = undefined;
                }
                else {
                    keysToReplace.set(key, index);
                }
            }
        }
        this._terminal.writeLine();
        this._terminal.writeLine(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Colors.green('Adding Artifactory token to: '), npmrcPath);
        const npmrcLines = [];
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(npmrcPath)) {
            const npmrcContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFile(npmrcPath, { convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.NewlineKind.Lf });
            npmrcLines.push(...npmrcContent.trimRight().split('\n'));
        }
        if (npmrcLines.length === 1 && npmrcLines[0] === '') {
            // Edge case where split() adds a blank line to the start of the file
            npmrcLines.length = 0;
        }
        // Make a set of existing .npmrc lines that are not key/value pairs.
        const npmrcNonKeyLinesSet = new Set();
        for (const npmrcLine of npmrcLines) {
            const trimmed = npmrcLine.trim();
            if (trimmed.length > 0) {
                if (SetupPackageRegistry._getNpmrcKey(trimmed) === undefined) {
                    npmrcNonKeyLinesSet.add(trimmed);
                }
            }
        }
        // Overwrite any existing lines that match a key from "linesToAdd"
        for (let index = 0; index < npmrcLines.length; ++index) {
            const line = npmrcLines[index];
            const key = SetupPackageRegistry._getNpmrcKey(line);
            if (key) {
                const linesToAddIndex = keysToReplace.get(key);
                if (linesToAddIndex !== undefined) {
                    npmrcLines[index] = workingLinesToAdd[linesToAddIndex] || '';
                    // Delete it since it's been replaced
                    keysToReplace.delete(key);
                    // Also remove it from "linesToAdd"
                    workingLinesToAdd[linesToAddIndex] = undefined;
                }
            }
        }
        if (npmrcLines.length > 0 && npmrcLines[npmrcLines.length - 1] !== '') {
            // Append a blank line
            npmrcLines.push('');
        }
        // Add any remaining values that weren't matched above
        for (const lineToAdd of workingLinesToAdd) {
            // If a line is undefined, that means we already used it to replace an existing line above
            if (lineToAdd !== undefined) {
                // If a line belongs to npmrcNonKeyLinesSet, then we should not add it because it's
                // already in the .npmrc file
                if (!npmrcNonKeyLinesSet.has(lineToAdd.trim())) {
                    npmrcLines.push(lineToAdd);
                }
            }
        }
        // Save the result
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.writeFile(npmrcPath, npmrcLines.join('\n').trimRight() + '\n');
    }
    static _getNpmrcKey(npmrcLine) {
        if (SetupPackageRegistry._isCommentLine(npmrcLine)) {
            return undefined;
        }
        const delimiterIndex = npmrcLine.indexOf('=');
        if (delimiterIndex < 1) {
            return undefined;
        }
        const key = npmrcLine.substring(0, delimiterIndex + 1);
        return key.trim();
    }
    static _isCommentLine(npmrcLine) {
        return /^\s*#/.test(npmrcLine);
    }
    /**
     * This is a workaround for https://github.com/npm/cli/issues/2740 where the NPM tool sometimes
     * mixes together JSON and terminal messages in a single STDERR stream.
     *
     * @remarks
     * Given an input like this:
     * ```
     * npm ERR! 404 Note that you can also install from a
     * npm ERR! 404 tarball, folder, http url, or git url.
     * {
     *   "error": {
     *     "code": "E404",
     *     "summary": "Not Found - GET https://registry.npmjs.org/@rushstack%2fnonexistent-package - Not found"
     *   }
     * }
     * npm ERR! A complete log of this run can be found in:
     * ```
     *
     * @returns the JSON section, or `undefined` if a JSON object could not be detected
     */
    static _tryFindJson(dirtyOutput) {
        const lines = dirtyOutput.split(/\r?\n/g);
        let startIndex;
        let endIndex;
        // Find the first line that starts with "{"
        for (let i = 0; i < lines.length; ++i) {
            const line = lines[i];
            if (/^\s*\{/.test(line)) {
                startIndex = i;
                break;
            }
        }
        if (startIndex === undefined) {
            return undefined;
        }
        // Find the last line that ends with "}"
        for (let i = lines.length - 1; i >= startIndex; --i) {
            const line = lines[i];
            if (/\}\s*$/.test(line)) {
                endIndex = i;
                break;
            }
        }
        if (endIndex === undefined) {
            return undefined;
        }
        return lines.slice(startIndex, endIndex + 1).join('\n');
    }
}
//# sourceMappingURL=SetupPackageRegistry.js.map

/***/ }),

/***/ 106622:
/*!*************************************************!*\
  !*** ./lib-esnext/logic/setup/TerminalInput.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerminalInput": () => (/* binding */ TerminalInput)
/* harmony export */ });
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! readline */ 514521);
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(readline__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ 677282);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _KeyboardLoop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./KeyboardLoop */ 223422);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





class YesNoKeyboardLoop extends _KeyboardLoop__WEBPACK_IMPORTED_MODULE_4__.KeyboardLoop {
    constructor(options) {
        super();
        this.result = undefined;
        this.options = options;
    }
    onStart() {
        this.stderr.write(colors_safe__WEBPACK_IMPORTED_MODULE_2___default().green('==>') + ' ');
        this.stderr.write(colors_safe__WEBPACK_IMPORTED_MODULE_2___default().bold(this.options.message));
        let optionSuffix = '';
        switch (this.options.defaultValue) {
            case true:
                optionSuffix = '(Y/n)';
                break;
            case false:
                optionSuffix = '(y/N)';
                break;
            default:
                optionSuffix = '(y/n)';
                break;
        }
        this.stderr.write(' ' + colors_safe__WEBPACK_IMPORTED_MODULE_2___default().bold(optionSuffix) + ' ');
    }
    onKeypress(character, key) {
        if (this.result !== undefined) {
            return;
        }
        switch (key.name) {
            case 'y':
                this.result = true;
                break;
            case 'n':
                this.result = false;
                break;
            case 'enter':
            case 'return':
                if (this.options.defaultValue !== undefined) {
                    this.result = this.options.defaultValue;
                }
                break;
        }
        if (this.result !== undefined) {
            this.stderr.write(this.result ? 'Yes\n' : 'No\n');
            this.resolveAsync();
            return;
        }
    }
}
class PasswordKeyboardLoop extends _KeyboardLoop__WEBPACK_IMPORTED_MODULE_4__.KeyboardLoop {
    constructor(options) {
        super();
        this._startX = 0;
        this._printedY = 0;
        this._lastPrintedLength = 0;
        this.result = '';
        this._options = options;
        this._passwordCharacter =
            this._options.passwordCharacter === undefined ? '*' : this._options.passwordCharacter.substr(0, 1);
    }
    _getLineWrapWidth() {
        return this.stderr.columns ? this.stderr.columns : 80;
    }
    onStart() {
        this.result = '';
        readline__WEBPACK_IMPORTED_MODULE_0__.cursorTo(this.stderr, 0);
        readline__WEBPACK_IMPORTED_MODULE_0__.clearLine(this.stderr, 1);
        const prefix = colors_safe__WEBPACK_IMPORTED_MODULE_2___default().green('==>') + ' ' + colors_safe__WEBPACK_IMPORTED_MODULE_2___default().bold(this._options.message) + ' ';
        this.stderr.write(prefix);
        let lineStartIndex = prefix.lastIndexOf('\n');
        if (lineStartIndex < 0) {
            lineStartIndex = 0;
        }
        const line = prefix.substring(lineStartIndex);
        this._startX = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AnsiEscape.removeCodes(line).length % this._getLineWrapWidth();
    }
    onKeypress(character, key) {
        switch (key.name) {
            case 'enter':
            case 'return':
                if (this._passwordCharacter !== '') {
                    // To avoid disclosing the length of the password, after the user presses ENTER,
                    // replace the "*********" sequence with exactly three stars ("***").
                    this._render(this._passwordCharacter.repeat(3));
                }
                this.stderr.write('\n');
                this.resolveAsync();
                return;
            case 'backspace':
                this.result = this.result.substring(0, this.result.length - 1);
                this._render(this.result);
                break;
            default:
                let printable = true;
                if (character === '') {
                    printable = false;
                }
                else if (key.name && key.name.length !== 1 && key.name !== 'space') {
                    printable = false;
                }
                else if (!key.name && !key.sequence) {
                    printable = false;
                }
                if (printable) {
                    this.result += character;
                    this._render(this.result);
                }
        }
    }
    _render(text) {
        // Optimize rendering when we don't need to erase anything
        const needsClear = text.length < this._lastPrintedLength;
        this._lastPrintedLength = text.length;
        this.hideCursor();
        // Restore Y
        while (this._printedY > 0) {
            readline__WEBPACK_IMPORTED_MODULE_0__.cursorTo(this.stderr, 0);
            if (needsClear) {
                readline__WEBPACK_IMPORTED_MODULE_0__.clearLine(this.stderr, 1);
            }
            readline__WEBPACK_IMPORTED_MODULE_0__.moveCursor(this.stderr, 0, -1);
            --this._printedY;
        }
        // Restore X
        readline__WEBPACK_IMPORTED_MODULE_0__.cursorTo(this.stderr, this._startX);
        let i = 0;
        let column = this._startX;
        this._printedY = 0;
        let buffer = '';
        while (i < text.length) {
            if (this._passwordCharacter === '') {
                buffer += text.substr(i, 1);
            }
            else {
                buffer += this._passwordCharacter;
            }
            ++i;
            ++column;
            // -1 to avoid weird TTY behavior in final column
            if (column >= this._getLineWrapWidth() - 1) {
                column = 0;
                ++this._printedY;
                buffer += '\n';
            }
        }
        this.stderr.write(buffer);
        if (needsClear) {
            readline__WEBPACK_IMPORTED_MODULE_0__.clearLine(this.stderr, 1);
        }
        this.unhideCursor();
    }
}
class TerminalInput {
    static async _readLine() {
        const readlineInterface = readline__WEBPACK_IMPORTED_MODULE_0__.createInterface({ input: process__WEBPACK_IMPORTED_MODULE_1__.stdin });
        try {
            return await new Promise((resolve, reject) => {
                readlineInterface.question('', (answer) => {
                    resolve(answer);
                });
            });
        }
        finally {
            readlineInterface.close();
        }
    }
    static async promptYesNo(options) {
        const keyboardLoop = new YesNoKeyboardLoop(options);
        await keyboardLoop.startAsync();
        return keyboardLoop.result;
    }
    static async promptLine(options) {
        const stderr = process__WEBPACK_IMPORTED_MODULE_1__.stderr;
        stderr.write(colors_safe__WEBPACK_IMPORTED_MODULE_2___default().green('==>') + ' ');
        stderr.write(colors_safe__WEBPACK_IMPORTED_MODULE_2___default().bold(options.message));
        stderr.write(' ');
        return await TerminalInput._readLine();
    }
    static async promptPasswordLine(options) {
        const keyboardLoop = new PasswordKeyboardLoop(options);
        await keyboardLoop.startAsync();
        return keyboardLoop.result;
    }
}
//# sourceMappingURL=TerminalInput.js.map

/***/ }),

/***/ 936800:
/*!*******************************************************************!*\
  !*** ./lib-esnext/logic/versionMismatch/VersionMismatchFinder.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionMismatchFinder": () => (/* binding */ VersionMismatchFinder)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 73666);
/* harmony import */ var _VersionMismatchFinderProject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VersionMismatchFinderProject */ 686807);
/* harmony import */ var _VersionMismatchFinderCommonVersions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VersionMismatchFinderCommonVersions */ 263689);
/* harmony import */ var _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../api/CustomTipsConfiguration */ 268756);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






const TRUNCATE_AFTER_PACKAGE_NAME_COUNT = 5;
class VersionMismatchFinder {
    constructor(projects, allowedAlternativeVersions) {
        this._projects = projects;
        this._mismatches = new Map();
        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();
        this._analyze();
    }
    static rushCheck(rushConfiguration, terminal, options = {}) {
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { terminal, isRushCheckCommand: true }));
    }
    static ensureConsistentVersions(rushConfiguration, terminal, options = {}) {
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { terminal, isRushCheckCommand: false, truncateLongPackageNameLists: true }));
    }
    /**
     * Populates a version mismatch finder object given a Rush Configuration.
     * Intentionally considers preferred versions.
     */
    static getMismatches(rushConfiguration, options = {}) {
        const commonVersions = rushConfiguration.getCommonVersions(options.variant);
        const projects = [];
        // Create an object for the purposes of reporting conflicts with preferredVersions from common-versions.json
        // Make sure this one is first so it doesn't get truncated when a long list is printed
        projects.push(new _VersionMismatchFinderCommonVersions__WEBPACK_IMPORTED_MODULE_2__.VersionMismatchFinderCommonVersions(commonVersions));
        for (const project of rushConfiguration.projects) {
            projects.push(new _VersionMismatchFinderProject__WEBPACK_IMPORTED_MODULE_3__.VersionMismatchFinderProject(project));
        }
        return new VersionMismatchFinder(projects, commonVersions.allowedAlternativeVersions);
    }
    static _checkForInconsistentVersions(rushConfiguration, options) {
        if (rushConfiguration.ensureConsistentVersions || options.isRushCheckCommand) {
            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfiguration, options);
            if (options.printAsJson) {
                mismatchFinder.printAsJson();
            }
            else {
                mismatchFinder.print(options.truncateLongPackageNameLists);
                if (mismatchFinder.numberOfMismatches > 0) {
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies!`));
                    rushConfiguration.customTipsConfiguration._showErrorTip(options.terminal, _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_4__.CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS);
                    if (!options.isRushCheckCommand && options.truncateLongPackageNameLists) {
                        // There isn't a --verbose flag in `rush install`/`rush update`, so a long list will always be truncated.
                        // eslint-disable-next-line no-console
                        console.log('For more detailed reporting about these version mismatches, use the "rush check --verbose" command.');
                    }
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.AlreadyReportedError();
                }
                else {
                    if (options.isRushCheckCommand) {
                        // eslint-disable-next-line no-console
                        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Found no mis-matching dependencies!`));
                    }
                }
            }
        }
    }
    get mismatches() {
        return this._mismatches;
    }
    get numberOfMismatches() {
        return this._mismatches.size;
    }
    getMismatches() {
        return this._getKeys(this._mismatches);
    }
    getVersionsOfMismatch(mismatch) {
        return this._mismatches.has(mismatch) ? this._getKeys(this._mismatches.get(mismatch)) : undefined;
    }
    getConsumersOfMismatch(mismatch, version) {
        const mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        const mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    }
    printAsJson() {
        const mismatchDependencies = [];
        this.getMismatches().forEach((dependency) => {
            const mismatchDependencyVersionArray = [];
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                const projects = [];
                this.getConsumersOfMismatch(dependency, version).forEach((project) => {
                    projects.push(project.friendlyName);
                });
                const mismatchDependencyVersion = {
                    version: version,
                    projects: projects
                };
                mismatchDependencyVersionArray.push(mismatchDependencyVersion);
            });
            const mismatchDependency = {
                dependencyName: dependency,
                versions: mismatchDependencyVersionArray
            };
            mismatchDependencies.push(mismatchDependency);
        });
        const output = {
            mismatchedVersions: mismatchDependencies
        };
        // eslint-disable-next-line no-console
        console.log(JSON.stringify(output, undefined, 2));
    }
    print(truncateLongPackageNameLists = false) {
        // Iterate over the list. For any dependency with mismatching versions, print the projects
        this.getMismatches().forEach((dependency) => {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(dependency));
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                // eslint-disable-next-line no-console
                console.log(`  ${version}`);
                const consumersOfMismatch = this.getConsumersOfMismatch(dependency, version);
                let numberToPrint = truncateLongPackageNameLists
                    ? TRUNCATE_AFTER_PACKAGE_NAME_COUNT
                    : consumersOfMismatch.length;
                let numberRemaining = consumersOfMismatch.length;
                for (const { friendlyName } of consumersOfMismatch) {
                    if (numberToPrint-- === 0) {
                        break;
                    }
                    numberRemaining--;
                    // eslint-disable-next-line no-console
                    console.log(`   - ${friendlyName}`);
                }
                if (numberRemaining > 0) {
                    // eslint-disable-next-line no-console
                    console.log(`   (and ${numberRemaining} others)`);
                }
            });
            // eslint-disable-next-line no-console
            console.log();
        });
    }
    _analyze() {
        this._projects.forEach((project) => {
            if (!project.skipRushCheck) {
                // NOTE: We do not consider peer dependencies here.  The purpose of "rush check" is
                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas
                // peer dependencies are just a compatibility statement that will be satisfied by a
                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency
                // patterns consistent, but on the other hand different projects may have different
                // levels of compatibility -- we should wait for someone to actually request this feature
                // before we get into that.)
                project.allDependencies.forEach((dependency) => {
                    if (dependency.dependencyType !== _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_5__.DependencyType.Peer) {
                        const version = dependency.version;
                        const isCyclic = project.decoupledLocalDependencies.has(dependency.name);
                        if (this._isVersionAllowedAlternative(dependency.name, version)) {
                            return;
                        }
                        const name = dependency.name + (isCyclic ? ' (cyclic)' : '');
                        let dependencyVersions = this._mismatches.get(name);
                        if (!dependencyVersions) {
                            this._mismatches.set(name, (dependencyVersions = new Map()));
                        }
                        const consumers = dependencyVersions.get(version);
                        if (!consumers) {
                            dependencyVersions.set(version, [project]);
                        }
                        else {
                            consumers.push(project);
                        }
                    }
                });
            }
        });
        this._mismatches.forEach((mismatches, project) => {
            if (mismatches.size <= 1) {
                this._mismatches.delete(project);
            }
        });
    }
    _isVersionAllowedAlternative(dependency, version) {
        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);
        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _getKeys(iterable) {
        const keys = [];
        if (iterable) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iterable.forEach((value, key) => {
                keys.push(key);
            });
        }
        return keys;
    }
}
//# sourceMappingURL=VersionMismatchFinder.js.map

/***/ }),

/***/ 263689:
/*!*********************************************************************************!*\
  !*** ./lib-esnext/logic/versionMismatch/VersionMismatchFinderCommonVersions.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionMismatchFinderCommonVersions": () => (/* binding */ VersionMismatchFinderCommonVersions)
/* harmony export */ });
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 73666);
/* harmony import */ var _VersionMismatchFinderEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VersionMismatchFinderEntity */ 725554);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class VersionMismatchFinderCommonVersions extends _VersionMismatchFinderEntity__WEBPACK_IMPORTED_MODULE_0__.VersionMismatchFinderEntity {
    constructor(commonVersionsConfiguration) {
        super({
            friendlyName: `preferred versions from ${_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commonVersionsFilename}`,
            decoupledLocalDependencies: new Set()
        });
        this._fileManager = commonVersionsConfiguration;
    }
    get filePath() {
        return this._fileManager.filePath;
    }
    get allDependencies() {
        const dependencies = [];
        this._fileManager.getAllPreferredVersions().forEach((version, dependencyName) => {
            dependencies.push(this._getPackageJsonDependency(dependencyName, version));
        });
        return dependencies;
    }
    tryGetDependency(packageName) {
        const version = this._fileManager.getAllPreferredVersions().get(packageName);
        if (!version) {
            return undefined;
        }
        else {
            return this._getPackageJsonDependency(packageName, version);
        }
    }
    tryGetDevDependency(packageName) {
        return undefined; // common-versions.json doesn't have a distinction between dev and non-dev dependencies
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        if (dependencyType !== _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__.DependencyType.Regular) {
            throw new Error(`${_RushConstants__WEBPACK_IMPORTED_MODULE_1__.RushConstants.commonVersionsFilename} only accepts "${_api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__.DependencyType.Regular}" dependencies`);
        }
        this._fileManager.preferredVersions.set(packageName, newVersion);
    }
    removeDependency(packageName) {
        throw new Error('Not supported.');
    }
    saveIfModified() {
        return this._fileManager.save();
    }
    _getPackageJsonDependency(dependencyName, version) {
        return new _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__.PackageJsonDependency(dependencyName, version, _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__.DependencyType.Regular, () => this.addOrUpdateDependency(dependencyName, version, _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_2__.DependencyType.Regular));
    }
}
//# sourceMappingURL=VersionMismatchFinderCommonVersions.js.map

/***/ }),

/***/ 725554:
/*!*************************************************************************!*\
  !*** ./lib-esnext/logic/versionMismatch/VersionMismatchFinderEntity.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionMismatchFinderEntity": () => (/* binding */ VersionMismatchFinderEntity)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
class VersionMismatchFinderEntity {
    constructor(options) {
        this.friendlyName = options.friendlyName;
        this.decoupledLocalDependencies = options.decoupledLocalDependencies;
        this.skipRushCheck = options.skipRushCheck;
    }
}
//# sourceMappingURL=VersionMismatchFinderEntity.js.map

/***/ }),

/***/ 686807:
/*!**************************************************************************!*\
  !*** ./lib-esnext/logic/versionMismatch/VersionMismatchFinderProject.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionMismatchFinderProject": () => (/* binding */ VersionMismatchFinderProject)
/* harmony export */ });
/* harmony import */ var _VersionMismatchFinderEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VersionMismatchFinderEntity */ 725554);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class VersionMismatchFinderProject extends _VersionMismatchFinderEntity__WEBPACK_IMPORTED_MODULE_0__.VersionMismatchFinderEntity {
    constructor(project) {
        super({
            friendlyName: project.packageName,
            decoupledLocalDependencies: project.decoupledLocalDependencies,
            skipRushCheck: project.skipRushCheck
        });
        this._fileManager = project.packageJsonEditor;
        this.packageName = project.packageName;
    }
    get filePath() {
        return this._fileManager.filePath;
    }
    get allDependencies() {
        return [...this._fileManager.dependencyList, ...this._fileManager.devDependencyList];
    }
    tryGetDependency(packageName) {
        return this._fileManager.tryGetDependency(packageName);
    }
    tryGetDevDependency(packageName) {
        return this._fileManager.tryGetDevDependency(packageName);
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        return this._fileManager.addOrUpdateDependency(packageName, newVersion, dependencyType);
    }
    removeDependency(packageName, dependencyType) {
        return this._fileManager.removeDependency(packageName, dependencyType);
    }
    saveIfModified() {
        return this._fileManager.saveIfModified();
    }
}
//# sourceMappingURL=VersionMismatchFinderProject.js.map

/***/ }),

/***/ 17314:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/yarn/YarnOptionsConfiguration.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YarnOptionsConfiguration": () => (/* binding */ YarnOptionsConfiguration)
/* harmony export */ });
/* harmony import */ var _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/BasePackageManagerOptionsConfiguration */ 573404);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Options that are only used when the yarn package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the yarn package manager
 * is not being used.
 *
 * @public
 */
class YarnOptionsConfiguration extends _base_BasePackageManagerOptionsConfiguration__WEBPACK_IMPORTED_MODULE_0__.PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        super(json);
        this.ignoreEngines = !!json.ignoreEngines;
    }
}
//# sourceMappingURL=YarnOptionsConfiguration.js.map

/***/ }),

/***/ 362701:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/yarn/YarnShrinkwrapFile.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YarnShrinkwrapFile": () => (/* binding */ YarnShrinkwrapFile)
/* harmony export */ });
/* harmony import */ var _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/BaseShrinkwrapFile */ 411534);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/PackageNameParsers */ 644443);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const lockfileModule = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Import.lazy('@yarnpkg/lockfile', require);
/**
 * Support for consuming the "yarn.lock" file.
 *
 * Yarn refers to its shrinkwrap file as a "lock file", even though it has nothing to do
 * with file locking.  Apparently this was based on a convention of the Ruby bundler.
 * Since Rush has to work interchangeably with 3 different package managers, here we refer
 * generically to yarn.lock as a "shrinkwrap file".
 *
 * If Rush's Yarn support gains popularity, we will try to improve the wording of
 * logging messages to use terminology more consistent with Yarn's own documentation.
 */
class YarnShrinkwrapFile extends _base_BaseShrinkwrapFile__WEBPACK_IMPORTED_MODULE_1__.BaseShrinkwrapFile {
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        this._tempProjectNames = [];
        const seenEntries = new Set();
        for (const key of Object.keys(this._shrinkwrapJson)) {
            // Example key:
            const packageNameAndSemVer = YarnShrinkwrapFile._decodePackageNameAndSemVer(key);
            // If it starts with @rush-temp, then include it:
            if (_api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__.PackageNameParsers.permissive.getScope(packageNameAndSemVer.packageName) ===
                _RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.rushTempNpmScope) {
                if (!/^file:/i.test(packageNameAndSemVer.semVerRange)) {
                    // Sanity check to make sure this is a real package.
                    // (Nobody should ever have an actual dependency on an "@rush-temp/" package.
                    throw new Error('Unexpected package/semver expression found in the Yarn shrinkwrap file (yarn.lock): ' +
                        JSON.stringify(key));
                }
                if (!seenEntries.add(packageNameAndSemVer.packageName)) {
                    // Sanity check -- this should never happen
                    throw new Error('Duplicate @rush-temp package found in the Yarn shrinkwrap file (yarn.lock): ' +
                        JSON.stringify(key));
                }
                this._tempProjectNames.push(packageNameAndSemVer.packageName);
                const entry = this._shrinkwrapJson[key];
                // Yarn fails installation if the integrity hash does not match a "file://" reference to a tarball.
                // This is incorrect:  Normally a mismatched integrity hash does indicate a corrupted download,
                // since an NPM registry normally guarantees that a specific version number cannot be republished
                // with different content.  But this is NOT true for a "file://" reference, and there are valid
                // reasons why someone would update the file.  (PNPM handles this correctly, by simply reinstalling
                // the tarball if its hash has changed.)
                //
                // As a workaround, we can simply remove the hashes from the shrinkwrap file.  We will convert this:
                //   "file:./projects/my-project.tgz#80cefe05fd715e65219d1ed481209dc4023408aa"
                // ..to this:
                //   "file:./projects/my-project.tgz"
                const indexOfHash = entry.resolved.indexOf('#');
                if (indexOfHash >= 0) {
                    entry.resolved = entry.resolved.substring(0, indexOfHash);
                }
            }
        }
        this._tempProjectNames.sort(); // make the result deterministic
        // We don't support Yarn workspaces yet
        this.isWorkspaceCompatible = false;
    }
    static loadFromFile(shrinkwrapFilename) {
        try {
            const shrinkwrapContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFile(shrinkwrapFilename);
            return YarnShrinkwrapFile.loadFromString(shrinkwrapContent);
        }
        catch (error) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
                return undefined; // file does not exist
            }
            throw new Error(`Error reading "${shrinkwrapFilename}":\n  ${error.message}`);
        }
    }
    static loadFromString(shrinkwrapContent) {
        const shrinkwrapJson = lockfileModule.parse(shrinkwrapContent);
        return new YarnShrinkwrapFile(shrinkwrapJson.object);
    }
    /**
     * The `@yarnpkg/lockfile` API only partially deserializes its data, and expects the caller
     * to parse the yarn.lock lookup keys (sometimes called a "pattern").
     *
     * Example input:  "js-tokens@^3.0.0 || ^4.0.0"
     * Example output: { packageName: "js-tokens", semVerRange: "^3.0.0 || ^4.0.0" }
     */
    static _decodePackageNameAndSemVer(packageNameAndSemVer) {
        const result = YarnShrinkwrapFile._packageNameAndSemVerRegExp.exec(packageNameAndSemVer);
        if (!result) {
            // Sanity check -- this should never happen
            throw new Error('Unable to parse package/semver expression in the Yarn shrinkwrap file (yarn.lock): ' +
                JSON.stringify(packageNameAndSemVer));
        }
        const packageName = result[1] || '';
        const parsedPackageName = _api_PackageNameParsers__WEBPACK_IMPORTED_MODULE_2__.PackageNameParsers.permissive.tryParse(packageName);
        if (parsedPackageName.error) {
            // Sanity check -- this should never happen
            throw new Error('Invalid package name the Yarn shrinkwrap file (yarn.lock): ' +
                JSON.stringify(packageNameAndSemVer) +
                '\n' +
                parsedPackageName.error);
        }
        return {
            packageName,
            semVerRange: result[2] || ''
        };
    }
    /**
     * This is the inverse of _decodePackageNameAndSemVer():
     * Given an IPackageNameAndSemVer object, recreate the yarn.lock lookup key
     * (sometimes called a "pattern").
     */
    static _encodePackageNameAndSemVer(packageNameAndSemVer) {
        return packageNameAndSemVer.packageName + '@' + packageNameAndSemVer.semVerRange;
    }
    /** @override */
    getTempProjectNames() {
        return this._tempProjectNames;
    }
    /** @override */
    hasCompatibleTopLevelDependency(dependencySpecifier) {
        // It seems like we should normalize the key somehow, but Yarn apparently does not
        // do any normalization.
        const key = YarnShrinkwrapFile._encodePackageNameAndSemVer({
            packageName: dependencySpecifier.packageName,
            semVerRange: dependencySpecifier.versionSpecifier
        });
        // Check whether this exact key appears in the shrinkwrap file
        return Object.hasOwnProperty.call(this._shrinkwrapJson, key);
    }
    /** @override */
    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {
        return this.hasCompatibleTopLevelDependency(dependencySpecifier);
    }
    /** @override */
    serialize() {
        return lockfileModule.stringify(this._shrinkwrapJson);
    }
    /** @override */
    getTopLevelDependencyVersion(dependencyName) {
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Not implemented');
    }
    /** @override */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Not implemented');
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return undefined;
    }
    /** @override */
    async isWorkspaceProjectModifiedAsync(project, variant) {
        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('Not implemented');
    }
}
// Example inputs:
// "js-tokens@^3.0.0 || ^4.0.0"
// "@rush-temp/api-extractor-test-03@file:./projects/api-extractor-test-03.tgz"
YarnShrinkwrapFile._packageNameAndSemVerRegExp = /^(@?[^@\s]+)(?:@(.*))?$/;

//# sourceMappingURL=YarnShrinkwrapFile.js.map

/***/ }),

/***/ 580814:
/*!**********************************************************!*\
  !*** ./lib-esnext/pluginFramework/PhasedCommandHooks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhasedCommandHooks": () => (/* binding */ PhasedCommandHooks)
/* harmony export */ });
/* harmony import */ var tapable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tapable */ 934828);
/* harmony import */ var tapable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tapable__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Hooks into the execution process for phased commands
 * @alpha
 */
class PhasedCommandHooks {
    constructor() {
        /**
         * Hook invoked to create operations for execution.
         * Use the context to distinguish between the initial run and phased runs.
         */
        this.createOperations = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesWaterfallHook(['operations', 'context'], 'createOperations');
        /**
         * Hook invoked before operation start
         * Hook is series for stable output.
         */
        this.beforeExecuteOperations = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['records', 'context']);
        /**
         * Hook invoked when operation status changed
         * Hook is series for stable output.
         */
        this.onOperationStatusChanged = new tapable__WEBPACK_IMPORTED_MODULE_0__.SyncHook(['record']);
        /**
         * Hook invoked after executing a set of operations.
         * Use the context to distinguish between the initial run and phased runs.
         * Hook is series for stable output.
         */
        this.afterExecuteOperations = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['results', 'context']);
        /**
         * Hook invoked before executing a operation.
         */
        this.beforeExecuteOperation = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesBailHook(['runnerContext'], 'beforeExecuteOperation');
        /**
         * Hook invoked after executing a operation.
         */
        this.afterExecuteOperation = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['runnerContext'], 'afterExecuteOperation');
        /**
         * Hook invoked after a run has finished and the command is watching for changes.
         * May be used to display additional relevant data to the user.
         * Only relevant when running in watch mode.
         */
        this.waitingForChanges = new tapable__WEBPACK_IMPORTED_MODULE_0__.SyncHook(undefined, 'waitingForChanges');
        /**
         * Hook invoked after executing operations and before waitingForChanges. Allows the caller
         * to augment or modify the log entry about to be written.
         */
        this.beforeLog = new tapable__WEBPACK_IMPORTED_MODULE_0__.SyncHook(['telemetryData'], 'beforeLog');
    }
}
//# sourceMappingURL=PhasedCommandHooks.js.map

/***/ }),

/***/ 176485:
/*!******************************************************************************!*\
  !*** ./lib-esnext/pluginFramework/PluginLoader/AutoinstallerPluginLoader.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoinstallerPluginLoader": () => (/* binding */ AutoinstallerPluginLoader)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logic/Autoinstaller */ 140603);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _PluginLoaderBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PluginLoaderBase */ 63389);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * @beta
 */
class AutoinstallerPluginLoader extends _PluginLoaderBase__WEBPACK_IMPORTED_MODULE_2__.PluginLoaderBase {
    constructor(options) {
        super(options);
        this.autoinstaller = new _logic_Autoinstaller__WEBPACK_IMPORTED_MODULE_3__.Autoinstaller({
            autoinstallerName: options.pluginConfiguration.autoinstallerName,
            rushConfiguration: this._rushConfiguration,
            restrictConsoleOutput: options.restrictConsoleOutput,
            rushGlobalFolder: options.rushGlobalFolder
        });
        this.packageFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this.autoinstaller.folderFullPath, 'node_modules', this.packageName);
    }
    /**
     * The folder where rush plugins static files are stored.
     * Example: `C:\MyRepo\common\autoinstallers\<autoinstaller_name>\rush-plugins`
     */
    static getPluginAutoinstallerStorePath(autoinstaller) {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(autoinstaller.folderFullPath, 'rush-plugins');
    }
    update() {
        const packageName = this.packageName;
        const pluginName = this.pluginName;
        const packageFolder = this.packageFolder;
        const manifestPath = path__WEBPACK_IMPORTED_MODULE_0__.join(packageFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushPluginManifestFilename);
        // validate
        const manifest = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.loadAndValidate(manifestPath, AutoinstallerPluginLoader._jsonSchema);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFile({
            sourcePath: manifestPath,
            destinationPath: this._getManifestPath()
        });
        const pluginManifest = manifest.plugins.find((item) => item.pluginName === pluginName);
        if (!pluginManifest) {
            throw new Error(`A plugin named "${pluginName}" is not provided by the Rush plugin package "${packageName}"`);
        }
        const commandLineJsonFilePath = pluginManifest.commandLineJsonFilePath;
        if (commandLineJsonFilePath) {
            const commandLineJsonFullFilePath = path__WEBPACK_IMPORTED_MODULE_0__.join(packageFolder, commandLineJsonFilePath);
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(commandLineJsonFullFilePath)) {
                this._terminal.writeErrorLine(`The Rush plugin "${pluginName}" from "${packageName}" specifies a commandLineJsonFilePath` +
                    ` ${commandLineJsonFilePath} that does not exist.`);
            }
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.copyFile({
                sourcePath: commandLineJsonFullFilePath,
                destinationPath: this._getCommandLineJsonFilePath()
            });
        }
    }
    _getCommandLineAdditionalPathFolders() {
        const additionalPathFolders = super._getCommandLineAdditionalPathFolders();
        additionalPathFolders.push(
        // Example: `common/autoinstaller/plugins/node_modules/.bin`
        path__WEBPACK_IMPORTED_MODULE_0__.join(this.autoinstaller.folderFullPath, 'node_modules', '.bin'));
        return additionalPathFolders;
    }
    _getPluginOptions() {
        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();
        const optionsSchema = this._getRushPluginOptionsSchema();
        let pluginOptions = {};
        try {
            pluginOptions = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.load(optionsJsonFilePath);
        }
        catch (e) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.isFileDoesNotExistError(e)) {
                if (optionsSchema) {
                    throw new Error(`Plugin options are required by ${this.pluginName} from package ${this.packageName}, please create it at ${optionsJsonFilePath}.`);
                }
                else {
                    return {};
                }
            }
            throw e;
        }
        if (optionsSchema) {
            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);
        }
        return pluginOptions;
    }
    _getManifestPath() {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushPluginManifestFilename);
    }
    _getCommandLineJsonFilePath() {
        return path__WEBPACK_IMPORTED_MODULE_0__.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, this.pluginName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.commandLineFilename);
    }
}
//# sourceMappingURL=AutoinstallerPluginLoader.js.map

/***/ }),

/***/ 537427:
/*!************************************************************************!*\
  !*** ./lib-esnext/pluginFramework/PluginLoader/BuiltInPluginLoader.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BuiltInPluginLoader": () => (/* binding */ BuiltInPluginLoader)
/* harmony export */ });
/* harmony import */ var _PluginLoaderBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PluginLoaderBase */ 63389);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * @remarks
 * Used to load plugins that are dependencies of Rush.
 */
class BuiltInPluginLoader extends _PluginLoaderBase__WEBPACK_IMPORTED_MODULE_0__.PluginLoaderBase {
    constructor(options) {
        super(options);
        this.packageFolder = options.pluginConfiguration.pluginPackageFolder;
    }
}
//# sourceMappingURL=BuiltInPluginLoader.js.map

/***/ }),

/***/ 63389:
/*!*********************************************************************!*\
  !*** ./lib-esnext/pluginFramework/PluginLoader/PluginLoaderBase.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PluginLoaderBase": () => (/* binding */ PluginLoaderBase)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _api_CommandLineConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/CommandLineConfiguration */ 563114);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _RushSdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RushSdk */ 851211);
/* harmony import */ var _schemas_rush_plugin_manifest_schema_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../schemas/rush-plugin-manifest.schema.json */ 564949);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






class PluginLoaderBase {
    constructor({ pluginConfiguration, rushConfiguration, terminal }) {
        this.packageName = pluginConfiguration.packageName;
        this.pluginName = pluginConfiguration.pluginName;
        this._rushConfiguration = rushConfiguration;
        this._terminal = terminal;
    }
    load() {
        const resolvedPluginPath = this._resolvePlugin();
        if (!resolvedPluginPath) {
            return undefined;
        }
        const pluginOptions = this._getPluginOptions();
        _RushSdk__WEBPACK_IMPORTED_MODULE_2__.RushSdk.ensureInitialized();
        return this._loadAndValidatePluginPackage(resolvedPluginPath, pluginOptions);
    }
    get pluginManifest() {
        return this._getRushPluginManifest();
    }
    getCommandLineConfiguration() {
        const commandLineJsonFilePath = this._getCommandLineJsonFilePath();
        if (!commandLineJsonFilePath) {
            return undefined;
        }
        const commandLineConfiguration = _api_CommandLineConfiguration__WEBPACK_IMPORTED_MODULE_3__.CommandLineConfiguration.tryLoadFromFile(commandLineJsonFilePath);
        if (!commandLineConfiguration) {
            return undefined;
        }
        for (const additionalPathFolder of this._getCommandLineAdditionalPathFolders().reverse()) {
            commandLineConfiguration.prependAdditionalPathFolder(additionalPathFolder);
        }
        commandLineConfiguration.shellCommandTokenContext = {
            packageFolder: this.packageFolder
        };
        return commandLineConfiguration;
    }
    _getCommandLineAdditionalPathFolders() {
        return [
            // Example: `@microsoft/rush-lib/node_modules/<packageName>/node_modules/.bin`
            // Example: `common/autoinstaller/plugins/node_modules/<packageName>/node_modules/.bin`
            path__WEBPACK_IMPORTED_MODULE_1__.join(this.packageFolder, 'node_modules', '.bin')
        ];
    }
    _getCommandLineJsonFilePath() {
        const { commandLineJsonFilePath } = this._getRushPluginManifest();
        if (!commandLineJsonFilePath) {
            return undefined;
        }
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this.packageFolder, commandLineJsonFilePath);
    }
    _loadAndValidatePluginPackage(resolvedPluginPath, options) {
        let pluginPackage;
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const loadedPluginPackage = require(resolvedPluginPath);
            pluginPackage = loadedPluginPackage.default || loadedPluginPackage;
        }
        catch (e) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Error loading rush plugin from "${resolvedPluginPath}": ${e}`);
        }
        if (!pluginPackage) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Rush plugin loaded from "${resolvedPluginPath}" is null or undefined.`);
        }
        this._terminal.writeVerboseLine(`Loaded rush plugin from "${resolvedPluginPath}"`);
        const plugin = new pluginPackage(options);
        if (!plugin.apply || typeof pluginPackage.apply !== 'function') {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Rush plugin must define an "apply" function. The plugin loaded from "${resolvedPluginPath}" ` +
                'either doesn\'t define an "apply" property, or its value isn\'t a function.');
        }
        return plugin;
    }
    _resolvePlugin() {
        const entryPoint = this._getRushPluginManifest().entryPoint;
        if (!entryPoint) {
            return undefined;
        }
        const packageFolder = this.packageFolder;
        const modulePath = path__WEBPACK_IMPORTED_MODULE_1__.join(packageFolder, entryPoint);
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(modulePath)) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Unable to find entry point "${modulePath}" for rush plugin "${this.pluginName}".`);
        }
        return modulePath;
    }
    _getPluginOptions() {
        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();
        const optionsSchema = this._getRushPluginOptionsSchema();
        let pluginOptions = {};
        try {
            pluginOptions = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.load(optionsJsonFilePath);
        }
        catch (e) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isFileDoesNotExistError(e)) {
                return {};
            }
            throw e;
        }
        if (optionsSchema) {
            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);
        }
        return pluginOptions;
    }
    _getPluginOptionsJsonFilePath() {
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.rushPluginOptionsFolder, `${this.pluginName}.json`);
    }
    _getRushPluginOptionsSchema() {
        const optionsSchema = this._getRushPluginManifest().optionsSchema;
        if (!optionsSchema) {
            return undefined;
        }
        const optionsSchemaFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.packageFolder, optionsSchema);
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromFile(optionsSchemaFilePath);
    }
    _getRushPluginManifest() {
        if (!this._manifestCache) {
            const packageName = this.packageName;
            const pluginName = this.pluginName;
            const manifestPath = this._getManifestPath();
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(manifestPath)) {
                throw new Error(`Manifest for rush plugin package ${packageName} not found.\nPlease run 'rush update' first.`);
            }
            const rushPluginManifestJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.loadAndValidate(manifestPath, PluginLoaderBase._jsonSchema);
            const pluginManifest = rushPluginManifestJson.plugins.find((item) => item.pluginName === pluginName);
            if (!pluginManifest) {
                throw new Error(`${pluginName} is not provided by Rush plugin package "${packageName}"`);
            }
            this._manifestCache = pluginManifest;
        }
        return this._manifestCache;
    }
    _getManifestPath() {
        return path__WEBPACK_IMPORTED_MODULE_1__.join(this.packageFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_4__.RushConstants.rushPluginManifestFilename);
    }
}
PluginLoaderBase._jsonSchema = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonSchema.fromLoadedObject(_schemas_rush_plugin_manifest_schema_json__WEBPACK_IMPORTED_MODULE_5__);

//# sourceMappingURL=PluginLoaderBase.js.map

/***/ }),

/***/ 851211:
/*!************************************************************!*\
  !*** ./lib-esnext/pluginFramework/PluginLoader/RushSdk.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushSdk": () => (/* binding */ RushSdk)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
class RushSdk {
    static ensureInitialized() {
        if (!RushSdk._initialized) {
            const rushLibModule = __webpack_require__(/*! ../../index */ 905031);
            // The "@rushstack/rush-sdk" shim will look for this global variable to obtain
            // Rush's instance of "@microsoft/rush-lib".
            global.___rush___rushLibModule = rushLibModule;
            RushSdk._initialized = true;
        }
    }
}
RushSdk._initialized = false;

//# sourceMappingURL=RushSdk.js.map

/***/ }),

/***/ 196314:
/*!*****************************************************!*\
  !*** ./lib-esnext/pluginFramework/PluginManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PluginManager": () => (/* binding */ PluginManager)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PluginLoader_BuiltInPluginLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PluginLoader/BuiltInPluginLoader */ 537427);
/* harmony import */ var _PluginLoader_AutoinstallerPluginLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PluginLoader/AutoinstallerPluginLoader */ 176485);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/Rush */ 465002);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




class PluginManager {
    constructor(options) {
        var _a, _b;
        this._loadedPluginNames = new Set();
        this._terminal = options.terminal;
        this._rushConfiguration = options.rushConfiguration;
        this._rushSession = options.rushSession;
        this._restrictConsoleOutput = options.restrictConsoleOutput;
        this._rushGlobalFolder = options.rushGlobalFolder;
        this._installedAutoinstallerNames = new Set();
        // Eventually we will require end users to explicitly configure all Rush plugins in use, regardless of
        // whether they are first party or third party plugins.  However, we're postponing that requirement
        // until after the plugin feature has stabilized and is fully documented.  In the meantime, Rush's
        // built-in plugins are dependencies of @microsoft/rush-lib and get loaded by default (without any
        // configuration).
        //
        // The plugins have devDependencies on Rush, which would create a circular dependency in our local
        // workspace if we added them to rush-lib/package.json.  Instead we put them in a special section
        // "publishOnlyDependencies" which gets moved into "dependencies" during publishing.
        const builtInPluginConfigurations = options.builtInPluginConfigurations;
        const ownPackageJsonDependencies = _api_Rush__WEBPACK_IMPORTED_MODULE_1__.Rush._rushLibPackageJson.dependencies || {};
        function tryAddBuiltInPlugin(builtInPluginName, pluginPackageName) {
            if (!pluginPackageName) {
                pluginPackageName = `@rushstack/${builtInPluginName}`;
            }
            if (ownPackageJsonDependencies[pluginPackageName]) {
                builtInPluginConfigurations.push({
                    packageName: pluginPackageName,
                    pluginName: builtInPluginName,
                    pluginPackageFolder: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Import.resolvePackage({
                        packageName: pluginPackageName,
                        baseFolderPath: __dirname
                    })
                });
            }
        }
        tryAddBuiltInPlugin('rush-amazon-s3-build-cache-plugin');
        tryAddBuiltInPlugin('rush-azure-storage-build-cache-plugin');
        tryAddBuiltInPlugin('rush-http-build-cache-plugin');
        // This is a secondary plugin inside the `@rushstack/rush-azure-storage-build-cache-plugin`
        // package. Because that package comes with Rush (for now), it needs to get registered here.
        // If the necessary config file doesn't exist, this plugin doesn't do anything.
        tryAddBuiltInPlugin('rush-azure-interactive-auth-plugin', '@rushstack/rush-azure-storage-build-cache-plugin');
        this._builtInPluginLoaders = builtInPluginConfigurations.map((pluginConfiguration) => {
            return new _PluginLoader_BuiltInPluginLoader__WEBPACK_IMPORTED_MODULE_2__.BuiltInPluginLoader({
                pluginConfiguration,
                rushConfiguration: this._rushConfiguration,
                terminal: this._terminal
            });
        });
        this._autoinstallerPluginLoaders = ((_b = (_a = this._rushConfiguration) === null || _a === void 0 ? void 0 : _a._rushPluginsConfiguration.configuration.plugins) !== null && _b !== void 0 ? _b : []).map((pluginConfiguration) => {
            return new _PluginLoader_AutoinstallerPluginLoader__WEBPACK_IMPORTED_MODULE_3__.AutoinstallerPluginLoader({
                pluginConfiguration,
                rushConfiguration: this._rushConfiguration,
                terminal: this._terminal,
                restrictConsoleOutput: this._restrictConsoleOutput,
                rushGlobalFolder: this._rushGlobalFolder
            });
        });
    }
    /**
     * If an error occurs while attempting to load plugins, it will be saved in this property.
     * Rush will attempt to continue and will report the error later by `BaseRushAction._throwPluginErrorIfNeed()`
     * (unless we are invoking a command that is used to fix plugin problems).
     */
    get error() {
        return this._error;
    }
    async updateAsync() {
        await this._preparePluginAutoinstallersAsync(this._autoinstallerPluginLoaders);
        const preparedAutoinstallerNames = new Set();
        for (const { autoinstaller } of this._autoinstallerPluginLoaders) {
            const storePath = _PluginLoader_AutoinstallerPluginLoader__WEBPACK_IMPORTED_MODULE_3__.AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(autoinstaller);
            if (!preparedAutoinstallerNames.has(autoinstaller.name)) {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.ensureEmptyFolder(storePath);
                preparedAutoinstallerNames.add(autoinstaller.name);
            }
        }
        for (const pluginLoader of this._autoinstallerPluginLoaders) {
            pluginLoader.update();
        }
    }
    async reinitializeAllPluginsForCommandAsync(commandName) {
        this._error = undefined;
        await this.tryInitializeUnassociatedPluginsAsync();
        await this.tryInitializeAssociatedCommandPluginsAsync(commandName);
    }
    async _preparePluginAutoinstallersAsync(pluginLoaders) {
        for (const { autoinstaller } of pluginLoaders) {
            if (!this._installedAutoinstallerNames.has(autoinstaller.name)) {
                await autoinstaller.prepareAsync();
                this._installedAutoinstallerNames.add(autoinstaller.name);
            }
        }
    }
    async tryInitializeUnassociatedPluginsAsync() {
        try {
            const autoinstallerPluginLoaders = this._getUnassociatedPluginLoaders(this._autoinstallerPluginLoaders);
            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);
            const builtInPluginLoaders = this._getUnassociatedPluginLoaders(this._builtInPluginLoaders);
            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);
        }
        catch (e) {
            this._error = e;
        }
    }
    async tryInitializeAssociatedCommandPluginsAsync(commandName) {
        try {
            const autoinstallerPluginLoaders = this._getPluginLoadersForCommand(commandName, this._autoinstallerPluginLoaders);
            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);
            const builtInPluginLoaders = this._getPluginLoadersForCommand(commandName, this._builtInPluginLoaders);
            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);
        }
        catch (e) {
            this._error = e;
        }
    }
    tryGetCustomCommandLineConfigurationInfos() {
        const commandLineConfigurationInfos = [];
        for (const pluginLoader of this._autoinstallerPluginLoaders) {
            const commandLineConfiguration = pluginLoader.getCommandLineConfiguration();
            if (commandLineConfiguration) {
                commandLineConfigurationInfos.push({
                    commandLineConfiguration,
                    pluginLoader
                });
            }
        }
        return commandLineConfigurationInfos;
    }
    _initializePlugins(pluginLoaders) {
        for (const pluginLoader of pluginLoaders) {
            const pluginName = pluginLoader.pluginName;
            if (this._loadedPluginNames.has(pluginName)) {
                throw new Error(`Error applying plugin: A plugin with name "${pluginName}" has already been applied`);
            }
            const plugin = pluginLoader.load();
            this._loadedPluginNames.add(pluginName);
            if (plugin) {
                this._applyPlugin(plugin, pluginName);
            }
        }
    }
    _getUnassociatedPluginLoaders(pluginLoaders) {
        return pluginLoaders.filter((pluginLoader) => {
            return !pluginLoader.pluginManifest.associatedCommands;
        });
    }
    _getPluginLoadersForCommand(commandName, pluginLoaders) {
        return pluginLoaders.filter((pluginLoader) => {
            var _a;
            return (_a = pluginLoader.pluginManifest.associatedCommands) === null || _a === void 0 ? void 0 : _a.includes(commandName);
        });
    }
    _applyPlugin(plugin, pluginName) {
        try {
            plugin.apply(this._rushSession, this._rushConfiguration);
        }
        catch (e) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError(`Error applying "${pluginName}": ${e}`);
        }
    }
}
//# sourceMappingURL=PluginManager.js.map

/***/ }),

/***/ 804876:
/*!*****************************************************!*\
  !*** ./lib-esnext/pluginFramework/RushLifeCycle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushLifecycleHooks": () => (/* binding */ RushLifecycleHooks)
/* harmony export */ });
/* harmony import */ var tapable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tapable */ 934828);
/* harmony import */ var tapable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tapable__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Hooks into the lifecycle of the Rush process invocation that plugins may tap into.
 *
 * @beta
 */
class RushLifecycleHooks {
    constructor() {
        /**
         * The hook to run before executing any Rush CLI Command.
         */
        this.initialize = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], 'initialize');
        /**
         * The hook to run before executing any global Rush CLI Command (defined in command-line.json).
         */
        this.runAnyGlobalCustomCommand = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], 'runAnyGlobalCustomCommand');
        /**
         * A hook map to allow plugins to hook specific named global commands (defined in command-line.json) before execution.
         */
        this.runGlobalCustomCommand = new tapable__WEBPACK_IMPORTED_MODULE_0__.HookMap((key) => {
            return new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], key);
        }, 'runGlobalCustomCommand');
        /**
         * The hook to run before executing any phased Rush CLI Command (defined in command-line.json, or the default "build" or "rebuild").
         */
        this.runAnyPhasedCommand = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], 'runAnyPhasedCommand');
        /**
         * A hook map to allow plugins to hook specific named phased commands (defined in command-line.json) before execution.
         */
        this.runPhasedCommand = new tapable__WEBPACK_IMPORTED_MODULE_0__.HookMap((key) => {
            return new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], key);
        }, 'runPhasedCommand');
        /**
         * The hook to run between preparing the common/temp folder and invoking the package manager during "rush install" or "rush update".
         */
        this.beforeInstall = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncSeriesHook(['command'], 'beforeInstall');
        /**
         * A hook to allow plugins to hook custom logic to process telemetry data.
         */
        this.flushTelemetry = new tapable__WEBPACK_IMPORTED_MODULE_0__.AsyncParallelHook(['telemetryData'], 'flushTelemetry');
    }
}
//# sourceMappingURL=RushLifeCycle.js.map

/***/ }),

/***/ 964818:
/*!***************************************************!*\
  !*** ./lib-esnext/pluginFramework/RushSession.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RushSession": () => (/* binding */ RushSession)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logging_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging/Logger */ 837149);
/* harmony import */ var _RushLifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RushLifeCycle */ 804876);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * @beta
 */
class RushSession {
    constructor(options) {
        this._cloudBuildCacheProviderFactories = new Map();
        this._cobuildLockProviderFactories = new Map();
        this._options = options;
        this.hooks = new _RushLifeCycle__WEBPACK_IMPORTED_MODULE_1__.RushLifecycleHooks();
    }
    getLogger(name) {
        if (!name) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('RushSession.getLogger(name) called without a name');
        }
        const terminalProvider = this._options.terminalProvider;
        const loggerOptions = {
            loggerName: name,
            getShouldPrintStacks: () => this._options.getIsDebugMode(),
            terminalProvider
        };
        return new _logging_Logger__WEBPACK_IMPORTED_MODULE_2__.Logger(loggerOptions);
    }
    get terminalProvider() {
        return this._options.terminalProvider;
    }
    registerCloudBuildCacheProviderFactory(cacheProviderName, factory) {
        if (this._cloudBuildCacheProviderFactories.has(cacheProviderName)) {
            throw new Error(`A build cache provider factory for ${cacheProviderName} has already been registered`);
        }
        this._cloudBuildCacheProviderFactories.set(cacheProviderName, factory);
    }
    getCloudBuildCacheProviderFactory(cacheProviderName) {
        return this._cloudBuildCacheProviderFactories.get(cacheProviderName);
    }
    registerCobuildLockProviderFactory(cobuildLockProviderName, factory) {
        if (this._cobuildLockProviderFactories.has(cobuildLockProviderName)) {
            throw new Error(`A cobuild lock provider factory for ${cobuildLockProviderName} has already been registered`);
        }
        this._cobuildLockProviderFactories.set(cobuildLockProviderName, factory);
    }
    getCobuildLockProviderFactory(cobuildLockProviderName) {
        return this._cobuildLockProviderFactories.get(cobuildLockProviderName);
    }
}
//# sourceMappingURL=RushSession.js.map

/***/ }),

/***/ 837149:
/*!******************************************************!*\
  !*** ./lib-esnext/pluginFramework/logging/Logger.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class Logger {
    constructor(options) {
        this._errors = [];
        this._warnings = [];
        this._options = options;
        this.terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Terminal(options.terminalProvider);
    }
    get errors() {
        return [...this.errors];
    }
    get warnings() {
        return [...this.warnings];
    }
    static getErrorMessage(error) {
        return error.message;
    }
    /**
     * {@inheritdoc ILogger.emitError}
     */
    emitError(error) {
        this._errors.push(error);
        this.terminal.writeErrorLine(`Error: ${Logger.getErrorMessage(error)}`);
        if (this._shouldPrintStacks && error.stack) {
            this.terminal.writeErrorLine(error.stack);
        }
    }
    /**
     * {@inheritdoc ILogger.emitWarning}
     */
    emitWarning(warning) {
        this._warnings.push(warning);
        this.terminal.writeWarningLine(`Warning: ${Logger.getErrorMessage(warning)}`);
        if (this._shouldPrintStacks && warning.stack) {
            this.terminal.writeWarningLine(warning.stack);
        }
    }
    get _shouldPrintStacks() {
        return this._options.getShouldPrintStacks();
    }
}
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ 21526:
/*!***********************************************!*\
  !*** ./lib-esnext/utilities/AsyncRecycler.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncRecycler": () => (/* binding */ AsyncRecycler)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 532081);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ 657147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






/**
 * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().
 * It works by moving one or more folders into a temporary "recycler" folder, and then launches a separate
 * background process to recursively delete that folder.
 */
class AsyncRecycler {
    constructor(recyclerFolder) {
        this.recyclerFolder = path__WEBPACK_IMPORTED_MODULE_3__.resolve(recyclerFolder);
        this._movedFolderCount = 0;
        this._deleting = false;
        this._prefix = `${Date.now()}`;
    }
    /**
     * Synchronously moves the specified folder into the recycler folder.  If the specified folder
     * does not exist, then no operation is performed.  After calling this function one or more times,
     * deleteAll() must be called to actually delete the contents of the recycler folder.
     */
    moveFolder(folderPath) {
        if (this._deleting) {
            throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');
        }
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.isUnder(this.recyclerFolder, folderPath)) {
            throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');
        }
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(folderPath)) {
            return;
        }
        ++this._movedFolderCount;
        // We need to do a simple "fs.renameSync" here, however if the folder we're trying to rename
        // has a lock, or if its destination container doesn't exist yet,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes renameSync to
        // fail. To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        _Utilities__WEBPACK_IMPORTED_MODULE_5__.Utilities.createFolderWithRetry(this.recyclerFolder);
        _Utilities__WEBPACK_IMPORTED_MODULE_5__.Utilities.retryUntilTimeout(() => this._renameOrRecurseInFolder(folderPath), maxWaitTimeMs, (e) => new Error(`Error: ${e}\nOften this is caused by a file lock from a process like the virus scanner.`), 'recycleFolder');
    }
    /**
     * This deletes all items under the specified folder, except for the items in the membersToExclude.
     * To be conservative, a case-insensitive comparison is used for membersToExclude.
     * The membersToExclude must be file/folder names that would match readdir() results.
     */
    moveAllItemsInFolder(folderPath, membersToExclude) {
        const resolvedFolderPath = path__WEBPACK_IMPORTED_MODULE_3__.resolve(folderPath);
        const excludeSet = new Set((membersToExclude || []).map((x) => x.toUpperCase()));
        for (const dirent of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItems(resolvedFolderPath)) {
            const normalizedMemberName = dirent.name.toUpperCase();
            if (!excludeSet.has(normalizedMemberName)) {
                const absolutePath = path__WEBPACK_IMPORTED_MODULE_3__.resolve(folderPath, dirent.name);
                if (dirent.isDirectory()) {
                    this._renameOrRecurseInFolder(absolutePath);
                }
                else {
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(absolutePath);
                }
            }
        }
    }
    /**
     * Starts an asynchronous process to delete the recycler folder.  Deleting will continue
     * even if the current Node.js process is killed.
     *
     * NOTE: To avoid spawning multiple instances of the same command, moveFolder()
     * MUST NOT be called again after deleteAll() has started.
     */
    deleteAll() {
        if (this._deleting) {
            throw new Error('AsyncRecycler.deleteAll() must not be called more than once');
        }
        this._deleting = true;
        if (this._movedFolderCount === 0) {
            // Nothing to do
            return;
        }
        // Asynchronously delete the folder contents.
        let command;
        let args;
        const options = {
            detached: true,
            // The child won't stay alive unless we detach its stdio
            stdio: 'ignore'
        };
        if (os__WEBPACK_IMPORTED_MODULE_2__.platform() === 'win32') {
            // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create
            // the new console for us.
            command = 'cmd.exe';
            // In PowerShell single-quote literals, single quotes are escaped by doubling them
            const escapedRecyclerFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Text.replaceAll(this.recyclerFolder, "'", "''");
            // As of PowerShell 3.0, the "\\?" prefix can be used for paths that exceed MAX_PATH.
            // (This prefix does not seem to work for cmd.exe's "rd" command.)
            args = [
                '/c',
                '"' +
                    'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command' +
                    ` Get-ChildItem -Force '${escapedRecyclerFolder}'` +
                    // The "^|" here prevents cmd.exe from interpreting the "|" symbol
                    ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse "\\\\?\\$($_.FullName)" }` +
                    '"'
            ];
            options.windowsVerbatimArguments = true;
        }
        else {
            command = 'rm';
            args = ['-rf'];
            let pathCount = 0;
            // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually
            // rather than rely on an unknown shell.
            for (const filename of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemNames(this.recyclerFolder)) {
                // The "." and ".." are supposed to be excluded, but let's be safe
                if (filename !== '.' && filename !== '..') {
                    args.push(path__WEBPACK_IMPORTED_MODULE_3__.join(this.recyclerFolder, filename));
                    ++pathCount;
                }
            }
            if (pathCount === 0) {
                // Nothing to do
                return;
            }
        }
        const process = child_process__WEBPACK_IMPORTED_MODULE_0__.spawn(command, args, options);
        // The child won't stay alive unless we unlink it from the parent process
        process.unref();
    }
    _renameOrRecurseInFolder(folderPath) {
        const ordinal = this._movedFolderCount++;
        const targetDir = `${this.recyclerFolder}/${this._prefix}_${ordinal}`;
        try {
            fs__WEBPACK_IMPORTED_MODULE_1__.renameSync(folderPath, targetDir);
            return;
        }
        catch (err) {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.isNotExistError(err)) {
                return;
            }
            if (err.code !== 'EPERM') {
                throw err;
            }
        }
        const children = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItems(folderPath);
        for (const child of children) {
            const absoluteChild = `${folderPath}/${child.name}`;
            if (child.isDirectory()) {
                this._renameOrRecurseInFolder(absoluteChild);
            }
            else {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(absoluteChild);
            }
        }
        // Yes, this is a folder. The API deletes empty folders, too.
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(folderPath);
    }
}
//# sourceMappingURL=AsyncRecycler.js.map

/***/ }),

/***/ 782038:
/*!**********************************************************!*\
  !*** ./lib-esnext/utilities/CollatedTerminalProvider.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollatedTerminalProvider": () => (/* binding */ CollatedTerminalProvider)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class CollatedTerminalProvider {
    get hasErrors() {
        return this._hasErrors;
    }
    get hasWarnings() {
        return this._hasWarnings;
    }
    constructor(collatedTerminal, options) {
        this._hasErrors = false;
        this._hasWarnings = false;
        this._debugEnabled = false;
        this.supportsColor = true;
        this.eolCharacter = '\n';
        this._collatedTerminal = collatedTerminal;
        this._debugEnabled = !!(options === null || options === void 0 ? void 0 : options.debugEnabled);
    }
    write(data, severity) {
        switch (severity) {
            case _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.TerminalProviderSeverity.log:
            case _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.TerminalProviderSeverity.verbose: {
                // Unlike the basic ConsoleTerminalProvider, verbose messages are always passed
                // to stdout -- by convention the user-controlled build script output is sent
                // to verbose, and will be routed to a variety of other providers in the ProjectBuilder.
                this._collatedTerminal.writeChunk({ text: data, kind: "O" /* TerminalChunkKind.Stdout */ });
                break;
            }
            case _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.TerminalProviderSeverity.debug: {
                // Similar to the basic ConsoleTerminalProvider, debug messages are discarded
                // unless they are explicitly enabled.
                if (this._debugEnabled) {
                    this._collatedTerminal.writeChunk({ text: data, kind: "O" /* TerminalChunkKind.Stdout */ });
                }
                break;
            }
            case _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.TerminalProviderSeverity.error: {
                this._collatedTerminal.writeChunk({ text: data, kind: "E" /* TerminalChunkKind.Stderr */ });
                this._hasErrors = true;
                break;
            }
            case _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.TerminalProviderSeverity.warning: {
                this._collatedTerminal.writeChunk({ text: data, kind: "E" /* TerminalChunkKind.Stderr */ });
                this._hasWarnings = true;
                break;
            }
            default: {
                throw new Error(`Unexpected severity: ${severity}`);
            }
        }
    }
}
//# sourceMappingURL=CollatedTerminalProvider.js.map

/***/ }),

/***/ 450153:
/*!*************************************!*\
  !*** ./lib-esnext/utilities/Npm.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Npm": () => (/* binding */ Npm)
/* harmony export */ });
/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities */ 827501);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class Npm {
    static publishedVersions(packageName, cwd, env, extraArgs = []) {
        const versions = [];
        try {
            const packageTime = _Utilities__WEBPACK_IMPORTED_MODULE_1__.Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'time', '--json', ...extraArgs], cwd, env, true);
            if (packageTime && packageTime !== '') {
                Object.keys(JSON.parse(packageTime)).forEach((v) => {
                    if (semver__WEBPACK_IMPORTED_MODULE_0__.valid(v)) {
                        versions.push(v);
                    }
                });
            }
            else {
                // eslint-disable-next-line no-console
                console.log(`Package ${packageName} time value does not exist. Fall back to versions.`);
                // time property does not exist. It happens sometimes. Fall back to versions.
                const packageVersions = _Utilities__WEBPACK_IMPORTED_MODULE_1__.Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'versions', '--json', ...extraArgs], cwd, env, true);
                if (packageVersions && packageVersions.length > 0) {
                    const parsedPackageVersions = JSON.parse(packageVersions);
                    // NPM <= 6 always returns an array, NPM >= 7 returns a string if the package has only one version available
                    (Array.isArray(parsedPackageVersions) ? parsedPackageVersions : [parsedPackageVersions]).forEach((version) => {
                        versions.push(version);
                    });
                }
                else {
                    // eslint-disable-next-line no-console
                    console.log(`No version is found for ${packageName}`);
                }
            }
        }
        catch (error) {
            if (error.message.indexOf('npm ERR! 404') >= 0) {
                // eslint-disable-next-line no-console
                console.log(`Package ${packageName} does not exist in the registry.`);
            }
            else {
                // eslint-disable-next-line no-console
                console.log(`Failed to get NPM information about ${packageName}.`);
                throw error;
            }
        }
        return versions;
    }
}
//# sourceMappingURL=Npm.js.map

/***/ }),

/***/ 946979:
/*!******************************************************!*\
  !*** ./lib-esnext/utilities/NullTerminalProvider.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullTerminalProvider": () => (/* binding */ NullTerminalProvider)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * A terminal provider like /dev/null
 */
class NullTerminalProvider {
    constructor() {
        this.supportsColor = false;
        this.eolCharacter = '\n';
    }
    write() { }
}
//# sourceMappingURL=NullTerminalProvider.js.map

/***/ }),

/***/ 529462:
/*!*********************************************************!*\
  !*** ./lib-esnext/utilities/OverlappingPathAnalyzer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlappingPathAnalyzer": () => (/* binding */ OverlappingPathAnalyzer)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,
 * 'lib/x' and 'lib/y' do not.
 */
class OverlappingPathAnalyzer {
    constructor() {
        this._root = {
            encounteredLabels: new Set(),
            paths: {}
        };
    }
    addPathAndGetFirstEncounteredLabels(path, label) {
        const pathParts = path.split('/');
        let currentNode = this._root;
        let currentNodeIsNew = false;
        let labelWasAlreadyPresentInCurrentNode = false;
        for (const pathPart of pathParts) {
            if (pathPart === '') {
                continue;
            }
            if (currentNode.label) {
                return [currentNode.label];
            }
            if (!currentNode.paths[pathPart]) {
                currentNodeIsNew = true;
                currentNode = currentNode.paths[pathPart] = {
                    encounteredLabels: new Set(),
                    paths: {}
                };
            }
            else {
                currentNodeIsNew = false;
                currentNode = currentNode.paths[pathPart];
            }
            labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);
            if (!labelWasAlreadyPresentInCurrentNode) {
                currentNode.encounteredLabels.add(label);
            }
        }
        if (currentNodeIsNew) {
            currentNode.label = label;
            return undefined;
        }
        else if (labelWasAlreadyPresentInCurrentNode) {
            return Array.from(currentNode.encounteredLabels);
        }
        else {
            const clonedEncounteredLabels = new Set(currentNode.encounteredLabels);
            clonedEncounteredLabels.delete(label);
            return Array.from(clonedEncounteredLabels);
        }
    }
}
//# sourceMappingURL=OverlappingPathAnalyzer.js.map

/***/ }),

/***/ 287644:
/*!***********************************************!*\
  !*** ./lib-esnext/utilities/PathConstants.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assetsFolderPath": () => (/* binding */ assetsFolderPath),
/* harmony export */   "installRunRushPnpmScriptFilename": () => (/* binding */ installRunRushPnpmScriptFilename),
/* harmony export */   "installRunRushScriptFilename": () => (/* binding */ installRunRushScriptFilename),
/* harmony export */   "installRunRushxScriptFilename": () => (/* binding */ installRunRushxScriptFilename),
/* harmony export */   "installRunScriptFilename": () => (/* binding */ installRunScriptFilename),
/* harmony export */   "pnpmfileShimFilename": () => (/* binding */ pnpmfileShimFilename),
/* harmony export */   "rushLibFolderRootPath": () => (/* binding */ rushLibFolderRootPath),
/* harmony export */   "scriptsFolderName": () => (/* binding */ scriptsFolderName),
/* harmony export */   "scriptsFolderPath": () => (/* binding */ scriptsFolderPath)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * The currently-executing rush-lib package's root folder path.
 */
const rushLibFolderRootPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);
/**
 * The path to the assets folder in rush-lib.
 */
const assetsFolderPath = `${rushLibFolderRootPath}/assets`;
/**
 * The folder name ("scripts") where the scripts in rush-lib are built.
 */
const scriptsFolderName = 'scripts';
const pnpmfileShimFilename = 'PnpmfileShim.js';
const installRunScriptFilename = 'install-run.js';
const installRunRushScriptFilename = 'install-run-rush.js';
const installRunRushxScriptFilename = 'install-run-rushx.js';
const installRunRushPnpmScriptFilename = 'install-run-rush-pnpm.js';
/**
 * The path to the scripts folder in rush-lib/dist.
 */
const scriptsFolderPath = `${rushLibFolderRootPath}/dist/${scriptsFolderName}`;
//# sourceMappingURL=PathConstants.js.map

/***/ }),

/***/ 407929:
/*!************************************************!*\
  !*** ./lib-esnext/utilities/SetRushLibPath.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/EnvironmentConfiguration */ 382806);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


const rootDir = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);
if (rootDir) {
    // Route to the 'main' field of package.json
    const rushLibIndex = require.resolve(rootDir, { paths: [] });
    process.env[_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_1__.EnvironmentVariableNames.RUSH_LIB_PATH] = rushLibIndex;
}
//# sourceMappingURL=SetRushLibPath.js.map

/***/ }),

/***/ 314318:
/*!*******************************************!*\
  !*** ./lib-esnext/utilities/Stopwatch.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stopwatch": () => (/* binding */ Stopwatch),
/* harmony export */   "StopwatchState": () => (/* binding */ StopwatchState)
/* harmony export */ });
/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utilities */ 827501);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Used with the Stopwatch class.
 */
var StopwatchState;
(function (StopwatchState) {
    StopwatchState[StopwatchState["Stopped"] = 1] = "Stopped";
    StopwatchState[StopwatchState["Started"] = 2] = "Started";
})(StopwatchState || (StopwatchState = {}));
/**
 * Represents a typical timer/stopwatch which keeps track
 * of elapsed time in between two events.
 */
class Stopwatch {
    constructor(getTime = _Utilities__WEBPACK_IMPORTED_MODULE_0__.Utilities.getTimeInMs) {
        this._startTime = undefined;
        this._endTime = undefined;
        this._getTime = getTime;
        this._state = StopwatchState.Stopped;
    }
    /**
     * Static helper function which creates a stopwatch which is immediately started
     */
    static start() {
        return new Stopwatch().start();
    }
    get state() {
        return this._state;
    }
    /**
     * Starts the stopwatch. Note that if end() has been called,
     * reset() should be called before calling start() again.
     */
    start() {
        if (this._startTime !== undefined) {
            throw new Error('Call reset() before starting the Stopwatch');
        }
        this._startTime = this._getTime();
        this._endTime = undefined;
        this._state = StopwatchState.Started;
        return this;
    }
    /**
     * Stops executing the stopwatch and saves the current timestamp
     */
    stop() {
        this._endTime = this._startTime !== undefined ? this._getTime() : undefined;
        this._state = StopwatchState.Stopped;
        return this;
    }
    /**
     * Resets all values of the stopwatch back to the original
     */
    reset() {
        this._endTime = this._startTime = undefined;
        this._state = StopwatchState.Stopped;
        return this;
    }
    /**
     * Displays how long the stopwatch has been executing in a human readable format.
     */
    toString() {
        if (this._state === StopwatchState.Stopped && this._startTime === undefined) {
            return '0.00 seconds (stopped)';
        }
        const totalSeconds = this.duration;
        if (totalSeconds > 60) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60.0;
            return `${minutes.toFixed(0)} minute${minutes === 1 ? '' : 's'} ${seconds.toFixed(1)} seconds`;
        }
        else {
            return `${totalSeconds.toFixed(2)} seconds`;
        }
    }
    /**
     * Get the duration in seconds.
     */
    get duration() {
        if (this._startTime === undefined) {
            return 0;
        }
        const curTime = this._endTime !== undefined ? this._endTime : this._getTime();
        return (curTime - this._startTime) / 1000.0;
    }
    /**
     * Return the start time of the most recent stopwatch run.
     */
    get startTime() {
        return this._startTime;
    }
    /**
     * Return the end time of the most recent stopwatch run.
     */
    get endTime() {
        return this._endTime;
    }
}
//# sourceMappingURL=Stopwatch.js.map

/***/ }),

/***/ 555368:
/*!***********************************************!*\
  !*** ./lib-esnext/utilities/TarExecutable.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarExecutable": () => (/* binding */ TarExecutable)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ 582361);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/EnvironmentConfiguration */ 382806);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





class TarExecutable {
    constructor(tarExecutablePath) {
        this._tarExecutablePath = tarExecutablePath;
    }
    static async tryInitializeAsync(terminal) {
        terminal.writeVerboseLine('Trying to find "tar" binary');
        const tarExecutablePath = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_4__.EnvironmentConfiguration.tarBinaryPath || (await TarExecutable._tryFindTarExecutablePathAsync());
        if (!tarExecutablePath) {
            terminal.writeVerboseLine('"tar" was not found on the PATH');
            return undefined;
        }
        return new TarExecutable(tarExecutablePath);
    }
    /**
     * @returns
     * The "tar" exit code
     */
    async tryUntarAsync(options) {
        return await this._spawnTarWithLoggingAsync(
        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.
        [
            // [Windows bsdtar 3.3.2] Extract: tar -x [options] [<patterns>]
            '-x',
            // [Windows bsdtar 3.3.2] -m    Don't restore modification times
            '-m',
            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\.\tape0)
            '-f',
            options.archivePath
        ], options.outputFolderPath, options.logFilePath);
    }
    /**
     * @returns
     * The "tar" exit code
     */
    async tryCreateArchiveFromProjectPathsAsync(options) {
        const { project, archivePath, paths, logFilePath } = options;
        const tarInput = paths.join('\n');
        // On Windows, tar.exe will report a "Failed to clean up compressor" error if the target folder
        // does not exist (GitHub #2622)
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolderAsync(path__WEBPACK_IMPORTED_MODULE_0__.dirname(archivePath));
        const projectFolderPath = project.projectFolder;
        const tarExitCode = await this._spawnTarWithLoggingAsync(
        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.
        [
            // [Windows bsdtar 3.3.2] -c Create
            '-c',
            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\.\tape0)
            '-f',
            archivePath,
            // [Windows bsdtar 3.3.2] -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma
            '-z',
            // [GNU tar 1.33] -T, --files-from=FILE      get names to extract or create from FILE
            //
            // Windows bsdtar does not document this parameter, but seems to accept it.
            '--files-from=-'
        ], projectFolderPath, logFilePath, tarInput);
        return tarExitCode;
    }
    async _spawnTarWithLoggingAsync(args, currentWorkingDirectory, logFilePath, input) {
        // Runs "tar" with the specified args and logs its output to the specified location.
        // The log file looks like this:
        //
        // Windows:
        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)
        // Invoking "C:\WINDOWS\system32\tar.exe -x -f E:\rush-cache\d18105f7f83eb610b468be4e2421681f4a52e44d"
        //
        // ======= BEGIN PROCESS OUTPUT =======
        // [stdout] <tar stdout output>
        // [stderr] <tar stderr output>
        // ======== END PROCESS OUTPUT ========
        //
        // Exited with code "0"
        //
        // Linux:
        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)
        // Invoking "/bin/tar -x -f /home/username/rush-cache/d18105f7f83eb610b468be4e2421681f4a52e44d"
        //
        // ======= BEGIN PROCESS OUTPUT =======
        // [stdout] <tar stdout output>
        // [stderr] <tar stderr output>
        // ======== END PROCESS OUTPUT ========
        //
        // Exited with code "0"
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolderAsync(path__WEBPACK_IMPORTED_MODULE_0__.dirname(logFilePath));
        const fileWriter = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileWriter.open(logFilePath);
        fileWriter.write([
            `Start time: ${new Date().toString()}`,
            `Invoking "${this._tarExecutablePath} ${args.join(' ')}"`,
            '',
            `======= BEGIN PROCESS INPUT ======`,
            input || '',
            '======== END PROCESS INPUT =======',
            '======= BEGIN PROCESS OUTPUT =======',
            ''
        ].join('\n'));
        const childProcess = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Executable.spawn(this._tarExecutablePath, args, {
            currentWorkingDirectory: currentWorkingDirectory
        });
        childProcess.stdout.on('data', (chunk) => fileWriter.write(`[stdout] ${chunk}`));
        childProcess.stderr.on('data', (chunk) => fileWriter.write(`[stderr] ${chunk}`));
        if (input !== undefined) {
            childProcess.stdin.write(input, 'utf-8');
            childProcess.stdin.end();
        }
        // Wait for process to exit and all streams to close
        const [tarExitCode] = await events__WEBPACK_IMPORTED_MODULE_3___default().once(childProcess, 'close');
        fileWriter.write(['======== END PROCESS OUTPUT ========', '', `Exited with code "${tarExitCode}"`].join('\n'));
        fileWriter.close();
        return tarExitCode;
    }
    static async _tryFindTarExecutablePathAsync() {
        if (os__WEBPACK_IMPORTED_MODULE_1___default().platform() === 'win32') {
            // If we're running on Windows, first try to use the OOB tar executable. If
            // we're running in the Git Bash, the tar executable on the PATH doesn't handle
            // Windows file paths correctly.
            // eslint-disable-next-line dot-notation
            const windowsFolderPath = process.env['WINDIR'];
            if (windowsFolderPath) {
                const defaultWindowsTarExecutablePath = `${windowsFolderPath}\\system32\\tar.exe`;
                if (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.existsAsync(defaultWindowsTarExecutablePath)) {
                    return defaultWindowsTarExecutablePath;
                }
            }
        }
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Executable.tryResolve('tar');
    }
}
//# sourceMappingURL=TarExecutable.js.map

/***/ }),

/***/ 827501:
/*!*******************************************!*\
  !*** ./lib-esnext/utilities/Utilities.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UNINITIALIZED": () => (/* binding */ UNINITIALIZED),
/* harmony export */   "Utilities": () => (/* binding */ Utilities)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 532081);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! perf_hooks */ 504074);
/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(perf_hooks__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _npmrcUtilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./npmrcUtilities */ 679877);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stream */ 12781);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







// eslint-disable-next-line @typescript-eslint/no-redeclare
const UNINITIALIZED = 'UNINITIALIZED';
class Utilities {
    /**
     * Get the user's home directory. On windows this looks something like "C:\users\username\" and on UNIX
     * this looks something like "/home/username/"
     */
    static getHomeFolder() {
        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
        const dirError = "Unable to determine the current user's home directory";
        if (unresolvedUserFolder === undefined) {
            throw new Error(dirError);
        }
        const homeFolder = path__WEBPACK_IMPORTED_MODULE_2__.resolve(unresolvedUserFolder);
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(homeFolder)) {
            throw new Error(dirError);
        }
        return homeFolder;
    }
    /**
     * Node.js equivalent of performance.now().
     */
    static getTimeInMs() {
        return perf_hooks__WEBPACK_IMPORTED_MODULE_3__.performance.now();
    }
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {
        const startTime = Utilities.getTimeInMs();
        let looped = false;
        let result;
        for (;;) {
            try {
                result = fn();
                break;
            }
            catch (e) {
                looped = true;
                const currentTime = Utilities.getTimeInMs();
                if (currentTime - startTime > maxWaitTimeMs) {
                    throw getTimeoutError(e);
                }
            }
        }
        if (looped) {
            const currentTime = Utilities.getTimeInMs();
            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);
            // This logging statement isn't meaningful to the end-user. `fnName` should be updated
            // to something like `operationDescription`
            // eslint-disable-next-line no-console
            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);
        }
        return result;
    }
    /**
     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a
     * retry loop to recover from temporary locks that may be held by other processes.
     * If the folder already exists, no error occurs.
     */
    static createFolderWithRetry(folderName) {
        // Note: If a file exists with the same name, then we fall through and report
        // an error.
        if (Utilities.directoryExists(folderName)) {
            return;
        }
        // We need to do a simple "FileSystem.ensureFolder(localModulesFolder)" here,
        // however if the folder we deleted above happened to contain any files,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes mkdirSync to
        // fail.  To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        return Utilities.retryUntilTimeout(() => _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}\nOften this is caused by a file lock ` +
            'from a process such as your text editor, command prompt, ' +
            'or a filesystem watcher.'), 'createFolderWithRetry');
    }
    /**
     * Determines if a path points to a directory and that it exists.
     */
    static directoryExists(directoryPath) {
        let exists = false;
        try {
            const lstat = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getLinkStatistics(directoryPath);
            exists = lstat.isDirectory();
        }
        catch (e) {
            /* no-op */
        }
        return exists;
    }
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    static dangerouslyDeletePath(folderPath) {
        try {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFolder(folderPath);
        }
        catch (e) {
            throw new Error(`${e.message}\nOften this is caused by a file lock from a process ` +
                'such as your text editor, command prompt, or a filesystem watcher');
        }
    }
    /*
     * Returns true if dateToCompare is more recent than all of the inputFilenames, which
     * would imply that we don't need to rebuild it. Returns false if any of the files
     * does not exist.
     * NOTE: The filenames can also be paths for directories, in which case the directory
     * timestamp is compared.
     */
    static isFileTimestampCurrent(dateToCompare, inputFilenames) {
        for (const inputFilename of inputFilenames) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(inputFilename)) {
                return false;
            }
            const inputStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getStatistics(inputFilename);
            if (dateToCompare < inputStats.mtime) {
                return false;
            }
        }
        return true;
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommand(options) {
        Utilities._executeCommandInternal(options.command, options.args, options.workingDirectory, options.suppressOutput ? undefined : [0, 1, 2], options.environment, options.keepEnvironment);
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     *
     * It's basically the same as executeCommand() except that it returns a Promise.
     */
    static async executeCommandAndInspectOutputAsync(options, onStdoutStreamChunk) {
        await Utilities._executeCommandAndInspectOutputInternalAsync(options.command, options.args, options.workingDirectory, options.suppressOutput ? undefined : onStdoutStreamChunk ? ['inherit', 'pipe', 'inherit'] : [0, 1, 2], options.environment, options.keepEnvironment, onStdoutStreamChunk);
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAndCaptureOutput(command, args, workingDirectory, environment, keepEnvironment = false) {
        const result = Utilities._executeCommandInternal(command, args, workingDirectory, ['pipe', 'pipe', 'pipe'], environment, keepEnvironment);
        return result.stdout.toString();
    }
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    static executeCommandWithRetry(options, maxAttempts, retryCallback) {
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        let attemptNumber = 1;
        for (;;) {
            try {
                Utilities.executeCommand(options);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('\nThe command failed:');
                // eslint-disable-next-line no-console
                console.log(` ${options.command} ` + options.args.join(' '));
                // eslint-disable-next-line no-console
                console.log(`ERROR: ${error.toString()}`);
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    // eslint-disable-next-line no-console
                    console.log(`Trying again (attempt #${attemptNumber})...\n`);
                    if (retryCallback) {
                        retryCallback();
                    }
                    continue;
                }
                else {
                    // eslint-disable-next-line no-console
                    console.error(`Giving up after ${attemptNumber} attempts\n`);
                    throw error;
                }
            }
            break;
        }
    }
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     * Using `onStdoutStreamChunk` to process the output of the command.
     *
     * Note: This is similar to {@link executeCommandWithRetry} except that it returns a Promise and provides a callback to process the output.
     */
    static async executeCommandAndProcessOutputWithRetryAsync(options, maxAttempts, onStdoutStreamChunk, retryCallback) {
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        let attemptNumber = 1;
        for (;;) {
            try {
                await Utilities.executeCommandAndInspectOutputAsync(options, onStdoutStreamChunk);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('\nThe command failed:');
                // eslint-disable-next-line no-console
                console.log(` ${options.command} ` + options.args.join(' '));
                // eslint-disable-next-line no-console
                console.log(`ERROR: ${error.toString()}`);
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    // eslint-disable-next-line no-console
                    console.log(`Trying again (attempt #${attemptNumber})...\n`);
                    if (retryCallback) {
                        retryCallback();
                    }
                    continue;
                }
                else {
                    // eslint-disable-next-line no-console
                    console.error(`Giving up after ${attemptNumber} attempts\n`);
                    throw error;
                }
            }
            break;
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommand(command, options) {
        const result = Utilities._executeLifecycleCommandInternal(command, child_process__WEBPACK_IMPORTED_MODULE_0__.spawnSync, options);
        if (options.handleOutput) {
            Utilities._processResult(result);
        }
        if (result.status !== null) {
            return result.status;
        }
        else {
            throw result.error || new Error('An unknown error occurred.');
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommandAsync(command, options) {
        return Utilities._executeLifecycleCommandInternal(command, child_process__WEBPACK_IMPORTED_MODULE_0__.spawn, options);
    }
    /**
     * For strings passed to a shell command, this adds appropriate escaping
     * to avoid misinterpretation of spaces or special characters.
     *
     * Example: 'hello there' --> '"hello there"'
     */
    static escapeShellParameter(parameter) {
        // This approach is based on what NPM 7 now does:
        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34
        return JSON.stringify(parameter);
    }
    /**
     * Installs a package by name and version in the specified directory.
     */
    static installPackageInDirectory(options) {
        const directory = path__WEBPACK_IMPORTED_MODULE_2__.resolve(options.directory);
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(directory)) {
            // eslint-disable-next-line no-console
            console.log('Deleting old files from ' + directory);
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureEmptyFolder(directory);
        const npmPackageJson = {
            dependencies: {
                [options.packageName]: options.version
            },
            description: 'Temporary file generated by the Rush tool',
            name: options.tempPackageTitle,
            private: true,
            version: '0.0.0'
        };
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.save(npmPackageJson, path__WEBPACK_IMPORTED_MODULE_2__.join(directory, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileConstants.PackageJson));
        if (options.commonRushConfigFolder) {
            Utilities.syncNpmrc(options.commonRushConfigFolder, directory);
        }
        // eslint-disable-next-line no-console
        console.log('\nRunning "npm install" in ' + directory);
        // NOTE: Here we use whatever version of NPM we happen to find in the PATH
        Utilities.executeCommandWithRetry({
            command: 'npm',
            args: ['install'],
            workingDirectory: directory,
            environment: Utilities._createEnvironmentForRushCommand({}),
            suppressOutput: options.suppressOutput
        }, options.maxInstallAttempts);
    }
    /**
     * Copies the file "sourcePath" to "destinationPath", overwriting the target file location.
     * If the source file does not exist, then the target file is deleted.
     */
    static syncFile(sourcePath, destinationPath) {
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(sourcePath)) {
            // eslint-disable-next-line no-console
            console.log(`Copying "${sourcePath}"`);
            // eslint-disable-next-line no-console
            console.log(`  --> "${destinationPath}"`);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.copyFile({ sourcePath, destinationPath });
        }
        else {
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(destinationPath)) {
                // If the source file doesn't exist and there is one in the target, delete the one in the target
                // eslint-disable-next-line no-console
                console.log(`Deleting ${destinationPath}`);
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(destinationPath);
            }
        }
    }
    static getRushConfigNotFoundError() {
        return new Error('Unable to find rush.json configuration file');
    }
    static async usingAsync(getDisposableAsync, doActionAsync) {
        let disposable;
        try {
            disposable = (await getDisposableAsync());
            await doActionAsync(disposable);
        }
        finally {
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
    }
    static _executeLifecycleCommandInternal(command, spawnFunction, options) {
        var _a;
        let shellCommand = process.env.comspec || 'cmd';
        let commandFlags = '/d /s /c';
        let useShell = true;
        if (process.platform !== 'win32') {
            shellCommand = 'sh';
            commandFlags = '-c';
            useShell = false;
        }
        const environment = Utilities._createEnvironmentForRushCommand({
            initCwd: options.initCwd,
            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { rushJsonFolder: (_a = options.rushConfiguration) === null || _a === void 0 ? void 0 : _a.rushJsonFolder, projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })
        });
        return spawnFunction(shellCommand, [commandFlags, command], {
            cwd: options.workingDirectory,
            shell: useShell,
            env: environment,
            stdio: options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2]
        });
    }
    /**
     * Returns a process.env environment suitable for executing lifecycle scripts.
     * @param initialEnvironment - an existing environment to copy instead of process.env
     *
     * @remarks
     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally
     * via the parent process's environment.
     */
    static _createEnvironmentForRushCommand(options) {
        var _a;
        if (options.initialEnvironment === undefined) {
            options.initialEnvironment = process.env;
        }
        // Set some defaults for the environment
        const environment = {};
        if ((_a = options.pathOptions) === null || _a === void 0 ? void 0 : _a.rushJsonFolder) {
            environment.RUSHSTACK_FILE_ERROR_BASE_FOLDER = options.pathOptions.rushJsonFolder;
        }
        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {
            const normalizedKey = os__WEBPACK_IMPORTED_MODULE_1__.platform() === 'win32' ? key.toUpperCase() : key;
            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere
            // with Rush's installations.  If we actually want it, we will set it explicitly below.
            if (normalizedKey === 'INIT_CWD') {
                continue;
            }
            // When NPM invokes a lifecycle event, it copies its entire configuration into environment
            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring
            // this along.
            //
            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring
            // back specific environment variables that the repo maintainer has determined to be safe.
            if (normalizedKey.match(/^NPM_CONFIG_/)) {
                continue;
            }
            // Use the uppercased environment variable name on Windows because environment variable names
            // are case-insensitive on Windows
            environment[normalizedKey] = options.initialEnvironment[key];
        }
        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers
        // the directory that NPM started in.  This allows naive scripts to change their current working directory
        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends
        // for toolchain scripts to be professionally written (versus brittle stuff like
        // "cd ./lib && npm run tsc && cd .."), we support INIT_CWD for compatibility.
        //
        // More about this feature: https://github.com/npm/npm/pull/12356
        if (options.initCwd) {
            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation
        }
        if (options.pathOptions) {
            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);
            }
            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);
            }
            if (options.pathOptions.additionalPathFolders) {
                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(path__WEBPACK_IMPORTED_MODULE_2__.delimiter);
            }
        }
        return environment;
    }
    /**
     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,
     * if `rootDirectory` is "/foobar" and `existingPath` is "/bin", this function will return
     * "/foobar/node_modules/.bin:/bin"
     */
    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {
        const binPath = path__WEBPACK_IMPORTED_MODULE_2__.resolve(rootDirectory, 'node_modules', '.bin');
        if (existingPath) {
            return `${binPath}${path__WEBPACK_IMPORTED_MODULE_2__.delimiter}${existingPath}`;
        }
        else {
            return binPath;
        }
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     *
     * It's the same as _executeCommandInternal except that it returns a promise.
     */
    static async _executeCommandAndInspectOutputInternalAsync(command, args, workingDirectory, stdio, environment, keepEnvironment = false, onStdoutStreamChunk) {
        return new Promise((resolve, reject) => {
            var _a;
            const options = {
                cwd: workingDirectory,
                shell: true,
                stdio: stdio,
                env: keepEnvironment
                    ? environment
                    : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment })
            };
            // Only escape the command if it actually contains spaces:
            const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);
            const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
            const childProcess = child_process__WEBPACK_IMPORTED_MODULE_0__.spawn(escapedCommand, escapedArgs, options);
            const inspectStream = new stream__WEBPACK_IMPORTED_MODULE_5__.PassThrough();
            inspectStream.on('data', (chunk) => {
                const strData = chunk.toString();
                onStdoutStreamChunk === null || onStdoutStreamChunk === void 0 ? void 0 : onStdoutStreamChunk(strData);
            });
            childProcess.on('close', (code, signal) => {
                // TODO: Is it possible that the childProcess is closed before the receiving the last chunks?
                if (code === 0) {
                    resolve();
                }
                else {
                    // mimic the current sync version "_executeCommandInternal" behavior.
                    reject(new Error(`The command failed with exit code ${code}`));
                }
            });
            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(inspectStream).pipe(process.stdout);
        });
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static _executeCommandInternal(command, args, workingDirectory, stdio, environment, keepEnvironment = false) {
        const options = {
            cwd: workingDirectory,
            shell: true,
            stdio: stdio,
            env: keepEnvironment
                ? environment
                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment }),
            maxBuffer: 10 * 1024 * 1024 // Set default max buffer size to 10MB
        };
        // This is needed since we specify shell=true below.
        // NOTE: On Windows if we escape "NPM", the spawnSync() function runs something like this:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '""NPM" "install""' ]
        //
        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's "%~dp0" variable will
        // return the current working directory instead of the batch file's directory.
        // The workaround is to not escape, npm, i.e. do this instead:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '"npm "install""' ]
        //
        // We will come up with a better solution for this when we promote executeCommand()
        // into node-core-library, but for now this hack will unblock people:
        // Only escape the command if it actually contains spaces:
        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);
        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
        let result = child_process__WEBPACK_IMPORTED_MODULE_0__.spawnSync(escapedCommand, escapedArgs, options);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (result.error && result.error.errno === 'ENOENT') {
            // This is a workaround for GitHub issue #25330
            // https://github.com/nodejs/node-v0.x-archive/issues/25330
            //
            // TODO: The fully worked out solution for this problem is now provided by the "Executable" API
            // from @rushstack/node-core-library
            result = child_process__WEBPACK_IMPORTED_MODULE_0__.spawnSync(command + '.cmd', args, options);
        }
        Utilities._processResult(result);
        return result;
    }
    static _processResult(result) {
        if (result.error) {
            result.error.message += '\n' + (result.stderr ? result.stderr.toString() + '\n' : '');
            throw result.error;
        }
        if (result.status) {
            throw new Error('The command failed with exit code ' +
                result.status +
                '\n' +
                (result.stderr ? result.stderr.toString() : ''));
        }
    }
}
Utilities.syncNpmrc = _npmrcUtilities__WEBPACK_IMPORTED_MODULE_6__.syncNpmrc;

//# sourceMappingURL=Utilities.js.map

/***/ }),

/***/ 618105:
/*!*******************************************!*\
  !*** ./lib-esnext/utilities/WebClient.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebClient": () => (/* binding */ WebClient),
/* harmony export */   "WebClientProxy": () => (/* binding */ WebClientProxy)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ 677282);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch */ 374809);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




// ===================================================================================================================
// AS A TEMPORARY WORKAROUND, THIS FILE WAS COPY+PASTED INTO THE "rush-amazon-s3-build-cache-plugin" PROJECT.
// See that copy for notes.
// ===================================================================================================================
const createHttpsProxyAgent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Import.lazy('https-proxy-agent', require);
/**
 * For use with {@link WebClient}.
 */
var WebClientProxy;
(function (WebClientProxy) {
    WebClientProxy[WebClientProxy["None"] = 0] = "None";
    WebClientProxy[WebClientProxy["Detect"] = 1] = "Detect";
    WebClientProxy[WebClientProxy["Fiddler"] = 2] = "Fiddler";
})(WebClientProxy || (WebClientProxy = {}));
/**
 * A helper for issuing HTTP requests.
 */
class WebClient {
    constructor() {
        this.standardHeaders = new node_fetch__WEBPACK_IMPORTED_MODULE_2__.Headers();
        this.accept = '*/*';
        this.userAgent = `rush node/${process__WEBPACK_IMPORTED_MODULE_1__.version} ${os__WEBPACK_IMPORTED_MODULE_0__.platform()} ${os__WEBPACK_IMPORTED_MODULE_0__.arch()}`;
        this.proxy = WebClientProxy.Detect;
    }
    static mergeHeaders(target, source) {
        source.forEach((value, name) => {
            target.set(name, value);
        });
    }
    addBasicAuthHeader(userName, password) {
        this.standardHeaders.set('Authorization', 'Basic ' + Buffer.from(userName + ':' + password).toString('base64'));
    }
    async fetchAsync(url, options) {
        const headers = new node_fetch__WEBPACK_IMPORTED_MODULE_2__.Headers();
        WebClient.mergeHeaders(headers, this.standardHeaders);
        if (options === null || options === void 0 ? void 0 : options.headers) {
            WebClient.mergeHeaders(headers, options.headers);
        }
        if (this.userAgent) {
            headers.set('user-agent', this.userAgent);
        }
        if (this.accept) {
            headers.set('accept', this.accept);
        }
        let proxyUrl = '';
        switch (this.proxy) {
            case WebClientProxy.Detect:
                if (process__WEBPACK_IMPORTED_MODULE_1__.env.HTTPS_PROXY) {
                    proxyUrl = process__WEBPACK_IMPORTED_MODULE_1__.env.HTTPS_PROXY;
                }
                else if (process__WEBPACK_IMPORTED_MODULE_1__.env.HTTP_PROXY) {
                    proxyUrl = process__WEBPACK_IMPORTED_MODULE_1__.env.HTTP_PROXY;
                }
                break;
            case WebClientProxy.Fiddler:
                // For debugging, disable cert validation
                // eslint-disable-next-line
                process__WEBPACK_IMPORTED_MODULE_1__.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
                proxyUrl = 'http://localhost:8888/';
                break;
        }
        let agent = undefined;
        if (proxyUrl) {
            agent = createHttpsProxyAgent(proxyUrl);
        }
        const timeoutMs = (options === null || options === void 0 ? void 0 : options.timeoutMs) !== undefined ? options.timeoutMs : 15 * 1000; // 15 seconds
        const requestInit = {
            method: options === null || options === void 0 ? void 0 : options.verb,
            headers: headers,
            agent: agent,
            timeout: timeoutMs
        };
        const putOptions = options;
        if (putOptions === null || putOptions === void 0 ? void 0 : putOptions.body) {
            requestInit.body = putOptions.body;
        }
        return await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()(url, requestInit);
    }
}
//# sourceMappingURL=WebClient.js.map

/***/ }),

/***/ 679877:
/*!************************************************!*\
  !*** ./lib-esnext/utilities/npmrcUtilities.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isVariableSetInNpmrcFile": () => (/* binding */ isVariableSetInNpmrcFile),
/* harmony export */   "syncNpmrc": () => (/* binding */ syncNpmrc)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 657147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
// IMPORTANT - do not use any non-built-in libraries in this file


/**
 * This function reads the content for given .npmrc file path, and also trims
 * unusable lines from the .npmrc file.
 *
 * @returns
 * The text of the the .npmrc.
 */
// create a global _combinedNpmrc for cache purpose
const _combinedNpmrcMap = new Map();
function _trimNpmrcFile(sourceNpmrcPath) {
    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);
    if (combinedNpmrcFromCache !== undefined) {
        return combinedNpmrcFromCache;
    }
    let npmrcFileLines = fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(sourceNpmrcPath).toString().split('\n');
    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
    const resultLines = [];
    // This finds environment variable tokens that look like "${VAR_NAME}"
    const expansionRegExp = /\$\{([^\}]+)\}/g;
    // Comment lines start with "#" or ";"
    const commentRegExp = /^\s*[#;]/;
    // Trim out lines that reference environment variables that aren't defined
    for (let line of npmrcFileLines) {
        let lineShouldBeTrimmed = false;
        //remove spaces before or after key and value
        line = line
            .split('=')
            .map((lineToTrim) => lineToTrim.trim())
            .join('=');
        // Ignore comment lines
        if (!commentRegExp.test(line)) {
            const environmentVariables = line.match(expansionRegExp);
            if (environmentVariables) {
                for (const token of environmentVariables) {
                    // Remove the leading "${" and the trailing "}" from the token
                    const environmentVariableName = token.substring(2, token.length - 1);
                    // Is the environment variable defined?
                    if (!process.env[environmentVariableName]) {
                        // No, so trim this line
                        lineShouldBeTrimmed = true;
                        break;
                    }
                }
            }
        }
        if (lineShouldBeTrimmed) {
            // Example output:
            // "; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}"
            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);
        }
        else {
            resultLines.push(line);
        }
    }
    const combinedNpmrc = resultLines.join('\n');
    //save the cache
    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
/**
 * As a workaround, copyAndTrimNpmrcFile() copies the .npmrc file to the target folder, and also trims
 * unusable lines from the .npmrc file.
 *
 * Why are we trimming the .npmrc lines?  NPM allows environment variables to be specified in
 * the .npmrc file to provide different authentication tokens for different registry.
 * However, if the environment variable is undefined, it expands to an empty string, which
 * produces a valid-looking mapping with an invalid URL that causes an error.  Instead,
 * we'd prefer to skip that line and continue looking in other places such as the user's
 * home directory.
 *
 * @returns
 * The text of the the .npmrc with lines containing undefined variables commented out.
 */
function _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath) {
    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose
    logger.info(`  --> "${targetNpmrcPath}"`);
    const combinedNpmrc = _trimNpmrcFile(sourceNpmrcPath);
    fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync(targetNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
/**
 * syncNpmrc() copies the .npmrc file to the target folder, and also trims unusable lines from the .npmrc file.
 * If the source .npmrc file not exist, then syncNpmrc() will delete an .npmrc that is found in the target folder.
 *
 * IMPORTANT: THIS CODE SHOULD BE KEPT UP TO DATE WITH Utilities._syncNpmrc()
 *
 * @returns
 * The text of the the synced .npmrc, if one exists. If one does not exist, then undefined is returned.
 */
function syncNpmrc(sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {
    // eslint-disable-next-line no-console
    info: console.log,
    // eslint-disable-next-line no-console
    error: console.error
}) {
    const sourceNpmrcPath = path__WEBPACK_IMPORTED_MODULE_1__.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');
    const targetNpmrcPath = path__WEBPACK_IMPORTED_MODULE_1__.join(targetNpmrcFolder, '.npmrc');
    try {
        if (fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(sourceNpmrcPath)) {
            return _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath);
        }
        else if (fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(targetNpmrcPath)) {
            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target
            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose
            fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync(targetNpmrcPath);
        }
    }
    catch (e) {
        throw new Error(`Error syncing .npmrc file: ${e}`);
    }
}
function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey) {
    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;
    //if .npmrc file does not exist, return false directly
    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(sourceNpmrcPath)) {
        return false;
    }
    const trimmedNpmrcFile = _trimNpmrcFile(sourceNpmrcPath);
    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');
    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;
}
//# sourceMappingURL=npmrcUtilities.js.map

/***/ }),

/***/ 569609:
/*!*************************************************!*\
  !*** ./lib-esnext/utilities/objectUtilities.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cloneDeep": () => (/* binding */ cloneDeep),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "objectsAreDeepEqual": () => (/* binding */ objectsAreDeepEqual)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Determines if two objects are deeply equal.
 */
function objectsAreDeepEqual(a, b) {
    if (a === b) {
        return true;
    }
    else {
        const aType = typeof a;
        const bType = typeof b;
        if (aType !== bType) {
            return false;
        }
        else {
            if (aType === 'object') {
                if (a === null || b === null) {
                    // We already handled the case where a === b, so if either is null, they are not equal
                    return false;
                }
                else if (Array.isArray(a)) {
                    if (!Array.isArray(b) || a.length !== b.length) {
                        return false;
                    }
                    else {
                        for (let i = 0; i < a.length; ++i) {
                            if (!objectsAreDeepEqual(a[i], b[i])) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                else {
                    const aObjectProperties = new Set(Object.getOwnPropertyNames(a));
                    const bObjectProperties = new Set(Object.getOwnPropertyNames(b));
                    if (aObjectProperties.size !== bObjectProperties.size) {
                        return false;
                    }
                    else {
                        for (const property of aObjectProperties) {
                            if (bObjectProperties.delete(property)) {
                                if (!objectsAreDeepEqual(a[property], b[property])) {
                                    return false;
                                }
                            }
                            else {
                                return false;
                            }
                        }
                        return bObjectProperties.size === 0;
                    }
                }
            }
            else {
                return false;
            }
        }
    }
}
function cloneDeep(obj) {
    return cloneDeepInner(obj, new Set());
}
function merge(base, other) {
    if (typeof other === 'object' && other !== null && !Array.isArray(other)) {
        for (const [key, value] of Object.entries(other)) {
            if (key in base) {
                const baseValue = base[key];
                if (typeof baseValue === 'object' && baseValue !== null && !Array.isArray(baseValue)) {
                    base[key] = merge(baseValue, value);
                }
                else {
                    base[key] = value;
                }
            }
            else {
                base[key] = value;
            }
        }
        return base;
    }
    else {
        return other;
    }
}
function cloneDeepInner(obj, seenObjects) {
    if (seenObjects.has(obj)) {
        throw new Error('Circular reference detected');
    }
    else if (typeof obj === 'object') {
        if (obj === null) {
            return null;
        }
        else {
            seenObjects.add(obj);
            if (Array.isArray(obj)) {
                const result = [];
                for (const item of obj) {
                    result.push(cloneDeepInner(item, new Set(seenObjects)));
                }
                return result;
            }
            else {
                const result = {};
                for (const key of Object.getOwnPropertyNames(obj)) {
                    const value = obj[key];
                    result[key] = cloneDeepInner(value, new Set(seenObjects));
                }
                return result;
            }
        }
    }
    else {
        return obj;
    }
}
//# sourceMappingURL=objectUtilities.js.map

/***/ }),

/***/ 405603:
/*!**********************************************************!*\
  !*** ./lib-esnext/schemas/approved-packages.schema.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush approved packages config file","description":"For use with the Rush tool, this file tracks a list of NPM packages that have been approved for usage. This schema is used by two config files browser-approved-packages.json and nonbrowser-approved-packages.jsons. See http://rushjs.io for details.","definitions":{"packageInfo":{"type":"object","properties":{"name":{"description":"The name of the NPM package, e.g. \\"@scope/example\\"","type":"string"},"allowedCategories":{"description":"If rush.json is using the \\"reviewCategories\\" field to classify projects, then the approval is limited to the listed \\"allowedCategories\\"; otherwise, any project may use the package.","type":"array","items":{"type":"string"}}},"additionalProperties":false,"required":["name"]}},"type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"packages":{"description":"A list of NPM packages that are approved for usage.","type":"array","items":{"$ref":"#/definitions/packageInfo"}}},"additionalProperties":false,"required":["packages"]}');

/***/ }),

/***/ 364692:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/artifactory.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush artifactory.json config file","description":"For use with the Rush tool, this configuration file manages Rush integration with JFrog Artifactory services. See http://rushjs.io for details.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to.  Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"packageRegistry":{"type":"object","properties":{"enabled":{"description":"Set this to \\"true\\" to enable Rush to manage tokens for an Artifactory NPM registry.  When enabled, \\"rush install\\" will automatically detect when the user\'s ~/.npmrc authentication token is missing or expired.  And \\"rush setup\\" will prompt the user to renew their token. The default value is false.","type":"boolean"},"registryUrl":{"description":"Specify the URL of your NPM registry.  This is the same URL that appears in your .npmrc file.  It should look something like this example:  https://your-company.jfrog.io/your-project/api/npm/npm-private/","type":"string"},"userNpmrcLinesToAdd":{"description":"A list of custom strings that \\"rush setup\\" should add to the user\'s ~/.npmrc file at the time when the token is updated.  This could be used for example to configure the company registry to be used whenever NPM is invoked as a standalone command (but it\'s not needed for Rush operations like \\"rush add\\" and \\"rush install\\", which get their mappings from the monorepo\'s common/config/rush/.npmrc file).\\n\\nNOTE: The ~/.npmrc settings are global for the user account on a given machine, so be careful about adding settings that may interfere with other work outside the monorepo.","type":"array","items":{"type":"string"}},"artifactoryWebsiteUrl":{"description":"Specifies the URL of the Artifactory control panel where the user can generate an API key.  This URL is printed after the \\"visitWebsite\\" message.  It should look something like this example: https://your-company.jfrog.io/  Specify an empty string to suppress this line entirely.","type":"string"},"credentialType":{"description":"Specifies the type of credential to save in the user\'s ~/.npmrc file. The default is \\"password\\", which means the user\'s entered API token will be passed to the Artifactory website URL specified and traded in for an npm registry password, which is saved. Specify \\"authToken\\" to save the authToken directly into the ~/.npmrc file and use that for credentials instead.","type":"string","enum":["password","authToken"]},"messageOverrides":{"description":"These settings allow the \\"rush setup\\" interactive prompts to be customized, for example with messages specific to your team or configuration.  Specify an empty string to suppress that message entirely.","type":"object","properties":{"introduction":{"description":"Overrides the message that normally says: \\"This monorepo consumes packages from an Artifactory private NPM registry.\\"","type":"string"},"obtainAnAccount":{"description":"Overrides the message that normally says: \\"Please contact the repository maintainers for help with setting up an Artifactory user account.\\"","type":"string"},"visitWebsite":{"description":"Overrides the message that normally says: \\"Please open this URL in your web browser:\\"  The \\"artifactoryWebsiteUrl\\" string is printed after this message.","type":"string"},"locateUserName":{"description":"Overrides the message that normally says: \\"Your user name appears in the upper-right corner of the JFrog website.\\"","type":"string"},"locateApiKey":{"description":"Overrides the message that normally says: \\"Click \'Edit Profile\' on the JFrog website.  Click the \'Generate API Key\' button if you haven\'t already done so previously.\\"","type":"string"},"userNamePrompt":{"description":"Overrides the message that normally prompts: \\"What is your Artifactory user name?\\"","type":"string"},"apiKeyPrompt":{"description":"Overrides the message that normally prompts: \\"What is your Artifactory API key?\\"","type":"string"}},"additionalProperties":false}},"required":["enabled","registryUrl","artifactoryWebsiteUrl"],"additionalProperties":false}},"additionalProperties":false}');

/***/ }),

/***/ 168442:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/build-cache.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Configuration for Rush\'s build cache.","description":"For use with the Rush tool, this file provides configuration options for cached project build output. See http://rushjs.io for details.","definitions":{"anything":{"type":["array","boolean","integer","number","object","string"],"items":{"$ref":"#/definitions/anything"}}},"type":"object","allOf":[{"type":"object","additionalProperties":false,"required":["buildCacheEnabled","cacheProvider"],"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"buildCacheEnabled":{"description":"Set this to true to enable the build cache feature.","type":"boolean"},"cacheProvider":{"description":"Specify the cache provider to use","type":"string"},"cacheEntryNamePattern":{"type":"string","description":"Setting this property overrides the cache entry ID. If this property is set, it must contain a [hash] token. It may also contain a [projectName] or a [projectName:normalize] token."},"azureBlobStorageConfiguration":{"type":"object","additionalProperties":false,"properties":{"storageAccountName":{"type":"string","description":"(Required) The name of the the Azure storage account to use for build cache."},"storageContainerName":{"type":"string","description":"(Required) The name of the container in the Azure storage account to use for build cache."},"azureEnvironment":{"type":"string","description":"The Azure environment the storage account exists in. Defaults to AzurePublicCloud.","enum":["AzurePublicCloud","AzureChina","AzureGermany","AzureGovernment"]},"blobPrefix":{"type":"string","description":"An optional prefix for cache item blob names."},"isCacheWriteAllowed":{"type":"boolean","description":"If set to true, allow writing to the cache. Defaults to false."}}},"amazonS3Configuration":{"type":"object","additionalProperties":false,"properties":{"s3Bucket":{"type":"string","description":"(Required unless s3Endpoint is specified) The name of the bucket to use for build cache (e.g. \\"my-bucket\\")."},"s3Endpoint":{"type":"string","description":"(Required unless s3Bucket is specified) The Amazon S3 endpoint of the bucket to use for build cache (e.g. \\"my-bucket.s3.us-east-2.amazonaws.com\\" or \\"http://localhost:9000\\").\\nThis shold not include any path, use the s3Prefix to set the path."},"s3Region":{"type":"string","description":"(Required) The Amazon S3 region of the bucket to use for build cache (e.g. \\"us-east-1\\")."},"s3Prefix":{"type":"string","description":"An optional prefix (\\"folder\\") for cache items. Should not start with /"},"isCacheWriteAllowed":{"type":"boolean","description":"If set to true, allow writing to the cache. Defaults to false."}}},"httpConfiguration":{"type":"object","additionalProperties":false,"properties":{"url":{"type":"string","description":"(Required) The URL of the server that stores the caches (e.g. \\"https://build-caches.example.com\\").","format":"uri"},"uploadMethod":{"type":"string","description":"(Optional) The HTTP method to use when writing to the cache (defaults to PUT).","enum":["PUT","POST","PATCH"],"default":"PUT"},"headers":{"type":"object","description":"(Optional) HTTP headers to pass to the cache server","properties":{},"additionalProperties":{"type":"string"}},"tokenHandler":{"type":"object","description":"(Optional) Shell command that prints the authorization token needed to communicate with the HTTPS server and exits with code 0. This command will be executed from the root of the monorepo.","properties":{"exec":{"type":"string","description":"(Required) The command or script to execute."},"args":{"type":"array","description":"(Optional) Arguments to pass to the command or script.","items":{"type":"string"}}}},"cacheKeyPrefix":{"type":"string","description":"(Optional) prefix for cache keys."},"isCacheWriteAllowed":{"type":"boolean","description":"(Optional) If set to true, allow writing to the cache. Defaults to false."}}}},"oneOf":[{"type":"object","additionalProperties":true,"properties":{"cacheProvider":{"type":"string","pattern":"^(?:(?!azure-blob-storage|amazon-s3|http).)*$"}}},{"type":"object","additionalProperties":true,"properties":{"cacheProvider":{"type":"string","enum":["azure-blob-storage"]},"azureBlobStorageConfiguration":{"type":"object","additionalProperties":true,"required":["storageAccountName","storageContainerName"],"properties":{"storageAccountName":{"$ref":"#/definitions/anything"},"storageContainerName":{"$ref":"#/definitions/anything"}}}}},{"type":"object","additionalProperties":true,"properties":{"cacheProvider":{"type":"string","enum":["amazon-s3"]},"amazonS3Configuration":{"type":"object","additionalProperties":true,"oneOf":[{"type":"object","required":["s3Region","s3Endpoint"],"properties":{"s3Endpoint":{"$ref":"#/definitions/anything"},"s3Region":{"$ref":"#/definitions/anything"}}},{"type":"object","required":["s3Region","s3Bucket"],"properties":{"s3Bucket":{"$ref":"#/definitions/anything"},"s3Region":{"$ref":"#/definitions/anything"}}}]}}},{"type":"object","additionalProperties":true,"properties":{"cacheProvider":{"type":"string","enum":["http"]},"httpConfiguration":{"type":"object","additionalProperties":true,"required":["url"],"properties":{"url":{"$ref":"#/definitions/anything"}}}}}]}]}');

/***/ }),

/***/ 608725:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/change-file.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Generated Rush changefiles","description":"For use with the Rush tool, this file tracks changes that are made to individual packages within the Rush repo. See http://rushjs.io for details.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"changes":{"description":"A list of changes that apply to the specified package. These changes will cause the specified package and all dependent packages ","type":"array","items":{"type":"object","required":["packageName","comment","type"],"properties":{"packageName":{"type":"string","description":"The name of the package that the change applies to."},"comment":{"type":"string","description":"A comment that describes the change being made."},"type":{"type":"string","description":"The change type associated with the change.","enum":["none","dependency","hotfix","patch","minor","major"]},"customFields":{"type":"object","description":"An optional dictionary of custom string fields.","patternProperties":{"^.*$":{"type":"string"}}}}}},"packageName":{"description":"The name of the package that the change file applies to.","type":"string"},"email":{"description":"The email address for the author of the change.","type":"string"}},"additionalProperties":false}');

/***/ }),

/***/ 288445:
/*!**************************************************!*\
  !*** ./lib-esnext/schemas/changelog.schema.json ***!
  \**************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Changelog file for packages in rush which should be published","description":"This file represents a JSON format of changelog of a package","additionalProperties":false,"properties":{"entries":{"description":"Entries within the changelog corresponding to each published version.","items":{"$ref":"#/definitions/IChangeLogEntry"},"type":"array"},"name":{"description":"Name of the project","type":"string"}},"required":["name","entries"],"type":"object","definitions":{"IChangeLogComment":{"additionalProperties":false,"description":"Interface representing a single changelog comment within an entry.","properties":{"author":{"description":"The author, if applicable, that created the change request.","type":"string"},"comment":{"description":"The given comment. (supports markdown.)","type":"string"},"commit":{"description":"The commit, if applicable, including the change request.","type":"string"},"customFields":{"type":"object","description":"An optional dictionary of custom string fields.","patternProperties":{"^.*$":{"type":"string"}}}},"required":["comment"],"type":"object"},"IChangeLogEntry":{"additionalProperties":false,"description":"Interface representing a single published entry in the changelog.","properties":{"comments":{"$ref":"#/definitions/IChangeLogEntryComments","description":"Comments for the entry, where key represents the ChangeType string (Example: major)"},"date":{"description":"The UTC date when the publish was applied. (Example: Fri, 02 Dec 2016 22:27:16 GMT)","type":"string"},"tag":{"description":"Git tag used to identify the published commit. (Example: b7f55611e54910327a206476b185265498c66acf)","type":"string"},"version":{"description":"Published version for the entry. (Example: 1.0.0)","type":"string"}},"required":["version","tag","comments"],"type":"object"},"IChangeLogEntryComments":{"additionalProperties":false,"description":"Interface representing a single published entry in the changelog.","properties":{"dependency":{"description":"Describes changes to the package\'s dependencies","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"},"hotfix":{"description":"Describe changes that do not have version information","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"},"major":{"description":"Describes changes which cause a major-level SemVer bump","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"},"minor":{"description":"Describes changes which cause a minor-level SemVer bump","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"},"none":{"description":"Describe changes that do not have version information","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"},"patch":{"description":"Describes changes which cause a patch-level SemVer bump","items":{"$ref":"#/definitions/IChangeLogComment"},"type":"array"}},"type":"object"}}}');

/***/ }),

/***/ 222518:
/*!************************************************!*\
  !*** ./lib-esnext/schemas/cobuild.schema.json ***!
  \************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Configuration for Rush\'s cobuild.","description":"For use with the Rush tool, this file provides configuration options for cobuild feature. See http://rushjs.io for details.","definitions":{"anything":{"type":["array","boolean","integer","number","object","string"],"items":{"$ref":"#/definitions/anything"}}},"type":"object","allOf":[{"type":"object","additionalProperties":false,"required":["cobuildFeatureEnabled","cobuildLockProvider"],"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"cobuildFeatureEnabled":{"description":"Set this to true to enable the cobuild feature.","type":"boolean"},"cobuildLockProvider":{"description":"Specify the cobuild lock provider to use","type":"string"}}}]}');

/***/ }),

/***/ 703450:
/*!*****************************************************!*\
  !*** ./lib-esnext/schemas/command-line.schema.json ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush command-line.json config file","description":"For use with the Rush tool, this file defines custom command line commands. See http://rushjs.io for details.","definitions":{"anything":{"type":["array","boolean","integer","number","object","string"],"items":{"$ref":"#/definitions/anything"}},"baseCommand":{"type":"object","additionalProperties":true,"required":["commandKind","name","summary"],"properties":{"commandKind":{"title":"Command Kind","description":"Indicates the kind of command: \\"bulk\\" commands are run separately for each project; \\"global\\" commands are run once for the entire repository.","type":"string","enum":["bulk","global","phased"]},"name":{"title":"Custom Command Name","description":"The name of the custom command, which can be invoked via \\"rush <name>\\"","type":"string"},"summary":{"title":"Custom Command Summary","description":"A short summary of the custom command, which will appear when printing command line usage (e.g. \\"rush --help\\")","type":"string"},"description":{"title":"Custom Command Description","description":"A detailed description of the command, which appears when requesting help for the command (e.g. \\"rush --help my-command\\"). If omitted, the summary will be used.","type":"string"},"safeForSimultaneousRushProcesses":{"title":"Safe For Simultaneous Rush Processes","description":"By default, Rush operations acquire a lock file which prevents multiple commands from executing simultaneously in the same repo folder.  (For example, it would be a mistake to run \\"rush install\\" and \\"rush build\\" at the same time.)  If your command makes sense to run concurrently with other operations, set safeForSimultaneousRushProcesses=true to disable this protection.  In particular, this is needed for custom scripts that invoke other Rush commands.","type":"boolean"}}},"bulkCommand":{"title":"Bulk Command","description":"A custom command that is run separately for each project in the repository","type":"object","allOf":[{"$ref":"#/definitions/baseCommand"},{"type":"object","additionalProperties":true,"required":["enableParallelism"],"properties":{"commandKind":{"enum":["bulk"]},"shellCommand":{"title":"Shell Command","description":"(Optional) If the \\"shellCommand\\" field is set for a bulk command, Rush will invoke it for each selected project; otherwise, Rush will invoke the package.json \\"scripts\\" entry matching Rush command name.\\n\\nThe string is the path to a script that will be invoked using the OS shell. The working directory will be the folder that contains rush.json.  If custom parameters are associated with this command, their values will be appended to the end of this string.","type":"string"},"enableParallelism":{"title":"enableParallelism","description":"If true then this command can be run in parallel, i.e. executed simultaneously for multiple projects.","type":"boolean"},"ignoreDependencyOrder":{"title":"ignoreDependencyOrder","description":"Normally projects will be processed according to their dependency order: a given project will not start processing the command until all of its dependencies have completed.  This restriction doesn\'t apply for certain operations, for example, a \\"clean\\" task that deletes output files.  In this case you can set \\"ignoreDependencyOrder\\" to true to increase parallelism.","type":"boolean"},"ignoreMissingScript":{"title":"Ignore Missing Script","description":"Normally Rush requires that each project\'s package.json has a \\"scripts\\" entry matching the custom command name. To disable this check, set \\"ignoreMissingScript\\" to true.","type":"boolean"},"incremental":{"title":"Incremental","description":"If true then this command will be incremental like the built-in \\"build\\" and \\"rebuild\\" commands","type":"boolean"},"allowWarningsInSuccessfulBuild":{"title":"Allow Warnings in Successful Build","description":"By default, Rush returns a nonzero exit code if errors or warnings occur during build. If this option is set to \\"true\\", Rush will return a zero exit code if warnings occur.","type":"boolean"},"watchForChanges":{"title":"Watch For Changes","description":"(EXPERIMENTAL) Normally Rush terminates after the command finishes. If this option is set to \\"true\\" Rush will instead enter a loop where it watches the file system for changes to the selected projects. Whenever a change is detected, the command will be invoked again for the changed project and any selected projects that directly or indirectly depend on it. For details, refer to the website article \\"Using watch mode\\".","type":"boolean"},"disableBuildCache":{"title":"Disable build cache.","description":"Disable build cache for this action. This may be useful if this command affects state outside of projects\' own folders. If the build cache is not configured, this also disables the legacy skip detection logic.","type":"boolean"}}},{"type":"object","additionalProperties":false,"properties":{"commandKind":{"$ref":"#/definitions/anything"},"name":{"$ref":"#/definitions/anything"},"summary":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"safeForSimultaneousRushProcesses":{"$ref":"#/definitions/anything"},"shellCommand":{"$ref":"#/definitions/anything"},"enableParallelism":{"$ref":"#/definitions/anything"},"ignoreDependencyOrder":{"$ref":"#/definitions/anything"},"ignoreMissingScript":{"$ref":"#/definitions/anything"},"incremental":{"$ref":"#/definitions/anything"},"allowWarningsInSuccessfulBuild":{"$ref":"#/definitions/anything"},"watchForChanges":{"$ref":"#/definitions/anything"},"disableBuildCache":{"$ref":"#/definitions/anything"}}}]},"globalCommand":{"title":"Global Command","description":"A custom command that is run once for the entire repository","type":"object","allOf":[{"$ref":"#/definitions/baseCommand"},{"type":"object","additionalProperties":true,"required":["shellCommand"],"properties":{"commandKind":{"enum":["global"]},"shellCommand":{"title":"Shell Command","description":"A command that that will be invoked using the OS shell. The working directory will be the folder that contains rush.json. Additional command-line parameters may be appended to the end of this string.","type":"string"},"autoinstallerName":{"title":"Autoinstaller Name","description":"If your \\"shellCommand\\" script depends on NPM packages, the recommended best practice is to make it into a regular Rush project that builds using your normal toolchain.  In cases where the command needs to work without first having to run \\"rush build\\", the recommended practice is to publish the project to an NPM registry and use common/scripts/install-run.js to launch it.\\n\\nAutoinstallers offer another possibility: They are folders under \\"common/autoinstallers\\" with a package.json file and shrinkwrap file. Rush will automatically invoke the package manager to install these dependencies before an associated command is invoked.  Autoinstallers have the advantage that they work even in a branch where \\"rush install\\" is broken, which makes them a good solution for Git hook scripts.  But they have the disadvantages of not being buildable projects, and of increasing the overall installation footprint for your monorepo.\\n\\nThe \\"autoinstallerName\\" setting must not contain a path and must be a valid NPM package name.\\n\\nFor example, the name \\"my-task\\" would map to \\"common/autoinstallers/my-task/package.json\\", and the \\"common/autoinstallers/my-task/node_modules/.bin\\" folder would be added to the shell PATH when invoking the \\"shellCommand\\".","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"commandKind":{"$ref":"#/definitions/anything"},"name":{"$ref":"#/definitions/anything"},"summary":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"safeForSimultaneousRushProcesses":{"$ref":"#/definitions/anything"},"shellCommand":{"$ref":"#/definitions/anything"},"autoinstallerName":{"$ref":"#/definitions/anything"}}}]},"phasedCommand":{"title":"Phased Command","description":"A command that contains multiple phases, that are run separately for each project","type":"object","allOf":[{"$ref":"#/definitions/baseCommand"},{"type":"object","additionalProperties":true,"required":["enableParallelism","phases"],"properties":{"commandKind":{"enum":["phased"]},"enableParallelism":{"title":"enableParallelism","description":"If true then this command can be run in parallel, i.e. executed simultaneously for multiple projects.","type":"boolean"},"incremental":{"title":"Incremental","description":"If true then this command\'s phases will be incremental and support caching.","type":"boolean"},"phases":{"title":"Phases","description":"List the phases associated with this command. Note that phases with dependencies will be implicitly included even if they aren\'t explicitly enumerated in this property.","type":"array","items":{"type":"string"}},"disableBuildCache":{"title":"Disable build cache.","description":"Disable build cache for this action. This may be useful if this command affects state outside of projects\' own folders. If the build cache is not configured, this also disables the legacy skip detection logic.","type":"boolean"},"watchOptions":{"title":"Watch Options","description":"Controls the file watching behavior of this command. If not specified, this command does not watch files.","type":"object","additionalProperties":false,"required":["alwaysWatch","watchPhases"],"properties":{"alwaysWatch":{"title":"Always Watch","description":"Indicates that this command will always watch for changes after the initial execution, as if the \\"--watch\\" CLI flag was passed.","type":"boolean"},"debounceMs":{"title":"Debounce Timeout in Milliseconds","description":"When watching, how long to wait after the last encountered file system event before execution. If another file system event occurs in this interval, the timeout will reset. Defaults to 1000ms (1 second).","type":"number"},"watchPhases":{"title":"Watch Phases","description":"List *exactly* the phases that should be run in watch mode for this command. If this property is specified and non-empty, after the phases defined in the \\"phases\\" property run, a file watcher will be started to watch projects for changes, and will run the phases listed in this property on changed projects.","type":"array","items":{"type":"string"}}}},"installOptions":{"title":"Install Options","description":"Controls behavior related to performing installation as part of executing this command.","type":"object","additionalProperties":false,"required":["alwaysInstall"],"properties":{"alwaysInstall":{"title":"Always Install","description":"Indicates that this command will always perform a standard \\"rush install\\" before executing, as if the \\"--install\\" CLI flag was passed.","type":"boolean"}}}}},{"type":"object","additionalProperties":false,"properties":{"commandKind":{"$ref":"#/definitions/anything"},"name":{"$ref":"#/definitions/anything"},"summary":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"safeForSimultaneousRushProcesses":{"$ref":"#/definitions/anything"},"enableParallelism":{"$ref":"#/definitions/anything"},"incremental":{"$ref":"#/definitions/anything"},"phases":{"$ref":"#/definitions/anything"},"watchOptions":{"$ref":"#/definitions/anything"},"installOptions":{"$ref":"#/definitions/anything"}}}]},"phase":{"title":"Phase","description":"A phase, used in the phased command feature.","type":"object","additionalProperties":false,"required":["name"],"properties":{"name":{"title":"Name","description":"The name of the phase. Note that this value must start with the \\"_phase:\\" prefix.","type":"string"},"dependencies":{"title":"Dependencies","description":"The dependencies of this phase.","type":"object","additionalProperties":false,"properties":{"self":{"title":"Self","description":"Dependency phases within the same project.","type":"array","uniqueItems":true,"items":{"type":"string"}},"upstream":{"title":"Upstream","description":"Dependency phases in upstream projects.","type":"array","uniqueItems":true,"items":{"type":"string"}}}},"ignoreMissingScript":{"title":"Ignore Missing Script","description":"Normally Rush requires that each project\'s package.json has a \\"scripts\\" entry matching the phase name. To disable this check, set \\"ignoreMissingScript\\" to true.","type":"boolean"},"allowWarningsOnSuccess":{"title":"Allow Warnings on Success","description":"By default, Rush returns a nonzero exit code if errors or warnings occur during a command. If this option is set to \\"true\\", Rush will return a zero exit code if warnings occur during the execution of this phase.","type":"boolean"},"missingScriptBehavior":{"title":"Missing Script Behavior","description":"What should happen if a project\'s package.json does not have a \\"scripts\\" entry matching the phase name, or it is an empty string. Supersedes \\"ignoreMissingScript\\". Defaults to \\"error\\".","type":"string","enum":["silent","log","error"]}}},"baseParameter":{"type":"object","additionalProperties":true,"required":["parameterKind","longName","description"],"properties":{"parameterKind":{"title":"Parameter Kind","description":"Indicates the kind of syntax for this command-line parameter: \\"flag\\" or \\"choice\\" or \\"string\\"","type":"string","enum":["flag","choice","string","integer","stringList","integerList","choiceList"]},"longName":{"title":"Long Name","description":"The name of the parameter (e.g. \\"--verbose\\").  This is a required field.","type":"string","pattern":"^-(-[a-z0-9]+)+$"},"shortName":{"title":"Short Name","description":"A optional short form of the parameter (e.g. \\"-v\\" instead of \\"--verbose\\")","type":"string","pattern":"^-[a-zA-Z]$"},"description":{"title":"Custom Parameter Description","description":"A detailed description of the parameter, which appears when requesting help for the command (e.g. \\"rush --help my-command\\").","type":"string"},"associatedCommands":{"title":"Associated Commands","description":"A list of custom commands and/or built-in Rush commands that this parameter may be used with","type":"array","items":{"type":"string"}},"associatedPhases":{"title":"Associated Phases","description":"A list of the names of the phases that this command-line parameter should be provided to.","type":"array","items":{"type":"string"}},"required":{"title":"Required","description":"If true, then this parameter must be included on the command line","type":"boolean"}}},"flagParameter":{"title":"Flag Parameter","description":"A custom command-line parameter whose presence acts as an on/off switch","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"properties":{"parameterKind":{"enum":["flag"]}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"}}}]},"stringParameter":{"title":"String Parameter","description":"A custom command-line parameter whose value is interpreted as a string","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["argumentName"],"properties":{"parameterKind":{"enum":["string"]},"argumentName":{"title":"Argument Name","description":"The name of the argument for this parameter.","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"argumentName":{"$ref":"#/definitions/anything"}}}]},"choiceParameter":{"title":"Choice Parameter","description":"A custom command-line parameter whose argument must be chosen from a list of allowable alternatives","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["alternatives"],"properties":{"parameterKind":{"enum":["choice"]},"alternatives":{"title":"Alternatives","description":"A list of alternative argument values that can be chosen for this parameter.","type":"array","minItems":1,"items":{"type":"object","additionalProperties":false,"required":["name","description"],"properties":{"name":{"title":"Name of Alternative","description":"A token that is one of the alternatives that can be used with the choice parameter, e.g. \\"vanilla\\" in \\"--flavor vanilla\\"","type":"string"},"description":{"title":"Description of Alternative","description":"A detailed description for the alternative that will be shown in the command-line help.","type":"string"}}}},"defaultValue":{"title":"Default Value","description":"If the parameter is omitted from the command line, this value will be inserted by default","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"alternatives":{"$ref":"#/definitions/anything"},"defaultValue":{"$ref":"#/definitions/anything"}}}]},"integerParameter":{"title":"Integer Parameter","description":"A custom command-line parameter whose value is interpreted as a integer","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["argumentName"],"properties":{"parameterKind":{"enum":["integer"]},"argumentName":{"title":"Argument Name","description":"The name of the argument for this parameter.","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"argumentName":{"$ref":"#/definitions/anything"}}}]},"stringListParameter":{"title":"String List Parameter","description":"A custom command-line parameter whose value is interpreted as a list of string","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["argumentName"],"properties":{"parameterKind":{"enum":["stringList"]},"argumentName":{"title":"Argument Name","description":"The name of the argument for this parameter.","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"argumentName":{"$ref":"#/definitions/anything"}}}]},"integerListParameter":{"title":"Integer List Parameter","description":"A custom command-line parameter whose value is interpreted as a list of integer","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["argumentName"],"properties":{"parameterKind":{"enum":["integerList"]},"argumentName":{"title":"Argument Name","description":"The name of the argument for this parameter.","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"argumentName":{"$ref":"#/definitions/anything"}}}]},"choiceListParameter":{"title":"Choice List Parameter","description":"A custom command-line parameter whose argument must be chosen from a list of allowable alternatives, value is interpreted as a list of choice","type":"object","allOf":[{"$ref":"#/definitions/baseParameter"},{"type":"object","additionalProperties":true,"required":["alternatives"],"properties":{"parameterKind":{"enum":["choiceList"]},"alternatives":{"title":"Alternatives","description":"A list of alternative argument values that can be chosen for this parameter.","type":"array","minItems":1,"items":{"type":"object","additionalProperties":false,"required":["name","description"],"properties":{"name":{"title":"Name of Alternative","description":"A token that is one of the alternatives that can be used with the choice parameter, e.g. \\"vanilla\\" in \\"--flavor vanilla\\"","type":"string"},"description":{"title":"Description of Alternative","description":"A detailed description for the alternative that will be shown in the command-line help.","type":"string"}}}},"defaultValue":{"title":"Default Value","description":"If the parameter is omitted from the command line, this value will be inserted by default","type":"string"}}},{"type":"object","additionalProperties":false,"properties":{"parameterKind":{"$ref":"#/definitions/anything"},"longName":{"$ref":"#/definitions/anything"},"shortName":{"$ref":"#/definitions/anything"},"description":{"$ref":"#/definitions/anything"},"associatedCommands":{"$ref":"#/definitions/anything"},"associatedPhases":{"$ref":"#/definitions/anything"},"required":{"$ref":"#/definitions/anything"},"alternatives":{"$ref":"#/definitions/anything"},"defaultValue":{"$ref":"#/definitions/anything"}}}]}},"type":"object","additionalProperties":false,"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"commands":{"title":"Custom Commands","description":"A list of custom commands that affect all projects in the repository.  These commands are invoked from the Rush command line.","type":"array","items":{"type":"object","oneOf":[{"$ref":"#/definitions/bulkCommand"},{"$ref":"#/definitions/globalCommand"},{"$ref":"#/definitions/phasedCommand"}]}},"phases":{"title":"Phases","description":"A list of phases that are associated with phased commands.","type":"array","items":{"$ref":"#/definitions/phase"}},"parameters":{"title":"Custom Parameters","description":"A list of custom command-line parameters that can be associated with custom commands and Rush\'s built-in commands.","type":"array","items":{"type":"object","oneOf":[{"$ref":"#/definitions/flagParameter"},{"$ref":"#/definitions/choiceParameter"},{"$ref":"#/definitions/stringParameter"},{"$ref":"#/definitions/integerParameter"},{"$ref":"#/definitions/stringListParameter"},{"$ref":"#/definitions/integerListParameter"},{"$ref":"#/definitions/choiceListParameter"}]}}}}');

/***/ }),

/***/ 355174:
/*!********************************************************!*\
  !*** ./lib-esnext/schemas/common-versions.schema.json ***!
  \********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush common-versions.json config file","description":"For use with the Rush tool, this file manages dependency versions that affect all projects in the repo. See http://rushjs.io for details.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"preferredVersions":{"description":"A table that specifies a \\"preferred version\\" for a given NPM package.  This feature is typically used to hold back an indirect dependency to a specific older version, or to reduce duplication of indirect dependencies. The \\"preferredVersions\\" value can be any SemVer range specifier (e.g. \\"~1.2.3\\").  Rush injects these values into the \\"dependencies\\" field of the top-level common/temp/package.json, which influences how the package manager will calculate versions.  The specific effect depends on your package manager.  Generally it will have no effect on an incompatible or already constrained SemVer range.  If you are using PNPM, similar effects can be achieved using the pnpmfile.js hook.  See the Rush documentation for more details.","type":"object","additionalProperties":{"type":"string"}},"implicitlyPreferredVersions":{"description":"When set to true, for all projects in the repo, all dependencies will be automatically added as preferredVersions, except in cases where different projects specify different version ranges for a given dependency.  For older package managers, this tended to reduce duplication of indirect dependencies.  However, it can sometimes cause trouble for indirect dependencies with incompatible peerDependencies ranges.","type":"boolean"},"allowedAlternativeVersions":{"description":"The \\"rush check\\" command can be used to enforce that every project in the repo must specify the same SemVer range for a given dependency.  However, sometimes exceptions are needed.  The allowedAlternativeVersions table allows you to list other SemVer ranges that will be accepted by \\"rush check\\" for a given dependency. Note that the normal version range (as inferred by looking at all projects in the repo) should NOT be included in this list.","type":"object","additionalProperties":{"type":"array","items":{"type":"string"}}}},"additionalProperties":false}');

/***/ }),

/***/ 334875:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/credentials.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Cache for credentials used with the Rush tool.","description":"For use with the Rush tool, this file acts as a cache for the credentials. See http://rushjs.io for details.","type":"object","required":["version","cacheEntries"],"properties":{"version":{"type":"string"},"cacheEntries":{"type":"object","patternProperties":{".+":{"type":"object","required":["expires","credential"],"properties":{"expires":{"type":"number"},"credential":{"type":"string"},"credentialMetadata":{"type":"object"}}}}}}}');

/***/ }),

/***/ 501107:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/custom-tips.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush custom-tips.json config file","description":"The config file for adding tips to specific messages.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"customTips":{"type":"array","items":{"type":"object","required":["tipId","message"],"additionalProperties":false,"properties":{"tipId":{"type":"string","description":"An identifier indicating a message that may be printed by Rush.  If that message is printed, then this custom tip will be shown.  Consult the Rush documentation for the current list of possible identifiers.","pattern":"^[A-Z0-9_]+$"},"message":{"type":"string","description":"The message text to be displayed for this tip."}}}}},"additionalProperties":false}');

/***/ }),

/***/ 173533:
/*!********************************************************!*\
  !*** ./lib-esnext/schemas/deploy-scenario.schema.json ***!
  \********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush config file that defines a deployment scenario","description":"This configuration file defines a deployment scenario for use with the \\"rush deploy\\" command. The default scenario file path is \\"deploy.json\\"; additional files use the naming pattern \\"deploy-<scenario-name>.json\\". For full documentation, please see https://rushjs.io","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"deploymentProjectNames":{"description":"The \\"rush deploy\\" command prepares a deployment folder, starting from the main project and collecting all of its dependencies (both NPM packages and other Rush projects).  The main project is specified using the \\"--project\\" parameter.  The \\"deploymentProjectNames\\" setting lists the allowable choices for the \\"--project\\" parameter; this documents the intended deployments for your monorepo and helps validate that \\"rush deploy\\" is invoked correctly.  If there is only one item in the \\"deploymentProjectNames\\" array, then \\"--project\\" can be omitted.  The names should be complete package names as declared in rush.json.\\n\\nIf the main project should include other unrelated Rush projects, add it to the \\"projectSettings\\" section, and then specify those projects in the \\"additionalProjectsToInclude\\" list.","type":"array","items":{"type":"string","minItems":1}},"includeDevDependencies":{"description":"When deploying a local Rush project, the package.json \\"devDependencies\\" are normally excluded. If you want to include them, set \\"includeDevDependencies\\" to true. The default value is false.","type":"boolean"},"includeNpmIgnoreFiles":{"description":"When deploying a local Rush project, normally the .npmignore filter is applied so that Rush only copies files that would be packaged by \\"npm pack\\".  Setting \\"includeNpmIgnoreFiles\\" to true will disable this filtering so that all files are copied (with a few trivial exceptions such as the \\"node_modules\\" folder). The default value is false.","type":"boolean"},"omitPnpmWorkaroundLinks":{"description":"To improve backwards compatibility with legacy packages, the PNPM package manager installs extra links in the node_modules folder that enable packages to import undeclared dependencies.  In some cases this workaround may significantly increase the installation footprint or cause other problems.  If your deployment does not require this workaround, you can set \\"omitPnpmWorkaroundLinks\\" to true to avoid creating the extra links.  The default value is false.","type":"boolean"},"linkCreation":{"description":"Specify how links (symbolic links, hard links, and/or NTFS junctions) will be created in the deployed folder:\\n\\"default\\": Create the links while copying the files; this is the default behavior.\\n\\"script\\": A Node.js script called \\"create-links.js\\" will be written.  When executed, this script will create the links described in the \\"deploy-metadata.json\\" output file.\\n\\"none\\": Do nothing; some other tool may create the links later.","type":"string","enum":["default","script","none"]},"folderToCopy":{"description":"If this path is specified, then after \\"rush deploy\\", recursively copy the files from this folder to the deployment target folder (common/deploy). This can be used to provide additional configuration files or scripts needed by the server when deploying. The path is resolved relative to the repository root.","type":"string"},"projectSettings":{"description":"Customize how Rush projects are processed during deployment.","type":"array","items":{"type":"object","properties":{"projectName":{"description":"The full package name of the project, which must be declared in rush.json.","type":"string"},"additionalProjectsToInclude":{"description":"A list of additional local Rush projects to be deployed with this project (beyond the package.json dependencies).  Specify full package names, which must be declared in rush.json.","type":"array","items":{"type":"string"}},"additionalDependenciesToInclude":{"description":"When deploying a project, the included dependencies are normally determined automatically based on package.json fields such as \'dependencies\', \'peerDependencies\', and \'optionalDependencies\', subject to other deployment settings such as \'includeDevDependencies\'. However, in cases where that information is not accurate, you can use \'additionalDependenciesToInclude\' to add more packages to the list.","type":"array","items":{"type":"string"}},"dependenciesToExclude":{"description":"This setting prevents specific dependencies from being deployed.  It only filters dependencies that are explicitly declared in package.json for this project.  It does not affect dependencies added via \'additionalProjectsToInclude\' or \'additionalDependenciesToInclude\', nor does it affect indirect dependencies.","type":"array","items":{"type":"string"}},"patternsToInclude":{"description":"A list of glob patterns to include when extracting this project. If a path is matched by both \\"patternsToInclude\\" and \\"patternsToExclude\\", the path will be excluded. If undefined, all paths will be included.","type":"array","items":{"type":"string"}},"patternsToExclude":{"description":"A list of glob patterns to exclude when extracting this project. If a path is matched by both \\"patternsToInclude\\" and \\"patternsToExclude\\", the path will be excluded. If undefined, no paths will be excluded.","type":"array","items":{"type":"string"}}},"required":["projectName"],"additionalProperties":false}},"dependencySettings":{"description":"Customize how third party dependencies are processed during deployment.","type":"array","items":{"type":"object","properties":{"dependencyName":{"description":"The full package name of third party dependency","type":"string"},"dependencyVersionRange":{"description":"The semantic version range of third party dependency","type":"string"},"patternsToInclude":{"description":"A list of glob patterns to include when extracting the dependency specified in this object. If a path is matched by both \\"patternsToInclude\\" and \\"patternsToExclude\\", the path will be excluded. If undefined, all paths will be included.","type":"array","items":{"type":"string"}},"patternsToExclude":{"description":"A list of glob patterns to include when extracting the dependency specified in this object. If a path is matched by both \\"patternsToInclude\\" and \\"patternsToExclude\\", the path will be excluded. If undefined, no paths will be excluded.","type":"array","items":{"type":"string"}}},"required":["dependencyName","dependencyVersionRange"],"additionalProperties":false}}},"required":["deploymentProjectNames"],"additionalProperties":false}');

/***/ }),

/***/ 329717:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/experiments.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush experiments.json config file","description":"For use with the Rush tool, this file allows repo maintainers to enable and disable experimental Rush features.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"usePnpmFrozenLockfileForRushInstall":{"description":"By default, \'rush install\' passes --no-prefer-frozen-lockfile to \'pnpm install\'. Set this option to true to pass \'--frozen-lockfile\' instead.","type":"boolean"},"usePnpmPreferFrozenLockfileForRushUpdate":{"description":"By default, \'rush update\' passes --no-prefer-frozen-lockfile to \'pnpm install\'. Set this option to true to pass \'--prefer-frozen-lockfile\' instead.","type":"boolean"},"usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate":{"description":"By default, \'rush update\' runs as a single operation. Set this option to true to instead update the lockfile with `--lockfile-only`, then perform a `--frozen-lockfile` install. Necessary when using the `afterAllResolved` hook in .pnpmfile.cjs.","type":"boolean"},"omitImportersFromPreventManualShrinkwrapChanges":{"description":"If using the \'preventManualShrinkwrapChanges\' option, only prevent manual changes to the total set of external dependencies referenced by the repository, not which projects reference which dependencies. This offers a balance between lockfile integrity and merge conflicts.","type":"boolean"},"noChmodFieldInTarHeaderNormalization":{"description":"If true, the chmod field in temporary project tar headers will not be normalized. This normalization can help ensure consistent tarball integrity across platforms.","type":"boolean"},"buildCacheWithAllowWarningsInSuccessfulBuild":{"description":"If true, build caching will respect the allowWarningsInSuccessfulBuild flag and cache builds with warnings. This will not replay warnings from the cached build.","type":"boolean"},"phasedCommands":{"description":"If true, the phased commands feature is enabled. To use this feature, create a \\"phased\\" command in common/config/rush/command-line.json.","type":"boolean"},"cleanInstallAfterNpmrcChanges":{"description":"If true, perform a clean install after when running `rush install` or `rush update` if the `.npmrc` file has changed since the last install.","type":"boolean"},"printEventHooksOutputToConsole":{"description":"If true, print the outputs of shell commands defined in event hooks to the console.","type":"boolean"},"forbidPhantomResolvableNodeModulesFolders":{"description":"If true, Rush will not allow node_modules in the repo folder or in parent folders.","type":"boolean"}},"additionalProperties":false}');

/***/ }),

/***/ 38317:
/*!****************************************************!*\
  !*** ./lib-esnext/schemas/pnpm-config.schema.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Pnpm configuration","description":"This configuration file provides settings specific to the PNPM package manager.","type":"object","additionalProperties":false,"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"useWorkspaces":{"description":"If true, then `rush install` and `rush update` will use the PNPM workspaces feature to perform the install, instead of the old model where Rush generated the symlinks for each projects\'s node_modules folder. This option is strongly recommended. The default value is false.","type":"boolean"},"strictPeerDependencies":{"description":"If true, then Rush will add the `--strict-peer-dependencies` command-line parameter when invoking PNPM. This causes `rush update` to fail if there are unsatisfied peer dependencies, which is an invalid state that can cause build failures or incompatible dependency versions. (For historical reasons, JavaScript package managers generally do not treat this invalid state as an error.) This is done via the \\"--strict-peer-dependencies\\" flag in PNPM version < 7.0.0 and via the \\"--no-strict-peer-dependencies\\" flag in PNPM >= 7.0.0. The default value is false.","type":"boolean"},"pnpmStore":{"description":"Specifies the location of the PNPM store.  There are two possible values:\\n\\n\\"local\\" - use the \\"pnpm-store\\" folder in the current configured temp folder: \\"common/temp/pnpm-store\\" by default.\\n\\"global\\" - use PNPM\'s global store, which has the benefit of being shared across multiple repo folders, but the disadvantage of less isolation for builds (e.g. bugs or incompatibilities when two repos use different releases of PNPM)\\n\\nIn both cases, the store path can be overridden by the environment variable RUSH_PNPM_STORE_PATH.\\n\\nThe default value is \\"local\\".","type":"string","enum":["local","global"]},"environmentVariables":{"description":"Environment variables for PNPM invocation","type":"object","additionalProperties":{"type":"object","properties":{"value":{"type":"string"},"override":{"type":"boolean"}},"additionalProperties":false}},"preventManualShrinkwrapChanges":{"description":"If true, then \\"rush install\\" will report an error if manual modifications were made to the PNPM shrinkwrap file without running `rush update` afterwards. To temporarily disable this validation when invoking \\"rush install\\", use the \\"--bypassPolicy\\" command-line parameter. The default value is false.","type":"boolean"},"globalOverrides":{"description":"The \\"globalOverrides\\" setting provides a simple mechanism for overriding version selections for all dependencies of all projects in the monorepo workspace. The settings are copied into the `pnpm.overrides` field of the `common/temp/package.json` file that is generated by Rush during installation.\\n\\nOrder of precedence: `.pnpmfile.cjs` has the highest precedence, followed by `unsupportedPackageJsonSettings`, `globalPeerDependencyRules`, `globalPackageExtensions`, and `globalOverrides` has lowest precedence.\\n\\nPNPM documentation: https://pnpm.io/package_json#pnpmoverrides","type":"object","additionalProperties":{"description":"You may specify the package the overridden dependency belongs to by separating the package selector from the dependency selector with a \\">\\", for example qar@1>zoo will only override the zoo dependency of qar@1, not for any other dependencies.","type":"string"}},"globalPeerDependencyRules":{"description":"The `globalPeerDependencyRules` setting provides various settings for suppressing validation errors that are reported during installation with `strictPeerDependencies=true`. The settings are copied into the `pnpm.peerDependencyRules` field of the `common/temp/package.json` file that is generated by Rush during installation.\\n\\nOrder of precedence: `.pnpmfile.cjs` has the highest precedence, followed by `unsupportedPackageJsonSettings`, `globalPeerDependencyRules`, `globalPackageExtensions`, and `globalOverrides` has lowest precedence.\\n\\nhttps://pnpm.io/package_json#pnpmpeerdependencyrules","type":"object","additionalProperties":false,"properties":{"ignoreMissing":{"description":"pnpm will not print warnings about missing peer dependencies from this list.","type":"array","items":{"type":"string"}},"allowedVersions":{"description":"Unmet peer dependency warnings will not be printed for peer dependencies of the specified range.","type":"object","additionalProperties":{"type":"string"}},"allowAny":{"description":"\\"allowAny\\" is an array of package name patterns, any peer dependency matching the pattern will be resolved from any version, regardless of the range specified in \\"peerDependencies\\"","type":"array","items":{"type":"string"}}}},"globalPackageExtensions":{"description":"This fields offer a way to extend the existing package definitions with additional information.","type":"object","additionalProperties":{"description":"Specify the extension to a package","type":"object","additionalProperties":false,"properties":{"dependencies":{"type":"object","additionalProperties":{"description":"Specify the version of the dependency","type":"string"}},"optionalDependencies":{"type":"object","additionalProperties":{"description":"Specify the version of the optionalDependency","type":"string"}},"peerDependencies":{"type":"object","additionalProperties":{"description":"Specify the version of the peerDependency","type":"string"}},"peerDependenciesMeta":{"description":"Specify the peerDependenciesMeta","type":"object","additionalProperties":{"type":"object","properties":{"optional":{"type":"boolean"}}}}}}},"globalNeverBuiltDependencies":{"description":"This field allows to ignore the builds of specific dependencies. The \\"preinstall\\", \\"install\\", and \\"postinstall\\" scripts of the listed packages will not be executed during installation.","type":"array","items":{"description":"Specify package name of the dependency","type":"string"}},"globalAllowedDeprecatedVersions":{"description":"The `globalAllowedDeprecatedVersions` setting suppresses installation warnings for package versions that the NPM registry reports as being deprecated. This is useful if the deprecated package is an indirect dependency of an external package that has not released a fix. The settings are copied into the `pnpm.allowedDeprecatedVersions` field of the `common/temp/package.json` file that is generated by Rush during installation.\\n\\nPNPM documentation: https://pnpm.io/package_json#pnpmalloweddeprecatedversions","type":"object","additionalProperties":{"type":"string"}},"globalPatchedDependencies":{"description":"(THIS FIELD IS MACHINE GENERATED)  The \\"globalPatchedDependencies\\" field is updated automatically by the `rush-pnpm patch-commit` command.  It is a dictionary, where the key is an NPM package name and exact version, and the value is a relative path to the associated patch file.\\n\\nPNPM documentation: https://pnpm.io/package_json#pnpmpatcheddependencies","type":"object","additionalProperties":{"type":"string"}},"unsupportedPackageJsonSettings":{"description":"(USE AT YOUR OWN RISK) This is a free-form property bag that will be copied into the `common/temp/package.json` file that is generated by Rush during installation. This provides a way to experiment with new PNPM features.  These settings will override any other Rush configuration associated with a given JSON field except for `.pnpmfile.cjs`.","type":"object"},"resolutionMode":{"description":"This option overrides the resolution-mode in PNPM. Use it if you want to change the default resolution behavior when installing dependencies. Defaults to \\"highest\\".\\n\\nPNPM documentation: https://pnpm.io/npmrc#resolution-mode.","type":"string","enum":["highest","time-based","lowest-direct"]}}}');

/***/ }),

/***/ 81360:
/*!***************************************************!*\
  !*** ./lib-esnext/schemas/repo-state.schema.json ***!
  \***************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush repo-state.json file","description":"For use with the Rush tool, this file tracks the state of various features in the Rush repo. See http://rushjs.io for details.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"pnpmShrinkwrapHash":{"description":"A hash of the contents of the PNPM shrinkwrap file for the repository. This hash is used to determine whether or not the shrinkwrap has been modified prior to install.","type":"string"},"preferredVersionsHash":{"description":"A hash of \\"preferred versions\\" for the repository. This hash is used to determine whether or not preferred versions have been modified prior to install.","type":"string"}},"additionalProperties":false}');

/***/ }),

/***/ 564949:
/*!*************************************************************!*\
  !*** ./lib-esnext/schemas/rush-plugin-manifest.schema.json ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema","title":"Rush plugin package manifest","description":"This file declares what kind of plugins this package provided.","type":"object","additionalProperties":false,"required":["plugins"],"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"plugins":{"type":"array","items":{"type":"object","required":["pluginName","description"],"additionalProperties":false,"properties":{"pluginName":{"type":"string"},"description":{"type":"string"},"entryPoint":{"description":"Specifies entry point path. This path is resolved relative to the package folder.","type":"string"},"optionsSchema":{"description":"Specifies options schema file path. This path is resolved relative to the package folder.","type":"string"},"associatedCommands":{"description":"Specifies associated commands with this plugin, plugin will be only installed when an associated command runs.","type":"array","items":{"type":"string"}},"commandLineJsonFilePath":{"description":"Specifies a command line config file path. The path is resolved relative to package folder. It defines custom command line commands, mostly same as command-line.json in Rush","type":"string"}}}}}}');

/***/ }),

/***/ 328689:
/*!*****************************************************!*\
  !*** ./lib-esnext/schemas/rush-plugins.schema.json ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema","title":"Rush rush-plugins.json config file","description":"This file defines plugins used by Rush","type":"object","required":["plugins"],"additionalProperties":false,"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"plugins":{"description":"A list of rush plugin definition.","type":"array","items":{"type":"object","required":["packageName","pluginName","autoinstallerName"],"additionalProperties":false,"properties":{"packageName":{"description":"The NPM package name of the rush plugin.","type":"string"},"pluginName":{"description":"The plugin name provided by rush plugin package.","type":"string"},"autoinstallerName":{"description":"Specifies an autoinstaller name where the rush plugin package is installed.","type":"string"}}}}}}');

/***/ }),

/***/ 262256:
/*!*****************************************************!*\
  !*** ./lib-esnext/schemas/rush-project.schema.json ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Configuration for Rush\'s build cache.","description":"For use with the Rush tool, this file provides per-project configuration options. See http://rushjs.io for details.","type":"object","additionalProperties":false,"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"extends":{"description":"Optionally specifies another JSON config file that this file extends from. This provides a way for standard settings to be shared across multiple projects.","type":"string"},"incrementalBuildIgnoredGlobs":{"type":"array","description":"The incremental analyzer can skip Rush commands for projects whose input files have not changed since the last build. Normally, every Git-tracked file under the project folder is assumed to be an input. Use \\"incrementalBuildIgnoredGlobs\\" to ignore specific files, specified as globs relative to the project folder.  The glob syntax is based on the .gitignore file format.","items":{"type":"string"}},"disableBuildCacheForProject":{"description":"Disable caching for this project. The project will never be restored from cache. This may be useful if this project affects state outside of its folder.","type":"boolean"},"operationSettings":{"type":"array","description":"Options for individual commands and phases.","items":{"type":"object","additionalProperties":false,"required":["operationName"],"properties":{"operationName":{"type":"string","description":"The name of the operation. This should be a key in the \\"package.json\\" file\'s \\"scripts\\" section."},"outputFolderNames":{"type":"array","description":"Specify the folders where this operation writes its output files. If enabled, the Rush build cache will restore these folders from the cache. The strings are folder names under the project root folder. These folders should not be tracked by Git. They must not contain symlinks.","items":{"type":"string"},"uniqueItems":true},"dependsOnEnvVars":{"type":"array","description":"Specify a list of environment variables that affect the output of this operation. If provided, the values of these variables will become part of the hash when reading and writing from cache.","items":{"type":"string"},"uniqueItems":true},"dependsOnAdditionalFiles":{"type":"array","description":"Specify a list of glob (minimatch) paths (absolute or relative) pointing to files (within or outside the .git repository) that affect the output of this operation. If provided, the hash values of these files will become part of the final hash when reading and writing from cache.","items":{"type":"string"},"uniqueItems":true},"disableBuildCacheForOperation":{"description":"Disable caching for this operation. The operation will never be restored from cache. This may be useful if this operation affects state outside of its folder.","type":"boolean"}}}}}}');

/***/ }),

/***/ 33477:
/*!***********************************************************!*\
  !*** ./lib-esnext/schemas/rush-user-settings.schema.json ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush per-user settings file","description":"For use with the Rush tool, this file stores user-specific settings options. See http://rushjs.io for details.","type":"object","properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"buildCacheFolder":{"type":"string","description":"If provided, store build cache in the specified folder. Must be an absolute path."}},"additionalProperties":false}');

/***/ }),

/***/ 35475:
/*!*********************************************!*\
  !*** ./lib-esnext/schemas/rush.schema.json ***!
  \*********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush main config File","description":"The main configuration file for the Rush multi-project build tool. See http://rushjs.io for details.","type":"object","definitions":{"environmentVariables":{"description":"Environment variables for the package manager","type":"object","additionalProperties":{"type":"object","properties":{"value":{"type":"string"},"override":{"type":"boolean"}},"additionalProperties":false}}},"properties":{"$schema":{"description":"Part of the JSON Schema standard, this optional keyword declares the URL of the schema that the file conforms to. Editors may download the schema and use it to perform syntax highlighting.","type":"string"},"npmVersion":{"description":"If specified, selects NPM as the package manager and specifies the deterministic version to be installed by Rush.","type":"string","pattern":"^[0-9]+\\\\.[0-9]+\\\\.[0-9a-zA-Z.+\\\\-]+$"},"pnpmVersion":{"description":"If specified, selects PNPM as the package manager and specifies the deterministic version to be installed by Rush.","type":"string","pattern":"^[0-9]+\\\\.[0-9]+\\\\.[0-9a-zA-Z.+\\\\-]+$"},"yarnVersion":{"description":"If specified, selects Yarn as the package manager and specifies the deterministic version to be installed by Rush.","type":"string","pattern":"^[0-9]+\\\\.[0-9]+\\\\.[0-9a-zA-Z.+\\\\-]+$"},"rushVersion":{"description":"The version of the Rush tool that will be used to build this repository.","type":"string","pattern":"^[0-9]+\\\\.[0-9]+\\\\.[0-9a-zA-Z.+\\\\-]+$"},"nodeSupportedVersionRange":{"description":"A node-semver expression (e.g. \\">=1.2.3 <2.0.0\\", see https://github.com/npm/node-semver) indicating which versions of Node.js can safely be used to build this repository.  If omitted, no validation is performed.","type":"string"},"nodeSupportedVersionInstructions":{"description":"If specified, when a rush command fails due to an unsupported node version, this additional instructional message is printed below the failure message.","type":"string"},"suppressNodeLtsWarning":{"description":"Rush normally prints a warning if it detects a pre-LTS Node.js version. If you are testing pre-LTS versions in preparation for supporting the first LTS version, you can use this setting to disable Rush\'s warning.","type":"boolean"},"projectFolderMinDepth":{"description":"The minimum folder depth for the projectFolder field.  The default value is 1, i.e. no slashes in the path name.","type":"number"},"ensureConsistentVersions":{"description":"If true, consistent version specifiers for dependencies will be enforced (i.e. \\"rush check\\" is run before some commands).","type":"boolean"},"hotfixChangeEnabled":{"description":"Allows creation of hotfix changes. This feature is experimental so it is disabled by default. If this is set, \\"rush change\\" only allows a \\"hotfix\\" change type to be specified. This change type will be used when publishing subsequent changes from the monorepo.","type":"boolean"},"npmOptions":{"description":"Options that are only used when the NPM package manager is selected.","type":"object","properties":{"environmentVariables":{"$ref":"#/definitions/environmentVariables"}},"additionalProperties":false},"pnpmOptions":{"description":"Options that are only used when the PNPM pacakge manager is selected.","type":"object","properties":{"pnpmStore":{"description":"Specifies the location of the PNPM store.  There are two possible values:\\n\\n\\"local\\" - use the \\"pnpm-store\\" folder in the current configured temp folder: \\"common/temp/pnpm-store\\" by default.\\n\\"global\\" - use PNPM\'s global store, which has the benefit of being shared across multiple repo folders, but the disadvantage of less isolation for builds (e.g. bugs or incompatibilities when two repos use different releases of PNPM)\\n\\nIn all cases, the store path will be overridden by the environment variable RUSH_PNPM_STORE_PATH.\\n\\nThe default value is \\"local\\".","type":"string","enum":["local","global"]},"strictPeerDependencies":{"description":"If true, then the installation will fail if there is a missing or invalid peer dependency in the tree, which is an invalid state that can cause build failures or incompatible dependency versions. (For historical reasons, JavaScript package managers generally do not treat this invalid state as an error.) This is done via the \\"--strict-peer-dependencies\\" flag in PNPM version < 7.0.0 and via the \\"--no-strict-peer-dependencies\\" flag in PNPM >= 7.0.0. The default value is false.","type":"boolean"},"resolutionStrategy":{"description":"(Deprecated) Configures the strategy used to select versions during installation.  This feature requires PNPM version 3.1 or newer.  It corresponds to the \\"--resolution-strategy\\" command-line option for PNPM.  Possible values are \\"fast\\" and \\"fewer-dependencies\\".  PNPM\'s default is \\"fast\\", but this may be incompatible with certain packages, for example the \\"@types\\" packages from DefinitelyTyped.  Rush\'s default is \\"fewer-dependencies\\", which causes PNPM to avoid installing a newer version if an already installed version can be reused; this is more similar to NPM\'s algorithm.","type":"string","enum":["fewer-dependencies","fast"]},"environmentVariables":{"$ref":"#/definitions/environmentVariables"},"preventManualShrinkwrapChanges":{"description":"If true, then \\"rush install\\" will report an error if manual modifications were made to the PNPM shrinkwrap file without running `rush update` afterwards. To temporarily disable this validation when invoking \\"rush install\\", use the \\"--bypassPolicy\\" command-line parameter. The default value is false.","type":"boolean"},"useWorkspaces":{"description":"If true, then Rush will use the workspaces feature to install and link packages when invoking PNPM. The default value is false.","type":"boolean"}},"additionalProperties":false},"yarnOptions":{"description":"Options that are only used when the Yarn pacakge manager is selected.","type":"object","properties":{"ignoreEngines":{"description":"If true, then Rush will add the \\"--ignore-engines\\" option when invoking Yarn. * This allows \\"rush install\\" to succeed if there are dependencies with engines defined in package.json which do not match the current environment. The default value is false.","type":"boolean"},"environmentVariables":{"$ref":"#/definitions/environmentVariables"}},"additionalProperties":false},"projectFolderMaxDepth":{"description":"The maximum folder depth for the projectFolder field.  The default value is 2, i.e. a single slash in the path name.","type":"number"},"allowMostlyStandardPackageNames":{"description":"Today the npmjs.com registry enforces fairly strict naming rules for packages, but in the early days there was no standard and hardly any enforcement.  A few large legacy projects are still using nonstandard package names, and private registries sometimes allow it.  Set \\"allowMostlyStandardPackageNames\\" to true to relax Rush\'s enforcement of package names.  This allows upper case letters and in the future may relax other rules, however we want to minimize these exceptions.  Many popular tools use certain punctuation characters as delimiters, based on the assumption that they will never appear in a package name; thus if we relax the rules too much it is likely to cause very confusing malfunctions. The default value is false.","type":"boolean"},"approvedPackagesPolicy":{"description":"Controls a package review workflow driven by the two config files \\"browser-approved-packages.json\\" and \\"nonbrowser-approved-packages.json\\"","type":"object","properties":{"reviewCategories":{"description":"A list of category names that can be applied to each project, and then referenced in \\"browser-approved-packages.json\\" and \\"nonbrowser-approved-packages.json\\"","type":"array","items":{"type":"string"}},"ignoredNpmScopes":{"description":"A list of NPM package scopes that will be excluded from review (e.g. \\"@types\\")","type":"array","items":{"type":"string","pattern":"^@"}}},"additionalProperties":false},"gitPolicy":{"description":"If the project is stored in a Git repository, additional settings related to Git","type":"object","properties":{"allowedEmailRegExps":{"description":"A list of regular expressions describing allowable e-mail patterns for Git commits.  They are case-insensitive anchored JavaScript RegExps.  Example: \\".*@example\\\\.com\\"","type":"array","items":{"type":"string"}},"sampleEmail":{"description":"An example valid e-mail address for \\"Mr. Example\\" that conforms to one of the allowedEmailRegExps.  Example: \\"mr-example@contoso\\\\.com\\"","type":"string"},"versionBumpCommitMessage":{"description":"The commit message to use when committing changes during \\"rush publish\\". Defaults to \\"Bump versions [skip ci]\\"","type":"string"},"changeLogUpdateCommitMessage":{"description":"The commit message to use when committing change log files \\"rush version\\". Defaults to \\"Update changelogs [skip ci]\\"","type":"string"},"changefilesCommitMessage":{"description":"The commit message to use when commiting change files made by \\"rush change\\". Defaults to \\"Rush change\\"","type":"string"},"tagSeparator":{"description":"The separator between package name and version in git tag. Defaults to \\"_\\"","type":"string"}},"additionalProperties":false},"variants":{"description":"Defines the list of installation variants for this repository. For more details about this feature, see this article: https://rushjs.io/pages/advanced/installation_variants/","type":"array","items":{"type":"object","properties":{"variantName":{"description":"The name of the variant. Maps to common/rush/variants/{name} under the repository root.","type":"string"},"description":{"description":"","type":"string"}},"required":["variantName","description"]}},"repository":{"description":"The repository location","type":"object","properties":{"url":{"type":"string","description":"The remote url of the repository. If a value is provided, \\"rush change\\" will use it to find the right remote to compare against."},"urls":{"description":"All allowed remote urls of the repository. If a value is provided, \\"rush change\\" will use one of these to find the right remote to compare against. Specifying multiple URLs is useful if a GitHub repository is renamed or for \\"<projectName>.visualstudio.com\\" vs \\"dev.azure.com/<projectName>\\" URLs.","type":"array","items":{"type":"string"}},"defaultBranch":{"description":"The default branch name. This tells \\"rush change\\" which remote branch to compare against. The default value is \\"main\\"","type":"string"},"defaultRemote":{"description":"The default remote. This tells \\"rush change\\" which remote to compare against if the remote URL is not set or if a remote matching the provided remote URL is not found.","type":"string"}},"additionalProperties":false},"telemetryEnabled":{"description":"Indicates whether telemetry data should be collected and stored in the Rush temp folder during Rush runs.","type":"boolean"},"allowedProjectTags":{"description":"This is an optional, but recommended, list of allowed tags that can be applied to Rush projects using the \\"tags\\" setting in this file.  This list is useful for preventing mistakes such as misspelling, and it also provides a centralized place to document your tags.  If \\"allowedProjectTags\\" list is not specified, then any valid tag is allowed.  A tag name must be one or more words separated by hyphens or slashes, where a word may contain lowercase ASCII letters, digits, \\".\\", and \\"@\\" characters.","type":"array","items":{"type":"string","pattern":"^[a-z0-9.@]+([-/][a-z0-9.@]+)*$"}},"projects":{"description":"A list of projects managed by this tool.","type":"array","items":{"type":"object","properties":{"packageName":{"description":"The NPM package name of the project.","type":"string"},"projectFolder":{"description":"The path to the project folder relative to the Rush config file.","type":"string"},"reviewCategory":{"description":"An optional category for usage in the \\"browser-approved-packages.json\\" and \\"nonbrowser-approved-packages.json\\" files.  Only strings from reviewCategories are allowed here.","type":"string"},"cyclicDependencyProjects":{"description":"(Deprecated) This field was renamed to \\"decoupledLocalDependencies\\".","type":"array","items":{"type":"string"}},"decoupledLocalDependencies":{"description":"A list of local projects that appear as devDependencies for this project, but cannot be locally linked because it would create a cyclic dependency; instead, the last published version will be installed in the Common folder.","type":"array","items":{"type":"string"}},"shouldPublish":{"description":"A flag indicating that changes to this project will be published to npm, which affects the Rush change and publish workflows.","type":"boolean"},"skipRushCheck":{"description":"If true, then this project will be ignored by the \\"rush check\\" command.  The default value is false.","type":"boolean"},"versionPolicyName":{"description":"An optional version policy associated with the project. Version policies are defined in \\"version-policies.json\\" file.","type":"string"},"publishFolder":{"description":"Facilitates postprocessing of a project\'s files prior to publishing. If specified, the \\"publishFolder\\" is the relative path to a subfolder of the project folder. The \\"rush publish\\" command will publish the subfolder instead of the project folder. The subfolder must contain its own package.json file, which is typically a build output.","type":"string"},"tags":{"description":"An optional set of custom tags that can be used to select this project. For example, adding \\"my-custom-tag\\" will allow this project to be selected by the command \\"rush list --only tag:my-custom-tag\\". The tag name must be one or more words separated by hyphens or slashes, where a word may contain lowercase ASCII letters, digits, \\".\\", and \\"@\\" characters.","type":"array","items":{"type":"string","pattern":"^[a-z0-9.@]+([-/][a-z0-9.@]+)*$"}}},"additionalProperties":false,"required":["packageName","projectFolder"]}},"eventHooks":{"description":"Hooks are customized script actions that Rush executes when specific events occur.","type":"object","properties":{"preRushInstall":{"description":"The list of scripts to run before the Rush installation starts.","type":"array","items":{"type":"string"}},"postRushInstall":{"description":"The list of scripts to run after the Rush installation finishes.","type":"array","items":{"type":"string"}},"preRushBuild":{"description":"The list of scripts to run before the Rush build command starts.","type":"array","items":{"type":"string"}},"postRushBuild":{"description":"The list of scripts to run after the Rush build command finishes.","type":"array","items":{"type":"string"}}},"additionalProperties":false}},"additionalProperties":false,"required":["rushVersion","projects"]}');

/***/ }),

/***/ 982478:
/*!*********************************************************!*\
  !*** ./lib-esnext/schemas/version-policies.schema.json ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-04/schema#","title":"Rush version-policies.json config file","description":"For use with the Rush tool, this file defines version policies. See http://rushjs.io for details.","type":"array","items":{"type":"object","allOf":[{"oneOf":[{"$ref":"#/definitions/lockStepVersion"},{"$ref":"#/definitions/individualVersion"}]},{"type":"object","properties":{"policyName":{"description":"The name of the version policy","type":"string"},"dependencies":{"type":"object","description":"Behavior when handling package dependencies during version bumps and publishing","properties":{"versionFormatForPublish":{"description":"The version to use for dependencies when publishing","type":"string","enum":["original","exact"]},"versionFormatForCommit":{"description":"The version to use for dependencies when committing to source","type":"string","enum":["original","wildcard"]}},"required":["versionFormatForPublish","versionFormatForCommit"],"additionalProperties":false}}}]},"definitions":{"any-value":{"type":["array","boolean","integer","number","object","string"],"items":{"$ref":"#/definitions/any-value"}},"lockStepVersion":{"type":"object","description":"Lockstep version policy","properties":{"policyName":{"$ref":"#/definitions/any-value"},"dependencies":{"$ref":"#/definitions/any-value"},"definitionName":{"description":"The name of version policy definition","type":"string","enum":["lockStepVersion"]},"version":{"description":"Current version for projects with lockStepVersion policy","type":"string","pattern":"^[0-9]+\\\\.[0-9]+\\\\.[0-9a-zA-Z.+\\\\-]+$"},"nextBump":{"description":"Type of next version bump","enum":["none","prerelease","minor","patch","major"]},"mainProject":{"description":"The main project for this version policy","type":"string"},"exemptFromRushChange":{"description":"If true, the version policy will not require changelog files.","type":"boolean"},"includeEmailInChangeFile":{"description":"If true, the generated changelog files will include the author\'s email address.","type":"boolean"}},"required":["policyName","definitionName","version"],"additionalProperties":false},"individualVersion":{"type":"object","description":"Lockstep version policy","properties":{"policyName":{"$ref":"#/definitions/any-value"},"dependencies":{"$ref":"#/definitions/any-value"},"definitionName":{"description":"The name of version policy definition","type":"string","enum":["individualVersion"]},"lockedMajor":{"description":"The locked major version","type":"number"},"exemptFromRushChange":{"description":"If true, the version policy will not require changelog files.","type":"boolean"},"includeEmailInChangeFile":{"description":"If true, the generated changelog files will include the author\'s email address.","type":"boolean"}},"required":["policyName","definitionName"],"additionalProperties":false}}}');

/***/ })

};
;
//# sourceMappingURL=commons.js.map