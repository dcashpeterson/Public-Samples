"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredAadTokenProvider = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var SPHttpBaseStrings_resx_1 = tslib_1.__importDefault(require("../../../SPHttpBaseStrings.resx"));
var AadConstants_1 = tslib_1.__importDefault(require("../../AadConstants"));
var AadFlights_1 = require("../../AadFlights");
var AadKillSwitches_1 = require("../../AadKillSwitches");
var ITokenProvider_1 = require("../../ITokenProvider");
/**
 * Class that extends on the Error class and adds an extra member variable
 * @internal
 */
var DetailedError = /** @class */ (function (_super) {
    tslib_1.__extends(DetailedError, _super);
    function DetailedError(errorMessage, code) {
        var _this = _super.call(this, errorMessage) || this;
        _this.code = code;
        return _this;
    }
    return DetailedError;
}(Error));
/**
 * This class allows a developer to obtain OAuth2 tokens from Azure AD.
 *
 * OAuth2 tokens are used to authenticate the user from the SharePoint page
 * to other services such as PowerBI, Sway, Exchange, Yammer, etc.
 *
 * @privateRemarks
 * AadTokenProvider is replacing the /_api.SP.OAuth.Token/Acquire endpoint
 * for authentication with ADAL.js. At some point in the near future, when Azure AD v2.0
 * can support the same scenarios as the original version, we will switch to MSAL.
 *
 * @public
 * @sealed
 */
var DeferredAadTokenProvider = /** @class */ (function () {
    /**
     * @internal
     */
    function DeferredAadTokenProvider(tokenAcquisitionEvent, beforeRedirectEvent, popupEvent, configuration, oboConfiguration, _oboFirstPartyTokenCallback, _oboThirdPartyTokenCallback) {
        this._oboFirstPartyTokenCallback = _oboFirstPartyTokenCallback;
        this._oboThirdPartyTokenCallback = _oboThirdPartyTokenCallback;
        sp_core_library_1.Validate.isNonemptyString(configuration.aadInstanceUrl, 'aadInstanceUrl');
        sp_core_library_1.Validate.isNonemptyString(configuration.aadTenantId, 'aadTenantId');
        sp_core_library_1.Validate.isNonemptyString(configuration.redirectUri, 'redirectUri');
        sp_core_library_1.Validate.isNonemptyString(configuration.servicePrincipalId, 'servicePrincipalId');
        this._defaultConfiguration = configuration;
        this._oboConfiguration = oboConfiguration;
        this._tokenAcquisitionEvent = tokenAcquisitionEvent;
        this.onBeforeRedirectEvent = beforeRedirectEvent;
        this.popupEvent = popupEvent;
        this._failedTokenRequests = new Map();
    }
    DeferredAadTokenProvider.prototype.getToken = function (resourceEndpoint, optionsOrUseCachedToken) {
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? optionsOrUseCachedToken
            : {
                useCachedToken: optionsOrUseCachedToken,
                authenticationScheme: ITokenProvider_1.IAuthenticationScheme.BEARER
            };
        if (this._defaultConfiguration.servicePrincipalId === sp_core_library_1.Guid.empty.toString()) {
            return Promise.reject(new Error(SPHttpBaseStrings_resx_1.default.servicePrincipalNotAvaliableError));
        }
        return this._getTokenInternal(resourceEndpoint, this._defaultConfiguration, options);
    };
    DeferredAadTokenProvider.prototype._getTokenData = function (resourceEndpoint, optionsOrUseCachedToken, skipLogging) {
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        if (skipLogging === void 0) { skipLogging = false; }
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? optionsOrUseCachedToken
            : {
                useCachedToken: optionsOrUseCachedToken,
                skipLoggingAndDisableRedirects: skipLogging,
                claims: undefined,
                authenticationScheme: ITokenProvider_1.IAuthenticationScheme.BEARER
            };
        if (this._defaultConfiguration.servicePrincipalId === sp_core_library_1.Guid.empty.toString()) {
            return Promise.reject(new Error(SPHttpBaseStrings_resx_1.default.servicePrincipalNotAvaliableError));
        }
        if (this._shouldUseMsalBrowserTokenProvider(this._defaultConfiguration)) {
            return this._getMsalBrowserTokenProvider(this._defaultConfiguration).then(function (tokenProvider) {
                return tokenProvider.getTokenData(resourceEndpoint, options);
            });
        }
        else if (this._shouldUseMsalTokenProvider(this._defaultConfiguration)) {
            return this._getMsalTokenProvider(this._defaultConfiguration).then(function (tokenProvider) {
                return tokenProvider.getTokenData(resourceEndpoint, options);
            });
        }
        else {
            var errorString = 'Getting token response not supported for the current token provider';
            throw new Error(errorString);
        }
    };
    DeferredAadTokenProvider.prototype._getTokenInternal = function (resourceEndpoint, configuration, optionsOrUseCachedToken) {
        var _this = this;
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? optionsOrUseCachedToken
            : {
                useCachedToken: optionsOrUseCachedToken,
                authenticationScheme: ITokenProvider_1.IAuthenticationScheme.BEARER
            };
        var acquireTokenQosMonitor = new sp_diagnostics_1._QosMonitor('AadTokenProvider.GetAppTokenTimePerf');
        if (!this._shouldTokenBeRequested(resourceEndpoint)) {
            acquireTokenQosMonitor.writeExpectedFailure('Token already requested and failed');
            if ((0, AadKillSwitches_1.isExtendedErrorObjectActivated)()) {
                throw Error('Token request previously failed');
            }
            else {
                throw new DetailedError('Token request previously failed', 'TokenRequestPreviouslyFailed');
            }
        }
        var getTokenPromise;
        var tokenProviderConfig = configuration || this._defaultConfiguration;
        if (this._shouldUseOboTokenExchange() && this._oboConfiguration) {
            // OBO Token Exchange is only supported for 3rd Parties. Using the default configuration will
            // prevent this code path from running for 1st party requests
            getTokenPromise = this._getOboTokenProvider(tokenProviderConfig, this._oboConfiguration, this._oboFirstPartyTokenCallback, this._oboThirdPartyTokenCallback).then(function (tokenProvider) { return _this._getToken(tokenProvider, resourceEndpoint, options); });
        }
        else if (this._shouldUseMsalBrowserTokenProvider(tokenProviderConfig)) {
            return this._getMsalBrowserTokenProvider(tokenProviderConfig).then(function (tokenProvider) {
                return _this._getToken(tokenProvider, resourceEndpoint, options);
            });
        }
        else if (this._shouldUseMsalTokenProvider(tokenProviderConfig)) {
            getTokenPromise = this._getMsalTokenProvider(tokenProviderConfig).then(function (tokenProvider) {
                return _this._getToken(tokenProvider, resourceEndpoint, options);
            });
        }
        else {
            getTokenPromise = this._getImplicitTokenProvider(tokenProviderConfig).then(function (tokenProvider) {
                return _this._getToken(tokenProvider, resourceEndpoint, options);
            });
        }
        return getTokenPromise
            .then(function (token) {
            var isInternal = tokenProviderConfig.servicePrincipalId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID;
            var extraData = {
                isInternal: isInternal
            };
            // We can only log the endpoint if first party to avoid privacy issues
            if (isInternal) {
                extraData.name = resourceEndpoint;
            }
            acquireTokenQosMonitor.writeSuccess(extraData);
            return token;
        })
            .catch(function (error) {
            if (!(0, AadKillSwitches_1.isAadTokenErrorLogKsActivated)()) {
                acquireTokenQosMonitor.writeUnexpectedFailure(/* tagNameSuffix */ undefined, error);
            }
            else {
                acquireTokenQosMonitor.writeUnexpectedFailure();
            }
            _this._addFailedRequest(resourceEndpoint);
            throw error;
        });
    };
    DeferredAadTokenProvider.prototype._addFailedRequest = function (resourceEndpoint) {
        if (!(0, AadKillSwitches_1.isSkipKnownErroneousResourcesActivated)()) {
            this._failedTokenRequests.set(resourceEndpoint, new Date(Date.now()));
        }
    };
    DeferredAadTokenProvider.prototype._shouldTokenBeRequested = function (resourceEndpoint) {
        if (!(0, AadKillSwitches_1.isSkipKnownErroneousResourcesActivated)()) {
            var previousFetchTime = this._failedTokenRequests.get(resourceEndpoint);
            if (previousFetchTime) {
                // 300000 is 5 minutes in milliseconds
                return Date.now() - previousFetchTime.getTime() > 300000;
            }
        }
        return true;
    };
    DeferredAadTokenProvider.prototype._getToken = function (tokenProvider, resourceEndpoint, options) {
        return tokenProvider.getToken(resourceEndpoint, options);
    };
    Object.defineProperty(DeferredAadTokenProvider.prototype, "tokenAcquisitionEvent", {
        /**
         * Notifies the developer when Token Acquisition requires user action.
         * @eventproperty
         */
        get: function () {
            return this._tokenAcquisitionEvent;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Check for determining if the MSAL API should be used in the current environment.
     * MSAL should be used when:
     *   1. AAD Session ID is a valid GUID.
     * In the case of invalid AAD Session IDs, this method will log the value.
     *
     * Note: If the AAD Session ID is missing, MSAL API can still be used, but the first attempt
     *       will result in an MSAL ClientAuthError or InteractionRequiredError.
     */
    DeferredAadTokenProvider.prototype._shouldUseMsalTokenProvider = function (configuration) {
        var isAadSessionIdValidGuid = !!sp_core_library_1.Guid.tryParse(configuration.aadSessionId);
        var shouldUseMsalTokenProvider = isAadSessionIdValidGuid || configuration.aadSessionId === '';
        if (!isAadSessionIdValidGuid) {
            var aadSessionIdQos = new sp_diagnostics_1._QosMonitor('DeferredAadTokenProvider._shouldUseMsalTokenProvider');
            var extraQosData = {
                aadSessionId: configuration.aadSessionId
            };
            if (shouldUseMsalTokenProvider) {
                configuration.aadSessionId = '';
            }
            aadSessionIdQos.writeUnexpectedFailure('isAadSessionIdValidGuid', undefined, extraQosData);
        }
        return shouldUseMsalTokenProvider;
    };
    /**
     * Given a token provider configuration, this method returns true if MsalBrowserTokenProvider should be
     * used. MsalBrowserTokenProvider should be used when:
     *   - A first party client ID is requesting a token.
     */
    DeferredAadTokenProvider.prototype._shouldUseMsalBrowserTokenProvider = function (configuration) {
        if (!(0, AadFlights_1.isMsalBrowserFlightEnabled)() &&
            !configuration.enableClaimChallenges &&
            !configuration.enableMetaOS) {
            return false;
        }
        var isFirstParty = this._isFirstParty(configuration.servicePrincipalId);
        return isFirstParty;
    };
    DeferredAadTokenProvider.prototype._getAdalAuthContextManager = function (configuration) {
        if (!this._authContextManager) {
            this._authContextManager = Promise.resolve().then(function () { return tslib_1.__importStar(require('../adalAuthContextManager/AdalAuthContextManager' /* webpackChunkName: 'adalauthcontext' */)); }).then(function (adalAuthContextManagerModule) { return new adalAuthContextManagerModule.AdalAuthContextManager(); });
        }
        return this._authContextManager;
    };
    DeferredAadTokenProvider.prototype._getMsalTokenProvider = function (configuration) {
        var _this = this;
        if ((0, AadFlights_1.isUseMsalCurrentChunkEnabled)()) {
            return Promise.resolve().then(function () { return tslib_1.__importStar(require('../msal/current/v1/MsalTokenProvider' /* webpackChunkName: 'msalImplicit' */)); }).then(function (msalTokenProviderModule) {
                if (_this._isFirstParty(configuration.servicePrincipalId)) {
                    if (!_this._firstPartyMsalTokenProvider) {
                        _this._firstPartyMsalTokenProvider = new msalTokenProviderModule.MsalTokenProvider(configuration);
                    }
                    return _this._firstPartyMsalTokenProvider;
                }
                else {
                    if (!_this._thirdPartyMsalTokenProvider) {
                        _this._thirdPartyMsalTokenProvider = new msalTokenProviderModule.MsalTokenProvider(configuration);
                    }
                    return _this._thirdPartyMsalTokenProvider;
                }
            });
        }
        else {
            return Promise.resolve().then(function () { return tslib_1.__importStar(require('../msalImplicit/MsalTokenProvider' /* webpackChunkName: 'msalImplicitLegacy' */)); }).then(function (msalTokenProviderModule) {
                if (_this._isFirstParty(configuration.servicePrincipalId)) {
                    if (!_this._firstPartyMsalTokenProvider) {
                        _this._firstPartyMsalTokenProvider = new msalTokenProviderModule.MsalTokenProvider(configuration);
                    }
                    return _this._firstPartyMsalTokenProvider;
                }
                else {
                    if (!_this._thirdPartyMsalTokenProvider) {
                        _this._thirdPartyMsalTokenProvider = new msalTokenProviderModule.MsalTokenProvider(configuration);
                    }
                    return _this._thirdPartyMsalTokenProvider;
                }
            });
        }
    };
    DeferredAadTokenProvider.prototype._getMsalBrowserTokenProvider = function (configuration) {
        var _this = this;
        if ((0, AadFlights_1.isMsalBrowserFirstPartyBuildFlightEnabled)() || configuration.enableMetaOS) {
            return Promise.resolve().then(function () { return tslib_1.__importStar(require('../msal/current/v2/MsalBrowserTokenProvider' /* webpackChunkName: 'msalBrowser' */)); }).then(function (msalBrowserTokenProviderModule) {
                if (!_this._firstPartyMsalBrowserTokenProvider) {
                    _this._firstPartyMsalBrowserTokenProvider =
                        new msalBrowserTokenProviderModule.MsalBrowserTokenProvider(configuration);
                }
                return _this._firstPartyMsalBrowserTokenProvider;
            });
        }
        else {
            return Promise.resolve().then(function () { return tslib_1.__importStar(require('../msalImplicit/msalBrowser/MsalBrowserTokenProvider' /* webpackChunkName: 'msalBrowserLegacy' */)); }).then(function (msalBrowserTokenProviderModule) {
                if (!_this._firstPartyMsalBrowserTokenProvider) {
                    _this._firstPartyMsalBrowserTokenProvider =
                        new msalBrowserTokenProviderModule.MsalBrowserTokenProvider(configuration);
                }
                return _this._firstPartyMsalBrowserTokenProvider;
            });
        }
    };
    DeferredAadTokenProvider.prototype._getImplicitTokenProvider = function (configuration) {
        var _this = this;
        return Promise.resolve().then(function () { return tslib_1.__importStar(require('../implicitTokenProvider/ImplicitFlowTokenProvider' /* webpackChunkName: 'spoImplicit' */)); }).then(function (implicitTokenProviderModule) {
            if (_this._isFirstParty(configuration.servicePrincipalId)) {
                if (!_this._firstPartyImplicitTokenProvider) {
                    _this._firstPartyImplicitTokenProvider = new implicitTokenProviderModule.ImplicitFlowTokenProvider(configuration);
                }
                return _this._firstPartyImplicitTokenProvider;
            }
            else {
                if (!_this._thirdPartyImplicitTokenProvider) {
                    _this._thirdPartyImplicitTokenProvider = new implicitTokenProviderModule.ImplicitFlowTokenProvider(configuration);
                }
                return _this._thirdPartyImplicitTokenProvider;
            }
        });
    };
    DeferredAadTokenProvider.prototype._getOboTokenProvider = function (configuration, oboConfiguration, oboFirstPartyTokenCallback, oboThirdPartyTokenCallback) {
        var _this = this;
        return this._getAdalAuthContextManager(configuration).then(function (adalAuthContextManager) {
            if (_this._isFirstParty(configuration.servicePrincipalId)) {
                if (!_this._firstPartyOboTokenProvider) {
                    _this._firstPartyOboTokenProvider = adalAuthContextManager.getOboTokenProvider(configuration, oboConfiguration, oboFirstPartyTokenCallback, oboThirdPartyTokenCallback);
                }
                return _this._firstPartyOboTokenProvider;
            }
            else {
                if (!_this._thirdPartyOboTokenProvider) {
                    _this._thirdPartyOboTokenProvider = adalAuthContextManager.getOboTokenProvider(configuration, oboConfiguration, oboFirstPartyTokenCallback, oboThirdPartyTokenCallback);
                }
                return _this._thirdPartyOboTokenProvider;
            }
        });
    };
    DeferredAadTokenProvider.prototype._isFirstParty = function (clientId) {
        return (clientId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID ||
            clientId === AadConstants_1.default.ODC_AAD_APP_PRINCIPAL_ID);
    };
    /**
     * Check for determining if the OBO Token Exchange API should be used in the current environment.
     */
    DeferredAadTokenProvider.prototype._shouldUseOboTokenExchange = function () {
        if ((0, AadKillSwitches_1.isTeamsBrowserHostedKSActive)()) {
            return !!this._oboConfiguration;
        }
        else {
            return (((((0, AadFlights_1.isOBOForAllTeamsScenariosEnabled)() && sp_core_library_1._BrowserUtilities.isTeamsHosted()) ||
                (!(0, AadKillSwitches_1.useOBOInWebForSecureBrokerKSActivated)() && sp_core_library_1._BrowserUtilities.isUsingSecureBroker())
                ? sp_core_library_1._BrowserUtilities.isTeamsHosted()
                : sp_core_library_1._BrowserUtilities.isWebViewHosted()) ||
                ((0, AadFlights_1.isSafariAuthPatchEnbled)() && /.*AppleWebKit.*Safari/.test(navigator.userAgent))) &&
                !!this._oboConfiguration);
        }
    };
    return DeferredAadTokenProvider;
}());
exports.DeferredAadTokenProvider = DeferredAadTokenProvider;
//# sourceMappingURL=DeferredAadTokenProvider.js.map