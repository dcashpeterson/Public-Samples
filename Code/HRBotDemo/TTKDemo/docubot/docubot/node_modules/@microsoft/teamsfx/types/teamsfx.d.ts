/// <reference types="node" />

import { AccessToken } from '@azure/identity';
import { Activity } from 'botbuilder';
import { Attachment } from 'botbuilder';
import { AuthenticationProvider } from '@microsoft/microsoft-graph-client';
import { AxiosInstance } from 'axios';
import { AxiosRequestConfig } from 'axios';
import { BotFrameworkAdapter } from 'botbuilder';
import { CardAction } from 'botbuilder';
import { CardImage } from 'botbuilder';
import { ChannelInfo } from 'botbuilder';
import { Client } from '@microsoft/microsoft-graph-client';
import { CloudAdapter } from 'botbuilder';
import { ComponentDialog } from 'botbuilder-dialogs';
import { ConnectionConfig } from 'tedious';
import { ConversationReference } from 'botbuilder';
import { ConversationState } from 'botbuilder';
import { Dialog } from 'botbuilder-dialogs';
import { DialogContext } from 'botbuilder-dialogs';
import { DialogTurnResult } from 'botbuilder-dialogs';
import { GetTokenOptions } from '@azure/identity';
import { HeroCard } from 'botbuilder';
import { InvokeResponse } from 'botbuilder';
import { MessagingExtensionResponse } from 'botbuilder';
import { O365ConnectorCard } from 'botbuilder';
import { ReceiptCard } from 'botbuilder';
import { Request as Request_2 } from 'botbuilder';
import { Response as Response_2 } from 'botbuilder';
import { SecureContextOptions } from 'tls';
import { SigninStateVerificationQuery } from 'botbuilder';
import { StatePropertyAccessor } from 'botbuilder';
import { StatusCodes } from 'botbuilder';
import { Storage as Storage_2 } from 'botbuilder';
import { TeamDetails } from 'botbuilder';
import { TeamsChannelAccount } from 'botbuilder';
import { ThumbnailCard } from 'botbuilder';
import { TokenCredential } from '@azure/identity';
import { TokenResponse } from 'botframework-schema';
import { TurnContext } from 'botbuilder';
import { UserState } from 'botbuilder';
import { WebRequest } from 'botbuilder';
import { WebResponse } from 'botbuilder';

/**
 * Options used to control how the response card will be sent to users.
 */
export declare enum AdaptiveCardResponse {
    /**
     * The response card will be replaced the current one for the interactor who trigger the action.
     */
    ReplaceForInteractor = 0,
    /**
     * The response card will be replaced the current one for all users in the chat.
     */
    ReplaceForAll = 1,
    /**
     * The response card will be sent as a new message for all users in the chat.
     */
    NewForAll = 2
}

/**
 * Define available location for API Key location
 */
export declare enum ApiKeyLocation {
    /**
     * The API Key is placed in request header
     */
    Header = 0,
    /**
     * The API Key is placed in query parameter
     */
    QueryParams = 1
}

/**
 * Provider that handles API Key authentication
 */
export declare class ApiKeyProvider implements AuthProvider {
    private keyName;
    private keyValue;
    private keyLocation;
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName: string, keyValue: string, keyLocation: ApiKeyLocation);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved like time-triggered automation job.
 *
 * @example
 * ```typescript
 * loadConfiguration(); // load configuration from environment variables
 * const credential = new AppCredential();
 * ```
 *
 * @remarks
 * Only works in in server side.
 */
export declare class AppCredential implements TokenCredential {
    private readonly msalClient;
    /**
     * Constructor of AppCredential.
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {AppCredentialAuthConfig} authConfig - The authentication configuration.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret or tenant id is not found in config.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    constructor(authConfig: AppCredentialAuthConfig);
    /**
     * Constructor of AppCredential.
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret or tenant id is not found in config.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    constructor(authConfig: AuthenticationConfiguration);
    /**
     * Get access token for credential.
     *
     * @example
     * ```typescript
     * await credential.getToken(["User.Read.All"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read.All") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read.All", "Calendars.Read"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read.All Calendars.Read") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read.All") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|ServiceError} when get access token with authentication error.
     * @throws {@link ErrorCode|InternalError} when get access token with unknown error.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Access token with expected scopes.
     * Throw error if get access token failed.
     */
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    private loadAndValidateConfig;
}

/**
 * Authentication configuration for AppCredential used in node environment
 */
export declare type AppCredentialAuthConfig = OnBehalfOfCredentialAuthConfig;

/**
 * Authentication related configuration.
 * @deprecated Please use {@link TeamsUserCredentialAuthConfig}
 * or {@link OnBehalfOfCredentialAuthConfig} or {@link AppCredentialAuthConfig} instead.
 */
export declare interface AuthenticationConfiguration {
    /**
     * Hostname of AAD authority. Default value comes from M365_AUTHORITY_HOST environment variable.
     *
     * @readonly
     */
    readonly authorityHost?: string;
    /**
     * AAD tenant id, default value comes from M365_TENANT_ID environment variable.
     *
     * @readonly
     */
    readonly tenantId?: string;
    /**
     * The client (application) ID of an App Registration in the tenant, default value comes from M365_CLIENT_ID environment variable
     *
     * @readonly
     */
    readonly clientId?: string;
    /**
     * Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal. Default value comes from M365_CLIENT_SECRET environment variable
     *
     * @readonly
     */
    readonly clientSecret?: string;
    /**
     * The content of a PEM-encoded public/private key certificate.
     *
     * @readonly
     */
    readonly certificateContent?: string;
    /**
     * Login page for Teams to redirect to.  Default value comes from INITIATE_LOGIN_ENDPOINT environment variable.
     *
     * @readonly
     */
    readonly initiateLoginEndpoint?: string;
    /**
     * Application ID URI. Default value comes from M365_APPLICATION_ID_URI environment variable.
     */
    readonly applicationIdUri?: string;
}

/**
 * Defines method that injects authentication info to http requests
 */
export declare interface AuthProvider {
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     */
    AddAuthenticationInfo: (config: AxiosRequestConfig) => Promise<AxiosRequestConfig>;
}

export { AxiosInstance }

/**
 * Provider that handles Basic authentication
 */
export declare class BasicAuthProvider implements AuthProvider {
    private userName;
    private password;
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName: string, password: string);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * Provider that handles Bearer Token authentication
 */
export declare class BearerTokenAuthProvider implements AuthProvider {
    private getToken;
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken: () => Promise<string>);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

declare namespace BotBuilderCloudAdapter {
    export {
        ConversationOptions_2 as ConversationOptions,
        NotificationOptions_3 as NotificationOptions,
        ConversationBot_2 as ConversationBot,
        BotSsoExecutionDialog,
        Channel_2 as Channel,
        Member_2 as Member,
        NotificationBot_2 as NotificationBot,
        sendAdaptiveCard_2 as sendAdaptiveCard,
        sendMessage_2 as sendMessage,
        TeamsBotInstallation_2 as TeamsBotInstallation,
        SearchScope_2 as SearchScope,
        CommandBot_2 as CommandBot,
        CardActionBot_2 as CardActionBot
    }
}
export { BotBuilderCloudAdapter }

/**
 * Interface for SSO configuration for Bot SSO
 */
export declare interface BotSsoConfig {
    /**
     * aad related configurations
     */
    aad: {
        /**
         * The list of scopes for which the token will have access
         */
        scopes: string[];
    } & ((OnBehalfOfCredentialAuthConfig & {
        initiateLoginEndpoint: string;
    }) | AuthenticationConfiguration);
    dialog?: {
        /**
         * Custom sso execution activity handler class which should implement the interface {@link BotSsoExecutionActivityHandler}. If not provided, it will use {@link DefaultBotSsoExecutionActivityHandler} by default
         */
        CustomBotSsoExecutionActivityHandler?: new (ssoConfig: BotSsoConfig) => BotSsoExecutionActivityHandler;
        /**
         * Conversation state for sso command bot, if not provided, it will use internal memory storage to create a new one.
         */
        conversationState?: ConversationState;
        /**
         * User state for sso command bot, if not provided, it will use internal memory storage to create a new one.
         */
        userState?: UserState;
        /**
         * Used by {@link BotSsoExecutionDialog} to remove duplicated messages, if not provided, it will use internal memory storage
         */
        dedupStorage?: Storage_2;
        /**
         * Settings used to configure an teams sso prompt dialog.
         */
        ssoPromptConfig?: {
            /**
             * Number of milliseconds the prompt will wait for the user to authenticate.
             * Defaults to a value `900,000` (15 minutes.)
             */
            timeout?: number;
            /**
             * Value indicating whether the TeamsBotSsoPrompt should end upon receiving an
             * invalid message.  Generally the TeamsBotSsoPrompt will end the auth flow when receives user
             * message not related to the auth flow. Setting the flag to false ignores the user's message instead.
             * Defaults to value `true`
             */
            endOnInvalidMessage?: boolean;
        };
    };
}

/**
 * Interface for user to customize SSO execution activity handler
 *
 * @remarks
 * Bot SSO execution activity handler is to handle SSO login process and trigger SSO command using {@link BotSsoExecutionDialog}.
 * You can use this interface to implement your own SSO execution dialog, and pass it to ConversationBot options:
 *
 * ```typescript
 * export const commandBot = new ConversationBot({
 *   ...
 *   ssoConfig: {
 *     ...
 *     dialog: {
 *       CustomBotSsoExecutionActivityHandler: YourCustomBotSsoExecutionActivityHandler,
 *     }
 *   },
 *    ...
 * });
 * ```
 * For details information about how to implement a BotSsoExecutionActivityHandler, please refer DefaultBotSsoExecutionActivityHandler class source code: https://aka.ms/teamsfx-default-sso-execution-activity-handler
 */
export declare interface BotSsoExecutionActivityHandler {
    /**
     * Add {@link TeamsFxBotSsoCommandHandler} instance to {@link BotSsoExecutionDialog}
     * @param handler {@link BotSsoExecutionDialogHandler} callback function
     * @param triggerPatterns The trigger pattern
     *
     * @remarks
     * This function is used to add SSO command to {@link BotSsoExecutionDialog} instance.
     */
    addCommand(handler: BotSsoExecutionDialogHandler, triggerPatterns: TriggerPatterns): void;
    /**
     * Called to initiate the event emission process.
     * @param context The context object for the current turn.
     */
    run(context: TurnContext): Promise<void>;
    /**
     * Receives invoke activities with Activity name of 'signin/verifyState'.
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query.
     * @returns A promise that represents the work queued.
     *
     * @remarks
     * It should trigger {@link BotSsoExecutionDialog} instance to handle signin process
     */
    handleTeamsSigninVerifyState(context: TurnContext, query: SigninStateVerificationQuery): Promise<void>;
    /**
     * Receives invoke activities with Activity name of 'signin/tokenExchange'
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query
     * @returns A promise that represents the work queued.
     *
     * @remarks
     * It should trigger {@link BotSsoExecutionDialog} instance to handle signin process
     */
    handleTeamsSigninTokenExchange(context: TurnContext, query: SigninStateVerificationQuery): Promise<void>;
}

/**
 * Sso execution dialog, use to handle sso command
 */
export declare class BotSsoExecutionDialog extends ComponentDialog {
    private dedupStorage;
    private dedupStorageKeys;
    private commandMapping;
    /**
     * Creates a new instance of the BotSsoExecutionDialog.
     * @param {@link Storage} dedupStorage Helper storage to remove duplicated messages
         * @param {@link TeamsBotSsoPromptSettings} settings The list of scopes for which the token will have access
             * @param {@link TeamsFx} teamsfx instance for authentication
                 * @param {string} dialogName custom dialog name
                 */
             constructor(dedupStorage: Storage_2, ssoPromptSettings: TeamsBotSsoPromptSettings, teamsfx: TeamsFx, dialogName?: string);
             /**
              * Creates a new instance of the BotSsoExecutionDialog.
              * @param {@link Storage} dedupStorage Helper storage to remove duplicated messages
                  * @param {@link TeamsBotSsoPromptSettings} settings The list of scopes for which the token will have access
                      * @param {@link OnBehalfOfCredentialAuthConfig} authConfig The authentication configuration.
                          * @param {string} initiateLoginEndpoint Login URL for Teams to redirect to.
                          * @param {string} dialogName custom dialog name
                          */
                      constructor(dedupStorage: Storage_2, ssoPromptSettings: TeamsBotSsoPromptSettings, authConfig: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, dialogName?: string);
                      /**
                       * Add TeamsFxBotSsoCommandHandler instance
                       * @param handler {@link BotSsoExecutionDialogHandler} callback function
                       * @param triggerPatterns The trigger pattern
                       */
                      addCommand(handler: BotSsoExecutionDialogHandler, triggerPatterns: TriggerPatterns): void;
                      private getCommandHash;
                      /**
                       * The run method handles the incoming activity (in the form of a DialogContext) and passes it through the dialog system.
                       *
                       * @param context The context object for the current turn.
                       * @param accessor The instance of StatePropertyAccessor for dialog system.
                       */
                      run(context: TurnContext, accessor: StatePropertyAccessor): Promise<void>;
                      private getActivityText;
                      private commandRouteStep;
                      private ssoStep;
                      private dedupStep;
                      /**
                       * Called when the component is ending.
                       *
                       * @param context Context for the current turn of conversation.
                       */
                      protected onEndDialog(context: TurnContext): Promise<void>;
                      /**
                       * If a user is signed into multiple Teams clients, the Bot might receive a "signin/tokenExchange" from each client.
                       * Each token exchange request for a specific user login will have an identical activity.value.Id.
                       * Only one of these token exchange requests should be processed by the bot. For a distributed bot in production,
                       * this requires a distributed storage to ensure only one token exchange is processed.
                       * @param context Context for the current turn of conversation.
                       * @returns boolean value indicate whether the message should be removed
                       */
                      private shouldDedup;
                      private getStorageKey;
                      private matchPattern;
                      private isPatternMatched;
                      private getMatchesCommandId;
                      /**
                       * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
                       * @param dc dialog context
                       * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
                       * @internal
                       */
                      private ensureMsTeamsChannel;
                  }

                  export declare type BotSsoExecutionDialogHandler = (context: TurnContext, tokenResponse: TeamsBotSsoPromptTokenResponse, message: CommandMessage) => Promise<void>;

                  /**
                   * A card action bot to respond to adaptive card universal actions.
                   */
                  /**
                   * @deprecated Use `BotBuilderCloudAdapter.CardActionBot` instead.
                   */
                  export declare class CardActionBot {
                      private readonly adapter;
                      private middleware;
                      /**
                       * Creates a new instance of the `CardActionBot`.
                       *
                       * @param adapter The bound `BotFrameworkAdapter`.
                       * @param options - initialize options
                       */
                      constructor(adapter: BotFrameworkAdapter, options?: CardActionOptions);
                      /**
                       * Registers a card action handler to the bot.
                       * @param actionHandler A card action handler to be registered.
                       */
                      registerHandler(actionHandler: TeamsFxAdaptiveCardActionHandler): void;
                      /**
                       * Registers card action handlers to the bot.
                       * @param actionHandlers A set of card action handlers to be registered.
                       */
                      registerHandlers(actionHandlers: TeamsFxAdaptiveCardActionHandler[]): void;
                  }

                  /**
                   * A card action bot to respond to adaptive card universal actions.
                   */
                  declare class CardActionBot_2 {
                      private readonly adapter;
                      private middleware;
                      /**
                       * Create a new instance of the `CardActionBot`.
                       *
                       * @param adapter - The bound `CloudAdapter`.
                       * @param options - The initialize options.
                       */
                      constructor(adapter: CloudAdapter, options?: CardActionOptions);
                      /**
                       * Register a card action handler to the bot.
                       *
                       * @param actionHandler - A card action handler to be registered.
                       */
                      registerHandler(actionHandler: TeamsFxAdaptiveCardActionHandler): void;
                      /**
                       * Register card action handlers to the bot.
                       *
                       * @param actionHandlers - A set of card action handlers to be registered.
                       */
                      registerHandlers(actionHandlers: TeamsFxAdaptiveCardActionHandler[]): void;
                  }

                  /**
                   * Options to initialize {@link CardActionBot}.
                   */
                  export declare interface CardActionOptions {
                      /**
                       * The action handlers to registered with the action bot. Each command should implement the interface {@link TeamsFxAdaptiveCardActionHandler} so that it can be correctly handled by this bot.
                       */
                      actions?: TeamsFxAdaptiveCardActionHandler[];
                  }

                  /**
                   * Provider that handles Certificate authentication
                   */
                  export declare class CertificateAuthProvider implements AuthProvider {
                      private certOption;
                      /**
                       *
                       * @param { SecureContextOptions } certOption - information about the cert used in http requests
                       *
                       * @throws {@link ErrorCode|InvalidParameter} - when cert option is empty.
                       */
                      constructor(certOption: SecureContextOptions);
                      /**
                       * Adds authentication info to http requests.
                       *
                       * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
                       * Refer https://axios-http.com/docs/req_config for detailed document.
                       *
                       * @returns Updated axios request config.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
                       */
                      AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
                  }

                  /**
                   * A {@link NotificationTarget} that represents a team channel.
                   *
                   * @remarks
                   * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
                   */
                  export declare class Channel implements NotificationTarget {
                      /**
                       * The parent {@link TeamsBotInstallation} where this channel is created from.
                       */
                      readonly parent: TeamsBotInstallation;
                      /**
                       * Detailed channel information.
                       */
                      readonly info: ChannelInfo;
                      /**
                       * Notification target type. For channel it's always "Channel".
                       */
                      readonly type: NotificationTargetType;
                      /**
                       * Constructor.
                       *
                       * @remarks
                       * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
                       *
                       * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
                       * @param info - Detailed channel information.
                       */
                      constructor(parent: TeamsBotInstallation, info: ChannelInfo);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - the plain text message.
                       * @param onError - an optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - the adaptive card raw JSON.
                       * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * @internal
                       */
                      private newConversation;
                  }

                  /**
                   * A {@link NotificationTarget} that represents a team channel.
                   *
                   * @remarks
                   * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
                   */
                  declare class Channel_2 implements NotificationTarget {
                      /**
                       * The parent {@link TeamsBotInstallation} where this channel is created from.
                       */
                      readonly parent: TeamsBotInstallation_2;
                      /**
                       * Detailed channel information.
                       */
                      readonly info: ChannelInfo;
                      /**
                       * Notification target type. For channel it's always "Channel".
                       */
                      readonly type: NotificationTargetType;
                      /**
                       * Constructor.
                       *
                       * @remarks
                       * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
                       *
                       * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
                       * @param info - Detailed channel information.
                       */
                      constructor(parent: TeamsBotInstallation_2, info: ChannelInfo);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - The plain text message.
                       * @param onError - An optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - The adaptive card raw JSON.
                       * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * @internal
                       */
                      private newConversation;
                  }

                  /**
                   * A command bot for receiving commands and sending responses in Teams.
                   *
                   * @remarks
                   * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
                   */
                  /**
                   * @deprecated Use `BotBuilderCloudAdapter.CommandBot` instead.
                   */
                  export declare class CommandBot {
                      private readonly adapter;
                      private readonly middleware;
                      private readonly ssoConfig;
                      /**
                       * Creates a new instance of the `CommandBot`.
                       *
                       * @param adapter The bound `BotFrameworkAdapter`.
                       * @param options - initialize options
                       */
                      constructor(adapter: BotFrameworkAdapter, options?: CommandOptions, ssoCommandActivityHandler?: BotSsoExecutionActivityHandler, ssoConfig?: BotSsoConfig);
                      /**
                       * Registers a command into the command bot.
                       *
                       * @param command The command to register.
                       */
                      registerCommand(command: TeamsFxBotCommandHandler): void;
                      /**
                       * Registers commands into the command bot.
                       *
                       * @param commands The commands to register.
                       */
                      registerCommands(commands: TeamsFxBotCommandHandler[]): void;
                      /**
                       * Registers a sso command into the command bot.
                       *
                       * @param command The command to register.
                       */
                      registerSsoCommand(ssoCommand: TeamsFxBotSsoCommandHandler): void;
                      /**
                       * Registers commands into the command bot.
                       *
                       * @param commands The commands to register.
                       */
                      registerSsoCommands(ssoCommands: TeamsFxBotSsoCommandHandler[]): void;
                      private validateSsoActivityHandler;
                  }

                  /**
                   * A command bot for receiving commands and sending responses in Teams.
                   *
                   * @remarks
                   * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
                   */
                  declare class CommandBot_2 {
                      private readonly adapter;
                      private readonly middleware;
                      private readonly ssoConfig;
                      /**
                       * Create a new instance of the `CommandBot`.
                       *
                       * @param adapter - The bound `CloudAdapter`.
                       * @param options - The initialize options
                       * @param ssoCommandActivityHandler - SSO execution activity handler.
                       * @param ssoConfig - SSO configuration for Bot SSO.
                       */
                      constructor(adapter: CloudAdapter, options?: CommandOptions, ssoCommandActivityHandler?: BotSsoExecutionActivityHandler, ssoConfig?: BotSsoConfig);
                      /**
                       * Register a command into the command bot.
                       *
                       * @param command - The command to be registered.
                       */
                      registerCommand(command: TeamsFxBotCommandHandler): void;
                      /**
                       * Register commands into the command bot.
                       *
                       * @param commands - The commands to be registered.
                       */
                      registerCommands(commands: TeamsFxBotCommandHandler[]): void;
                      /**
                       * Register a sso command into the command bot.
                       *
                       * @param ssoCommand - The sso command to be registered.
                       */
                      registerSsoCommand(ssoCommand: TeamsFxBotSsoCommandHandler): void;
                      /**
                       * Register sso commands into the command bot.
                       *
                       * @param ssoCommands - The sso commands to be registered.
                       */
                      registerSsoCommands(ssoCommands: TeamsFxBotSsoCommandHandler[]): void;
                      private validateSsoActivityHandler;
                  }

                  /**
                   * Interface for a command message that can handled in a command handler.
                   */
                  export declare interface CommandMessage {
                      /**
                       * Text of the message sent by the user.
                       */
                      text: string;
                      /**
                       * The capture groups that matched to the {@link TriggerPatterns} in a {@link TeamsFxBotCommandHandler} instance.
                       */
                      matches?: RegExpMatchArray;
                  }

                  /**
                   * Options to initialize {@link CommandBot}.
                   */
                  export declare interface CommandOptions {
                      /**
                       * The commands to registered with the command bot. Each command should implement the interface {@link TeamsFxBotCommandHandler} so that it can be correctly handled by this command bot.
                       */
                      commands?: TeamsFxBotCommandHandler[];
                      /**
                       * The commands to registered with the sso command bot. Each sso command should implement the interface {@link TeamsFxBotSsoCommandHandler} so that it can be correctly handled by this command bot.
                       */
                      ssoCommands?: TeamsFxBotSsoCommandHandler[];
                  }

                  /**
                   * Provide utilities for bot conversation, including:
                   *   - handle command and response.
                   *   - send notification to varies targets (e.g., member, group, channel).
                   *
                   * @example
                   * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
                   *
                   * ```typescript
                   * // register through constructor
                   * const conversationBot = new ConversationBot({
                   *   command: {
                   *     enabled: true,
                   *     commands: [ new HelloWorldCommandHandler() ],
                   *   },
                   * });
                   *
                   * // register through `register*` API
                   * conversationBot.command.registerCommand(new HelpCommandHandler());
                   * ```
                   *
                   * For notification, you can enable notification at initialization, then send notifications at any time.
                   *
                   * ```typescript
                   * // enable through constructor
                   * const conversationBot = new ConversationBot({
                   *   notification: {
                   *     enabled: true,
                   *   },
                   * });
                   *
                   * // get all bot installations and send message
                   * for (const target of await conversationBot.notification.installations()) {
                   *   await target.sendMessage("Hello Notification");
                   * }
                   *
                   * // alternative - send message to all members
                   * for (const target of await conversationBot.notification.installations()) {
                   *   for (const member of await target.members()) {
                   *     await member.sendMessage("Hello Notification");
                   *   }
                   * }
                   * ```
                   *
                   * @remarks
                   * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
                   *
                   * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
                   *
                   * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
                   */
                  /**
                   * @deprecated Use `BotBuilderCloudAdapter.ConversationBot` instead.
                   */
                  export declare class ConversationBot {
                      /**
                       * The bot adapter.
                       */
                      readonly adapter: BotFrameworkAdapter;
                      /**
                       * The entrypoint of command and response.
                       */
                      readonly command?: CommandBot;
                      /**
                       * The entrypoint of notification.
                       */
                      readonly notification?: NotificationBot;
                      /**
                       * The action handler used for adaptive card universal actions.
                       */
                      readonly cardAction?: CardActionBot;
                      /**
                       * Creates new instance of the `ConversationBot`.
                       *
                       * @remarks
                       * It's recommended to create your own adapter and storage for production environment instead of the default one.
                       *
                       * @param options - initialize options
                       */
                      constructor(options: ConversationOptions);
                      private createDefaultAdapter;
                      /**
                       * The request handler to integrate with web request.
                       *
                       * @param req - an Express or Restify style request object.
                       * @param res - an Express or Restify style response object.
                       * @param logic - the additional function to handle bot context.
                       *
                       * @example
                       * For example, to use with Restify:
                       * ``` typescript
                       * // The default/empty behavior
                       * server.post("api/messages", conversationBot.requestHandler);
                       *
                       * // Or, add your own logic
                       * server.post("api/messages", async (req, res) => {
                       *   await conversationBot.requestHandler(req, res, async (context) => {
                       *     // your-own-context-logic
                       *   });
                       * });
                       * ```
                       */
                      requestHandler(req: WebRequest, res: WebResponse, logic?: (context: TurnContext) => Promise<any>): Promise<void>;
                  }

                  /**
                   * Provide utilities for bot conversation, including:
                   *   - handle command and response.
                   *   - send notification to varies targets (e.g., member, group, channel).
                   *
                   * @example
                   * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
                   *
                   * ```typescript
                   * import { BotBuilderCloudAdapter } from "@microsoft/teamsfx";
                   * import ConversationBot = BotBuilderCloudAdapter.ConversationBot;
                   *
                   * // register through constructor
                   * const conversationBot = new ConversationBot({
                   *   command: {
                   *     enabled: true,
                   *     commands: [ new HelloWorldCommandHandler() ],
                   *   },
                   * });
                   *
                   * // register through `register*` API
                   * conversationBot.command.registerCommand(new HelpCommandHandler());
                   * ```
                   *
                   * For notification, you can enable notification at initialization, then send notifications at any time.
                   *
                   * ```typescript
                   * import { BotBuilderCloudAdapter } from "@microsoft/teamsfx";
                   * import ConversationBot = BotBuilderCloudAdapter.ConversationBot;
                   *
                   * // enable through constructor
                   * const conversationBot = new ConversationBot({
                   *   notification: {
                   *     enabled: true,
                   *   },
                   * });
                   *
                   * // get all bot installations and send message
                   * for (const target of await conversationBot.notification.installations()) {
                   *   await target.sendMessage("Hello Notification");
                   * }
                   *
                   * // alternative - send message to all members
                   * for (const target of await conversationBot.notification.installations()) {
                   *   for (const member of await target.members()) {
                   *     await member.sendMessage("Hello Notification");
                   *   }
                   * }
                   * ```
                   *
                   * @remarks
                   * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
                   *
                   * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
                   *
                   * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
                   */
                  declare class ConversationBot_2 {
                      /**
                       * The bot adapter.
                       */
                      readonly adapter: CloudAdapter;
                      /**
                       * The entrypoint of command and response.
                       */
                      readonly command?: CommandBot_2;
                      /**
                       * The entrypoint of notification.
                       */
                      readonly notification?: NotificationBot_2;
                      /**
                       * The action handler used for adaptive card universal actions.
                       */
                      readonly cardAction?: CardActionBot_2;
                      /**
                       * Create new instance of the `ConversationBot`.
                       *
                       * @remarks
                       * It's recommended to create your own adapter and storage for production environment instead of the default one.
                       *
                       * @param options - The initialize options.
                       */
                      constructor(options: ConversationOptions_2);
                      private createDefaultAdapter;
                      /**
                       * The request handler to integrate with web request.
                       *
                       * @param req - An incoming HTTP [Request](xref:botbuilder.Request).
                       * @param res - The corresponding HTTP [Response](xref:botbuilder.Response).
                       * @param logic - The additional function to handle bot context.
                       *
                       * @example
                       * For example, to use with Restify:
                       * ``` typescript
                       * // The default/empty behavior
                       * server.use(restify.plugins.bodyParser());
                       * server.post("api/messages", conversationBot.requestHandler);
                       *
                       * // Or, add your own logic
                       * server.use(restify.plugins.bodyParser());
                       * server.post("api/messages", async (req, res) => {
                       *   await conversationBot.requestHandler(req, res, async (context) => {
                       *     // your-own-context-logic
                       *   });
                       * });
                       * ```
                       */
                      requestHandler(req: Request_2, res: Response_2, logic?: (context: TurnContext) => Promise<any>): Promise<void>;
                  }

                  /**
                   * Options to initialize {@link ConversationBot}
                   * @deprecated Please use BotBuilderCloudAdapter.ConversationOptions instead.
                   */
                  export declare interface ConversationOptions {
                      /**
                       * The bot adapter. If not provided, a default adapter will be created:
                       * - with `adapterConfig` as constructor parameter.
                       * - with a default error handler that logs error to console, sends trace activity, and sends error message to user.
                       *
                       * @remarks
                       * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
                       */
                      adapter?: BotFrameworkAdapter;
                      /**
                       * If `adapter` is not provided, this `adapterConfig` will be passed to the new `BotFrameworkAdapter` when created internally.
                       *
                       * @remarks
                       * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
                       */
                      adapterConfig?: {
                          [key: string]: unknown;
                      };
                      /**
                       * Configurations for sso command bot
                       */
                      ssoConfig?: BotSsoConfig;
                      /**
                       * The command part.
                       */
                      command?: CommandOptions & {
                          /**
                           * Whether to enable command or not.
                           */
                          enabled?: boolean;
                      };
                      /**
                       * The notification part.
                       */
                      notification?: NotificationOptions_2 & {
                          /**
                           * Whether to enable notification or not.
                           */
                          enabled?: boolean;
                      };
                      /**
                       * The adaptive card action handler part.
                       */
                      cardAction?: CardActionOptions & {
                          /**
                           * Whether to enable adaptive card actions or not.
                           */
                          enabled?: boolean;
                      };
                  }

                  /**
                   * Options to initialize {@link ConversationBot}
                   */
                  declare interface ConversationOptions_2 {
                      /**
                       * The bot adapter. If not provided, a default adapter will be created:
                       * - with `adapterConfig` as constructor parameter.
                       * - with a default error handler that logs error to console, sends trace activity, and sends error message to user.
                       *
                       * @remarks
                       * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
                       */
                      adapter?: CloudAdapter;
                      /**
                       * If `adapter` is not provided, this `adapterConfig` will be passed to the new `CloudAdapter` when created internally.
                       *
                       * @remarks
                       * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
                       */
                      adapterConfig?: {
                          [key: string]: unknown;
                      };
                      /**
                       * Configurations for sso command bot
                       */
                      ssoConfig?: BotSsoConfig;
                      /**
                       * The command part.
                       */
                      command?: CommandOptions & {
                          /**
                           * Whether to enable command or not.
                           */
                          enabled?: boolean;
                      };
                      /**
                       * The notification part.
                       */
                      notification?: NotificationOptions_3 & {
                          /**
                           * Whether to enable notification or not.
                           */
                          enabled?: boolean;
                      };
                      /**
                       * The adaptive card action handler part.
                       */
                      cardAction?: CardActionOptions & {
                          /**
                           * Whether to enable adaptive card actions or not.
                           */
                          enabled?: boolean;
                      };
                  }

                  /**
                   * A store to persist notification target references.
                   */
                  export declare interface ConversationReferenceStore {
                      /**
                       * Add a conversation reference to the store. If overwrite, update existing one, otherwise add when not exist.
                       *
                       * @param key the key of the conversation reference.
                       * @param reference the conversation reference to add.
                       * @param options the options to add the conversation reference.
                       *
                       * @returns true if added or updated, false if not changed.
                       */
                      add(key: string, reference: Partial<ConversationReference>, options: ConversationReferenceStoreAddOptions): Promise<boolean>;
                      /**
                       * Remove a conversation reference from the store.
                       *
                       * @param key the key of the conversation reference.
                       * @param reference the conversation reference to remove.
                       *
                       * @returns true if exist and removed, false if not changed.
                       */
                      remove(key: string, reference: Partial<ConversationReference>): Promise<boolean>;
                      /**
                       * List stored conversation reference by page.
                       *
                       * @param pageSize the page size.
                       * @param continuationToken the continuation token to get next page.
                       *
                       * @returns a paged list of conversation references.
                       */
                      list(pageSize?: number, continuationToken?: string): Promise<PagedData<Partial<ConversationReference>>>;
                  }

                  /**
                   * Options to add a conversation reference to the store.
                   */
                  export declare interface ConversationReferenceStoreAddOptions {
                      /**
                       * Whether to overwrite the existing conversation reference.
                       */
                      overwrite?: boolean;
                  }

                  /**
                   * Initializes new Axios instance with specific auth provider
                   *
                   * @param apiEndpoint - Base url of the API
                   * @param authProvider - Auth provider that injects authentication info to each request
                   * @returns axios instance configured with specfic auth provider
                   *
                   * @example
                   * ```typescript
                   * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
                   * ```
                   */
                  export declare function createApiClient(apiEndpoint: string, authProvider: AuthProvider): AxiosInstance;

                  /**
                   * Get Microsoft graph client.
                   * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
                   * ```typescript
                   * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
                   * const graph = Client.initWithMiddleware({
                   *   authProvider: authProvider,
                   * });
                   * ```
                   *
                   * @example
                   * Get Microsoft graph client by TokenCredential
                   * ```typescript
                   * // Sso token example (Azure Function)
                   * const ssoToken = "YOUR_TOKEN_STRING";
                   * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
                   * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
                   * const graphClient = await createMicrosoftGraphClient(credential);
                   * const profile = await graphClient.api("/me").get();
                   *
                   * // TeamsBotSsoPrompt example (Bot Application)
                   * const requiredScopes = ["User.Read"];
                   * const config: Configuration = {
                   *    loginUrl: loginUrl,
                   *    clientId: clientId,
                   *    clientSecret: clientSecret,
                   *    tenantId: tenantId
                   * };
                   * const prompt = new TeamsBotSsoPrompt(dialogId, {
                   *    config: config
                   *    scopes: ["User.Read"],
                   * });
                   * this.addDialog(prompt);
                   *
                   * const oboCredential = new OnBehalfOfAADUserCredential(
                   *  getUserId(dialogContext),
                   *  {
                   *    clientId: "AAD_APP_ID",
                   *    clientSecret: "AAD_APP_SECRET"
                   *  });
                   * try {
                   *    const graphClient = await createMicrosoftGraphClient(credential);
                   *    const profile = await graphClient.api("/me").get();
                   * } catch (e) {
                   *    dialogContext.beginDialog(dialogId);
                   *    return Dialog.endOfTurn();
                   * }
                   * ```
                   *
                   * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
                   * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
                   *
                   * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                   *
                   * @returns Graph client with specified scopes.
                   */
                  export declare function createMicrosoftGraphClient(teamsfx: TeamsFxConfiguration, scopes?: string | string[]): Client;

                  /**
                   * Get Microsoft graph client.
                   * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
                   * ```typescript
                   * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
                   * const graph = Client.initWithMiddleware({
                   *   authProvider: authProvider,
                   * });
                   * ```
                   *
                   * @example
                   * Get Microsoft graph client by TokenCredential
                   * ```typescript
                   * // In browser: TeamsUserCredential
                   * const authConfig: TeamsUserCredentialAuthConfig = {
                   *   clientId: "xxx",
                   initiateLoginEndpoint: "https://xxx/auth-start.html",
                   * };

                   * const credential = new TeamsUserCredential(authConfig);

                   * const scope = "User.Read";
                   * await credential.login(scope);

                   * const client = createMicrosoftGraphClientWithCredential(credential, scope);

                   * // In node: OnBehalfOfUserCredential
                   * const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
                   *   authorityHost: "xxx",
                   *   clientId: "xxx",
                   *   tenantId: "xxx",
                   *   clientSecret: "xxx",
                   * };

                   * const oboCredential = new OnBehalfOfUserCredential(ssoToken, oboAuthConfig);
                   * const scope = "User.Read";
                   * const client = createMicrosoftGraphClientWithCredential(oboCredential, scope);

                   * // In node: AppCredential
                   * const appAuthConfig: AppCredentialAuthConfig = {
                   *   authorityHost: "xxx",
                   *   clientId: "xxx",
                   *   tenantId: "xxx",
                   *   clientSecret: "xxx",
                   * };
                   * const appCredential = new AppCredential(appAuthConfig);
                   * const scope = "User.Read";
                   * const client = createMicrosoftGraphClientWithCredential(appCredential, scope);
                   *
                   * const profile = await client.api("/me").get();
                   * ```
                   *
                   * @param {TokenCredential} credential - Used to provide configuration and auth.
                   * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
                   *
                   * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                   *
                   * @returns Graph client with specified scopes.
                   */
                  export declare function createMicrosoftGraphClientWithCredential(credential: TokenCredential, scopes?: string | string[]): Client;

                  /**
                   * Helper to create SecureContextOptions from PEM format cert
                   *
                   * @param { string | Buffer } cert - The cert chain in PEM format
                   * @param { string | Buffer } key - The private key for the cert chain
                   * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
                   *
                   * @returns Instance of SecureContextOptions
                   *
                   * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
                   *
                   */
                  export declare function createPemCertOption(cert: string | Buffer, key: string | Buffer, options?: {
                      passphrase?: string;
                      ca?: string | Buffer;
                  }): SecureContextOptions;

                  /**
                   * Helper to create SecureContextOptions from PFX format cert
                   *
                   * @param { string | Buffer } pfx - The content of .pfx file
                   * @param { {passphrase?: string} } options - Optional settings when create the cert options.
                   *
                   * @returns Instance of SecureContextOptions
                   *
                   * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
                   *
                   */
                  export declare function createPfxCertOption(pfx: string | Buffer, options?: {
                      passphrase?: string;
                  }): SecureContextOptions;

                  /**
                   * Error code to trace the error types.
                   */
                  export declare enum ErrorCode {
                      /**
                       * Invalid parameter error.
                       */
                      InvalidParameter = "InvalidParameter",
                      /**
                       * Invalid configuration error.
                       */
                      InvalidConfiguration = "InvalidConfiguration",
                      /**
                       * Invalid certificate error.
                       */
                      InvalidCertificate = "InvalidCertificate",
                      /**
                       * Internal error.
                       */
                      InternalError = "InternalError",
                      /**
                       * Channel is not supported error.
                       */
                      ChannelNotSupported = "ChannelNotSupported",
                      /**
                       * Failed to retrieve sso token
                       */
                      FailedToRetrieveSsoToken = "FailedToRetrieveSsoToken",
                      /**
                       * Failed to process sso handler
                       */
                      FailedToProcessSsoHandler = "FailedToProcessSsoHandler",
                      /**
                       * Cannot find command
                       */
                      CannotFindCommand = "CannotFindCommand",
                      /**
                       * Failed to run sso step
                       */
                      FailedToRunSsoStep = "FailedToRunSsoStep",
                      /**
                       * Failed to run dedup step
                       */
                      FailedToRunDedupStep = "FailedToRunDedupStep",
                      /**
                       * Sso activity handler is undefined
                       */
                      SsoActivityHandlerIsUndefined = "SsoActivityHandlerIsUndefined",
                      /**
                       * Runtime is not supported error.
                       */
                      RuntimeNotSupported = "RuntimeNotSupported",
                      /**
                       * User failed to finish the AAD consent flow failed.
                       */
                      ConsentFailed = "ConsentFailed",
                      /**
                       * The user or administrator has not consented to use the application error.
                       */
                      UiRequiredError = "UiRequiredError",
                      /**
                       * Token is not within its valid time range error.
                       */
                      TokenExpiredError = "TokenExpiredError",
                      /**
                       * Call service (AAD or simple authentication server) failed.
                       */
                      ServiceError = "ServiceError",
                      /**
                       * Operation failed.
                       */
                      FailedOperation = "FailedOperation",
                      /**
                       * Invalid response error.
                       */
                      InvalidResponse = "InvalidResponse",
                      /**
                       * Identity type error.
                       */
                      IdentityTypeNotSupported = "IdentityTypeNotSupported",
                      /**
                       * Authentication info already exists error.
                       */
                      AuthorizationInfoAlreadyExists = "AuthorizationInfoAlreadyExists"
                  }

                  /**
                   * Error class with code and message thrown by the SDK.
                   */
                  export declare class ErrorWithCode extends Error {
                      /**
                       * Error code
                       *
                       * @readonly
                       */
                      code: string | undefined;
                      /**
                       * Constructor of ErrorWithCode.
                       *
                       * @param {string} message - error message.
                       * @param {ErrorCode} code - error code.
                       */
                      constructor(message?: string, code?: ErrorCode);
                  }

                  /**
                   * Get log level.
                   *
                   * @returns Log level
                   */
                  export declare function getLogLevel(): LogLevel | undefined;

                  export declare interface GetTeamsUserTokenOptions extends GetTokenOptions {
                      resources?: string[];
                  }

                  /**
                   * Generate connection configuration consumed by tedious.
                   *
                   * @deprecated we recommend you compose your own Tedious configuration for better flexibility.
                   *
                   * @param {TeamsFx} teamsfx - Used to provide configuration and auth
                   * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
                   *
                   * @returns Connection configuration of tedious for the SQL.
                   *
                   * @throws {@link ErrorCode|InvalidConfiguration} when SQL config resource configuration is invalid.
                   * @throws {@link ErrorCode|InternalError} when get user MSI token failed or MSI token is invalid.
                   * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                   */
                  export declare function getTediousConnectionConfig(teamsfx: TeamsFx, databaseName?: string): Promise<ConnectionConfig>;

                  /**
                   * Users execute link query in message extension with SSO or access token.
                   *
                   * @param {TurnContext} context - The context object for the current turn.
                   * @param {OnBehalfOfCredentialAuthConfig} config - User custom the message extension authentication configuration.
                   * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
                   * @param {string| string[]} scopes - The list of scopes for which the token will have access.
                   * @param {function} logic - Business logic when executing the link query in message extension with SSO or access token.
                   *
                   * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension link query.
                   * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
                   * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
                   * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
                   * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                   * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
                   *
                   * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
                   */
                  export declare function handleMessageExtensionLinkQueryWithSSO(context: TurnContext, config: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, scopes: string | string[], logic: (token: MessageExtensionTokenResponse) => Promise<any>): Promise<void | MessagingExtensionResponse>;

                  /**
                   * Users execute query in message extension with SSO or access token.
                   *
                   * @param {TurnContext} context - The context object for the current turn.
                   * @param {OnBehalfOfCredentialAuthConfig} config - User custom the message extension authentication configuration.
                   * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
                   * @param {string| string[]} scopes - The list of scopes for which the token will have access.
                   * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
                   *
                   * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension query.
                   * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
                   * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
                   * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
                   * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                   * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
                   *
                   * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
                   */
                  export declare function handleMessageExtensionQueryWithSSO(context: TurnContext, config: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, scopes: string | string[], logic: (token: MessageExtensionTokenResponse) => Promise<any>): Promise<void | MessagingExtensionResponse>;

                  /**
                   * Users execute query in message extension with SSO or access token.
                   * @deprecated Use {@link handleMessageExtensionQueryWithSSO} instead.
                   *
                   * @param {TurnContext} context - The context object for the current turn.
                   * @param {AuthenticationConfiguration} config - User custom the message extension authentication configuration.
                   * @param {string| string[]} scopes - The list of scopes for which the token will have access.
                   * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
                   *
                   * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension query.
                   * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
                   * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
                   * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
                   * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                   * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
                   *
                   * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
                   */
                  export declare function handleMessageExtensionQueryWithToken(context: TurnContext, config: AuthenticationConfiguration | null, scopes: string | string[], logic: (token: MessageExtensionTokenResponse) => Promise<any>): Promise<MessagingExtensionResponse | void>;

                  /**
                   * Identity type to use in authentication.
                   */
                  export declare enum IdentityType {
                      /**
                       * Represents the current user of Teams.
                       */
                      User = "User",
                      /**
                       * Represents the application itself.
                       */
                      App = "Application"
                  }

                  /**
                   * Status code for an `application/vnd.microsoft.error` invoke response.
                   */
                  export declare enum InvokeResponseErrorCode {
                      /**
                       * Invalid request.
                       */
                      BadRequest = 400,
                      /**
                       * Internal server error.
                       */
                      InternalServerError = 500
                  }

                  /**
                   * Provides methods for formatting various invoke responses a bot can send to respond to an invoke request.
                   *
                   * @remarks
                   * All of these functions return an `InvokeResponse` object, which can be
                   * passed as input to generate a new `invokeResponse` activity.
                   *
                   * This example sends an invoke response that contains an adaptive card.
                   *
                   * ```typescript
                   *
                   * const myCard = {
                   *    type: "AdaptiveCard",
                   *    body: [
                   *     {
                   *       "type": "TextBlock",
                   *       "text": "This is a sample card"
                   *     }],
                   *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
                   *     version: "1.4"
                   *  };
                   *
                   * const invokeResponse = InvokeResponseFactory.adaptiveCard(myCard);
                   * await context.sendActivity({
                   *    type: ActivityTypes.InvokeResponse,
                   *    value: invokeResponse,
                   *  });
                   * ```
                   */
                  export declare class InvokeResponseFactory {
                      /**
                       * Create an invoke response from a text message.
                       * The type of the invoke response is `application/vnd.microsoft.activity.message`
                       * indicates the request was successfully processed.
                       *
                       * @param message - A text message included in a invoke response.
                       *
                       * @returns An `InvokeResponse` object.
                       */
                      static textMessage(message: string): InvokeResponse;
                      /**
                       * Create an invoke response from an adaptive card.
                       *
                       * The type of the invoke response is `application/vnd.microsoft.card.adaptive` indicates
                       * the request was successfully processed, and the response includes an adaptive card
                       * that the client should display in place of the current one.
                       *
                       * @param card - The adaptive card JSON payload.
                       *
                       * @returns An `InvokeResponse` object.
                       */
                      static adaptiveCard(card: unknown): InvokeResponse;
                      /**
                       * Create an invoke response with error code and message.
                       *
                       * The type of the invoke response is `application/vnd.microsoft.error` indicates
                       * the request was failed to processed.
                       *
                       * @param errorCode - The status code indicates error, available values:
                       *  - 400 (BadRequest): indicate the incoming request was invalid.
                       *  - 500 (InternalServerError): indicate an unexpected error occurred.
                       * @param errorMessage - The error message.
                       *
                       * @returns An `InvokeResponse` object.
                       */
                      static errorResponse(errorCode: InvokeResponseErrorCode, errorMessage: string): InvokeResponse;
                      /**
                       * Create an invoke response with status code and response value.
                       * @param statusCode - The status code.
                       * @param body - The value of the response body.
                       *
                       * @returns An `InvokeResponse` object.
                       */
                      static createInvokeResponse(statusCode: StatusCodes, body?: unknown): InvokeResponse;
                  }

                  /**
                   * Log function for customized logging.
                   */
                  export declare type LogFunction = (level: LogLevel, message: string) => void;

                  /**
                   * Interface for customized logger.
                   */
                  export declare interface Logger {
                      /**
                       * Writes to error level logging or lower.
                       */
                      error(message: string): void;
                      /**
                       * Writes to warning level logging or lower.
                       */
                      warn(message: string): void;
                      /**
                       * Writes to info level logging or lower.
                       */
                      info(message: string): void;
                      /**
                       * Writes to verbose level logging.
                       */
                      verbose(message: string): void;
                  }

                  /**
                   * Log level.
                   */
                  export declare enum LogLevel {
                      /**
                       * Show verbose, information, warning and error message.
                       */
                      Verbose = 0,
                      /**
                       * Show information, warning and error message.
                       */
                      Info = 1,
                      /**
                       * Show warning and error message.
                       */
                      Warn = 2,
                      /**
                       * Show error message.
                       */
                      Error = 3
                  }

                  /**
                   * A {@link NotificationTarget} that represents a team member.
                   *
                   * @remarks
                   * It's recommended to get members from {@link TeamsBotInstallation.members()}.
                   */
                  export declare class Member implements NotificationTarget {
                      /**
                       * The parent {@link TeamsBotInstallation} where this member is created from.
                       */
                      readonly parent: TeamsBotInstallation;
                      /**
                       * Detailed member account information.
                       */
                      readonly account: TeamsChannelAccount;
                      /**
                       * Notification target type. For member it's always "Person".
                       */
                      readonly type: NotificationTargetType;
                      /**
                       * Constructor.
                       *
                       * @remarks
                       * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
                       *
                       * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
                       * @param account - Detailed member account information.
                       */
                      constructor(parent: TeamsBotInstallation, account: TeamsChannelAccount);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - the plain text message.
                       * @param onError - an optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - the adaptive card raw JSON.
                       * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * @internal
                       */
                      private newConversation;
                  }

                  /**
                   * A {@link NotificationTarget} that represents a team member.
                   *
                   * @remarks
                   * It's recommended to get members from {@link TeamsBotInstallation.members()}.
                   */
                  declare class Member_2 implements NotificationTarget {
                      /**
                       * The parent {@link TeamsBotInstallation} where this member is created from.
                       */
                      readonly parent: TeamsBotInstallation_2;
                      /**
                       * Detailed member account information.
                       */
                      readonly account: TeamsChannelAccount;
                      /**
                       * Notification target type. For member it's always "Person".
                       */
                      readonly type: NotificationTargetType;
                      /**
                       * Constructor.
                       *
                       * @remarks
                       * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
                       *
                       * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
                       * @param account - Detailed member account information.
                       */
                      constructor(parent: TeamsBotInstallation_2, account: TeamsChannelAccount);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - The plain text message.
                       * @param onError - An optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - The adaptive card raw JSON.
                       * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * @internal
                       */
                      private newConversation;
                  }

                  /**
                   * Provides utility method to build bot message with cards that supported in Teams.
                   */
                  export declare class MessageBuilder {
                      /**
                       * Build a bot message activity attached with adaptive card.
                       *
                       * @param cardTemplate The adaptive card template.
                       * @param data card data used to render the template.
                       * @returns A bot message activity attached with an adaptive card.
                       *
                       * @example
                       * ```javascript
                       * const cardTemplate = {
                       *   type: "AdaptiveCard",
                       *   body: [
                       *     {
                       *       "type": "TextBlock",
                       *       "text": "${title}",
                       *       "size": "Large"
                       *     },
                       *     {
                       *       "type": "TextBlock",
                       *       "text": "${description}"
                       *     }],
                       *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
                       *     version: "1.4"
                       *  };
                       *
                       * type CardData = {
                       *   title: string,
                       *   description: string
                       * };
                       * const card = MessageBuilder.attachAdaptiveCard<CardData>(
                       *   cardTemplate, {
                       *   title: "sample card title",
                       *   description: "sample card description"
                       * });
                       * ```
                       */
                      static attachAdaptiveCard<TData extends object>(cardTemplate: unknown, data: TData): Partial<Activity>;
                      /**
                       * Build a bot message activity attached with an adaptive card.
                       *
                       * @param card The adaptive card content.
                       * @returns A bot message activity attached with an adaptive card.
                       */
                      static attachAdaptiveCardWithoutData(card: unknown): Partial<Activity>;
                      /**
                       * Build a bot message activity attached with an hero card.
                       *
                       * @param title The card title.
                       * @param images Optional. The array of images to include on the card.
                       * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
                       *      is converted to an `imBack` button with a title and value set to the value of the string.
                       * @param other Optional. Any additional properties to include on the card.
                       *
                       * @returns A bot message activity attached with a hero card.
                       *
                       * @example
                       * ```javascript
                       * const message = MessageBuilder.attachHeroCard(
                       *      'sample title',
                       *      ['https://example.com/sample.jpg'],
                       *      ['action']
                       * );
                       * ```
                       */
                      static attachHeroCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Partial<Activity>;
                      /**
                       * Returns an attachment for a sign-in card.
                       *
                       * @param title The title for the card's sign-in button.
                       * @param url The URL of the sign-in page to use.
                       * @param text Optional. Additional text to include on the card.
                       *
                       * @returns A bot message activity attached with a sign-in card.
                       *
                       * @remarks
                       * For channels that don't natively support sign-in cards, an alternative message is rendered.
                       */
                      static attachSigninCard(title: string, url: string, text?: string): Partial<Activity>;
                      /**
                       * Build a bot message activity attached with an Office 365 connector card.
                       *
                       * @param card A description of the Office 365 connector card.
                       * @returns A bot message activity attached with an Office 365 connector card.
                       */
                      static attachO365ConnectorCard(card: O365ConnectorCard): Partial<Activity>;
                      /**
                       * Build a message activity attached with a receipt card.
                       * @param card A description of the receipt card.
                       * @returns A message activity attached with a receipt card.
                       */
                      static AttachReceiptCard(card: ReceiptCard): Partial<Activity>;
                      /**
                       *
                       * @param title The card title.
                       * @param images Optional. The array of images to include on the card.
                       * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
                       *      is converted to an `imBack` button with a title and value set to the value of the string.
                       * @param other Optional. Any additional properties to include on the card.
                       * @returns A message activity attached with a thumbnail card
                       */
                      static attachThumbnailCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Partial<Activity>;
                      /**
                       * Add an attachement to a bot activity.
                       * @param attachement The attachment object to attach.
                       * @returns A message activity with an attachment.
                       */
                      static attachContent(attachement: Attachment): Partial<Activity>;
                  }

                  /**
                   * Token response provided by Teams Bot SSO prompt
                   */
                  export declare interface MessageExtensionTokenResponse extends TokenResponse {
                      /**
                       * SSO token for user
                       */
                      ssoToken: string;
                      /**
                       * Expire time of SSO token
                       */
                      ssoTokenExpiration: string;
                  }

                  /**
                   * The response of a message action, e.g., `sendMessage`, `sendAdaptiveCard`.
                   */
                  declare interface MessageResponse {
                      /**
                       * Id of the message.
                       */
                      id?: string;
                  }

                  /**
                   * Microsoft Graph auth provider for Teams Framework
                   * @deprecated Use `TokenCredentialAuthenticationProvider` from `@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials` instead.
                   */
                  export declare class MsGraphAuthProvider implements AuthenticationProvider {
                      private credentialOrTeamsFx;
                      private scopes;
                      /**
                       * Constructor of MsGraphAuthProvider.
                       *
                       * @param {TeamsFxConfiguration} teamsfx - Used to provide configuration and auth.
                       * @param {string | string[]} scopes - The list of scopes for which the token will have access.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       *
                       * @returns An instance of MsGraphAuthProvider.
                       */
                      constructor(teamsfx: TeamsFxConfiguration, scopes?: string | string[]);
                      /**
                       * Constructor of MsGraphAuthProvider.
                       *
                       * @param {TokenCredential} credential - credential used to provide configuration and auth.
                       * @param {string | string[]} scopes - The list of scopes for which the token will have access.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       *
                       * @returns An instance of MsGraphAuthProvider.
                       */
                      constructor(credential: TokenCredential, scopes?: string | string[]);
                      /**
                       * Get access token for Microsoft Graph API requests.
                       *
                       * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
                       * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
                       * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
                       * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       *
                       * @returns Access token from the credential.
                       *
                       */
                      getAccessToken(): Promise<string>;
                  }

                  /**
                   * Provide utilities to send notification to varies targets (e.g., member, group, channel).
                   */
                  /**
                   * @deprecated Use `BotBuilderCloudAdapter.NotificationBot` instead.
                   */
                  export declare class NotificationBot {
                      private readonly conversationReferenceStore;
                      private readonly adapter;
                      /**
                       * constructor of the notification bot.
                       *
                       * @remarks
                       * To ensure accuracy, it's recommended to initialize before handling any message.
                       *
                       * @param adapter - the bound `BotFrameworkAdapter`
                       * @param options - initialize options
                       */
                      constructor(adapter: BotFrameworkAdapter, options?: NotificationOptions_2);
                      /**
                       * Get all targets where the bot is installed.
                       *
                       * @remarks
                       * The result is retrieving from the persisted storage.
                       *
                       * @returns - an array of {@link TeamsBotInstallation}.
                       */
                      installations(): Promise<TeamsBotInstallation[]>;
                      /**
                       * Returns the first {@link Member} where predicate is true, and undefined otherwise.
                       *
                       * @param predicate find calls predicate once for each member of the installation,
                       * until it finds one where predicate returns true. If such a member is found, find
                       * immediately returns that member. Otherwise, find returns undefined.
                       * @param scope the scope to find members from the installations
                       * (personal chat, group chat, Teams channel).
                       * @returns the first {@link Member} where predicate is true, and undefined otherwise.
                       */
                      findMember(predicate: (member: Member) => Promise<boolean>, scope?: SearchScope): Promise<Member | undefined>;
                      /**
                       * Returns the first {@link Channel} where predicate is true, and undefined otherwise.
                       * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
                       *
                       * @param predicate find calls predicate once for each channel of the installation,
                       * until it finds one where predicate returns true. If such a channel is found, find
                       * immediately returns that channel. Otherwise, find returns undefined.
                       * @returns the first {@link Channel} where predicate is true, and undefined otherwise.
                       */
                      findChannel(predicate: (channel: Channel, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel | undefined>;
                      /**
                       * Returns all {@link Member} where predicate is true, and empty array otherwise.
                       *
                       * @param predicate find calls predicate for each member of the installation.
                       * @param scope the scope to find members from the installations
                       * (personal chat, group chat, Teams channel).
                       * @returns an array of {@link Member} where predicate is true, and empty array otherwise.
                       */
                      findAllMembers(predicate: (member: Member) => Promise<boolean>, scope?: SearchScope): Promise<Member[]>;
                      /**
                       * Returns all {@link Channel} where predicate is true, and empty array otherwise.
                       * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
                       *
                       * @param predicate find calls predicate for each channel of the installation.
                       * @returns an array of {@link Channel} where predicate is true, and empty array otherwise.
                       */
                      findAllChannels(predicate: (channel: Channel, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel[]>;
                      private matchSearchScope;
                  }

                  /**
                   * Provide utilities to send notification to varies targets (e.g., member, group, channel).
                   */
                  declare class NotificationBot_2 {
                      private readonly conversationReferenceStore;
                      private readonly adapter;
                      private readonly botAppId;
                      /**
                       * Constructor of the notification bot.
                       *
                       * @remarks
                       * To ensure accuracy, it's recommended to initialize before handling any message.
                       *
                       * @param adapter - The bound `CloudAdapter`
                       * @param options - The initialize options
                       */
                      constructor(adapter: CloudAdapter, options?: NotificationOptions_3);
                      /**
                       * Create a {@link TeamsBotInstallation} instance with conversation reference.
                       *
                       * @param conversationReference - The bound `ConversationReference`.
                       * @returns - The {@link TeamsBotInstallation} instance or null.
                       */
                      buildTeamsBotInstallation(conversationReference: Partial<ConversationReference>): TeamsBotInstallation_2 | null;
                      /**
                       * Validate the installation by getting paged memebers.
                       *
                       * @param conversationReference The bound `ConversationReference`.
                       * @returns Returns false if recieves `BotNotInConversationRoster` error, otherwise returns true.
                       */
                      validateInstallation(conversationReference: Partial<ConversationReference>): Promise<boolean>;
                      /**
                       * Gets a pagined list of targets where the bot is installed.
                       *
                       * @remarks
                       * The result is retrieving from the persisted storage.
                       *
                       * @param pageSize - Suggested number of entries on a page.
                       * @param continuationToken - A continuation token.
                       *
                       * @returns An array of {@link TeamsBotInstallation} with paged data and continuation token.
                       */
                      getPagedInstallations(pageSize?: number, continuationToken?: string, validationEnabled?: boolean): Promise<PagedData<TeamsBotInstallation_2>>;
                      /**
                       * Get all targets where the bot is installed.
                       *
                       * @remarks
                       * The result is retrieving from the persisted storage.
                       *
                       * @returns An array of {@link TeamsBotInstallation}.
                       *
                       * @deprecated Use getPagedInstallations instead.
                       */
                      installations(): Promise<TeamsBotInstallation_2[]>;
                      /**
                       * Return the first {@link Member} where predicate is true, and undefined otherwise.
                       *
                       * @param predicate - Find calls predicate once for each member of the installation,
                       * until it finds one where predicate returns true. If such a member is found, find
                       * immediately returns that member. Otherwise, find returns undefined.
                       * @param scope - The scope to find members from the installations
                       * (personal chat, group chat, Teams channel).
                       *
                       * @returns The first {@link Member} where predicate is true, and `undefined` otherwise.
                       */
                      findMember(predicate: (member: Member_2) => Promise<boolean>, scope?: SearchScope_2): Promise<Member_2 | undefined>;
                      /**
                       * Return the first {@link Channel} where predicate is true, and undefined otherwise.
                       * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
                       *
                       * @param predicate - Find calls predicate once for each channel of the installation,
                       * until it finds one where predicate returns true. If such a channel is found, find
                       * immediately returns that channel. Otherwise, find returns `undefined`.
                       *
                       * @returns The first {@link Channel} where predicate is true, and `undefined` otherwise.
                       */
                      findChannel(predicate: (channel: Channel_2, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel_2 | undefined>;
                      /**
                       * Return all {@link Member} where predicate is true, and empty array otherwise.
                       *
                       * @param predicate - Find calls predicate for each member of the installation.
                       * @param scope - The scope to find members from the installations
                       * (personal chat, group chat, Teams channel).
                       *
                       * @returns An array of {@link Member} where predicate is true, and empty array otherwise.
                       */
                      findAllMembers(predicate: (member: Member_2) => Promise<boolean>, scope?: SearchScope_2): Promise<Member_2[]>;
                      /**
                       * Return all {@link Channel} where predicate is true, and empty array otherwise.
                       * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
                       *
                       * @param predicate - Find calls predicate for each channel of the installation.
                       *
                       * @returns An array of {@link Channel} where predicate is true, and empty array otherwise.
                       */
                      findAllChannels(predicate: (channel: Channel_2, teamDetails: TeamDetails | undefined) => Promise<boolean>): Promise<Channel_2[]>;
                      private matchSearchScope;
                  }

                  /**
                   * Options to initialize {@link NotificationBot}.
                   * @deprecated Please use BotBuilderCloudAdapter.NotificationOptions instead.
                   */
                  declare interface NotificationOptions_2 {
                      /**
                       * An optional storage to persist bot notification connections.
                       *
                       * @remarks
                       * If `storage` is not provided, a default local file storage will be used,
                       * which stores notification connections into:
                       *   - ".notification.localstore.json" if running locally
                       *   - "${process.env.TEMP}/.notification.localstore.json" if `process.env.RUNNING_ON_AZURE` is set to "1"
                       *
                       * It's recommended to use your own shared storage for production environment.
                       */
                      storage?: NotificationTargetStorage;
                  }
                  export { NotificationOptions_2 as NotificationOptions }

                  /**
                   * Options to initialize {@link NotificationBot}.
                   */
                  declare interface NotificationOptions_3 {
                      /**
                       * An optional input of bot app Id.
                       *
                       * @remarks
                       * If `botAppId` is not provided, `process.env.BOT_ID` will be used by default.
                       */
                      botAppId?: string;
                      /**
                       * An optional store to persist bot notification target references.
                       *
                       * @remarks
                       * If `store` is not provided, a default conversation reference store will be used,
                       * which stores notification target references into:
                       *  - `.notification.localstore.json` if running locally
                       *  - `${process.env.TEMP}/.notification.localstore.json` if `process.env.RUNNING_ON_AZURE` is set to "1"
                       *
                       * It's recommended to use your own store for production environment.
                       */
                      store?: ConversationReferenceStore;
                      /**
                       * An optional storage to persist bot notification target references.
                       *
                       * @remarks
                       * If `storage` is not provided, a default local file storage will be used,
                       * which stores notification target references into:
                       *   - `.notification.localstore.json` if running locally
                       *   - `${process.env.TEMP}/.notification.localstore.json` if `process.env.RUNNING_ON_AZURE` is set to "1"
                       *
                       * It's recommended to use your own shared storage for production environment.
                       *
                       * @deprecated Use `store` to customize the way to persist bot notification target references instead.
                       */
                      storage?: NotificationTargetStorage;
                  }

                  /**
                   * Represent a notification target.
                   */
                  export declare interface NotificationTarget {
                      /**
                       * The type of target, could be "Channel" or "Group" or "Person".
                       */
                      readonly type?: NotificationTargetType;
                      /**
                       * Send a plain text message.
                       *
                       * @param text - the plain text message.
                       * @param onError - an optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns the response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - the adaptive card raw JSON.
                       * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns the response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                  }

                  /**
                   * Interface for a storage provider that stores and retrieves notification target references.
                   *
                   * @deprecated Use ConversationReferenceStore to customize the way
                   * to persist bot notification connections instead.
                   */
                  export declare interface NotificationTargetStorage {
                      /**
                       * Read one notification target by its key.
                       *
                       * @param key - the key of a notification target.
                       *
                       * @returns - the notification target. Or undefined if not found.
                       */
                      read(key: string): Promise<{
                          [key: string]: unknown;
                      } | undefined>;
                      /**
                       * List all stored notification targets.
                       *
                       * @returns - an array of notification target. Or an empty array if nothing is stored.
                       */
                      list(): Promise<{
                          [key: string]: unknown;
                      }[]>;
                      /**
                       * Write one notification target by its key.
                       *
                       * @param key - the key of a notification target.
                       * @param object - the notification target.
                       */
                      write(key: string, object: {
                          [key: string]: unknown;
                      }): Promise<void>;
                      /**
                       * Delete one notification target by its key.
                       *
                       * @param key - the key of a notification target.
                       */
                      delete(key: string): Promise<void>;
                  }

                  /**
                   * The target type where the notification will be sent to.
                   *
                   * @remarks
                   * - "Channel" means to a team channel. (By default, notification to a team will be sent to its "General" channel.)
                   * - "Group" means to a group chat.
                   * - "Person" means to a personal chat.
                   */
                  export declare enum NotificationTargetType {
                      /**
                       * The notification will be sent to a team channel.
                       * (By default, notification to a team will be sent to its "General" channel.)
                       */
                      Channel = "Channel",
                      /**
                       * The notification will be sent to a group chat.
                       */
                      Group = "Group",
                      /**
                       * The notification will be sent to a personal chat.
                       */
                      Person = "Person"
                  }

                  /**
                   * Authentication configuration for OnBehalfOfCredential used in node environment
                   */
                  export declare type OnBehalfOfCredentialAuthConfig = {
                      /**
                       * Hostname of AAD authority.
                       */
                      authorityHost: string;
                      /**
                       * The client (application) ID of an App Registration in the tenant
                       */
                      clientId: string;
                      /**
                       * AAD tenant id
                       *
                       * @readonly
                       */
                      tenantId: string;
                  } & ({
                      /**
                       * Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.
                       */
                      clientSecret: string;
                      certificateContent?: never;
                  } | {
                      clientSecret?: never;
                      /**
                       * The content of a PEM-encoded public/private key certificate.
                       *
                       * @readonly
                       */
                      certificateContent: string;
                  });

                  /**
                   * Represent on-behalf-of flow to get user identity, and it is designed to be used in server side.
                   *
                   * @example
                   * ```typescript
                   * const credential = new OnBehalfOfUserCredential(ssoToken);
                   * ```
                   *
                   * @remarks
                   * Can only be used in server side.
                   */
                  export declare class OnBehalfOfUserCredential implements TokenCredential {
                      private msalClient;
                      private ssoToken;
                      /**
                       * Constructor of OnBehalfOfUserCredential
                       *
                       * @remarks
                       * Only works in in server side.
                       *
                       * @param {string} ssoToken - User token provided by Teams SSO feature.
                       * @param {OnBehalfOfCredentialAuthConfig} config - The authentication configuration.
                       *
                       * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret, certificate content, authority host or tenant id is not found in config.
                       * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       */
                      constructor(ssoToken: string, config: OnBehalfOfCredentialAuthConfig);
                      /**
                       * Constructor of OnBehalfOfUserCredential
                       *
                       * @remarks
                       * Only works in in server side.
                       *
                       * @param {string} ssoToken - User token provided by Teams SSO feature.
                       * @param {AuthenticationConfiguration} config - The authentication configuration. Use environment variables if not provided.
                       *
                       * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret, certificate content, authority host or tenant id is not found in config.
                       * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       */
                      constructor(ssoToken: string, config: AuthenticationConfiguration);
                      /**
                       * Get access token from credential.
                       *
                       * @example
                       * ```typescript
                       * await credential.getToken([]) // Get SSO token using empty string array
                       * await credential.getToken("") // Get SSO token using empty string
                       * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
                       * await credential.getToken(".default") // Get Graph access token with default scope using string
                       * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
                       * await credential.getToken("User.Read") // Get Graph access token for single scope using string
                       * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
                       * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
                       * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
                       * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
                       * ```
                       *
                       * @param {string | string[]} scopes - The list of scopes for which the token will have access.
                       * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
                       *
                       * @throws {@link ErrorCode|InternalError} when failed to acquire access token on behalf of user with unknown error.
                       * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
                       * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
                       * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       *
                       * @returns Access token with expected scopes.
                       *
                       * @remarks
                       * If scopes is empty string or array, it returns SSO token.
                       * If scopes is non-empty, it returns access token for target scope.
                       */
                      getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
                      /**
                       * Get basic user info from SSO token.
                       *
                       * @example
                       * ```typescript
                       * const currentUser = getUserInfo();
                       * ```
                       *
                       * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       *
                       * @returns Basic user info with user displayName, objectId and preferredUserName.
                       */
                      getUserInfo(): UserInfo;
                      private generateAuthServerError;
                  }

                  /**
                   * Represents a page of data.
                   */
                  export declare interface PagedData<T> {
                      /**
                       * Page of data.
                       */
                      data: T[];
                      /**
                       * The Continuation Token to pass to get the next page of results.
                       *
                       * @remarks
                       * Undefined or empty token means the page reaches the end.
                       */
                      continuationToken?: string;
                  }

                  /**
                   * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
                   * The search scope is a flagged enum and it can be combined with `|`.
                   * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
                   */
                  export declare enum SearchScope {
                      /**
                       * Search members from the installations in personal chat only.
                       */
                      Person = 1,
                      /**
                       * Search members from the installations in group chat only.
                       */
                      Group = 2,
                      /**
                       * Search members from the installations in Teams channel only.
                       */
                      Channel = 4,
                      /**
                       * Search members from all installations including personal chat, group chat and Teams channel.
                       */
                      All = 7
                  }

                  /**
                   * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
                   * The search scope is a flagged enum and it can be combined with `|`.
                   * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
                   */
                  declare enum SearchScope_2 {
                      /**
                       * Search members from the installations in personal chat only.
                       */
                      Person = 1,
                      /**
                       * Search members from the installations in group chat only.
                       */
                      Group = 2,
                      /**
                       * Search members from the installations in Teams channel only.
                       */
                      Channel = 4,
                      /**
                       * Search members from all installations including personal chat, group chat and Teams channel.
                       */
                      All = 7
                  }

                  /**
                   * Send an adaptive card message to a notification target.
                   *
                   * @param target - the notification target.
                   * @param card - the adaptive card raw JSON.
                   * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
                   * If not defined, error will be handled by `BotAdapter.onTurnError`.
                   * @returns the response of sending adaptive card message.
                   */
                  export declare function sendAdaptiveCard(target: NotificationTarget, card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

                  /**
                   * Send an adaptive card message to a notification target.
                   *
                   * @param target - The notification target.
                   * @param card - The adaptive card raw JSON.
                   * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
                   * If not defined, error will be handled by `BotAdapter.onTurnError`.
                   *
                   * @returns The response of sending adaptive card message.
                   */
                  declare function sendAdaptiveCard_2(target: NotificationTarget, card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

                  /**
                   * Send a plain text message to a notification target.
                   *
                   * @param target - the notification target.
                   * @param text - the plain text message.
                   * @param onError - an optional error handler that can catch exceptions during message sending.
                   * If not defined, error will be handled by `BotAdapter.onTurnError`.
                   * @returns the response of sending message.
                   */
                  export declare function sendMessage(target: NotificationTarget, text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

                  /**
                   * Send a plain text message to a notification target.
                   *
                   * @param target - The notification target.
                   * @param text - The plain text message.
                   * @param onError - An optional error handler that can catch exceptions during message sending.
                   * If not defined, error will be handled by `BotAdapter.onTurnError`.
                   *
                   * @returns The response of sending message.
                   */
                  declare function sendMessage_2(target: NotificationTarget, text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;

                  /**
                   * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
                   *
                   * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
                   *
                   * @example
                   * ```typescript
                   * setLogFunction((level: LogLevel, message: string) => {
                   *   if (level === LogLevel.Error) {
                   *     console.log(message);
                   *   }
                   * });
                   * ```
                   */
                  export declare function setLogFunction(logFunction?: LogFunction): void;

                  /**
                   * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
                   *
                   * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
                   *
                   * @example
                   * ```typescript
                   * setLogger({
                   *   verbose: console.debug,
                   *   info: console.info,
                   *   warn: console.warn,
                   *   error: console.error,
                   * });
                   * ```
                   */
                  export declare function setLogger(logger?: Logger): void;

                  /**
                   * Update log level helper.
                   *
                   * @param { LogLevel } level - log level in configuration
                   */
                  export declare function setLogLevel(level: LogLevel): void;

                  /**
                   * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
                   * - Personal chat
                   * - Group chat
                   * - Team (by default the `General` channel)
                   *
                   * @remarks
                   * It's recommended to get bot installations from {@link ConversationBot.installations()}.
                   */
                  /**
                   * @deprecated Use `BotBuilderCloudAdapter.TeamsBotInstallation` instead.
                   */
                  export declare class TeamsBotInstallation implements NotificationTarget {
                      /**
                       * The bound `BotFrameworkAdapter`.
                       */
                      readonly adapter: BotFrameworkAdapter;
                      /**
                       * The bound `ConversationReference`.
                       */
                      readonly conversationReference: Partial<ConversationReference>;
                      /**
                       * Notification target type.
                       *
                       * @remarks
                       * - "Channel" means bot is installed into a team and notification will be sent to its "General" channel.
                       * - "Group" means bot is installed into a group chat.
                       * - "Person" means bot is installed into a personal scope and notification will be sent to personal chat.
                       */
                      readonly type?: NotificationTargetType;
                      /**
                       * Constructor
                       *
                       * @remarks
                       * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
                       *
                       * @param adapter - the bound `BotFrameworkAdapter`.
                       * @param conversationReference - the bound `ConversationReference`.
                       */
                      constructor(adapter: BotFrameworkAdapter, conversationReference: Partial<ConversationReference>);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - the plain text message.
                       * @param onError - an optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - the adaptive card raw JSON.
                       * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       * @returns the response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Get channels from this bot installation.
                       *
                       * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
                       */
                      channels(): Promise<Channel[]>;
                      /**
                       * Get members from this bot installation.
                       *
                       * @returns an array of members from where the bot is installed.
                       */
                      members(): Promise<Member[]>;
                      /**
                       * Get team details from this bot installation
                       *
                       * @returns the team details if bot is installed into a team, otherwise returns undefined.
                       */
                      getTeamDetails(): Promise<TeamDetails | undefined>;
                  }

                  /**
                   * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
                   * - Personal chat
                   * - Group chat
                   * - Team (by default the `General` channel)
                   *
                   * @remarks
                   * It's recommended to get bot installations from {@link ConversationBot.installations()}.
                   */
                  declare class TeamsBotInstallation_2 implements NotificationTarget {
                      /**
                       * The bound `CloudAdapter`.
                       */
                      readonly adapter: CloudAdapter;
                      /**
                       * The bound `ConversationReference`.
                       */
                      readonly conversationReference: Partial<ConversationReference>;
                      /**
                       * The bot app id.
                       */
                      readonly botAppId: string;
                      /**
                       * Notification target type.
                       *
                       * @remarks
                       * - "Channel" means bot is installed into a team and notification will be sent to its "General" channel.
                       * - "Group" means bot is installed into a group chat.
                       * - "Person" means bot is installed into a personal scope and notification will be sent to personal chat.
                       */
                      readonly type?: NotificationTargetType;
                      /**
                       * Constructor
                       *
                       * @remarks
                       * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
                       *
                       * @param adapter - The bound `CloudAdapter`.
                       * @param conversationReference - The bound `ConversationReference`.
                       * @param botAppId - The bot app id.
                       */
                      constructor(adapter: CloudAdapter, conversationReference: Partial<ConversationReference>, botAppId: string);
                      /**
                       * Send a plain text message.
                       *
                       * @param text - The plain text message.
                       * @param onError - An optional error handler that can catch exceptions during message sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending message.
                       */
                      sendMessage(text: string, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Send an adaptive card message.
                       *
                       * @param card - The adaptive card raw JSON.
                       * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
                       * If not defined, error will be handled by `BotAdapter.onTurnError`.
                       *
                       * @returns The response of sending adaptive card message.
                       */
                      sendAdaptiveCard(card: unknown, onError?: (context: TurnContext, error: Error) => Promise<void>): Promise<MessageResponse>;
                      /**
                       * Get channels from this bot installation.
                       *
                       * @returns An array of channels if bot is installed into a team, otherwise returns an empty array.
                       */
                      channels(): Promise<Channel_2[]>;
                      /**
                       * Gets a pagined list of members from this bot installation.
                       *
                       * @param pageSize - Suggested number of entries on a page.
                       * @param continuationToken - A continuation token.
                       * @returns An array of members from where the bot is installed.
                       */
                      getPagedMembers(pageSize?: number, continuationToken?: string): Promise<PagedData<Member_2>>;
                      /**
                       * Get members from this bot installation.
                       *
                       * @returns An array of members from where the bot is installed.
                       *
                       * @deprecated Use `getPagedMembers` instead.
                       */
                      members(): Promise<Member_2[]>;
                      /**
                       * Get team details from this bot installation
                       *
                       * @returns The team details if bot is installed into a team, otherwise returns `undefined`.
                       */
                      getTeamDetails(): Promise<TeamDetails | undefined>;
                  }

                  /**
                   * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
                   * help receive oauth token, asks the user to consent if needed.
                   *
                   * @remarks
                   * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
                   * the token store.
                   *
                   * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
                   * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
                   *
                   * @example
                   * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
                   * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
                   * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
                   * needed and their access token will be passed as an argument to the callers next waterfall step:
                   *
                   * ```JavaScript
                   * const { ConversationState, MemoryStorage } = require('botbuilder');
                   * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
                   * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
                   *
                   * const convoState = new ConversationState(new MemoryStorage());
                   * const dialogState = convoState.createProperty('dialogState');
                   * const dialogs = new DialogSet(dialogState);
                   *
                   * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
                   *    scopes: ["User.Read"],
                   * }));
                   *
                   * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
                   *      async (step) => {
                   *          return await step.beginDialog('TeamsBotSsoPrompt');
                   *      },
                   *      async (step) => {
                   *          const token = step.result;
                   *          if (token) {
                   *
                   *              // ... continue with task needing access token ...
                   *
                   *          } else {
                   *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
                   *              return await step.endDialog();
                   *          }
                   *      }
                   * ]));
                   * ```
                   */
                  export declare class TeamsBotSsoPrompt extends Dialog {
                      private authConfig;
                      private initiateLoginEndpoint;
                      private settings;
                      /**
                       * Constructor of TeamsBotSsoPrompt.
                       *
                       * @param {TeamsFx} teamsfx - Used to provide configuration and auth
                       * @param {string} dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
                       * @param {TeamsBotSsoPromptSettings} settings Settings used to configure the prompt.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       */
                      constructor(teamsfx: TeamsFx, dialogId: string, settings: TeamsBotSsoPromptSettings);
                      /**
                       * Constructor of TeamsBotSsoPrompt.
                       *
                       * @param {OnBehalfOfCredentialAuthConfig} authConfig - Used to provide configuration and auth
                       * @param {string} initiateLoginEndpoint - Login URL for Teams to redirect to
                       * @param {string} dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
                       * @param {TeamsBotSsoPromptSettings} settings Settings used to configure the prompt.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       */
                      constructor(authConfig: OnBehalfOfCredentialAuthConfig, initiateLoginEndpoint: string, dialogId: string, settings: TeamsBotSsoPromptSettings);
                      /**
                       * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
                       * @remarks
                       * If the task is successful, the result indicates whether the prompt is still
                       * active after the turn has been processed by the prompt.
                       *
                       * @param dc The DialogContext for the current turn of the conversation.
                       *
                       * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
                       * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       *
                       * @returns A `Promise` representing the asynchronous operation.
                       */
                      beginDialog(dc: DialogContext): Promise<DialogTurnResult>;
                      /**
                       * Called when a prompt dialog is the active dialog and the user replied with a new activity.
                       *
                       * @remarks
                       * If the task is successful, the result indicates whether the dialog is still
                       * active after the turn has been processed by the dialog.
                       * The prompt generally continues to receive the user's replies until it accepts the
                       * user's reply as valid input for the prompt.
                       *
                       * @param dc The DialogContext for the current turn of the conversation.
                       *
                       * @returns A `Promise` representing the asynchronous operation.
                       *
                       * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
                       */
                      continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
                      private loadAndValidateConfig;
                      /**
                       * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
                       * @param dc dialog context
                       * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
                       * @internal
                       */
                      private ensureMsTeamsChannel;
                      /**
                       * Send OAuthCard that tells Teams to obtain an authentication token for the bot application.
                       * For details see https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots.
                       *
                       * @internal
                       */
                      private sendOAuthCardAsync;
                      /**
                       * Get sign in resource.
                       *
                       * @throws {@link ErrorCode|InvalidConfiguration} if client id, tenant id or initiate login endpoint is not found in config.
                       *
                       * @internal
                       */
                      private getSignInResource;
                      /**
                       * @internal
                       */
                      private recognizeToken;
                      /**
                       * @internal
                       */
                      private getTokenExchangeInvokeResponse;
                      /**
                       * @internal
                       */
                      private isTeamsVerificationInvoke;
                      /**
                       * @internal
                       */
                      private isTokenExchangeRequestInvoke;
                      /**
                       * @internal
                       */
                      private isTokenExchangeRequest;
                  }

                  /**
                   * Settings used to configure an TeamsBotSsoPrompt instance.
                   */
                  export declare interface TeamsBotSsoPromptSettings {
                      /**
                       * The array of strings that declare the desired permissions and the resources requested.
                       */
                      scopes: string[];
                      /**
                       * (Optional) number of milliseconds the prompt will wait for the user to authenticate.
                       * Defaults to a value `900,000` (15 minutes.)
                       */
                      timeout?: number;
                      /**
                       * (Optional) value indicating whether the TeamsBotSsoPrompt should end upon receiving an
                       * invalid message.  Generally the TeamsBotSsoPrompt will end the auth flow when receives user
                       * message not related to the auth flow. Setting the flag to false ignores the user's message instead.
                       * Defaults to value `true`
                       */
                      endOnInvalidMessage?: boolean;
                  }

                  /**
                   * Token response provided by Teams Bot SSO prompt
                   */
                  export declare interface TeamsBotSsoPromptTokenResponse extends TokenResponse {
                      /**
                       * SSO token for user
                       */
                      ssoToken: string;
                      /**
                       * Expire time of SSO token
                       */
                      ssoTokenExpiration: string;
                  }

                  /**
                   * A class providing credential and configuration.
                   * @deprecated Please use {@link TeamsUserCredential}
                   * in browser environment and {@link OnBehalfOfUserCredential} or {@link AppCredential} in NodeJS.
                   */
                  export declare class TeamsFx implements TeamsFxConfiguration {
                      private configuration;
                      private oboUserCredential?;
                      private appCredential?;
                      private identityType;
                      /**
                       * Constructor of TeamsFx
                       *
                       * @param {IdentityType} identityType - Choose user or app identity
                       * @param customConfig - key/value pairs of customized configuration that overrides default ones.
                       *
                       * @throws {@link ErrorCode|IdentityTypeNotSupported} when setting app identity in browser.
                       */
                      constructor(identityType?: IdentityType, customConfig?: Record<string, string> | AuthenticationConfiguration);
                      /**
                       * Identity type set by user.
                       *
                       * @returns identity type.
                       */
                      getIdentityType(): IdentityType;
                      /**
                       * Credential instance according to identity type choice.
                       *
                       * @remarks If user identity is chose, will return {@link TeamsUserCredential}
                       * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
                       * identity is chose, will return {@link AppCredential}.
                       *
                       * @returns instance implements TokenCredential interface.
                       */
                      getCredential(): TokenCredential;
                      /**
                       * Get user information.
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       * @returns UserInfo object.
                       */
                      getUserInfo(resources?: string[]): Promise<UserInfo>;
                      /**
                       * Popup login page to get user's access token with specific scopes.
                       *
                       * @remarks
                       * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
                       *
                       * @example
                       * ```typescript
                       * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
                       * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
                       * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
                       * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
                       * ```
                       * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       *
                       * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
                       * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
                       */
                      login(scopes: string | string[], resources?: string[]): Promise<void>;
                      /**
                       * Set SSO token when using user identity in NodeJS.
                       * @param {string} ssoToken - used for on behalf of user flow.
                       * @returns self instance.
                       */
                      setSsoToken(ssoToken: string): TeamsFx;
                      /**
                       * Usually used by service plugins to retrieve specific config
                       * @param {string} key - configuration key.
                       * @returns value in configuration.
                       */
                      getConfig(key: string): string;
                      /**
                       * Check the value of specific key.
                       * @param {string} key - configuration key.
                       * @returns true if corresponding value is not empty string.
                       */
                      hasConfig(key: string): boolean;
                      /**
                       * Get all configurations.
                       * @returns key value mappings.
                       */
                      getConfigs(): Record<string, string>;
                      /**
                       * Load configuration from environment variables.
                       */
                      private loadFromEnv;
                  }

                  /**
                   * Interface for adaptive card action handler that can process card action invoke and return a response.
                   */
                  export declare interface TeamsFxAdaptiveCardActionHandler {
                      /**
                       * The verb defined in adaptive card action that can trigger this handler.
                       * The verb string here is case-insensitive.
                       */
                      triggerVerb: string;
                      /**
                       * Specify the behavior for how the card response will be sent in Teams conversation.
                       * The default value is `AdaptiveCardResponse.ReplaceForInteractor`, which means the card
                       * response will replace the current one only for the interactor.
                       */
                      adaptiveCardResponse?: AdaptiveCardResponse;
                      /**
                       * The handler function that will be invoked when the action is fired.
                       * @param context The turn context.
                       * @param actionData The contextual data that associated with the action.
                       *
                       * @returns A `Promise` representing a invoke response for the adaptive card invoke action.
                       * You can use the `InvokeResponseFactory` utility class to create an invoke response from
                       *  - A text message:
                       *   ```typescript
                       *   return InvokeResponseFactory.textMessage("Action is processed successfully!");
                       *   ```
                       *  - An adaptive card:
                       *    ```typescript
                       *    const responseCard = AdaptiveCards.declare(helloWorldCard).render(actionData);
                       return InvokeResponseFactory.adaptiveCard(responseCard);
                       *    ```
                       *  - An error response:
                       *     ```typescript
                       *     return InvokeResponseFactory.errorResponse(InvokeResponseErrorCode.BadRequest, "Invalid request");
                       *     ```
                       *
                       * @remarks For more details about the invoke response format, refer to https://docs.microsoft.com/en-us/adaptive-cards/authoring-cards/universal-action-model#response-format.
                       */
                      handleActionInvoked(context: TurnContext, actionData: any): Promise<InvokeResponse>;
                  }

                  /**
                   * Interface for a command handler that can process command to a TeamsFx bot and return a response.
                   */
                  export declare interface TeamsFxBotCommandHandler {
                      /**
                       * The string or regular expression patterns that can trigger this handler.
                       */
                      triggerPatterns: TriggerPatterns;
                      /**
                       * Handles a bot command received activity.
                       *
                       * @param context The bot context.
                       * @param message The command message the user types from Teams.
                       * @returns A `Promise` representing an activity or text to send as the command response.
                       * Or no return value if developers want to send the response activity by themselves in this method.
                       */
                      handleCommandReceived(context: TurnContext, message: CommandMessage): Promise<string | Partial<Activity> | void>;
                  }

                  /**
                   * Interface for a command handler that can process sso command to a TeamsFx bot and return a response.
                   */
                  export declare interface TeamsFxBotSsoCommandHandler {
                      /**
                       * The string or regular expression patterns that can trigger this handler.
                       */
                      triggerPatterns: TriggerPatterns;
                      /**
                       * Handles a bot command received activity.
                       *
                       * @param context The bot context.
                       * @param message The command message the user types from Teams.
                       * @param tokenResponse The tokenResponse which contains sso token that can be used to exchange access token for the bot.
                       * @returns A `Promise` representing an activity or text to send as the command response.
                       * Or no return value if developers want to send the response activity by themselves in this method.
                       */
                      handleCommandReceived(context: TurnContext, message: CommandMessage, tokenResponse: TeamsBotSsoPromptTokenResponse): Promise<string | Partial<Activity> | void>;
                  }

                  /**
                   * TeamsFx interface that provides credential and configuration.
                   * @deprecated Please use {@link TeamsUserCredential}
                   * in browser environment and {@link OnBehalfOfUserCredential} or {@link AppCredential} in NodeJS.
                   */
                  declare interface TeamsFxConfiguration {
                      /**
                       * Identity type set by user.
                       *
                       * @returns identity type.
                       */
                      getIdentityType(): IdentityType;
                      /**
                       * Credential instance according to identity type choice.
                       *
                       * @remarks If user identity is chose, will return {@link TeamsUserCredential}
                       * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
                       * identity is chose, will return {@link AppCredential}.
                       *
                       * @returns instance implements TokenCredential interface.
                       */
                      getCredential(): TokenCredential;
                      /**
                       * Get user information.
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       * @returns UserInfo object.
                       */
                      getUserInfo(resources?: string[]): Promise<UserInfo>;
                      /**
                       * Popup login page to get user's access token with specific scopes.
                       *
                       * @remarks
                       * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
                       *
                       * @example
                       * ```typescript
                       * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
                       * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
                       * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
                       * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
                       * ```
                       * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       *
                       * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
                       * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
                       * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
                       * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
                       */
                      login(scopes: string | string[], resources?: string[]): Promise<void>;
                      /**
                       * Set SSO token when using user identity in NodeJS.
                       * @param {string} ssoToken - used for on behalf of user flow.
                       * @returns self instance.
                       */
                      setSsoToken(ssoToken: string): TeamsFxConfiguration;
                      /**
                       * Usually used by service plugins to retrieve specific config
                       * @param {string} key - configuration key.
                       * @returns value in configuration.
                       */
                      getConfig(key: string): string;
                      /**
                       * Check the value of specific key.
                       * @param {string} key - configuration key.
                       * @returns true if corresponding value is not empty string.
                       */
                      hasConfig(key: string): boolean;
                      /**
                       * Get all configurations.
                       * @returns key value mappings.
                       */
                      getConfigs(): Record<string, string>;
                  }

                  /**
                   * Represent Teams current user's identity, and it is used within Teams client applications.
                   *
                   * @remarks
                   * Can only be used within Teams.
                   */
                  export declare class TeamsUserCredential implements TokenCredential {
                      /**
                       * Constructor of TeamsUserCredential.
                       * @remarks
                       * Can only be used within Teams.
                       */
                      constructor(authConfig: TeamsUserCredentialAuthConfig);
                      constructor(authConfig: AuthenticationConfiguration);
                      /**
                       * Popup login page to get user's access token with specific scopes.
                       *
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       *
                       * @remarks
                       * Can only be used within Teams.
                       */
                      login(scopes: string | string[], resources?: string[]): Promise<void>;
                      /**
                       * Get access token from credential.
                       * @remarks
                       * Can only be used within Teams.
                       */
                      getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
                      /**
                       * Get basic user info from SSO token
                       *
                       * @param {string[]} resources - The optional list of resources for full trust Teams apps.
                       *
                       * @remarks
                       * Can only be used within Teams.
                       */
                      getUserInfo(resources?: string[]): Promise<UserInfo>;
                  }

                  /**
                   * Authentication configuration for TeamsUserCredential used in browser environment
                   */
                  export declare type TeamsUserCredentialAuthConfig = {
                      /**
                       * Login page for Teams to redirect to.
                       */
                      initiateLoginEndpoint: string;
                      /**
                       * The client (application) ID of an App Registration in the tenant
                       */
                      clientId: string;
                  };

                  /**
                   * The trigger pattern used to trigger a {@link TeamsFxBotCommandHandler} instance.
                   */
                  export declare type TriggerPatterns = string | RegExp | (string | RegExp)[];

                  /**
                   * UserInfo with user displayName, objectId and preferredUserName.
                   */
                  export declare interface UserInfo {
                      /**
                       * User Display Name.
                       *
                       * @readonly
                       */
                      displayName: string;
                      /**
                       * User unique reference within the Azure Active Directory domain.
                       *
                       * @readonly
                       */
                      objectId: string;
                      /**
                       * User tenant ID.
                       *
                       * @readonly
                       */
                      tenantId: string;
                      /**
                       * Usually be the email address.
                       *
                       * @readonly
                       */
                      preferredUserName: string;
                  }

                  export { }
