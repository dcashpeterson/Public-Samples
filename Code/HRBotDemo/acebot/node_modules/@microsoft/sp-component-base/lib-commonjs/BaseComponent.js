"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The base class for client-side components such as BaseClientSideWebPart or BaseExtension.
 *
 * @public
 */
var BaseComponent = /** @class */ (function () {
    /** @internal */
    function BaseComponent() {
        /**
         * Stores whether or not this component has a dynamic data source.
         * @internal
         */
        this._isWebPartAndContainsDynamicDataSource = false;
        this._isDisposed = false;
        // empty block
    }
    Object.defineProperty(BaseComponent.prototype, "_dynamicDataSourceId", {
        /**
         * Returns the dynamic data source id for the current instance of the component.
         *
         * @internal
         */
        get: function () {
            return "".concat(this.manifest.componentType, ".").concat(this.manifest.id, ".").concat(this.instanceId);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Disposes the component.
     *
     * @remarks
     * Third-party code generally does not need to call this method; it's invoked
     * automatically when the lifecycle ends for a web part or extension.  To perform
     * custom cleanup when your component is disposed, override the {@link BaseComponent.onDispose}
     * method.
     */
    BaseComponent.prototype.dispose = function () {
        if (!this._isDisposed) {
            this.onDispose();
            this.context.dispose();
            delete this.context;
            this._isDisposed = true;
        }
    };
    Object.defineProperty(BaseComponent.prototype, "_containsDynamicDataSource", {
        /**
         * Returns whether or not this component contains a dynamic data source.
         * @internal
         */
        get: function () {
            return this._isWebPartAndContainsDynamicDataSource;
        },
        /**
         * @internal
         */
        set: function (val) {
            this._isWebPartAndContainsDynamicDataSource = this.manifest.componentType === 'WebPart' ? val : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "isDisposed", {
        /**
         * Returns true if the component has been already disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "manifest", {
        /**
         * Provides access to the manifest for the client-side component.
         * virtual
         * @remarks
         * Child classes can override this with more specialized manifest types.
         */
        get: function () {
            return this.context.manifest;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This event method is called at the end of the component's lifecycle.
     * It provides an opportunity to release any associated resources, cancel any
     * outstanding requests, etc.
     * virtual
     */
    BaseComponent.prototype.onDispose = function () {
        // (empty block)
    };
    Object.defineProperty(BaseComponent.prototype, "instanceId", {
        /**
         * A unique identifier for the instance of the component.
         *
         * @remarks
         * A component implementation can be loaded multiple times on the page.
         * For example, if the component is a charting web part, multiple instances of this web part
         * could be added to the SharePoint canvas.  The instanceId uniquely identifies each
         * of these instances.
         */
        get: function () {
            return this.context.instanceId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "componentId", {
        /**
         * Returns the component identifier as defined in the component's associated manifest.
         *
         * @remarks
         * Each client-side component has an associated manifest that is used by the sp-loader to load its scripts,
         * and which may include additional metadata about the component.  The manifest is uniquely identified using
         * a text string containing a lower case GUID value.
         */
        get: function () {
            return this.context.manifest.id;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @internal
     */
    BaseComponent.prototype._initializeContext = function (context) {
        this.context = context;
        this.onProvideServices(context.serviceScope);
        /*
         * Calling finish on an already finished servicescope will throw.
         * Hence, checking it before finishing the servicescope.
         *
         * In the case of ApplicationCustomizers, it's context is calling 'finish'
         * on the service scope. Hence, it is required to have the below check.
         */
        if (!context.serviceScope._isFinished) {
            context.serviceScope.finish();
        }
        this.context._initializeDynamicData(this, context.serviceScope);
    };
    /**
     * This event method allows a component to add custom services to its
     * {@link @microsoft/sp-core-library#ServiceScope}.
     *
     * @remarks
     * This event method is fired before {@link @microsoft/sp-core-library#ServiceScope | ServiceScope.finish()}
     * is called, allowing the component to provide custom services.
     *
     * virtual
     *
     * @alpha
     */
    BaseComponent.prototype.onProvideServices = function (serviceScope) {
        // empty block
    };
    return BaseComponent;
}());
exports.default = BaseComponent;
//# sourceMappingURL=BaseComponent.js.map