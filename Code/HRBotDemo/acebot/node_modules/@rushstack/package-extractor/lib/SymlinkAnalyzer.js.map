{"version":3,"file":"SymlinkAnalyzer.js","sourceRoot":"","sources":["../src/SymlinkAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { FileSystem, type FileSystemStats, Sort } from '@rushstack/node-core-library';\n\nimport * as path from 'path';\n\nexport interface IPathNodeBase {\n  kind: 'file' | 'folder' | 'link';\n  nodePath: string;\n  linkStats: FileSystemStats;\n}\n\n/**\n * Represents a file object analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface IFileNode extends IPathNodeBase {\n  kind: 'file';\n}\n\n/**\n * Represents a folder object analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface IFolderNode extends IPathNodeBase {\n  kind: 'folder';\n}\n\n/**\n * Represents a symbolic link analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface ILinkNode extends IPathNodeBase {\n  kind: 'link';\n\n  /**\n   * The immediate target that the symlink resolves to.\n   */\n  linkTarget: string;\n}\n\nexport type PathNode = IFileNode | IFolderNode | ILinkNode;\n\n/**\n * Represents a symbolic link.\n *\n * @public\n */\nexport interface ILinkInfo {\n  /**\n   * The type of link that was encountered.\n   */\n  kind: 'fileLink' | 'folderLink';\n\n  /**\n   * The path to the link, relative to the root of the extractor output folder.\n   */\n  linkPath: string;\n\n  /**\n   * The target that the link points to.\n   */\n  targetPath: string;\n}\n\nexport interface ISymlinkAnalyzerOptions {\n  requiredSourceParentPath?: string;\n}\n\nexport class SymlinkAnalyzer {\n  private readonly _requiredSourceParentPath: string | undefined;\n\n  // The directory tree discovered so far\n  private readonly _nodesByPath: Map<string, PathNode> = new Map<string, PathNode>();\n\n  // The symlinks that we encountered while building the directory tree\n  private readonly _linkInfosByPath: Map<string, ILinkInfo> = new Map<string, ILinkInfo>();\n\n  public constructor(options: ISymlinkAnalyzerOptions = {}) {\n    this._requiredSourceParentPath = options.requiredSourceParentPath;\n  }\n\n  public async analyzePathAsync(inputPath: string, preserveLinks: boolean = false): Promise<PathNode> {\n    // First, try to short-circuit the analysis if we've already analyzed this path\n    const resolvedPath: string = path.resolve(inputPath);\n    const existingNode: PathNode | undefined = this._nodesByPath.get(resolvedPath);\n    if (existingNode) {\n      return existingNode;\n    }\n\n    // Postfix a '/' to the end of the path. This will get trimmed off later, but it\n    // ensures that the last path component is included in the loop below.\n    let targetPath: string = `${resolvedPath}${path.sep}`;\n    let targetPathIndex: number = -1;\n    let currentNode: PathNode | undefined;\n\n    while ((targetPathIndex = targetPath.indexOf(path.sep, targetPathIndex + 1)) >= 0) {\n      if (targetPathIndex === 0) {\n        // Edge case for a Unix path like \"/folder/file\" --> [ \"\", \"folder\", \"file\" ]\n        continue;\n      }\n\n      const currentPath: string = targetPath.slice(0, targetPathIndex);\n      currentNode = this._nodesByPath.get(currentPath);\n      if (currentNode === undefined) {\n        const linkStats: FileSystemStats = await FileSystem.getLinkStatisticsAsync(currentPath);\n        if (linkStats.isSymbolicLink()) {\n          // Link target paths can be relative or absolute, so we need to resolve them\n          const linkTargetPath: string = await FileSystem.readLinkAsync(currentPath);\n          const resolvedLinkTargetPath: string = path.resolve(path.dirname(currentPath), linkTargetPath);\n\n          // Do a check to make sure that the link target path is not outside the source folder\n          if (this._requiredSourceParentPath) {\n            const relativeLinkTargetPath: string = path.relative(\n              this._requiredSourceParentPath,\n              resolvedLinkTargetPath\n            );\n            if (relativeLinkTargetPath.startsWith('..')) {\n              throw new Error(\n                `Symlink targets not under folder \"${this._requiredSourceParentPath}\": ` +\n                  `${currentPath} -> ${resolvedLinkTargetPath}`\n              );\n            }\n          }\n\n          currentNode = {\n            kind: 'link',\n            nodePath: currentPath,\n            linkStats,\n            linkTarget: resolvedLinkTargetPath\n          };\n        } else if (linkStats.isDirectory()) {\n          currentNode = {\n            kind: 'folder',\n            nodePath: currentPath,\n            linkStats\n          };\n        } else if (linkStats.isFile()) {\n          currentNode = {\n            kind: 'file',\n            nodePath: currentPath,\n            linkStats\n          };\n        } else {\n          throw new Error('Unknown object type: ' + currentPath);\n        }\n        this._nodesByPath.set(currentPath, currentNode);\n      }\n\n      if (!preserveLinks) {\n        while (currentNode?.kind === 'link') {\n          const targetNode: PathNode = await this.analyzePathAsync(currentNode.linkTarget, true);\n\n          // Have we created an ILinkInfo for this link yet?\n          if (!this._linkInfosByPath.has(currentNode.nodePath)) {\n            // Follow any symbolic links to determine whether the final target is a directory\n            const targetStats: FileSystemStats = await FileSystem.getStatisticsAsync(targetNode.nodePath);\n            const targetIsDirectory: boolean = targetStats.isDirectory();\n            const linkInfo: ILinkInfo = {\n              kind: targetIsDirectory ? 'folderLink' : 'fileLink',\n              linkPath: currentNode.nodePath,\n              targetPath: targetNode.nodePath\n            };\n            this._linkInfosByPath.set(currentNode.nodePath, linkInfo);\n          }\n\n          const nodeTargetPath: string = targetNode.nodePath;\n          const remainingPath: string = targetPath.slice(targetPathIndex);\n          targetPath = path.join(nodeTargetPath, remainingPath);\n          targetPathIndex = nodeTargetPath.length;\n          currentNode = targetNode;\n        }\n      }\n\n      if (targetPath.length === targetPathIndex + 1) {\n        // We've reached the end of the path\n        break;\n      }\n    }\n\n    if (!currentNode) {\n      throw new Error('Unable to analyze path: ' + inputPath);\n    }\n\n    return currentNode;\n  }\n\n  /**\n   * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePathAsync}.\n   */\n  public reportSymlinks(): ILinkInfo[] {\n    const list: ILinkInfo[] = [...this._linkInfosByPath.values()];\n    Sort.sortBy(list, (x) => x.linkPath);\n    return list;\n  }\n}\n"]}