{"version":3,"file":"chunks/LinkManagerFactory.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACsD;AACG;AAClD;AACP;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA,2BAA2B,kEAAe;AAC1C;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA,gEAAgE,iCAAiC;AACjG;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACiC;AACJ;AAC4C;AACnB;AACA;AACwB;AACjB;AACtD;AACP;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C,QAAQ,iFAAuB;AAC/B;AACA,YAAY,oGAAyC;AACrD;AACA;AACA;AACA;AACA,yBAAyB,0CAAa,CAAC,gFAAsB;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,+FAAqC;AACrD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAyB;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAmC;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,2FAAiC;AACjD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAA+B;AACvC;AACA,YAAY,iFAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA,iBAAiB,2EAAiB;AAClC,gBAAgB,iFAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,iFAA+B;AAC3C,mCAAmC,wFAA8B;AACjE;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD,qCAAqC,sCAAS;AAC9C,sCAAsC,sFAA4B;AAClE;AACA,4CAA4C,kFAAwB,CAAC,gFAAsB;AAC3F;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,yCAAyC,gFAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,YAAY,iFAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAW;AACtC,0BAA0B,iEAAe;AACzC;AACA;AACA,QAAQ,oFAAqC;AAC7C;AACA;AACA,2BAA2B,wDAAY,oCAAoC,qBAAqB;AAChG;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7KA;AACA;AACwD;AACxD;AACA,2BAA2B;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AACA;AACiC;AACJ;AACI;AACN;AACqB;AACyC;AAC/B;AACJ;AACW;AAChB;AACsB;AAChE,6BAA6B,kEAAe;AACnD;AACA,iCAAiC,iGAAuC,CAAC,0DAAe;AACxF,kCAAkC,iEAAwB;AAC1D,wCAAwC,yDAAa;AACrD;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAS,2CAA2C,0FAAwC;AAChI;AACA,gCAAgC,sCAAS,2CAA2C,0FAAwC;AAC5H;AACA,wCAAwC,sCAAS,6BAA6B,mFAAyB;AACvG,YAAY,kFAA+B;AAC3C,YAAY,wCAAW;AACvB;AACA;AACA;AACA,aAAa;AACb;AACA,sCAAsC,sCAAS,2CAA2C,qFAAmC,EAAE,gFAA8B;AAC7J,mCAAmC,4EAAmC;AACtE;AACA,YAAY,+EAAqB;AACjC,YAAY,+EAAqB;AACjC;AACA;AACA;AACA,oCAAoC,0EAAiC;AACrE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wEAA+B;AAChF,yBAAyB,6CAAgB;AACzC;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAa,+BAA+B,iBAAiB,MAAM,kBAAkB;AACzH,+DAA+D,wBAAwB;AACvF,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sCAAS;AAChE,oDAAoD,0EAAiC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAS;AAC5D,gDAAgD,0EAAiC;AACjF;AACA;AACA,mDAAmD,kBAAkB,GAAG,sBAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,4CAA4C,uEAA8B;AAC1E,2DAA2D,gBAAgB,eAAe,kBAAkB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAS;AAC7C,qCAAqC,sCAAS;AAC9C,gBAAgB,2EAAiB;AACjC;AACA;AACA;AACA,iCAAiC,wEAAqB;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AAC6B;AAC2B;AACN;AAClD;AACA,2BAA2B;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AAChD,yBAAyB,0DAAW;AAC3C;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,0CAAa,kBAAkB,IAAI,yBAAyB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AAC6B;AACI;AACS;AACC;AACV;AACA;AACmF;AAC1D;AACR;AACQ;AAC+B;AACzF;AACA;AACA;AACO,8BAA8B,kEAAe;AACpD;AACA;AACA,gCAAgC,0CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gFAA+B;AACtE;AACA,0BAA0B,uEAAa,+BAA+B,+CAA+C;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,gCAAgC,sCAAS,2CAA2C,0FAAwC;AAC5H;AACA,oCAAoC,sCAAS,kBAAkB,mFAAyB;AACxF;AACA,kCAAkC,sCAAS,2CAA2C,qFAAmC,EAAE,gFAA8B;AACzJ,8BAA8B,oFAAoC;AAClE,6BAA6B,+EAA+B;AAC5D;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sCAAS;AACpD,wCAAwC,+EAA+B;AACvE;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,4BAA4B,eAAe,SAAS,oBAAoB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,wBAAwB;AACnG;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,kCAAkC,wBAAwB;AAC7F;AACA;AACA;AACA;AACA,sCAAsC,yCAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,wEAAwE,wBAAwB;AACnI;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAS;AACvC,iCAAiC,sCAAS;AAC1C,cAAc,sDAAY;AAC1B;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+EAAqB;AAC1D,sCAAsC,iBAAiB,EAAE,aAAa;AACtE;AACA,gCAAgC,4BAA4B,GAAG,8CAChC;AAC/B;AACA,mCAAmC;AACnC;AACA,mBAAmB,sCAAS,2CAA2C,qFAAmC,uBAAuB,qFAAmC;AACpK;AACA;AACA,oBAAoB,oBAAoB,QAAQ,+HAA+B;AAC/E;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa,EAAE,aAAa;AAChF,mBAAmB,sCAAS,2CAA2C,qFAAmC,uBAAuB,qFAAmC;AACpK;AACA;AACA,oBAAoB,oBAAoB,QAAQ,yHAAyB;AACzE;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB,EAAE,aAAa;AAClE,mBAAmB,sCAAS,2CAA2C,qFAAmC,uBAAuB,qFAAmC;AACpK;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wDAAS,CAAC,+EAAqB;AACrF;AACA,mBAAmB,sCAAS,2CAA2C,qFAAmC,uDAAuD,qFAAmC;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAS;AAC5D,aAAa,2EAAiB;AAC9B;AACA,sBAAsB,uEAAa,sCAAsC,eAAe,QAAQ,wBAAwB;AACxH;AACA,aAAa,sFAA4B;AACzC;AACA,sBAAsB,uEAAa,gBAAgB,eAAe,yBAAyB,wBAAwB;AACnH;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,uDAAuD;AACvD;AACA;AACA,0BAA0B,uEAAa,6CAA6C,eAAe;AACnG,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,mCAAmC,sCAAS;AAC5C,wBAAwB,kFAA6B;AACrD,gCAAgC,+EAA+B;AAC/D;AACA;AACA,kDAAkD,gFAAsB;AACxE;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/LinkManagerFactory.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PackageLookup.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseLinkManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BasePackage.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmLinkManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmPackage.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmLinkManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { NpmLinkManager } from './npm/NpmLinkManager';\nimport { PnpmLinkManager } from './pnpm/PnpmLinkManager';\nexport class LinkManagerFactory {\n    static getLinkManager(rushConfiguration) {\n        switch (rushConfiguration.packageManager) {\n            case 'npm':\n                return new NpmLinkManager(rushConfiguration);\n            case 'pnpm':\n                return new PnpmLinkManager(rushConfiguration);\n            case 'yarn':\n                // Yarn uses the same node_modules structure as NPM\n                return new NpmLinkManager(rushConfiguration);\n            default:\n                throw new Error(`Unsupported package manager: ${rushConfiguration.packageManager}`);\n        }\n    }\n}\n//# sourceMappingURL=LinkManagerFactory.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class PackageLookup {\n    constructor() {\n        this._packageMap = new Map();\n    }\n    loadTree(root) {\n        const queue = [root];\n        // We want the lookup to return the shallowest match, so this is a breadth first\n        // traversal\n        for (;;) {\n            const current = queue.shift();\n            if (!current) {\n                break;\n            }\n            for (const child of current.children) {\n                queue.push(child);\n            }\n            const key = current.nameAndVersion;\n            if (!this._packageMap.has(key)) {\n                this._packageMap.set(key, current);\n            }\n        }\n    }\n    getPackage(nameAndVersion) {\n        return this._packageMap.get(nameAndVersion);\n    }\n}\n//# sourceMappingURL=PackageLookup.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { LastLinkFlagFactory } from '../../api/LastLinkFlag';\nexport var SymlinkKind;\n(function (SymlinkKind) {\n    SymlinkKind[SymlinkKind[\"File\"] = 0] = \"File\";\n    SymlinkKind[SymlinkKind[\"Directory\"] = 1] = \"Directory\";\n})(SymlinkKind || (SymlinkKind = {}));\nexport class BaseLinkManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    static _createSymlink(options) {\n        const newLinkFolder = path.dirname(options.newLinkPath);\n        FileSystem.ensureFolder(newLinkFolder);\n        let targetPath;\n        if (EnvironmentConfiguration.absoluteSymlinks) {\n            targetPath = options.linkTargetPath;\n        }\n        else {\n            // Link to the relative path, to avoid going outside containers such as a Docker image\n            targetPath = path.relative(FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);\n        }\n        if (process.platform === 'win32') {\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                // For directories, we use a Windows \"junction\".  On Unix, this produces a regular symlink.\n                FileSystem.createSymbolicLinkJunction({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n                // administrator permission.\n                // NOTE: We cannot use the relative path for hard links\n                FileSystem.createHardLink({\n                    linkTargetPath: options.linkTargetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n        else {\n            // However hard links seem to cause build failures on Mac, so for all other operating systems\n            // we use symbolic links for this case.\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                FileSystem.createSymbolicLinkFolder({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                FileSystem.createSymbolicLinkFile({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n    }\n    /**\n     * For a Package object that represents a top-level Rush project folder\n     * (i.e. with source code that we will be building), this clears out its\n     * node_modules folder and then recursively creates all the symlinked folders.\n     */\n    static _createSymlinksForTopLevelProject(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        // Sanity check\n        if (localPackage.parent) {\n            throw new Error('The provided package is not a top-level project');\n        }\n        // The root-level folder is the project itself, so we simply delete its node_modules\n        // to start clean\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + localModuleFolder);\n        Utilities.dangerouslyDeletePath(localModuleFolder);\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * This is a helper function used by createSymlinksForTopLevelProject().\n     * It will recursively creates symlinked folders corresponding to each of the\n     * Package objects in the provided tree.\n     */\n    static _createSymlinksForDependencies(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        if (!localPackage.symlinkTargetFolderPath) {\n            throw new InternalError('localPackage.symlinkTargetFolderPath was not assigned');\n        }\n        // This is special case for when localPackage.name has the form '@scope/name',\n        // in which case we need to create the '@scope' folder first.\n        const parentFolderPath = path.dirname(localPackage.folderPath);\n        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {\n            if (!FileSystem.exists(parentFolderPath)) {\n                Utilities.createFolderWithRetry(parentFolderPath);\n            }\n        }\n        if (localPackage.children.length === 0) {\n            // If there are no children, then we can symlink the entire folder\n            BaseLinkManager._createSymlink({\n                linkTargetPath: localPackage.symlinkTargetFolderPath,\n                newLinkPath: localPackage.folderPath,\n                symlinkKind: SymlinkKind.Directory\n            });\n        }\n        else {\n            // If there are children, then we need to symlink each item in the folder individually\n            Utilities.createFolderWithRetry(localPackage.folderPath);\n            for (const filename of FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {\n                if (filename.toLowerCase() !== 'node_modules') {\n                    // Create the symlink\n                    let symlinkKind = SymlinkKind.File;\n                    const linkSource = path.join(localPackage.folderPath, filename);\n                    let linkTarget = path.join(localPackage.symlinkTargetFolderPath, filename);\n                    const linkStats = FileSystem.getLinkStatistics(linkTarget);\n                    if (linkStats.isSymbolicLink()) {\n                        const targetStats = FileSystem.getStatistics(FileSystem.getRealPath(linkTarget));\n                        if (targetStats.isDirectory()) {\n                            // Neither a junction nor a directory-symlink can have a directory-symlink\n                            // as its target; instead, we must obtain the real physical path.\n                            // A junction can link to another junction.  Unfortunately, the node 'fs' API\n                            // lacks the ability to distinguish between a junction and a directory-symlink\n                            // (even though it has the ability to create them both), so the safest policy\n                            // is to always make a junction and always to the real physical path.\n                            linkTarget = FileSystem.getRealPath(linkTarget);\n                            symlinkKind = SymlinkKind.Directory;\n                        }\n                    }\n                    else if (linkStats.isDirectory()) {\n                        symlinkKind = SymlinkKind.Directory;\n                    }\n                    BaseLinkManager._createSymlink({\n                        linkTargetPath: linkTarget,\n                        newLinkPath: linkSource,\n                        symlinkKind\n                    });\n                }\n            }\n        }\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.\n     * @param force - Normally the operation will be skipped if the links are already up to date;\n     *   if true, this option forces the links to be recreated.\n     */\n    async createSymlinksForProjects(force) {\n        // eslint-disable-next-line no-console\n        console.log('\\n' + colors.bold('Linking local projects'));\n        const stopwatch = Stopwatch.start();\n        await this._linkProjects();\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        LastLinkFlagFactory.getCommonTempFlag(this._rushConfiguration).create();\n        stopwatch.stop();\n        // eslint-disable-next-line no-console\n        console.log('\\n' + colors.green(`Linking finished successfully. (${stopwatch.toString()})`));\n        // eslint-disable-next-line no-console\n        console.log('\\nNext you should probably run \"rush build\" or \"rush rebuild\"');\n    }\n}\n//# sourceMappingURL=BaseLinkManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile } from '@rushstack/node-core-library';\n/**\n * The type of dependency; used by IPackageDependency.\n */\nexport var PackageDependencyKind;\n(function (PackageDependencyKind) {\n    PackageDependencyKind[PackageDependencyKind[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * The dependency was listed in the optionalDependencies section of package.json.\n     */\n    PackageDependencyKind[PackageDependencyKind[\"Optional\"] = 1] = \"Optional\";\n    /**\n     * The dependency should be a symlink to a project that is locally built by Rush..\n     */\n    PackageDependencyKind[PackageDependencyKind[\"LocalLink\"] = 2] = \"LocalLink\";\n})(PackageDependencyKind || (PackageDependencyKind = {}));\n/**\n * Represents an NPM package being processed by the linking algorithm.\n */\nexport class BasePackage {\n    constructor(name, version, folderPath, packageJson) {\n        /**\n         * If this is a local path that we are planning to symlink to a target folder,\n         * then symlinkTargetFolderPath keeps track of the intended target.\n         */\n        this.symlinkTargetFolderPath = undefined;\n        this.name = name;\n        this.packageJson = packageJson;\n        this.version = version;\n        this.folderPath = folderPath;\n        // Extract `@alias-scope/alias-name` from  `C:\\node_modules\\@alias-scope\\alias-name`\n        const pathParts = folderPath.split(/[\\\\\\/]/);\n        this.installedName = pathParts[pathParts.length - 1];\n        if (pathParts.length >= 2) {\n            // Is there an NPM scope?\n            const parentFolder = pathParts[pathParts.length - 2];\n            if (parentFolder[0] === '@') {\n                this.installedName = parentFolder + '/' + this.installedName;\n            }\n        }\n        this.children = [];\n        this._childrenByName = new Map();\n    }\n    /**\n     * Used by link managers, creates a virtual Package object that represents symbolic links\n     * which will be created later\n     */\n    static createLinkedPackage(name, version, folderPath, packageJson) {\n        return new BasePackage(name, version, folderPath, packageJson);\n    }\n    /**\n     * Used by \"npm link\" to simulate a temp project that is missing from the common/node_modules\n     * folder (e.g. because it was added after the shrinkwrap file was regenerated).\n     * @param packageJsonFilename - Filename of the source package.json\n     *        Example: `C:\\MyRepo\\common\\temp\\projects\\project1\\package.json`\n     * @param targetFolderName - Filename where it should have been installed\n     *        Example: `C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\\project1`\n     */\n    static createVirtualTempPackage(packageJsonFilename, installFolderName) {\n        const packageJson = JsonFile.load(packageJsonFilename);\n        return BasePackage.createLinkedPackage(packageJson.name, packageJson.version, installFolderName, packageJson);\n    }\n    get nameAndVersion() {\n        let result = '';\n        if (this.name) {\n            result += this.name;\n        }\n        else {\n            result += '(missing name)';\n        }\n        result += '@';\n        if (this.version) {\n            result += this.version;\n        }\n        else {\n            result += '(missing version)';\n        }\n        return result;\n    }\n    addChild(child) {\n        if (child.parent) {\n            throw new Error('Child already has a parent');\n        }\n        if (this._childrenByName.has(child.installedName)) {\n            throw new Error(`Child already exists: ${child.installedName}`);\n        }\n        child.parent = this;\n        this.children.push(child);\n        this._childrenByName.set(child.installedName, child);\n    }\n    getChildByName(childPackageName) {\n        return this._childrenByName.get(childPackageName);\n    }\n    printTree(indent) {\n        if (!indent) {\n            indent = '';\n        }\n        // eslint-disable-next-line no-console\n        console.log(indent + this.nameAndVersion);\n        for (const child of this.children) {\n            child.printTree(indent + '  ');\n        }\n    }\n}\n//# sourceMappingURL=BasePackage.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport * as tar from 'tar';\nimport readPackageTree from 'read-package-tree';\nimport { FileSystem, FileConstants, LegacyAdapters } from '@rushstack/node-core-library';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { Utilities } from '../../utilities/Utilities';\nimport { NpmPackage, PackageDependencyKind } from './NpmPackage';\nimport { PackageLookup } from '../PackageLookup';\nimport { BaseLinkManager, SymlinkKind } from '../base/BaseLinkManager';\nexport class NpmLinkManager extends BaseLinkManager {\n    async _linkProjects() {\n        const npmPackage = await LegacyAdapters.convertCallbackToPromise(readPackageTree, this._rushConfiguration.commonTempFolder);\n        const commonRootPackage = NpmPackage.createFromNpm(npmPackage);\n        const commonPackageLookup = new PackageLookup();\n        commonPackageLookup.loadTree(commonRootPackage);\n        for (const rushProject of this._rushConfiguration.projects) {\n            // eslint-disable-next-line no-console\n            console.log(`\\nLINKING: ${rushProject.packageName}`);\n            this._linkProject(rushProject, commonRootPackage, commonPackageLookup);\n        }\n    }\n    /**\n     * This is called once for each local project from Rush.json.\n     * @param project             The local project that we will create symlinks for\n     * @param commonRootPackage   The common/temp/package.json package\n     * @param commonPackageLookup A dictionary for finding packages under common/temp/node_modules\n     */\n    _linkProject(project, commonRootPackage, commonPackageLookup) {\n        let commonProjectPackage = commonRootPackage.getChildByName(project.tempProjectName);\n        if (!commonProjectPackage) {\n            // Normally we would expect the temp project to have been installed into the common\\node_modules\n            // folder.  However, if it was recently added, \"rush install\" doesn't technically require\n            // this, as long as its dependencies can be found at the root of the NPM shrinkwrap file.\n            // This avoids the need to run \"rush generate\" unnecessarily.\n            // Example: \"project1\"\n            const unscopedTempProjectName = this._rushConfiguration.packageNameParser.getUnscopedName(project.tempProjectName);\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\project1\n            const extractedFolder = path.join(this._rushConfiguration.commonTempFolder, RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\project1.tgz\"\n            const tarballFile = path.join(this._rushConfiguration.commonTempFolder, RushConstants.rushTempProjectsFolderName, unscopedTempProjectName + '.tgz');\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\project1\\package.json\"\n            const packageJsonFilename = path.join(extractedFolder, 'package', FileConstants.PackageJson);\n            Utilities.createFolderWithRetry(extractedFolder);\n            tar.extract({\n                cwd: extractedFolder,\n                file: tarballFile,\n                sync: true\n            });\n            // Example: \"C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\\project1\"\n            const installFolderName = path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, RushConstants.rushTempNpmScope, unscopedTempProjectName);\n            commonProjectPackage = NpmPackage.createVirtualTempPackage(packageJsonFilename, installFolderName);\n            // remove the extracted tarball contents\n            FileSystem.deleteFile(packageJsonFilename);\n            FileSystem.deleteFile(extractedFolder);\n            commonRootPackage.addChild(commonProjectPackage);\n        }\n        // TODO: Validate that the project's package.json still matches the common folder\n        const localProjectPackage = NpmPackage.createLinkedNpmPackage(project.packageJsonEditor.name, commonProjectPackage.version, commonProjectPackage.dependencies, project.projectFolder);\n        const queue = [];\n        queue.push({\n            commonPackage: commonProjectPackage,\n            localPackage: localProjectPackage,\n            cyclicSubtreeRoot: undefined\n        });\n        for (;;) {\n            const queueItem = queue.shift();\n            if (!queueItem) {\n                break;\n            }\n            // A project from somewhere under \"common/temp/node_modules\"\n            const commonPackage = queueItem.commonPackage;\n            // A symlinked virtual package somewhere under \"this-project/node_modules\",\n            // where \"this-project\" corresponds to the \"project\" parameter for linkProject().\n            const localPackage = queueItem.localPackage;\n            // If we encounter a dependency listed in decoupledLocalDependencies, this will be set to the root\n            // of the localPackage subtree where we will stop creating local links.\n            const cyclicSubtreeRoot = queueItem.cyclicSubtreeRoot;\n            // NOTE: It's important that this traversal follows the dependencies in the Common folder,\n            // because for Rush projects this will be the union of\n            // devDependencies / dependencies / optionalDependencies.\n            for (const dependency of commonPackage.dependencies) {\n                let startingCyclicSubtree = false;\n                // Should this be a \"local link\" to a top-level Rush project (i.e. versus a regular link\n                // into the Common folder)?\n                const matchedRushPackage = this._rushConfiguration.getProjectByName(dependency.name);\n                if (matchedRushPackage) {\n                    const matchedVersion = matchedRushPackage.packageJsonEditor.version;\n                    // The dependency name matches an Rush project, but are there any other reasons not\n                    // to create a local link?\n                    if (cyclicSubtreeRoot) {\n                        // DO NOT create a local link, because this is part of an existing\n                        // decoupledLocalDependencies subtree\n                    }\n                    else if (project.decoupledLocalDependencies.has(dependency.name)) {\n                        // DO NOT create a local link, because we are starting a new\n                        // decoupledLocalDependencies subtree\n                        startingCyclicSubtree = true;\n                    }\n                    else if (dependency.kind !== PackageDependencyKind.LocalLink &&\n                        !semver.satisfies(matchedVersion, dependency.versionRange)) {\n                        // DO NOT create a local link, because the local project's version isn't SemVer compatible.\n                        // (Note that in order to make version bumping work as expected, we ignore SemVer for\n                        // immediate dependencies of top-level projects, indicated by PackageDependencyKind.LocalLink.\n                        // Is this wise?)\n                        // eslint-disable-next-line no-console\n                        console.log(colors.yellow(`Rush will not locally link ${dependency.name} for ${localPackage.name}` +\n                            ` because the requested version \"${dependency.versionRange}\" is incompatible` +\n                            ` with the local version ${matchedVersion}`));\n                    }\n                    else {\n                        // Yes, it is compatible, so create a symlink to the Rush project.\n                        // Is the dependency already resolved?\n                        const resolution = localPackage.resolveOrCreate(dependency.name);\n                        if (!resolution.found || resolution.found.version !== matchedVersion) {\n                            // We did not find a suitable match, so place a new local package that\n                            // symlinks to the Rush project\n                            const newLocalFolderPath = path.join(resolution.parentForCreate.folderPath, 'node_modules', dependency.name);\n                            const newLocalPackage = NpmPackage.createLinkedNpmPackage(dependency.name, matchedVersion, \n                            // Since matchingRushProject does not have a parent, its dependencies are\n                            // guaranteed to be already fully resolved inside its node_modules folder.\n                            [], newLocalFolderPath);\n                            newLocalPackage.symlinkTargetFolderPath = matchedRushPackage.projectFolder;\n                            resolution.parentForCreate.addChild(newLocalPackage);\n                            // (There are no dependencies, so we do not need to push it onto the queue.)\n                        }\n                        continue;\n                    }\n                }\n                // We can't symlink to an Rush project, so instead we will symlink to a folder\n                // under the \"Common\" folder\n                const commonDependencyPackage = commonPackage.resolve(dependency.name);\n                if (commonDependencyPackage) {\n                    // This is the version that was chosen when \"npm install\" ran in the common folder\n                    const effectiveDependencyVersion = commonDependencyPackage.version;\n                    // Is the dependency already resolved?\n                    let resolution;\n                    if (!cyclicSubtreeRoot || !matchedRushPackage) {\n                        // Perform normal module resolution.\n                        resolution = localPackage.resolveOrCreate(dependency.name);\n                    }\n                    else {\n                        // We are inside a decoupledLocalDependencies subtree (i.e. cyclicSubtreeRoot != undefined),\n                        // and the dependency is a local project (i.e. matchedRushPackage != undefined), so\n                        // we use a special module resolution strategy that places everything under the\n                        // cyclicSubtreeRoot.\n                        resolution = localPackage.resolveOrCreate(dependency.name, cyclicSubtreeRoot);\n                    }\n                    if (!resolution.found || resolution.found.version !== effectiveDependencyVersion) {\n                        // We did not find a suitable match, so place a new local package\n                        const newLocalFolderPath = path.join(resolution.parentForCreate.folderPath, 'node_modules', commonDependencyPackage.name);\n                        const newLocalPackage = NpmPackage.createLinkedNpmPackage(commonDependencyPackage.name, commonDependencyPackage.version, commonDependencyPackage.dependencies, newLocalFolderPath);\n                        const commonPackageFromLookup = commonPackageLookup.getPackage(newLocalPackage.nameAndVersion);\n                        if (!commonPackageFromLookup) {\n                            throw new Error(`The ${localPackage.name}@${localPackage.version} package was not found` +\n                                ` in the common folder`);\n                        }\n                        newLocalPackage.symlinkTargetFolderPath = commonPackageFromLookup.folderPath;\n                        let newCyclicSubtreeRoot = cyclicSubtreeRoot;\n                        if (startingCyclicSubtree) {\n                            // If we are starting a new subtree, then newLocalPackage will be its root\n                            // NOTE: cyclicSubtreeRoot is guaranteed to be undefined here, since we never start\n                            // a new tree inside an existing tree\n                            newCyclicSubtreeRoot = newLocalPackage;\n                        }\n                        resolution.parentForCreate.addChild(newLocalPackage);\n                        queue.push({\n                            commonPackage: commonDependencyPackage,\n                            localPackage: newLocalPackage,\n                            cyclicSubtreeRoot: newCyclicSubtreeRoot\n                        });\n                    }\n                }\n                else {\n                    if (dependency.kind !== PackageDependencyKind.Optional) {\n                        throw new Error(`The dependency \"${dependency.name}\" needed by \"${localPackage.name}\"` +\n                            ` was not found in the common folder -- do you need to run \"rush install\"?`);\n                    }\n                    else {\n                        // eslint-disable-next-line no-console\n                        console.log('Skipping optional dependency: ' + dependency.name);\n                    }\n                }\n            }\n        }\n        // When debugging, you can uncomment this line to dump the data structure\n        // to the console:\n        // localProjectPackage.printTree();\n        NpmLinkManager._createSymlinksForTopLevelProject(localProjectPackage);\n        // Also symlink the \".bin\" folder\n        if (localProjectPackage.children.length > 0) {\n            const commonBinFolder = path.join(this._rushConfiguration.commonTempFolder, 'node_modules', '.bin');\n            const projectBinFolder = path.join(localProjectPackage.folderPath, 'node_modules', '.bin');\n            if (FileSystem.exists(commonBinFolder)) {\n                NpmLinkManager._createSymlink({\n                    linkTargetPath: commonBinFolder,\n                    newLinkPath: projectBinFolder,\n                    symlinkKind: SymlinkKind.Directory\n                });\n            }\n        }\n    }\n}\n//# sourceMappingURL=NpmLinkManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile } from '@rushstack/node-core-library';\nimport { BasePackage } from '../base/BasePackage';\n/**\n * The type of dependency; used by IPackageDependency.\n */\nexport var PackageDependencyKind;\n(function (PackageDependencyKind) {\n    PackageDependencyKind[PackageDependencyKind[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * The dependency was listed in the optionalDependencies section of package.json.\n     */\n    PackageDependencyKind[PackageDependencyKind[\"Optional\"] = 1] = \"Optional\";\n    /**\n     * The dependency should be a symlink to a project that is locally built by Rush..\n     */\n    PackageDependencyKind[PackageDependencyKind[\"LocalLink\"] = 2] = \"LocalLink\";\n})(PackageDependencyKind || (PackageDependencyKind = {}));\nexport class NpmPackage extends BasePackage {\n    constructor(name, version, dependencies, folderPath) {\n        super(name, version, folderPath, undefined);\n        this.dependencies = dependencies.slice(0); // clone the array\n        this.parent = undefined;\n    }\n    /**\n     * Used by \"npm link\" when creating a Package object that represents symbolic links to be created.\n     */\n    static createLinkedNpmPackage(name, version, dependencies, folderPath) {\n        return new NpmPackage(name, version, dependencies, folderPath);\n    }\n    /**\n     * Used by \"npm link\" to simulate a temp project that is missing from the common/node_modules\n     * folder (e.g. because it was added after the shrinkwrap file was regenerated).\n     * @param packageJsonFilename - Filename of the source package.json\n     *        Example: `C:\\MyRepo\\common\\temp\\projects\\project1\\package.json`\n     * @param targetFolderName - Filename where it should have been installed\n     *        Example: `C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\\project1`\n     */\n    static createVirtualTempPackage(packageJsonFilename, installFolderName) {\n        const packageJson = JsonFile.load(packageJsonFilename);\n        const npmPackage = {\n            children: [],\n            error: null,\n            id: 0,\n            isLink: false,\n            package: packageJson,\n            parent: null,\n            path: installFolderName,\n            realpath: installFolderName\n        };\n        return NpmPackage.createFromNpm(npmPackage);\n    }\n    /**\n     * Recursive constructs a tree of NpmPackage objects using information returned\n     * by the \"read-package-tree\" library.\n     */\n    static createFromNpm(npmPackage) {\n        if (npmPackage.error) {\n            throw new Error(`Failed to parse package.json for ${path.basename(npmPackage.path)}: ${npmPackage.error.message}`);\n        }\n        let dependencies = [];\n        const dependencyNames = new Set();\n        const packageJson = npmPackage.package;\n        if (packageJson.optionalDependencies) {\n            for (const dependencyName of Object.keys(packageJson.optionalDependencies)) {\n                if (!dependencyNames.has(dependencyName)) {\n                    dependencyNames.add(dependencyName);\n                    dependencies.push({\n                        name: dependencyName,\n                        versionRange: packageJson.optionalDependencies[dependencyName],\n                        kind: PackageDependencyKind.Optional\n                    });\n                }\n            }\n        }\n        if (packageJson.dependencies) {\n            for (const dependencyName of Object.keys(packageJson.dependencies)) {\n                if (!dependencyNames.has(dependencyName)) {\n                    dependencyNames.add(dependencyName);\n                    dependencies.push({\n                        name: dependencyName,\n                        versionRange: packageJson.dependencies[dependencyName],\n                        kind: PackageDependencyKind.Normal\n                    });\n                }\n            }\n        }\n        if (packageJson.rushDependencies) {\n            for (const dependencyName of Object.keys(packageJson.rushDependencies)) {\n                if (!dependencyNames.has(dependencyName)) {\n                    dependencyNames.add(dependencyName);\n                    dependencies.push({\n                        name: dependencyName,\n                        versionRange: packageJson.dependencies[dependencyName],\n                        kind: PackageDependencyKind.LocalLink\n                    });\n                }\n            }\n        }\n        dependencies = dependencies.sort((a, b) => a.name.localeCompare(b.name));\n        const newPackage = new NpmPackage(npmPackage.package.name, npmPackage.package.version, dependencies, \n        // NOTE: We don't use packageNode.realpath here, because if \"npm unlink\" was\n        // performed without redoing \"rush link\", then a broken symlink is better than\n        // a symlink to the wrong thing.\n        npmPackage.path);\n        for (const child of npmPackage.children) {\n            newPackage.addChild(NpmPackage.createFromNpm(child));\n        }\n        return newPackage;\n    }\n    /**\n     * Searches the node_modules hierarchy for the nearest matching package with the\n     * given name.  Note that the nearest match may have an incompatible version.\n     * If a match is found, then the \"found\" result will not be undefined.\n     * In either case, the parentForCreate result indicates where the missing\n     * dependency can be added, i.e. if the requested dependency was not found\n     * or was found with an incompatible version.\n     *\n     * \"cyclicSubtreeRoot\" is a special optional parameter that specifies a different\n     * root for the tree; the decoupledLocalDependencies feature uses this to isolate\n     * certain devDependencies in their own subtree.\n     */\n    resolveOrCreate(dependencyName, cyclicSubtreeRoot) {\n        let currentParent = this;\n        let parentForCreate = undefined;\n        for (;;) {\n            // Does any child match?\n            for (const child of currentParent.children) {\n                // The package.json name can differ from the installation folder name, in the case of an NPM package alias\n                // such as this:\n                //\n                // \"dependencies\": {\n                //   \"@alias-scope/alias-name\": \"npm:target-name@^1.2.3\"\n                // }\n                //\n                // Thus we need to compare child.installedName instead of child.name:\n                if (child.installedName === dependencyName) {\n                    // One of the children matched.  Note that parentForCreate may be\n                    // undefined, e.g. if an immediate child is found but has the wrong version,\n                    // then we have no place in the tree to create another version.\n                    return { found: child, parentForCreate };\n                }\n            }\n            // If no child matched, then make this node the \"parentForCreate\" where we\n            // could add a missing dependency.\n            parentForCreate = currentParent;\n            if (!currentParent.parent || (cyclicSubtreeRoot && currentParent === cyclicSubtreeRoot)) {\n                // We reached the root without finding a match\n                // parentForCreate will be the root.\n                return { found: undefined, parentForCreate };\n            }\n            // Continue walking upwards.\n            currentParent = currentParent.parent;\n        }\n    }\n    /**\n     * Searches the node_modules hierarchy for the nearest matching package with the\n     * given name.  If no match is found, then undefined is returned.\n     */\n    resolve(dependencyName) {\n        return this.resolveOrCreate(dependencyName).found;\n    }\n}\n//# sourceMappingURL=NpmPackage.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport uriEncode from 'strict-uri-encode';\nimport pnpmLinkBins from '@pnpm/link-bins';\nimport * as semver from 'semver';\nimport colors from 'colors/safe';\nimport { AlreadyReportedError, FileSystem, FileConstants, InternalError, Path } from '@rushstack/node-core-library';\nimport { BaseLinkManager } from '../base/BaseLinkManager';\nimport { BasePackage } from '../base/BasePackage';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PnpmShrinkwrapFile, normalizePnpmVersionSpecifier } from './PnpmShrinkwrapFile';\n// special flag for debugging, will print extra diagnostic information,\n// but comes with performance cost\nconst DEBUG = false;\nexport class PnpmLinkManager extends BaseLinkManager {\n    constructor() {\n        super(...arguments);\n        this._pnpmVersion = new semver.SemVer(this._rushConfiguration.packageManagerToolVersion);\n    }\n    /**\n     * @override\n     */\n    async createSymlinksForProjects(force) {\n        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;\n        if (useWorkspaces) {\n            // eslint-disable-next-line no-console\n            console.log(colors.red('Linking is not supported when using workspaces. Run \"rush install\" or \"rush update\" ' +\n                'to restore project node_modules folders.'));\n            throw new AlreadyReportedError();\n        }\n        await super.createSymlinksForProjects(force);\n    }\n    async _linkProjects() {\n        if (this._rushConfiguration.projects.length > 0) {\n            // Use shrinkwrap from temp as the committed shrinkwrap may not always be up to date\n            // See https://github.com/microsoft/rushstack/issues/1273#issuecomment-492779995\n            const pnpmShrinkwrapFile = PnpmShrinkwrapFile.loadFromFile(this._rushConfiguration.tempShrinkwrapFilename);\n            if (!pnpmShrinkwrapFile) {\n                throw new InternalError(`Cannot load shrinkwrap at \"${this._rushConfiguration.tempShrinkwrapFilename}\"`);\n            }\n            for (const rushProject of this._rushConfiguration.projects) {\n                await this._linkProject(rushProject, pnpmShrinkwrapFile);\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow('\\nWarning: Nothing to do. Please edit rush.json and add at least one project' +\n                ' to the \"projects\" section.\\n'));\n        }\n    }\n    /**\n     * This is called once for each local project from Rush.json.\n     * @param project             The local project that we will create symlinks for\n     * @param rushLinkJson        The common/temp/rush-link.json output file\n     */\n    async _linkProject(project, pnpmShrinkwrapFile) {\n        // eslint-disable-next-line no-console\n        console.log(`\\nLINKING: ${project.packageName}`);\n        // first, read the temp package.json information\n        // Example: \"project1\"\n        const unscopedTempProjectName = this._rushConfiguration.packageNameParser.getUnscopedName(project.tempProjectName);\n        // Example: \"C:\\MyRepo\\common\\temp\\projects\\project1\n        const extractedFolder = path.join(this._rushConfiguration.commonTempFolder, RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);\n        // Example: \"C:\\MyRepo\\common\\temp\\projects\\project1\\package.json\"\n        const packageJsonFilename = path.join(extractedFolder, FileConstants.PackageJson);\n        // Example: \"C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\\project1\"\n        const installFolderName = path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, RushConstants.rushTempNpmScope, unscopedTempProjectName);\n        const commonPackage = BasePackage.createVirtualTempPackage(packageJsonFilename, installFolderName);\n        const localPackage = BasePackage.createLinkedPackage(project.packageName, commonPackage.version, project.projectFolder);\n        // now that we have the temp package.json, we can go ahead and link up all the direct dependencies\n        // first, start with the rush dependencies, we just need to link to the project folder\n        for (const dependencyName of Object.keys(commonPackage.packageJson.rushDependencies || {})) {\n            const matchedRushPackage = this._rushConfiguration.getProjectByName(dependencyName);\n            if (matchedRushPackage) {\n                // We found a suitable match, so place a new local package that\n                // symlinks to the Rush project\n                const matchedVersion = matchedRushPackage.packageJsonEditor.version;\n                // e.g. \"C:\\my-repo\\project-a\\node_modules\\project-b\" if project-b is a rush dependency of project-a\n                const newLocalFolderPath = path.join(localPackage.folderPath, 'node_modules', dependencyName);\n                const newLocalPackage = BasePackage.createLinkedPackage(dependencyName, matchedVersion, newLocalFolderPath);\n                newLocalPackage.symlinkTargetFolderPath = matchedRushPackage.projectFolder;\n                localPackage.children.push(newLocalPackage);\n            }\n            else {\n                throw new InternalError(`Cannot find dependency \"${dependencyName}\" for \"${project.packageName}\" in the Rush configuration`);\n            }\n        }\n        // Iterate through all the regular dependencies\n        // With npm, it's possible for two different projects to have dependencies on\n        // the same version of the same library, but end up with different implementations\n        // of that library, if the library is installed twice and with different secondary\n        // dependencies.The NpmLinkManager recursively links dependency folders to try to\n        // honor this. Since PNPM always uses the same physical folder to represent a given\n        // version of a library, we only need to link directly to the folder that PNPM has chosen,\n        // and it will have a consistent set of secondary dependencies.\n        // each of these dependencies should be linked in a special folder that pnpm\n        // creates for the installed version of each .TGZ package, all we need to do\n        // is re-use that symlink in order to get linked to whatever PNPM thought was\n        // appropriate. This folder is usually something like:\n        // C:\\{uri-encoded-path-to-tgz}\\node_modules\\{package-name}\n        // e.g.:\n        //   file:projects/bentleyjs-core.tgz\n        //   file:projects/build-tools.tgz_dc21d88642e18a947127a751e00b020a\n        //   file:projects/imodel-from-geojson.tgz_request@2.88.0\n        const tempProjectDependencyKey = pnpmShrinkwrapFile.getTempProjectDependencyKey(project.tempProjectName);\n        if (!tempProjectDependencyKey) {\n            throw new Error(`Cannot get dependency key for temp project: ${project.tempProjectName}`);\n        }\n        // e.g.: file:projects/project-name.tgz\n        const tarballEntry = pnpmShrinkwrapFile.getTarballPath(tempProjectDependencyKey);\n        if (!tarballEntry) {\n            throw new InternalError(`Cannot find tarball path for \"${project.tempProjectName}\" in shrinkwrap.`);\n        }\n        // e.g.: projects\\api-documenter.tgz\n        const relativePathToTgzFile = tarballEntry.slice(`file:`.length);\n        // e.g.: C:\\wbt\\common\\temp\\projects\\api-documenter.tgz\n        const absolutePathToTgzFile = path.resolve(this._rushConfiguration.commonTempFolder, relativePathToTgzFile);\n        // The folder name in `.local` is constructed as:\n        //   UriEncode(absolutePathToTgzFile) + _suffix\n        //\n        // Note that _suffix is not encoded. The tarball attribute of the package 'file:projects/project-name.tgz_suffix'\n        // holds the tarball path 'file:projects/project-name.tgz', which can be used for the constructing the folder name.\n        //\n        // '_suffix' is extracted by stripping the tarball path from top level dependency value.\n        // tarball path = 'file:projects/project-name.tgz'\n        // top level dependency = 'file:projects/project-name.tgz_suffix'\n        // e.g.:\n        //   '' [empty string]\n        //   _@types+node@14.18.36\n        //   _jsdom@11.12.0\n        //   _2a665c89609864b4e75bc5365d7f8f56\n        //   (@types/node@14.18.36)\n        const folderNameSuffix = tarballEntry && tarballEntry.length < tempProjectDependencyKey.length\n            ? tempProjectDependencyKey.slice(tarballEntry.length)\n            : '';\n        // e.g.: C:\\wbt\\common\\temp\\node_modules\\.local\\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\\node_modules\n        const pathToLocalInstallation = await this._getPathToLocalInstallationAsync(tarballEntry, absolutePathToTgzFile, folderNameSuffix);\n        const parentShrinkwrapEntry = pnpmShrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);\n        if (!parentShrinkwrapEntry) {\n            throw new InternalError(`Cannot find shrinkwrap entry using dependency key for temp project: ${project.tempProjectName}`);\n        }\n        for (const dependencyName of Object.keys(commonPackage.packageJson.dependencies || {})) {\n            const newLocalPackage = this._createLocalPackageForDependency(project, parentShrinkwrapEntry, localPackage, pathToLocalInstallation, dependencyName);\n            localPackage.addChild(newLocalPackage);\n        }\n        // TODO: Rush does not currently handle optional dependencies of projects. This should be uncommented when\n        // support is added\n        // for (const dependencyName of Object.keys(commonPackage.packageJson!.optionalDependencies || {})) {\n        //   const newLocalPackage: BasePackage | undefined = this._createLocalPackageForDependency(\n        //     project,\n        //     parentShrinkwrapEntry,\n        //     localPackage,\n        //     pathToLocalInstallation,\n        //     dependencyName,\n        //     true); // isOptional\n        //   if (newLocalPackage) {\n        //     localPackage.addChild(newLocalPackage);\n        //   }\n        // }\n        if (DEBUG) {\n            localPackage.printTree();\n        }\n        await pnpmShrinkwrapFile.getProjectShrinkwrap(project).updateProjectShrinkwrapAsync();\n        PnpmLinkManager._createSymlinksForTopLevelProject(localPackage);\n        // Also symlink the \".bin\" folder\n        const projectFolder = path.join(localPackage.folderPath, 'node_modules');\n        const projectBinFolder = path.join(localPackage.folderPath, 'node_modules', '.bin');\n        await pnpmLinkBins(projectFolder, projectBinFolder, {\n            warn: (msg) => {\n                // eslint-disable-next-line no-console\n                console.warn(colors.yellow(msg));\n            }\n        });\n    }\n    async _getPathToLocalInstallationAsync(tarballEntry, absolutePathToTgzFile, folderSuffix) {\n        if (this._pnpmVersion.major === 6) {\n            // PNPM 6 changed formatting to replace all ':' and '/' chars with '+'. Additionally, folder names > 120\n            // are trimmed and hashed. NOTE: PNPM internally uses fs.realpath.native, which will cause additional\n            // issues in environments that do not support long paths.\n            // See https://github.com/pnpm/pnpm/releases/tag/v6.0.0\n            // e.g.:\n            //   C++dev+imodeljs+imodeljs+common+temp+projects+presentation-integration-tests.tgz_jsdom@11.12.0\n            //   C++dev+imodeljs+imodeljs+common+temp+projects+presentation-integrat_089eb799caf0f998ab34e4e1e9254956\n            const specialCharRegex = /\\/|:/g;\n            const escapedLocalPath = Path.convertToSlashes(absolutePathToTgzFile).replace(specialCharRegex, '+');\n            let folderName = `local+${escapedLocalPath}${folderSuffix}`;\n            if (folderName.length > 120) {\n                folderName = `${folderName.substring(0, 50)}_${crypto\n                    .createHash('md5')\n                    .update(folderName)\n                    .digest('hex')}`;\n            }\n            return path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, '.pnpm', folderName, RushConstants.nodeModulesFolderName);\n        }\n        else if (this._pnpmVersion.major >= 8) {\n            const { depPathToFilename } = await import('@pnpm/dependency-path');\n            // PNPM 8 changed the local path format again and the hashing algorithm, and\n            // is now using the scoped '@pnpm/dependency-path' package\n            // See https://github.com/pnpm/pnpm/releases/tag/v8.0.0\n            // e.g.:\n            //   file+projects+presentation-integration-tests.tgz_jsdom@11.12.0\n            const folderName = depPathToFilename(`${tarballEntry}${folderSuffix}`);\n            return path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, '.pnpm', folderName, RushConstants.nodeModulesFolderName);\n        }\n        else if (this._pnpmVersion.major >= 7) {\n            const { depPathToFilename } = await import('dependency-path');\n            // PNPM 7 changed the local path format again and the hashing algorithm\n            // See https://github.com/pnpm/pnpm/releases/tag/v7.0.0\n            // e.g.:\n            //   file+projects+presentation-integration-tests.tgz_jsdom@11.12.0\n            const escapedLocalPath = depPathToFilename(tarballEntry);\n            const folderName = `${escapedLocalPath}${folderSuffix}`;\n            return path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, '.pnpm', folderName, RushConstants.nodeModulesFolderName);\n        }\n        else {\n            // e.g.:\n            //   C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\n            //   C%3A%2Fdev%2Fimodeljs%2Fimodeljs%2Fcommon%2Ftemp%2Fprojects%2Fpresentation-integration-tests.tgz_jsdom@11.12.0\n            //   C%3A%2Fdev%2Fimodeljs%2Fimodeljs%2Fcommon%2Ftemp%2Fprojects%2Fbuild-tools.tgz_2a665c89609864b4e75bc5365d7f8f56\n            const folderNameInLocalInstallationRoot = uriEncode(Path.convertToSlashes(absolutePathToTgzFile)) + folderSuffix;\n            // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0\n            return path.join(this._rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName, '.pnpm', 'local', folderNameInLocalInstallationRoot, RushConstants.nodeModulesFolderName);\n        }\n    }\n    _createLocalPackageForDependency(project, parentShrinkwrapEntry, localPackage, pathToLocalInstallation, dependencyName, isOptional = false) {\n        // the dependency we are looking for should have already created a symlink here\n        // FYI dependencyName might contain an NPM scope, here it gets converted into a filesystem folder name\n        // e.g. if the dependency is supi:\n        // \"C:\\wbt\\common\\temp\\node_modules\\.local\\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\\node_modules\\supi\"\n        const dependencyLocalInstallationSymlink = path.join(pathToLocalInstallation, dependencyName);\n        if (!FileSystem.exists(dependencyLocalInstallationSymlink)) {\n            // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior\n            throw new InternalError(`Cannot find installed dependency \"${dependencyName}\" in \"${pathToLocalInstallation}\"`);\n        }\n        if (!FileSystem.getLinkStatistics(dependencyLocalInstallationSymlink).isSymbolicLink()) {\n            // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior\n            throw new InternalError(`Dependency \"${dependencyName}\" is not a symlink in \"${pathToLocalInstallation}`);\n        }\n        // read the version number from the shrinkwrap entry and return if no version is specified\n        // and the dependency is optional\n        const versionSpecifier = isOptional\n            ? (parentShrinkwrapEntry.optionalDependencies || {})[dependencyName]\n            : (parentShrinkwrapEntry.dependencies || {})[dependencyName];\n        if (!versionSpecifier) {\n            if (!isOptional) {\n                throw new InternalError(`Cannot find shrinkwrap entry dependency \"${dependencyName}\" for temp project: ` +\n                    `${project.tempProjectName}`);\n            }\n            return;\n        }\n        const newLocalFolderPath = path.join(localPackage.folderPath, 'node_modules', dependencyName);\n        const version = normalizePnpmVersionSpecifier(versionSpecifier);\n        const newLocalPackage = BasePackage.createLinkedPackage(dependencyName, version, newLocalFolderPath);\n        // The dependencyLocalInstallationSymlink is just a symlink to another folder. To reduce the number of filesystem\n        // reads that are needed, we will link to where that symlink pointed, rather than linking to a link.\n        newLocalPackage.symlinkTargetFolderPath = FileSystem.getRealPath(dependencyLocalInstallationSymlink);\n        return newLocalPackage;\n    }\n}\n//# sourceMappingURL=PnpmLinkManager.js.map"],"names":[],"sourceRoot":""}