"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zSchemaOptions = void 0;
exports.ZSchema = require("z-schema");
// @todo 264263 - utilize the schema validator in sp-build-common
const fs = __importStar(require("fs"));
const os_1 = require("os");
const path = __importStar(require("path"));
// Discover the schema files
const schemasDirectory = path.join(__dirname, 'manifestSchemas', 'jsonSchemas');
const schemaFiles = fs.readdirSync(schemasDirectory);
const schemas = schemaFiles.map((schemaFile) => require(path.join(schemasDirectory, schemaFile)));
const manifestSchema = require('./manifestSchemas/jsonSchemas/client-side-component-manifest.schema.json');
const applicationSchema = require('./manifestSchemas/jsonSchemas/client-side-application-manifest.schema.json');
const webPartSchema = require('./manifestSchemas/jsonSchemas/client-side-web-part-manifest.schema.json');
const commandSetSchema = require('./manifestSchemas/jsonSchemas/command-set-extension-manifest.schema.json');
const extensionSchema = require('./manifestSchemas/jsonSchemas/client-side-extension-manifest.schema.json');
const librarySchema = require('./manifestSchemas/jsonSchemas/client-side-library-manifest.schema.json');
const assemblySchema = require('./manifestSchemas/jsonSchemas/client-side-assembly-manifest.schema.json');
const multiVersionSchema = require('./manifestSchemas/jsonSchemas/client-side-multi-version-manifest.schema.json');
exports.zSchemaOptions = {
    breakOnFirstError: true,
    forceAdditional: true,
    forceItems: true,
    forceMaxLength: false,
    forceProperties: false,
    noExtraKeywords: true,
    noTypeless: true,
    noEmptyStrings: true
};
const schemaValidator = new exports.ZSchema(exports.zSchemaOptions);
schemaValidator.validateSchema(schemas);
class ManifestValidator {
    static validateApplicationManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, applicationSchema);
    }
    static validateCommandSetManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, commandSetSchema);
    }
    static validateExtensionManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, extensionSchema);
    }
    static validateWebPartManifest(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, webPartSchema);
    }
    static validateLibraryManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, librarySchema);
    }
    static validateAssemblyManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, assemblySchema);
    }
    static validateMultiVersionManifest(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, multiVersionSchema);
    }
    static validateManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, manifestSchema);
    }
    static extractInnerErrorMessages(errors) {
        const printZSchemaError = (error) => {
            let innerErrors = [];
            (error.inner || []).forEach((innerErr) => {
                innerErrors = innerErrors.concat(printZSchemaError(innerErr));
            });
            return [`(${error.path}) ${error.message}`].concat(innerErrors);
        };
        let errorList = [];
        errors.map((error) => {
            errorList = errorList.concat(printZSchemaError(error));
        });
        return errorList;
    }
    static getFormattedErrorMessage(errors) {
        return this.extractInnerErrorMessages(errors).join(os_1.EOL);
    }
    static _validateManifest(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest, schema) {
        if (!schema) {
            throw new Error('Unable to find the manifest schema.');
        }
        if (typeof manifest === 'string') {
            manifest = JSON.parse(manifest);
        }
        const result = schemaValidator.validate(manifest, schema);
        return {
            result: result,
            errors: schemaValidator.getLastErrors() || []
        };
    }
}
exports.default = ManifestValidator;
//# sourceMappingURL=manifestSchemaValidator.js.map