import { DeviceCodeCredential, AzureAuthorityHosts } from '@azure/identity';
import type { ITerminal } from '@rushstack/node-core-library';
import type { ICredentialCacheEntry } from '@rushstack/rush-sdk';
/**
 * @public
 */
export type ExpiredCredentialBehavior = 'logWarning' | 'throwError' | 'ignore';
/**
 * @public
 */
export interface ITryGetCachedCredentialOptionsBase {
    /**
     * The behavior to take when the cached credential has expired.
     * Defaults to 'throwError'
     */
    expiredCredentialBehavior?: ExpiredCredentialBehavior;
    terminal?: ITerminal;
}
/**
 * @public
 */
export interface ITryGetCachedCredentialOptionsLogWarning extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'logWarning';
    terminal: ITerminal;
}
/**
 * @public
 */
export interface ITryGetCachedCredentialOptionsThrow extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'throwError';
}
/**
 * @public
 */
export interface ITryGetCachedCredentialOptionsIgnore extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'ignore';
}
export type ITryGetCachedCredentialOptions = ITryGetCachedCredentialOptionsLogWarning | ITryGetCachedCredentialOptionsThrow | ITryGetCachedCredentialOptionsIgnore;
/**
 * @public
 */
export type AzureEnvironmentName = keyof typeof AzureAuthorityHosts;
/**
 * @public
 */
export interface IAzureAuthenticationBaseOptions {
    azureEnvironment?: AzureEnvironmentName;
    credentialUpdateCommandForLogging?: string | undefined;
}
/**
 * @public
 */ export interface ICredentialResult {
    credentialString: string;
    expiresOn?: Date;
    credentialMetadata?: object;
}
/**
 * @public
 */
export declare abstract class AzureAuthenticationBase {
    protected abstract readonly _credentialNameForCache: string;
    protected abstract readonly _credentialKindForLogging: string;
    protected readonly _credentialUpdateCommandForLogging: string | undefined;
    protected readonly _azureEnvironment: AzureEnvironmentName;
    private __credentialCacheId;
    private get _credentialCacheId();
    constructor(options: IAzureAuthenticationBaseOptions);
    updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void>;
    /**
     * Launches an interactive flow to renew a cached credential.
     *
     * @param terminal - The terminal to log output to
     * @param onlyIfExistingCredentialExpiresAfter - If specified, and a cached credential exists that is still valid
     * after the date specified, no action will be taken.
     */
    updateCachedCredentialInteractiveAsync(terminal: ITerminal, onlyIfExistingCredentialExpiresAfter?: Date): Promise<void>;
    deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void>;
    tryGetCachedCredentialAsync(options?: ITryGetCachedCredentialOptionsThrow | ITryGetCachedCredentialOptionsIgnore): Promise<ICredentialCacheEntry | undefined>;
    tryGetCachedCredentialAsync(options: ITryGetCachedCredentialOptionsLogWarning): Promise<ICredentialCacheEntry | undefined>;
    /**
     * Get parts of the cache ID that are specific to the credential type. Note that this should
     * not contain the Azure environment or the {@link AzureAuthenticationBase._credentialNameForCache}
     * value, as those are added automatically.
     */
    protected abstract _getCacheIdParts(): string[];
    protected abstract _getCredentialFromDeviceCodeAsync(terminal: ITerminal, deviceCodeCredential: DeviceCodeCredential): Promise<ICredentialResult>;
    private _getCredentialAsync;
}
//# sourceMappingURL=AzureAuthenticationBase.d.ts.map