{"version":3,"file":"HttpBuildCacheProvider.js","sourceRoot":"","sources":["../src/HttpBuildCacheProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITerminal, Executable, Async } from '@rushstack/node-core-library';\nimport {\n  ICloudBuildCacheProvider,\n  ICredentialCacheEntry,\n  CredentialCache,\n  RushSession,\n  EnvironmentConfiguration\n} from '@rushstack/rush-sdk';\nimport fetch, { BodyInit, Response } from 'node-fetch';\n\nenum CredentialsOptions {\n  Optional,\n  Required,\n  Omit\n}\n\nenum FailureType {\n  None,\n  Informational,\n  Warning,\n  Error,\n  Authentication\n}\n\nexport interface IHttpBuildCacheTokenHandler {\n  exec: string;\n  args?: string[];\n}\n\n/**\n * @public\n */\nexport interface IHttpBuildCacheProviderOptions {\n  url: string;\n  tokenHandler?: IHttpBuildCacheTokenHandler;\n  uploadMethod?: string;\n  minHttpRetryDelayMs?: number;\n  headers?: Record<string, string>;\n  cacheKeyPrefix?: string;\n  isCacheWriteAllowed: boolean;\n  pluginName: string;\n  rushProjectRoot: string;\n}\n\nconst MAX_HTTP_CACHE_ATTEMPTS: number = 3;\nconst DEFAULT_MIN_HTTP_RETRY_DELAY_MS = 2500;\n\nexport class HttpBuildCacheProvider implements ICloudBuildCacheProvider {\n  private readonly _pluginName: string;\n  private readonly _rushSession: RushSession;\n  private readonly _rushProjectRoot: string;\n  private readonly _environmentCredential: string | undefined;\n  private readonly _isCacheWriteAllowedByConfiguration: boolean;\n  private readonly _url: URL;\n  private readonly _uploadMethod: string;\n  private readonly _headers: Record<string, string>;\n  private readonly _cacheKeyPrefix: string;\n  private readonly _tokenHandler: IHttpBuildCacheTokenHandler | undefined;\n  private readonly _minHttpRetryDelayMs: number;\n  private __credentialCacheId: string | undefined;\n\n  public get isCacheWriteAllowed(): boolean {\n    return EnvironmentConfiguration.buildCacheWriteAllowed ?? this._isCacheWriteAllowedByConfiguration;\n  }\n\n  public constructor(options: IHttpBuildCacheProviderOptions, rushSession: RushSession) {\n    this._pluginName = options.pluginName;\n    this._rushSession = rushSession;\n    this._rushProjectRoot = options.rushProjectRoot;\n\n    this._environmentCredential = EnvironmentConfiguration.buildCacheCredential;\n    this._isCacheWriteAllowedByConfiguration = options.isCacheWriteAllowed;\n    this._url = new URL(options.url.endsWith('/') ? options.url : options.url + '/');\n    this._uploadMethod = options.uploadMethod ?? 'PUT';\n    this._headers = options.headers ?? {};\n    this._tokenHandler = options.tokenHandler;\n    this._cacheKeyPrefix = options.cacheKeyPrefix ?? '';\n    this._minHttpRetryDelayMs = options.minHttpRetryDelayMs ?? DEFAULT_MIN_HTTP_RETRY_DELAY_MS;\n  }\n\n  public async tryGetCacheEntryBufferByIdAsync(\n    terminal: ITerminal,\n    cacheId: string\n  ): Promise<Buffer | undefined> {\n    try {\n      const result = await this._http({\n        terminal: terminal,\n        relUrl: `${this._cacheKeyPrefix}${cacheId}`,\n        method: 'GET',\n        body: undefined,\n        warningText: 'Could not get cache entry',\n        readBody: true,\n        maxAttempts: MAX_HTTP_CACHE_ATTEMPTS\n      });\n\n      return Buffer.isBuffer(result) ? result : undefined;\n    } catch (e) {\n      terminal.writeWarningLine(`Error getting cache entry: ${e}`);\n      return undefined;\n    }\n  }\n\n  public async trySetCacheEntryBufferAsync(\n    terminal: ITerminal,\n    cacheId: string,\n    objectBuffer: Buffer\n  ): Promise<boolean> {\n    if (!this.isCacheWriteAllowed) {\n      terminal.writeErrorLine('Writing to cache is not allowed in the current configuration.');\n      return false;\n    }\n\n    terminal.writeDebugLine('Uploading object with cacheId: ', cacheId);\n\n    try {\n      const result = await this._http({\n        terminal: terminal,\n        relUrl: `${this._cacheKeyPrefix}${cacheId}`,\n        method: this._uploadMethod,\n        body: objectBuffer,\n        warningText: 'Could not write cache entry',\n        readBody: false,\n        maxAttempts: MAX_HTTP_CACHE_ATTEMPTS\n      });\n\n      return result !== false;\n    } catch (e) {\n      terminal.writeWarningLine(`Error uploading cache entry: ${e}`);\n      return false;\n    }\n  }\n\n  public async updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.setCacheEntry(this._credentialCacheId, {\n          credential: credential\n        });\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  public async updateCachedCredentialInteractiveAsync(terminal: ITerminal): Promise<void> {\n    if (!this._tokenHandler) {\n      throw new Error(\n        `The interactive cloud credentials flow is not configured.\\n` +\n          `Set the 'tokenHandler' setting in 'common/config/rush-plugins/${this._pluginName}.json' to a command that writes your credentials to standard output and exits with code 0 ` +\n          `or provide your credentials to rush using the --credential flag instead. Credentials must be the ` +\n          `'Authorization' header expected by ${this._url.href}`\n      );\n    }\n\n    const cmd: string = `${this._tokenHandler.exec} ${(this._tokenHandler.args || []).join(' ')}`;\n    terminal.writeVerboseLine(`Running '${cmd}' to get credentials`);\n    const result = Executable.spawnSync(this._tokenHandler.exec, this._tokenHandler.args || []);\n\n    terminal.writeErrorLine(result.stderr);\n\n    if (result.error) {\n      throw new Error(`Could not obtain credentials. The command '${cmd}' failed.`);\n    }\n\n    const credential = result.stdout.trim();\n    terminal.writeVerboseLine('Got credentials');\n\n    await this.updateCachedCredentialAsync(terminal, credential);\n\n    terminal.writeLine('Updated credentials cache');\n  }\n\n  public async deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.deleteCacheEntry(this._credentialCacheId);\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  private get _credentialCacheId(): string {\n    if (!this.__credentialCacheId) {\n      const cacheIdParts: string[] = [this._url.href];\n\n      if (this._isCacheWriteAllowedByConfiguration) {\n        cacheIdParts.push('cacheWriteAllowed');\n      }\n\n      this.__credentialCacheId = cacheIdParts.join('|');\n    }\n\n    return this.__credentialCacheId;\n  }\n\n  private async _http(options: {\n    terminal: ITerminal;\n    relUrl: string;\n    method: string;\n    body: BodyInit | undefined;\n    warningText: string;\n    readBody: boolean;\n    maxAttempts: number;\n    credentialOptions?: CredentialsOptions;\n  }): Promise<Buffer | boolean> {\n    const { terminal, relUrl, method, body, warningText, readBody, credentialOptions } = options;\n    const safeCredentialOptions = credentialOptions ?? CredentialsOptions.Optional;\n    const credentials = await this._tryGetCredentials(safeCredentialOptions);\n    const url = new URL(relUrl, this._url).href;\n\n    const headers: Record<string, string> = {};\n    if (typeof credentials === 'string') {\n      headers.Authorization = credentials;\n    }\n\n    for (const [key, value] of Object.entries(this._headers)) {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    }\n\n    const bodyLength = (body as { length: number })?.length || 'unknown';\n\n    terminal.writeDebugLine(`[http-build-cache] request: ${method} ${url} ${bodyLength} bytes`);\n\n    const response = await fetch(url, {\n      method: method,\n      headers: headers,\n      body: body,\n      redirect: 'follow'\n    });\n\n    if (!response.ok) {\n      const isNonCredentialResponse = response.status >= 500 && response.status < 600;\n\n      if (\n        !isNonCredentialResponse &&\n        typeof credentials !== 'string' &&\n        safeCredentialOptions === CredentialsOptions.Optional\n      ) {\n        // If we don't already have credentials yet, and we got a response from the server\n        // that is a \"normal\" failure (4xx), then we assume that credentials are probably\n        // required. Re-attempt the request, requiring credentials this time.\n        //\n        // This counts as part of the \"first attempt\", so it is not included in the max attempts\n        return await this._http({ ...options, credentialOptions: CredentialsOptions.Required });\n      }\n\n      if (options.maxAttempts > 1) {\n        // Pause a bit before retrying in case the server is busy\n        // Add some random jitter to the retry so we can spread out load on the remote service\n        // A proper solution might add exponential back off in case the retry count is high (10 or more)\n        const factor = 1.0 + Math.random(); // A random number between 1.0 and 2.0\n        const retryDelay = Math.floor(factor * this._minHttpRetryDelayMs);\n\n        await Async.sleep(retryDelay);\n\n        return await this._http({ ...options, maxAttempts: options.maxAttempts - 1 });\n      }\n\n      this._reportFailure(terminal, method, response, false, warningText);\n      return false;\n    }\n\n    const result: Buffer | boolean = readBody ? Buffer.from(await response.arrayBuffer()) : true;\n\n    terminal.writeDebugLine(\n      `[http-build-cache] actual response: ${response.status} ${url} ${\n        result === true ? 'true' : result.length\n      } bytes`\n    );\n\n    return result;\n  }\n\n  private async _tryGetCredentials(options: CredentialsOptions.Required): Promise<string>;\n  private async _tryGetCredentials(options: CredentialsOptions.Optional): Promise<string | undefined>;\n  private async _tryGetCredentials(options: CredentialsOptions.Omit): Promise<undefined>;\n  private async _tryGetCredentials(options: CredentialsOptions): Promise<string | undefined>;\n  private async _tryGetCredentials(options: CredentialsOptions): Promise<string | undefined> {\n    if (options === CredentialsOptions.Omit) {\n      return;\n    }\n\n    let credentials: string | undefined = this._environmentCredential;\n\n    if (credentials === undefined) {\n      credentials = await this._tryGetCredentialsFromCache();\n    }\n\n    if (typeof credentials !== 'string' && options === CredentialsOptions.Required) {\n      throw new Error(\n        [\n          `Credentials for ${this._url.href} have not been provided.`,\n          `In CI, verify that RUSH_BUILD_CACHE_CREDENTIAL contains a valid Authorization header value.`,\n          ``,\n          `For local developers, run:`,\n          ``,\n          `    rush update-cloud-credentials --interactive`,\n          ``\n        ].join('\\n')\n      );\n    }\n\n    return credentials;\n  }\n\n  private async _tryGetCredentialsFromCache(): Promise<string | undefined> {\n    let cacheEntry: ICredentialCacheEntry | undefined;\n\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: false\n      },\n      (credentialsCache: CredentialCache) => {\n        cacheEntry = credentialsCache.tryGetCacheEntry(this._credentialCacheId);\n      }\n    );\n\n    if (cacheEntry) {\n      const expirationTime: number | undefined = cacheEntry.expires?.getTime();\n      if (!expirationTime || expirationTime >= Date.now()) {\n        return cacheEntry.credential;\n      }\n    }\n  }\n\n  private _getFailureType(requestMethod: string, response: Response, isRedirect: boolean): FailureType {\n    if (response.ok) {\n      return FailureType.None;\n    }\n\n    switch (response.status) {\n      case 503: {\n        // We select 503 specifically because this represents \"service unavailable\" and\n        // \"rate limit throttle\" errors, which are transient issues.\n        //\n        // There are other 5xx errors, such as 501, that can occur if the request is\n        // malformed, so as a general rule we want to let through other 5xx errors\n        // so the user can troubleshoot.\n\n        // Don't fail production builds with warnings for transient issues\n        return FailureType.Informational;\n      }\n\n      case 401:\n      case 403:\n      case 407: {\n        if (requestMethod === 'GET' && (isRedirect || response.redirected)) {\n          // Cache misses for GET requests are not errors\n          // This is a workaround behavior where a server can issue a redirect and we fail to authenticate at the new location.\n          // We do not want to signal this as an authentication failure because the authorization header is not passed on to redirects.\n          // i.e The authentication header was accepted for the first request and therefore subsequent failures\n          // where it was not present should not be attributed to the header.\n          // This scenario usually comes up with services that redirect to pre-signed URLS that don't actually exist.\n          // Those services then usually treat the 404 as a 403 to prevent leaking information.\n          return FailureType.None;\n        }\n\n        return FailureType.Authentication;\n      }\n\n      case 404: {\n        if (requestMethod === 'GET') {\n          // Cache misses for GET requests are not errors\n          return FailureType.None;\n        }\n      }\n    }\n\n    // Let dev builds succeed, let Prod builds fail\n    return FailureType.Warning;\n  }\n\n  private _reportFailure(\n    terminal: ITerminal,\n    requestMethod: string,\n    response: Response,\n    isRedirect: boolean,\n    message: string\n  ): void {\n    switch (this._getFailureType(requestMethod, response, isRedirect)) {\n      default: {\n        terminal.writeErrorLine(`${message}: HTTP ${response.status}: ${response.statusText}`);\n        break;\n      }\n\n      case FailureType.Warning: {\n        terminal.writeWarningLine(`${message}: HTTP ${response.status}: ${response.statusText}`);\n        break;\n      }\n\n      case FailureType.Informational: {\n        terminal.writeLine(`${message}: HTTP ${response.status}: ${response.statusText}`);\n        break;\n      }\n\n      case FailureType.None: {\n        terminal.writeDebugLine(`${message}: HTTP ${response.status}: ${response.statusText}`);\n        break;\n      }\n\n      case FailureType.Authentication: {\n        throw new Error(\n          [\n            `${this._url.href} responded with ${response.status}: ${response.statusText}.`,\n            `Credentials may be misconfigured or have expired.`,\n            `In CI, verify that RUSH_BUILD_CACHE_CREDENTIAL contains a valid Authorization header value.`,\n            ``,\n            `For local developers, run:`,\n            ``,\n            `    rush update-cloud-credentials --interactive`,\n            ``\n          ].join('\\n')\n        );\n      }\n    }\n  }\n}\n"]}