"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ExecutionQueue_1 = tslib_1.__importDefault(require("../ExecutionQueue"));
/**
 * QosLogger allows multiple QosMonitors to be deferred processed.
 * @internal
 */
var QosLogger = /** @class */ (function () {
    function QosLogger() {
        this._qosEvents = new Map();
        this._deferExecutor = new ExecutionQueue_1.default();
        this._shouldProcessInRealTime = false;
        this._initializeLogger();
    }
    Object.defineProperty(QosLogger, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new QosLogger();
            }
            return this._instance;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosLogger.prototype, "shouldProcessInRealTime", {
        get: function () {
            return this._shouldProcessInRealTime;
        },
        set: function (processInRealTime) {
            this._shouldProcessInRealTime = processInRealTime;
            this._deferExecutor.shouldExecuteInRealTime = processInRealTime;
        },
        enumerable: false,
        configurable: true
    });
    QosLogger.prototype.setLogger = function (qosLogger) {
        this._qosLogger = qosLogger;
    };
    QosLogger.prototype.getQosEvent = function (key) {
        return this._qosEvents.get(key);
    };
    QosLogger.prototype.startQosMonitor = function (key, startData) {
        if (!this._qosEvents.has(key)) {
            this._deferExecutor.addExecutionEntry('start', key, startData);
        }
    };
    QosLogger.prototype.writeQosEndResult = function (key, endData) {
        this._deferExecutor.addExecutionEntry('end', key, endData);
    };
    QosLogger.prototype._startMonitor = function (key, event) {
        if (this._qosLogger) {
            this._qosEvents.set(key, new this._qosLogger(event));
        }
    };
    QosLogger.prototype._endMonitor = function (key, event) {
        var qosEvent = this._qosEvents.get(key);
        if (qosEvent) {
            qosEvent.end(event);
            this._qosEvents.delete(key);
        }
    };
    QosLogger.prototype._initializeLogger = function () {
        var _this = this;
        var startHandler = (function (key, e) {
            _this._startMonitor(key, e);
        });
        var endHandler = (function (key, e) {
            _this._endMonitor(key, e);
        });
        this._deferExecutor.addHandler('start', startHandler);
        this._deferExecutor.addHandler('end', endHandler);
    };
    return QosLogger;
}());
exports.default = QosLogger;
//# sourceMappingURL=QosLogger.js.map