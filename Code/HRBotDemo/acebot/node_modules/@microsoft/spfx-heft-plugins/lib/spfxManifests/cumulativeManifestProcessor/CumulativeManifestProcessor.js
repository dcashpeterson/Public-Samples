"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CumulativeManifestProcessor = exports.DependencyDiscoveryMode = void 0;
const path = __importStar(require("path"));
const lodash_1 = require("lodash");
const Resolve = __importStar(require("resolve"));
const node_core_library_1 = require("@rushstack/node-core-library");
const ManifestsFileBuilder_1 = require("../manifestFileBuilder/ManifestsFileBuilder");
const ManifestUrlProcessor_1 = require("./ManifestUrlProcessor");
const CUMULATIVE_MANIFEST_FILENAME = 'manifests';
/**
 * @internal
 */
var DependencyDiscoveryMode;
(function (DependencyDiscoveryMode) {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    DependencyDiscoveryMode[DependencyDiscoveryMode["none"] = 0] = "none";
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    DependencyDiscoveryMode[DependencyDiscoveryMode["shallow"] = 1] = "shallow";
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    DependencyDiscoveryMode[DependencyDiscoveryMode["deep"] = 2] = "deep";
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    DependencyDiscoveryMode[DependencyDiscoveryMode["deepSparse"] = 3] = "deepSparse";
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    DependencyDiscoveryMode[DependencyDiscoveryMode["deepSparseIgnoreFirstProject"] = 4] = "deepSparseIgnoreFirstProject";
})(DependencyDiscoveryMode = exports.DependencyDiscoveryMode || (exports.DependencyDiscoveryMode = {}));
/**
 * @internal
 */
class CumulativeManifestProcessor {
    constructor(options) {
        this._options = {
            includeAssemblies: false,
            ignoreNonSpfxManifests: false,
            ignoreOutputManifestIds: [],
            explicitInclude: [],
            ...options
        };
        this._discoveryCache = new Map();
    }
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    async generateCumulativeManifestAsync(debugManifests, manifestsJsFileMetadata) {
        if (!this._options) {
            // TODO: use terminal object for logging
            // eslint-disable-next-line no-console
            console.log('No cumulative manifest options specified. Skipping cumulative manifest generation.');
            return;
        }
        const referencedProjectManifests = this.discoverManifests(this._options.rootPath, DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
        const baseUrl = this._options.baseUrl || 'https://localhost:4321'; // Default if one isn't already defined
        const manifests = {};
        for (const id in referencedProjectManifests) {
            if (referencedProjectManifests.hasOwnProperty(id)) {
                manifests[id] = {};
                for (const version in referencedProjectManifests[id]) {
                    if (referencedProjectManifests[id].hasOwnProperty(version)) {
                        manifests[id][version] = this._getTransformedManifest(referencedProjectManifests[id][version], baseUrl);
                    }
                }
            }
        }
        for (const manifest of debugManifests) {
            const id = manifest.id;
            if (!manifests[id]) {
                manifests[id] = {};
            }
            manifests[id][manifest.version] = manifest;
        }
        const manifestsArray = [];
        for (const id in manifests) {
            if (manifests.hasOwnProperty(id) && this._options.ignoreOutputManifestIds.indexOf(id) === -1) {
                for (const version in manifests[id]) {
                    if (manifests[id].hasOwnProperty(version)) {
                        manifestsArray.push(manifests[id][version]);
                    }
                }
            }
        }
        // Write the manifests.json file
        node_core_library_1.FileSystem.writeFile(path.resolve(this._options.rootPath, this._options.tempFolderName, `${CUMULATIVE_MANIFEST_FILENAME}.json`), JSON.stringify(manifestsArray), { ensureFolderExists: true });
        await (0, ManifestsFileBuilder_1.buildManifestsJsAsync)(manifestsArray, path.join(this._options.rootPath, this._options.tempFolderName, `${CUMULATIVE_MANIFEST_FILENAME}.js`), undefined, manifestsJsFileMetadata);
    }
    reset() {
        this._discoveryCache.clear();
    }
    discoverManifests(packagePath, forceSearchMode, options = {}) {
        return this._discoverManifestsInner(packagePath, forceSearchMode, options, false);
    }
    _discoverManifestsInner(packagePath, forceSearchMode, options, canSkipPackage) {
        const optionsToUse = (0, lodash_1.cloneDeep)(options);
        if (!optionsToUse.projectTargetFolder) {
            optionsToUse.projectTargetFolder = this._options.distFolderName || 'dist';
        }
        if (!optionsToUse.manifestFileRegex) {
            optionsToUse.manifestFileRegex = options.manifestFileRegex || /^[^\.\\\/]+\.manifest\.json$/;
        }
        const resolvedPackagePath = node_core_library_1.FileSystem.getRealPath(packagePath);
        if (options.preserveSymlinks === false) {
            packagePath = resolvedPackagePath;
        }
        if (this._discoveryCache.has(resolvedPackagePath)) {
            return this._discoveryCache.get(resolvedPackagePath);
        }
        const referencedProjectManifests = {};
        const tempPath = path.join(packagePath, this._options.tempFolderName || 'temp');
        const targetFolderPath = path.join(packagePath, optionsToUse.projectTargetFolder);
        const packageJsonPath = path.join(packagePath, 'package.json');
        // We want to make sure if we have multiple files with the same component's manifest, we pick the one that
        //  was generated most recently.
        let fileModifiedTime = 0;
        let linkedProjectManifests = undefined;
        let foundCumulativeManifestsFile = false;
        if (forceSearchMode === DependencyDiscoveryMode.none) {
            try {
                const manifestMapPath = path.join(tempPath, `${CUMULATIVE_MANIFEST_FILENAME}.json`);
                const fileStats = node_core_library_1.FileSystem.getStatistics(manifestMapPath);
                fileModifiedTime = fileStats.mtime.getTime();
                linkedProjectManifests = node_core_library_1.JsonFile.load(manifestMapPath);
                foundCumulativeManifestsFile = true;
            }
            catch (e) {
                this._options.terminal.writeVerboseLine(`Unable to get "manifests.json" file for project in "${packagePath}". We'll ` +
                    'try to get each manifest separately');
            }
        }
        // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.
        if (!linkedProjectManifests) {
            linkedProjectManifests = [];
            // Look for files called something like "abc123.manifest.json" without any leading slashes or extra periods
            try {
                for (const targetFilename of node_core_library_1.FileSystem.readFolderItemNames(targetFolderPath)) {
                    if (targetFilename.match(optionsToUse.manifestFileRegex)) {
                        const targetFilePath = path.join(targetFolderPath, targetFilename);
                        try {
                            const fileStats = node_core_library_1.FileSystem.getStatistics(targetFilePath);
                            const manifestData = (0, lodash_1.cloneDeep)(node_core_library_1.JsonFile.load(targetFilePath));
                            if (this._options.ignoreNonSpfxManifests) {
                                // Ensure that some expected values exist. Validating against the real schema is
                                // unnecessarily complex
                                if (!manifestData.id) {
                                    continue;
                                }
                                if (manifestData.manifestVersion === 2) {
                                    if (!manifestData.loaderConfig) {
                                        continue;
                                    }
                                }
                                else if (manifestData.manifestVersion === 1) {
                                    if (!manifestData.versions) {
                                        continue;
                                    }
                                }
                            }
                            linkedProjectManifests.push({
                                manifestData: manifestData,
                                manifestPath: targetFilePath
                            });
                            fileModifiedTime = Math.max(fileModifiedTime, fileStats.mtime.getTime());
                        }
                        catch (e) {
                            // eslint-disable-next-line no-console
                            console.log(`BAD!!: ${targetFilePath}, ${e}`);
                        }
                    }
                }
            }
            catch (e) {
                /* Error getting manifest file data */
            }
        }
        if (!foundCumulativeManifestsFile && // If we find a cumulative file, we can probably skip a deeper search
            (forceSearchMode === DependencyDiscoveryMode.deep ||
                forceSearchMode === DependencyDiscoveryMode.deepSparseIgnoreFirstProject ||
                linkedProjectManifests.length > 0)) {
            // If this project has manifests, or we're forcing search, let's look in its references in other projects
            const packages = new Map();
            const packageJson = node_core_library_1.JsonFile.load(path.join(packagePath, 'package.json'));
            if (!canSkipPackage || !packageJson.skipInDependencyScan) {
                const getPackages = (refs, optional) => {
                    if (refs) {
                        // eslint-disable-next-line guard-for-in
                        for (const packageName in refs) {
                            packages.set(packageName, optional);
                        }
                    }
                };
                getPackages(packageJson.dependencies, false);
                getPackages(packageJson.devDependencies, true);
                getPackages(packageJson.optionalDependencies, true);
            }
            // Search each referenced project for manifests
            for (const [packageName, optional] of packages) {
                let referencedPackagePath;
                try {
                    // First, try to resolve the package. Don't resolve symlinks under the assumption that
                    // the dependency a monorepo-linked project. If it is a project in the same Rush monorepo,
                    // this will resolve correctly and will return a path under the project being built.
                    //
                    // The resolved package path should be the path under the project being built, in the cae of
                    // a monorepo-linked project because `heft start` serves the project root and
                    // provides monorepo-linked projects in the `manifests.js` file. The paths to these
                    // projects must be relative to the folder being served. If the package root was
                    // realpathed, transitive dependencies inside the monorepo would be resolved outside
                    // of the project root and could not be accessed by the browser.
                    referencedPackagePath = this._resolvePackage(packageName, packagePath, false);
                }
                catch (e) {
                    try {
                        // Try again, this time resolving symlinks.
                        referencedPackagePath = this._resolvePackage(packageName, packagePath, true);
                    }
                    catch (f) {
                        if (!optional) {
                            // Only warn if this isn't an optional package
                            this._options.terminal.writeWarningLine(`Unable to resolve project "${packageName}". Ensure it has been linked.`);
                        }
                    }
                }
                if (referencedPackagePath) {
                    const recursiveForceSearchMode = forceSearchMode === DependencyDiscoveryMode.shallow
                        ? DependencyDiscoveryMode.none
                        : forceSearchMode === DependencyDiscoveryMode.deepSparseIgnoreFirstProject
                            ? DependencyDiscoveryMode.deepSparse
                            : forceSearchMode;
                    const manifests = this._discoverManifestsInner(referencedPackagePath, recursiveForceSearchMode, optionsToUse, true);
                    for (const manifestId in manifests) {
                        if (manifests.hasOwnProperty(manifestId)) {
                            const manifestVersions = manifests[manifestId];
                            if (!referencedProjectManifests[manifestId]) {
                                referencedProjectManifests[manifestId] = {};
                            }
                            for (const manifestVersion in manifestVersions) {
                                if (manifestVersions.hasOwnProperty(manifestVersion)) {
                                    referencedProjectManifests[manifestId][manifestVersion] = manifestVersions[manifestVersion];
                                }
                            }
                        }
                    }
                }
            }
        }
        const assemblyIds = new Set();
        // If we found any manifests directly linked to this project, merge them into the manifests discovered in other
        // projects
        if (linkedProjectManifests) {
            let packageName = '';
            const manifestsToFilter = new Set();
            // Include the package name if we found a single project manifest in the target folder
            let isSinglePackage = linkedProjectManifests.length === 1;
            if (!isSinglePackage && linkedProjectManifests.length === 2) {
                const manifestA = linkedProjectManifests[0].manifestData;
                const manifestB = linkedProjectManifests[1].manifestData;
                if (manifestA.id === manifestB.rootComponentId ||
                    manifestB.id === manifestA.rootComponentId) {
                    // If we have two manifests, determine if one is the assembly of the other
                    isSinglePackage = true;
                    const assemblyId = manifestB.rootComponentId
                        ? manifestB.id
                        : manifestA.id;
                    assemblyIds.add(assemblyId);
                    if (!this._options.includeAssemblies && this._options.explicitInclude.indexOf(assemblyId) === -1) {
                        // We want to filter the assemblies manifest because we never want an assembly's ID to be a dependency
                        manifestsToFilter.add(assemblyId);
                    }
                }
            }
            if (isSinglePackage) {
                try {
                    const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
                    packageName = packageJson.name;
                }
                catch (e) {
                    /* empty */
                }
            }
            for (const manifest of linkedProjectManifests) {
                const manifestData = manifest.manifestData;
                if (!manifestsToFilter.has(manifestData.id)) {
                    const id = manifestData.id;
                    const componentManifest = manifestData;
                    const multiversionManifest = manifestData;
                    const isAssembly = assemblyIds.has(id);
                    if (componentManifest.version) {
                        // Single-version manifest
                        this._insertManifestIntoMap(referencedProjectManifests, manifest.manifestPath, packageName, fileModifiedTime, componentManifest, isAssembly);
                    }
                    else if (multiversionManifest.versions) {
                        // Multiversion manifest
                        for (const version in multiversionManifest.versions) {
                            if (multiversionManifest.versions.hasOwnProperty(version)) {
                                this._insertManifestIntoMap(referencedProjectManifests, manifest.manifestPath, packageName, fileModifiedTime, multiversionManifest.versions[version], isAssembly);
                            }
                        }
                    }
                    else {
                        throw new Error(`Invalid manifest with id "${id}" in ${packagePath}.`);
                    }
                }
            }
        }
        this._discoveryCache.set(resolvedPackagePath, referencedProjectManifests);
        return referencedProjectManifests;
    }
    _insertManifestIntoMap(referencedProjectManifests, manifestPath, packageName, fileModifiedTime, manifest, isAssembly) {
        const id = manifest.id;
        const version = manifest.version;
        if (!referencedProjectManifests[id]) {
            referencedProjectManifests[id] = {};
        }
        this._doTemporaryManifestFixups(manifest);
        const existingReference = referencedProjectManifests[id][version];
        if (!existingReference) {
            referencedProjectManifests[id][version] = {
                manifestCreationTime: fileModifiedTime,
                id: manifest.id,
                version: version,
                manifestPath: manifestPath,
                packageName: packageName,
                manifestData: manifest,
                isAssembly: isAssembly
            };
        }
    }
    _doTemporaryManifestFixups(manifestData) {
        function trimLeadingDist() {
            const DIST_SLASH = 'dist/';
            const entryModuleId = manifestData.loaderConfig.entryModuleId;
            const entryModule = manifestData.loaderConfig.scriptResources[entryModuleId];
            if (entryModule.type !== 'path') {
                throw new Error('Expected to find path module type');
            }
            else {
                let pathStr;
                let isIntegrityPath;
                if (typeof entryModule.path === 'string') {
                    pathStr = entryModule.path;
                    isIntegrityPath = false;
                }
                else {
                    pathStr = entryModule.path.path;
                    isIntegrityPath = true;
                }
                if (pathStr.startsWith(DIST_SLASH)) {
                    pathStr = pathStr.substr(DIST_SLASH.length);
                    if (isIntegrityPath) {
                        entryModule.path.path = pathStr;
                    }
                    else {
                        entryModule.path = pathStr;
                    }
                }
            }
        }
        switch (manifestData.id) {
            case '229b8d08-79f3-438b-8c21-4613fc877abd': // sp-load-themed-styles
                trimLeadingDist();
                break;
        }
    }
    _getTransformedManifest(referencedProject, baseUrl) {
        const relativePath = path.relative(this._options.rootPath, path.dirname(referencedProject.manifestPath));
        const manifest = referencedProject.manifestData;
        ManifestUrlProcessor_1.ManifestUrlProcessor.processInternalModuleBaseUrls(manifest, relativePath, baseUrl);
        return manifest;
    }
    _resolvePackage(packageName, rootPath, resolveSymlinks) {
        // This is inspired by the "resolvePackage" function in
        // https://github.com/microsoft/rushstack/blob/master/libraries/node-core-library/src/Import.ts, except that
        // it adds support for not resolving symlinks
        let normalizedRootPath = resolveSymlinks ? node_core_library_1.FileSystem.getRealPath(rootPath) : rootPath;
        normalizedRootPath =
            node_core_library_1.PackageJsonLookup.instance.tryGetPackageFolderFor(normalizedRootPath) || normalizedRootPath;
        // Append a slash to the package name to ensure `Resolve.sync` doesn't attempt to return a system package
        const normalizedPackageName = `${packageName}/`;
        try {
            return path.dirname(Resolve.sync(normalizedPackageName, {
                basedir: normalizedRootPath,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            }));
        }
        catch (e1) {
            try {
                // If we fail, see if we're trying to resolve to the current package
                const currentPackageJson = node_core_library_1.JsonFile.load(path.join(normalizedRootPath, 'package.json'));
                if (currentPackageJson.name === packageName) {
                    return normalizedRootPath;
                }
                else {
                    throw e1;
                }
            }
            catch (e2) {
                throw e1;
            }
        }
    }
}
exports.CumulativeManifestProcessor = CumulativeManifestProcessor;
//# sourceMappingURL=CumulativeManifestProcessor.js.map