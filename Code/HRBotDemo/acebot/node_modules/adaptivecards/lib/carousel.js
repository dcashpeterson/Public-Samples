"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CarouselEvent = exports.Carousel = exports.CarouselPage = void 0;
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var card_elements_1 = require("./card-elements");
var Enums = require("./enums");
var serialization_1 = require("./serialization");
var registry_1 = require("./registry");
var enums_1 = require("./enums");
var strings_1 = require("./strings");
var swiper_1 = require("swiper");
var Utils = require("./utils");
var shared_1 = require("./shared");
// Note: to function correctly, consumers need to have CSS from swiper/css, swiper/css/pagination, and
// swiper/css/navigation
var CarouselPage = /** @class */ (function (_super) {
    __extends(CarouselPage, _super);
    function CarouselPage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#region Schema
    CarouselPage.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        // `style`, `bleed`, `isVisible` are not supported in CarouselPage
        schema.remove(card_elements_1.Container.styleProperty);
        schema.remove(card_elements_1.Container.bleedProperty);
        schema.remove(card_elements_1.Container.isVisibleProperty);
    };
    //#endregion
    CarouselPage.prototype.internalRender = function () {
        var carouselSlide = document.createElement("div");
        carouselSlide.className = this.hostConfig.makeCssClassName("swiper-slide");
        // `isRtl()` will set the correct value of rtl by reading the value from the parents
        this.rtl = this.isRtl();
        var renderedElement = _super.prototype.internalRender.call(this);
        Utils.appendChild(carouselSlide, renderedElement);
        return carouselSlide;
    };
    CarouselPage.prototype.getForbiddenActionTypes = function () {
        return [card_elements_1.ShowCardAction, card_elements_1.ToggleVisibilityAction];
    };
    CarouselPage.prototype.getForbiddenChildElements = function () {
        return this.forbiddenChildElements();
    };
    CarouselPage.prototype.forbiddenChildElements = function () {
        return __spreadArray([
            card_elements_1.ToggleVisibilityAction.JsonTypeName,
            card_elements_1.ShowCardAction.JsonTypeName,
            "Media",
            "ActionSet",
            "Input.Text",
            "Input.Date",
            "Input.Time",
            "Input.Number",
            "Input.ChoiceSet",
            "Input.Toggle",
            "Carousel"
        ], _super.prototype.forbiddenChildElements.call(this), true);
    };
    CarouselPage.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this.setShouldFallback(false);
    };
    CarouselPage.prototype.shouldSerialize = function (_context) {
        return true;
    };
    CarouselPage.prototype.getJsonTypeName = function () {
        return "CarouselPage";
    };
    Object.defineProperty(CarouselPage.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CarouselPage.prototype, "hasVisibleSeparator", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    return CarouselPage;
}(card_elements_1.Container));
exports.CarouselPage = CarouselPage;
var Carousel = /** @class */ (function (_super) {
    __extends(Carousel, _super);
    function Carousel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.carouselLoop = true;
        _this.carouselOrientation = Enums.Orientation.Horizontal;
        _this._pages = [];
        _this._currentIndex = 0;
        _this._previousEventType = Enums.CarouselInteractionEvent.Pagination;
        return _this;
    }
    //#region Schema
    Carousel.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        // `style`, `bleed`, `isVisible` are not supported in Carousel
        schema.remove(card_elements_1.Container.styleProperty);
        schema.remove(card_elements_1.Container.bleedProperty);
        schema.remove(card_elements_1.Container.isVisibleProperty);
    };
    Object.defineProperty(Carousel.prototype, "timer", {
        get: function () {
            var timer = this.getValue(Carousel.timerProperty);
            if (timer && timer < this.hostConfig.carousel.minAutoplayDelay) {
                console.warn(strings_1.Strings.errors.tooLittleTimeDelay);
                timer = this.hostConfig.carousel.minAutoplayDelay;
            }
            return timer;
        },
        set: function (value) {
            if (value && value < this.hostConfig.carousel.minAutoplayDelay) {
                console.warn(strings_1.Strings.errors.tooLittleTimeDelay);
                this.setValue(Carousel.timerProperty, this.hostConfig.carousel.minAutoplayDelay);
            }
            else {
                this.setValue(Carousel.timerProperty, value);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Carousel.prototype, "initialPageIndex", {
        get: function () {
            return this.getValue(Carousel.initialPageProperty);
        },
        set: function (value) {
            if (this.isValidParsedPageIndex(value)) {
                this.setValue(Carousel.initialPageProperty, value);
            }
            else {
                console.warn(strings_1.Strings.errors.invalidInitialPageIndex(value));
                this.setValue(Carousel.initialPageProperty, 0);
            }
        },
        enumerable: false,
        configurable: true
    });
    Carousel.prototype.isValidParsedPageIndex = function (index) {
        return this._pages ? this.isValidPageIndex(index, this._pages.length) : false;
    };
    Carousel.prototype.isValidRenderedPageIndex = function (index) {
        return this._renderedPages ? this.isValidPageIndex(index, this._renderedPages.length) : false;
    };
    Carousel.prototype.isValidPageIndex = function (index, collectionSize) {
        return (collectionSize > 0 && 0 <= index && index < collectionSize);
    };
    Object.defineProperty(Carousel.prototype, "previousEventType", {
        //#endregion
        get: function () {
            return this._previousEventType;
        },
        set: function (eventType) {
            this._previousEventType = eventType;
        },
        enumerable: false,
        configurable: true
    });
    // Question: Why do we place this on the Carousel instead of the CarouselPage?
    Carousel.prototype.forbiddenChildElements = function () {
        return __spreadArray([
            card_elements_1.ToggleVisibilityAction.JsonTypeName,
            card_elements_1.ShowCardAction.JsonTypeName,
            "Media",
            "ActionSet",
            "Input.Text",
            "Input.Date",
            "Input.Time",
            "Input.Number",
            "Input.ChoiceSet",
            "Input.Toggle"
        ], _super.prototype.forbiddenChildElements.call(this), true);
    };
    Carousel.prototype.adjustRenderedElementSize = function (renderedElement) {
        _super.prototype.adjustRenderedElementSize.call(this, renderedElement);
        if (this.height == "stretch" && this._containerForAdorners !== undefined) {
            this._containerForAdorners.style.height = "100%";
        }
        // Assign the explicit height to carouselPageContainer if given
        if (this.carouselHeight) {
            this._carouselPageContainer.style.height = this.carouselHeight + "px";
        }
    };
    Carousel.prototype.getJsonTypeName = function () {
        return "Carousel";
    };
    Carousel.prototype.getItemCount = function () {
        return this._pages.length;
    };
    Carousel.prototype.getItemAt = function (index) {
        return this._pages[index];
    };
    Carousel.prototype.addPage = function (page) {
        this._pages.push(page);
        page.setParent(this);
    };
    Carousel.prototype.removeItem = function (item) {
        if (item instanceof CarouselPage) {
            var itemIndex = this._pages.indexOf(item);
            if (itemIndex >= 0) {
                this._pages.splice(itemIndex, 1);
                item.setParent(undefined);
                this.updateLayout();
                return true;
            }
        }
        return false;
    };
    Carousel.prototype.getFirstVisibleRenderedItem = function () {
        var _a;
        if (this.renderedElement && ((_a = this._renderedPages) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            return this._renderedPages[0];
        }
        else {
            return undefined;
        }
    };
    Carousel.prototype.getLastVisibleRenderedItem = function () {
        var _a;
        if (this.renderedElement && ((_a = this._renderedPages) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            return this._renderedPages[this._renderedPages.length - 1];
        }
        else {
            return undefined;
        }
    };
    Object.defineProperty(Carousel.prototype, "currentPageId", {
        get: function () {
            var _a, _b;
            if ((_b = (_a = this._carousel) === null || _a === void 0 ? void 0 : _a.slides) === null || _b === void 0 ? void 0 : _b.length) {
                var activeSlide = this._carousel.slides[this._carousel.activeIndex];
                return activeSlide.id;
            }
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Carousel.prototype, "currentPageIndex", {
        get: function () {
            var _a;
            return (_a = this._carousel) === null || _a === void 0 ? void 0 : _a.realIndex;
        },
        enumerable: false,
        configurable: true
    });
    Carousel.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this._pages = [];
        var jsonPages = source["pages"];
        if (Array.isArray(jsonPages)) {
            for (var _i = 0, jsonPages_1 = jsonPages; _i < jsonPages_1.length; _i++) {
                var item = jsonPages_1[_i];
                var page = this.createCarouselPageInstance(item, context);
                if (page) {
                    this._pages.push(page);
                }
            }
        }
        // everything is parsed do validate on initial page index
        this.validateParsing(context);
    };
    Carousel.prototype.validateParsing = function (context) {
        if (!this.isValidParsedPageIndex(this.initialPageIndex)) {
            context.logParseEvent(this, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidInitialPageIndex(this.initialPageIndex));
        }
    };
    Carousel.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        context.serializeArray(target, "pages", this._pages);
    };
    Carousel.prototype.internalRender = function () {
        var _a;
        this._renderedPages = [];
        if (this._pages.length <= 0) {
            return undefined;
        }
        this.validateOrientationProperties();
        var cardLevelContainer = document.createElement("div");
        cardLevelContainer.className = this.hostConfig.makeCssClassName("ac-carousel-card-level-container");
        var carouselContainer = document.createElement("div");
        carouselContainer.className = this.hostConfig.makeCssClassName("swiper", "ac-carousel");
        this._carouselPageContainer = carouselContainer;
        var containerForAdorners = document.createElement("div");
        containerForAdorners.className = this.hostConfig.makeCssClassName("ac-carousel-container");
        this._containerForAdorners = containerForAdorners;
        cardLevelContainer.appendChild(containerForAdorners);
        var navigationContainer = document.createElement("div");
        navigationContainer.className = this.hostConfig.makeCssClassName("ac-carousel-navigation");
        containerForAdorners.appendChild(navigationContainer);
        var carouselWrapper = document.createElement("div");
        carouselWrapper.className = this.hostConfig.makeCssClassName("swiper-wrapper", "ac-carousel-card-container");
        carouselWrapper.style.display = "flex";
        switch (this.getEffectiveVerticalContentAlignment()) {
            case Enums.VerticalAlignment.Top:
                carouselWrapper.style.alignItems = "flex-start";
                break;
            case Enums.VerticalAlignment.Bottom:
                carouselWrapper.style.alignItems = "flex-end";
                break;
            default:
                carouselWrapper.style.alignItems = "center";
                break;
        }
        if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation) {
            // Forces the container to be at least as tall as its content.
            //
            // Fixes a quirk in Chrome where, for nested flex elements, the
            // inner element's height would never exceed the outer element's
            // height. This caused overflow truncation to break -- containers
            // would always be measured as not overflowing, since their heights
            // were constrained by their parents as opposed to truly reflecting
            // the height of their content.
            //
            // See the "Browser Rendering Notes" section of this answer:
            // https://stackoverflow.com/questions/36247140/why-doesnt-flex-item-shrink-past-content-size
            carouselWrapper.style.minHeight = "-webkit-min-content";
        }
        var prevElementDiv = document.createElement("div");
        prevElementDiv.className = this.hostConfig.makeCssClassName("swiper-button-prev");
        var nextElementDiv = document.createElement("div");
        nextElementDiv.className = this.hostConfig.makeCssClassName("swiper-button-next");
        if (this.carouselOrientation === Enums.Orientation.Horizontal) {
            this.updateCssForHorizontalCarousel(prevElementDiv, nextElementDiv);
        }
        else {
            this.updateCssForVerticalCarousel(navigationContainer, prevElementDiv, nextElementDiv);
        }
        var pagination = document.createElement("div");
        pagination.className = this.hostConfig.makeCssClassName("swiper-pagination", "ac-carousel-pagination");
        navigationContainer.appendChild(prevElementDiv);
        Utils.addCancelSelectActionEventHandler(prevElementDiv);
        navigationContainer.appendChild(pagination);
        Utils.addCancelSelectActionEventHandler(pagination);
        navigationContainer.appendChild(nextElementDiv);
        Utils.addCancelSelectActionEventHandler(nextElementDiv);
        if (this.isDesignMode()) {
            // If we are in design mode, we need to ensure these elements are in front of the peers
            prevElementDiv.style.zIndex = "20";
            nextElementDiv.style.zIndex = "20";
            pagination.style.zIndex = "20";
        }
        var requestedNumberOfPages = Math.min(this._pages.length, this.hostConfig.carousel.maxCarouselPages);
        if (this._pages.length > this.hostConfig.carousel.maxCarouselPages) {
            console.warn(strings_1.Strings.errors.tooManyCarouselPages);
        }
        if (this._pages.length > 0) {
            for (var i = 0; i < requestedNumberOfPages; i++) {
                var page = this._pages[i];
                var renderedItem = this.isElementAllowed(page) ? page.render() : undefined;
                renderedItem === null || renderedItem === void 0 ? void 0 : renderedItem.classList.add("ac-carousel-page");
                (_a = renderedItem === null || renderedItem === void 0 ? void 0 : renderedItem.children[0]) === null || _a === void 0 ? void 0 : _a.classList.add("ac-carousel-page-container");
                if (renderedItem) {
                    Utils.appendChild(carouselWrapper, renderedItem);
                    this._renderedPages.push(page);
                }
            }
        }
        carouselContainer.appendChild(carouselWrapper);
        carouselContainer.tabIndex = this.isDesignMode() ? -1 : 0;
        containerForAdorners.appendChild(carouselContainer);
        // `isRtl()` will set the correct value of rtl by reading the value from the parents
        this.rtl = this.isRtl();
        this.applyRTL(pagination);
        if (!this.isDesignMode()) {
            if (this.isValidRenderedPageIndex(this.initialPageIndex)) {
                this._currentIndex = this.initialPageIndex;
            }
            else {
                console.warn(strings_1.Strings.errors.invalidInitialPageIndex(this.initialPageIndex));
                this._currentIndex = 0;
            }
        }
        this.initializeCarouselControl(carouselContainer, nextElementDiv, prevElementDiv, pagination, this.rtl);
        return this._renderedPages.length > 0 ? cardLevelContainer : undefined;
    };
    Carousel.prototype.applyRTL = function (pagination) {
        _super.prototype.applyRTL.call(this, this._carouselPageContainer);
        if (this.rtl) {
            pagination.classList.add(this.hostConfig.makeCssClassName("ac-carousel-pagination-rtl"));
        }
    };
    Carousel.prototype.validateOrientationProperties = function () {
        if (!this.carouselHeight) {
            this.carouselOrientation = Enums.Orientation.Horizontal;
        }
    };
    Carousel.prototype.updateCssForHorizontalCarousel = function (prevElementDiv, nextElementDiv) {
        prevElementDiv.classList.add(this.hostConfig.makeCssClassName("ac-carousel-left"));
        nextElementDiv.classList.add(this.hostConfig.makeCssClassName("ac-carousel-right"));
    };
    Carousel.prototype.updateCssForVerticalCarousel = function (navigationContainer, prevElementDiv, nextElementDiv) {
        this._containerForAdorners.classList.add(this.hostConfig.makeCssClassName("ac-carousel-container-vertical"));
        navigationContainer.classList.add(this.hostConfig.makeCssClassName("ac-carousel-navigation-vertical"));
        prevElementDiv.classList.add(this.hostConfig.makeCssClassName("ac-carousel-up"));
        nextElementDiv.classList.add(this.hostConfig.makeCssClassName("ac-carousel-down"));
    };
    Carousel.prototype.initializeCarouselControl = function (carouselContainer, nextElement, prevElement, paginationElement, rtl) {
        var _this = this;
        var _a, _b, _c;
        var nextElementAdjustedForRtl = (rtl === undefined || !rtl ? nextElement : prevElement);
        var prevElementAdjustedForRtl = (rtl === undefined || !rtl ? prevElement : nextElement);
        var prevElementAdjustedForOrientation = (Enums.Orientation.Horizontal === this.carouselOrientation) ? prevElementAdjustedForRtl : prevElement;
        var nextElementAdjustedForOrientation = (Enums.Orientation.Horizontal === this.carouselOrientation) ? nextElementAdjustedForRtl : nextElement;
        var swiperOptions = {
            loop: !this.isDesignMode() && this.carouselLoop,
            modules: [swiper_1.Navigation, swiper_1.Pagination, swiper_1.Scrollbar, swiper_1.A11y, swiper_1.History, swiper_1.Keyboard],
            pagination: {
                el: paginationElement,
                clickable: true
            },
            navigation: {
                prevEl: prevElementAdjustedForOrientation,
                nextEl: nextElementAdjustedForOrientation
            },
            a11y: {
                enabled: true
            },
            keyboard: {
                enabled: false,
                onlyInViewport: true
            },
            direction: this.carouselOrientation === Enums.Orientation.Horizontal ? "horizontal" : "vertical",
            resizeObserver: false,
            initialSlide: this._currentIndex
        };
        if (this.timer && !this.isDesignMode()) {
            (_a = swiperOptions.modules) === null || _a === void 0 ? void 0 : _a.push(swiper_1.Autoplay);
            swiperOptions.autoplay = { delay: this.timer, pauseOnMouseEnter: true };
        }
        var carousel = new swiper_1.Swiper(carouselContainer, swiperOptions);
        // While the 'pauseOnMouseEnter' option should resume autoplay on
        // mouse exit it doesn't do it, so adding custom events to handle it
        carouselContainer.addEventListener("mouseenter", function (_event) {
            var _a;
            (_a = carousel.autoplay) === null || _a === void 0 ? void 0 : _a.stop();
        });
        carouselContainer.addEventListener("mouseleave", function (_event) {
            var _a;
            (_a = carousel.autoplay) === null || _a === void 0 ? void 0 : _a.start();
        });
        carousel.on('navigationNext', function (swiper) {
            _this.raiseCarouselEvent(Enums.CarouselInteractionEvent.NavigationNext);
        });
        carousel.on('navigationPrev', function (swiper) {
            _this.raiseCarouselEvent(Enums.CarouselInteractionEvent.NavigationPrevious);
        });
        carousel.on('slideChangeTransitionEnd', function (swiper) {
            _this.currentIndex = swiper.realIndex;
            _this.raiseCarouselEvent(Enums.CarouselInteractionEvent.Pagination);
        });
        carousel.on('autoplay', function () {
            _this.raiseCarouselEvent(Enums.CarouselInteractionEvent.Autoplay);
        });
        carousel.on('paginationRender', function (swiper, paginationEl) {
            swiper.pagination.bullets.forEach(function (bullet, index) {
                bullet.addEventListener("keypress", function (event) {
                    if (event.key == "Enter") {
                        event.preventDefault();
                        swiper.slideTo(index + 1);
                    }
                });
            });
        });
        carousel.on('destroy', function () {
            _this.destroyResizeObserver();
        });
        prevElement.title = (_b = prevElement.ariaLabel) !== null && _b !== void 0 ? _b : strings_1.Strings.defaults.carouselNavigationPreviousTooltip();
        nextElement.title = (_c = nextElement.ariaLabel) !== null && _c !== void 0 ? _c : strings_1.Strings.defaults.carouselNavigationNextTooltip();
        this._carousel = carousel;
        this.createResizeObserver();
    };
    Carousel.prototype.createCarouselPageInstance = function (source, context) {
        return context.parseCardObject(this, source, this.forbiddenChildElements(), !this.isDesignMode(), function (typeName) {
            return !typeName || typeName === "CarouselPage" ? new CarouselPage() : undefined;
        }, function (typeName, _errorType) {
            context.logParseEvent(undefined, enums_1.ValidationEvent.ElementTypeNotAllowed, strings_1.Strings.errors.elementTypeNotAllowed(typeName));
        });
    };
    Carousel.prototype.slideTo = function (index) {
        var _a;
        (_a = this._carousel) === null || _a === void 0 ? void 0 : _a.slideTo(index);
    };
    Object.defineProperty(Carousel.prototype, "carouselPageContainer", {
        get: function () {
            return this._carouselPageContainer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Carousel.prototype, "currentIndex", {
        get: function () {
            return this._currentIndex;
        },
        set: function (currentIndex) {
            this._currentIndex = currentIndex;
        },
        enumerable: false,
        configurable: true
    });
    Carousel.prototype.createCarouselEvent = function (type) {
        var currentPageId;
        if (this.currentPageIndex != undefined) {
            currentPageId = this.getItemAt(this.currentPageIndex).id;
        }
        return new CarouselEvent(type, this.id, currentPageId, this.currentPageIndex);
    };
    Carousel.prototype.raiseCarouselEvent = function (eventType) {
        var card = this.parent ? this.parent.getRootElement() : undefined;
        var onCarouselEventHandler = card && card.onCarouselEvent
            ? card.onCarouselEvent
            : card_elements_1.AdaptiveCard.onCarouselEvent;
        // pagination event is triggered on slide transition end event 
        if (onCarouselEventHandler && eventType == Enums.CarouselInteractionEvent.Pagination) {
            // returns the event type that causes slide transition
            onCarouselEventHandler(this.createCarouselEvent(this.previousEventType));
        }
        this.previousEventType = eventType;
    };
    /// Swiper version 8 added requestAnimationFrame() call in its resize observer code
    /// The new call causes flickering issue,
    /// We've copied resize observer code from Swiper version 7 with some modifications
    Carousel.prototype.createResizeObserver = function () {
        var _this = this;
        var _a;
        if (!this.checkIfCarouselInValidStateForResizeEvent()) {
            return;
        }
        this._observer = new ResizeObserver(function (entries) {
            var _a, _b, _c, _d;
            var width = (_a = _this._carousel) === null || _a === void 0 ? void 0 : _a.width;
            var height = (_b = _this._carousel) === null || _b === void 0 ? void 0 : _b.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_a) {
                var _b;
                var contentBoxSize = _a.contentBoxSize, contentRect = _a.contentRect, target = _a.target;
                if (target && target !== ((_b = _this._carousel) === null || _b === void 0 ? void 0 : _b.el)) {
                    return;
                }
                newWidth = contentRect
                    ? contentRect.width
                    : (contentBoxSize[0] || contentBoxSize).inlineSize;
                newHeight = contentRect
                    ? contentRect.height
                    : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width || newHeight !== height) {
                if (_this.checkIfCarouselInValidStateForResizeEvent()) {
                    (_c = _this._carousel) === null || _c === void 0 ? void 0 : _c.emit('beforeResize');
                    (_d = _this._carousel) === null || _d === void 0 ? void 0 : _d.emit('resize');
                }
            }
        });
        this._observer.observe((_a = this._carousel) === null || _a === void 0 ? void 0 : _a.el);
    };
    Carousel.prototype.destroyResizeObserver = function () {
        var _a;
        if (this._observer && this._observer.unobserve && ((_a = this._carousel) === null || _a === void 0 ? void 0 : _a.el)) {
            this._observer.unobserve(this._carousel.el);
            this._observer = null;
        }
    };
    ;
    Carousel.prototype.checkIfCarouselInValidStateForResizeEvent = function () {
        return this._carousel && !this._carousel.destroyed;
    };
    Carousel.timerProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_6, "timer", undefined);
    Carousel.initialPageProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_6, "initialPage", 0);
    Carousel.loopProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_6, "loop", true);
    Carousel.orientationProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_6, "orientation", Enums.Orientation, Enums.Orientation.Horizontal);
    Carousel.carouselHeightProperty = new serialization_1.PixelSizeProperty(serialization_1.Versions.v1_6, "heightInPixels");
    __decorate([
        (0, serialization_1.property)(Carousel.timerProperty)
    ], Carousel.prototype, "timer", null);
    __decorate([
        (0, serialization_1.property)(Carousel.initialPageProperty)
    ], Carousel.prototype, "initialPageIndex", null);
    __decorate([
        (0, serialization_1.property)(Carousel.loopProperty)
    ], Carousel.prototype, "carouselLoop", void 0);
    __decorate([
        (0, serialization_1.property)(Carousel.orientationProperty)
    ], Carousel.prototype, "carouselOrientation", void 0);
    __decorate([
        (0, serialization_1.property)(Carousel.carouselHeightProperty)
    ], Carousel.prototype, "carouselHeight", void 0);
    return Carousel;
}(card_elements_1.Container));
exports.Carousel = Carousel;
var CarouselEvent = /** @class */ (function () {
    function CarouselEvent(type, carouselId, activeCarouselPageId, activeCarouselPageIndex) {
        this.type = type;
        this.carouselId = carouselId;
        this.activeCarouselPageId = activeCarouselPageId;
        this.activeCarouselPageIndex = activeCarouselPageIndex;
    }
    return CarouselEvent;
}());
exports.CarouselEvent = CarouselEvent;
registry_1.GlobalRegistry.defaultElements.register("Carousel", Carousel, serialization_1.Versions.v1_6);
//# sourceMappingURL=carousel.js.map