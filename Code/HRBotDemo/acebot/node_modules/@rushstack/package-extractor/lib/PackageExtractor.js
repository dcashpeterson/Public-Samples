"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageExtractor = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const minimatch_1 = require("minimatch");
const semver_1 = __importDefault(require("semver"));
const npm_packlist_1 = __importDefault(require("npm-packlist"));
const link_bins_1 = __importDefault(require("@pnpm/link-bins"));
const ignore_1 = __importDefault(require("ignore"));
const node_core_library_1 = require("@rushstack/node-core-library");
const ArchiveManager_1 = require("./ArchiveManager");
const SymlinkAnalyzer_1 = require("./SymlinkAnalyzer");
const Utils_1 = require("./Utils");
const PathConstants_1 = require("./PathConstants");
/**
 * Manages the business logic for the "rush deploy" command.
 *
 * @public
 */
class PackageExtractor {
    /**
     * Get a list of files that would be included in a package created from the provided package root path.
     *
     * @beta
     */
    static async getPackageIncludedFilesAsync(packageRootPath) {
        // Use npm-packlist to filter the files.  Using the Walker class (instead of the default API) ensures
        // that "bundledDependencies" are not included.
        const walkerPromise = new Promise((resolve, reject) => {
            const walker = new npm_packlist_1.default.Walker({
                path: packageRootPath
            });
            walker.on('done', resolve).on('error', reject).start();
        });
        const npmPackFiles = await walkerPromise;
        return npmPackFiles;
    }
    /**
     * Extract a package using the provided options
     */
    async extractAsync(options) {
        const { terminal, projectConfigurations, sourceRootFolder, targetRootFolder, mainProjectName, overwriteExisting, createArchiveFilePath, createArchiveOnly, dependencyConfigurations } = options;
        if (createArchiveOnly) {
            if (options.linkCreation !== 'script' && options.linkCreation !== 'none') {
                throw new Error('createArchiveOnly is only supported when linkCreation is "script" or "none"');
            }
            if (!createArchiveFilePath) {
                throw new Error('createArchiveOnly is only supported when createArchiveFilePath is specified');
            }
        }
        let archiver;
        let archiveFilePath;
        if (createArchiveFilePath) {
            if (path.extname(createArchiveFilePath) !== '.zip') {
                throw new Error('Only archives with the .zip file extension are currently supported.');
            }
            archiveFilePath = path.resolve(targetRootFolder, createArchiveFilePath);
            archiver = new ArchiveManager_1.ArchiveManager();
        }
        await node_core_library_1.FileSystem.ensureFolderAsync(targetRootFolder);
        terminal.writeLine(node_core_library_1.Colors.cyan(`Extracting to target folder:  ${targetRootFolder}`));
        terminal.writeLine(node_core_library_1.Colors.cyan(`Main project for extraction: ${mainProjectName}`));
        try {
            const existingExtraction = (await node_core_library_1.FileSystem.readFolderItemNamesAsync(targetRootFolder)).length > 0;
            if (existingExtraction) {
                if (!overwriteExisting) {
                    throw new Error('The extraction target folder is not empty. Overwrite must be explicitly requested');
                }
                else {
                    terminal.writeLine('Deleting target folder contents...');
                    terminal.writeLine('');
                    await node_core_library_1.FileSystem.ensureEmptyFolderAsync(targetRootFolder);
                }
            }
        }
        catch (error) {
            if (!node_core_library_1.FileSystem.isFolderDoesNotExistError(error)) {
                throw error;
            }
        }
        // Create a new state for each run
        const state = {
            foldersToCopy: new Set(),
            packageJsonByPath: new Map(),
            projectConfigurationsByName: new Map(projectConfigurations.map((p) => [p.projectName, p])),
            projectConfigurationsByPath: new Map(projectConfigurations.map((p) => [p.projectFolder, p])),
            dependencyConfigurationsByName: new Map(),
            symlinkAnalyzer: new SymlinkAnalyzer_1.SymlinkAnalyzer({ requiredSourceParentPath: sourceRootFolder }),
            archiver
        };
        // set state dependencyConfigurationsByName
        for (const dependencyConfiguration of dependencyConfigurations || []) {
            const { dependencyName } = dependencyConfiguration;
            let existingDependencyConfigurations = state.dependencyConfigurationsByName.get(dependencyName);
            if (!existingDependencyConfigurations) {
                existingDependencyConfigurations = [];
                state.dependencyConfigurationsByName.set(dependencyName, existingDependencyConfigurations);
            }
            existingDependencyConfigurations.push(dependencyConfiguration);
        }
        await this._performExtractionAsync(options, state);
        if (archiver && archiveFilePath) {
            terminal.writeLine(`Creating archive at "${archiveFilePath}"`);
            await archiver.createArchiveAsync(archiveFilePath);
        }
    }
    async _performExtractionAsync(options, state) {
        var _a;
        const { terminal, mainProjectName, sourceRootFolder, targetRootFolder, folderToCopy: addditionalFolderToCopy, linkCreation } = options;
        const { projectConfigurationsByName, foldersToCopy, symlinkAnalyzer } = state;
        const mainProjectConfiguration = projectConfigurationsByName.get(mainProjectName);
        if (!mainProjectConfiguration) {
            throw new Error(`Main project "${mainProjectName}" was not found in the list of projects`);
        }
        // Calculate the set with additionalProjectsToInclude
        const includedProjectsSet = new Set([mainProjectConfiguration]);
        for (const { additionalProjectsToInclude } of includedProjectsSet) {
            if (additionalProjectsToInclude) {
                for (const additionalProjectNameToInclude of additionalProjectsToInclude) {
                    const additionalProjectToInclude = projectConfigurationsByName.get(additionalProjectNameToInclude);
                    if (!additionalProjectToInclude) {
                        throw new Error(`Project "${additionalProjectNameToInclude}" was not found in the list of projects.`);
                    }
                    includedProjectsSet.add(additionalProjectToInclude);
                }
            }
        }
        for (const { projectName, projectFolder } of includedProjectsSet) {
            terminal.writeLine(node_core_library_1.Colors.cyan(`Analyzing project: ${projectName}`));
            await this._collectFoldersAsync(projectFolder, options, state);
        }
        if (!options.createArchiveOnly) {
            terminal.writeLine(`Copying folders to target folder "${targetRootFolder}"`);
        }
        await node_core_library_1.Async.forEachAsync(foldersToCopy, async (folderToCopy) => {
            await this._extractFolderAsync(folderToCopy, options, state);
        }, {
            concurrency: 10
        });
        switch (linkCreation) {
            case 'script': {
                const sourceFilePath = path.join(PathConstants_1.scriptsFolderPath, PathConstants_1.createLinksScriptFilename);
                if (!options.createArchiveOnly) {
                    terminal.writeLine(`Creating ${PathConstants_1.createLinksScriptFilename}`);
                    await node_core_library_1.FileSystem.copyFileAsync({
                        sourcePath: sourceFilePath,
                        destinationPath: path.join(targetRootFolder, PathConstants_1.createLinksScriptFilename),
                        alreadyExistsBehavior: node_core_library_1.AlreadyExistsBehavior.Error
                    });
                }
                await ((_a = state.archiver) === null || _a === void 0 ? void 0 : _a.addToArchiveAsync({
                    filePath: sourceFilePath,
                    archivePath: PathConstants_1.createLinksScriptFilename
                }));
                break;
            }
            case 'default': {
                terminal.writeLine('Creating symlinks');
                const linksToCopy = symlinkAnalyzer.reportSymlinks();
                await node_core_library_1.Async.forEachAsync(linksToCopy, async (linkToCopy) => {
                    await this._extractSymlinkAsync(linkToCopy, options, state);
                });
                await this._makeBinLinksAsync(options, state);
                break;
            }
            default: {
                break;
            }
        }
        terminal.writeLine('Creating extractor-metadata.json');
        await this._writeExtractorMetadataAsync(options, state);
        if (addditionalFolderToCopy) {
            const sourceFolderPath = path.resolve(sourceRootFolder, addditionalFolderToCopy);
            await node_core_library_1.FileSystem.copyFilesAsync({
                sourcePath: sourceFolderPath,
                destinationPath: targetRootFolder,
                alreadyExistsBehavior: node_core_library_1.AlreadyExistsBehavior.Error
            });
        }
    }
    /**
     * Recursively crawl the node_modules dependencies and collect the result in IExtractorState.foldersToCopy.
     */
    async _collectFoldersAsync(packageJsonFolder, options, state) {
        const { terminal, pnpmInstallFolder, transformPackageJson } = options;
        const { projectConfigurationsByPath } = state;
        const packageJsonFolderPathQueue = new node_core_library_1.AsyncQueue([packageJsonFolder]);
        await node_core_library_1.Async.forEachAsync(packageJsonFolderPathQueue, async ([packageJsonFolderPath, callback]) => {
            var _a;
            const packageJsonRealFolderPath = await node_core_library_1.FileSystem.getRealPathAsync(packageJsonFolderPath);
            if (state.foldersToCopy.has(packageJsonRealFolderPath)) {
                // we've already seen this folder
                callback();
                return;
            }
            state.foldersToCopy.add(packageJsonRealFolderPath);
            const originalPackageJson = await node_core_library_1.JsonFile.loadAsync(path.join(packageJsonRealFolderPath, 'package.json'));
            // Transform packageJson using the provided transformer, if requested
            const packageJson = (_a = transformPackageJson === null || transformPackageJson === void 0 ? void 0 : transformPackageJson(originalPackageJson)) !== null && _a !== void 0 ? _a : originalPackageJson;
            state.packageJsonByPath.set(packageJsonRealFolderPath, packageJson);
            // Union of keys from regular dependencies, peerDependencies, optionalDependencies
            // (and possibly devDependencies if includeDevDependencies=true)
            const dependencyNamesToProcess = new Set();
            // Just the keys from optionalDependencies and peerDependencies
            const optionalDependencyNames = new Set();
            for (const name of Object.keys(packageJson.dependencies || {})) {
                dependencyNamesToProcess.add(name);
            }
            for (const name of Object.keys(packageJson.peerDependencies || {})) {
                dependencyNamesToProcess.add(name);
                optionalDependencyNames.add(name); // consider peers optional, since they are so frequently broken
            }
            for (const name of Object.keys(packageJson.optionalDependencies || {})) {
                dependencyNamesToProcess.add(name);
                optionalDependencyNames.add(name);
            }
            // Check to see if this is a local project
            const projectConfiguration = projectConfigurationsByPath.get(packageJsonRealFolderPath);
            if (projectConfiguration) {
                if (options.includeDevDependencies) {
                    for (const name of Object.keys(packageJson.devDependencies || {})) {
                        dependencyNamesToProcess.add(name);
                    }
                }
                this._applyDependencyFilters(terminal, dependencyNamesToProcess, projectConfiguration.additionalDependenciesToInclude, projectConfiguration.dependenciesToExclude);
            }
            for (const dependencyPackageName of dependencyNamesToProcess) {
                try {
                    const dependencyPackageFolderPath = await node_core_library_1.Import.resolvePackageAsync({
                        packageName: dependencyPackageName,
                        baseFolderPath: packageJsonRealFolderPath,
                        getRealPathAsync: async (filePath) => {
                            try {
                                return (await state.symlinkAnalyzer.analyzePathAsync(filePath)).nodePath;
                            }
                            catch (error) {
                                if (node_core_library_1.FileSystem.isFileDoesNotExistError(error)) {
                                    return filePath;
                                }
                                throw error;
                            }
                        }
                    });
                    packageJsonFolderPathQueue.push(dependencyPackageFolderPath);
                }
                catch (resolveErr) {
                    if (optionalDependencyNames.has(dependencyPackageName)) {
                        // Ignore missing optional dependency
                        continue;
                    }
                    throw resolveErr;
                }
            }
            // Replicate the links to the virtual store. Note that if the package has not been hoisted by
            // PNPM, the package will not be resolvable from here.
            // Only apply this logic for packages that were actually installed under the common/temp folder.
            if (pnpmInstallFolder && node_core_library_1.Path.isUnder(packageJsonFolderPath, pnpmInstallFolder)) {
                try {
                    // The PNPM virtual store links are created in this folder.  We will resolve the current package
                    // from that location and collect any additional links encountered along the way.
                    // TODO: This can be configured via NPMRC. We should support that.
                    const pnpmDotFolderPath = path.join(pnpmInstallFolder, 'node_modules', '.pnpm');
                    // TODO: Investigate how package aliases are handled by PNPM in this case.  For example:
                    //
                    // "dependencies": {
                    //   "alias-name": "npm:real-name@^1.2.3"
                    // }
                    const dependencyPackageFolderPath = await node_core_library_1.Import.resolvePackageAsync({
                        packageName: packageJson.name,
                        baseFolderPath: pnpmDotFolderPath,
                        getRealPathAsync: async (filePath) => {
                            try {
                                return (await state.symlinkAnalyzer.analyzePathAsync(filePath)).nodePath;
                            }
                            catch (error) {
                                if (node_core_library_1.FileSystem.isFileDoesNotExistError(error)) {
                                    return filePath;
                                }
                                throw error;
                            }
                        }
                    });
                    packageJsonFolderPathQueue.push(dependencyPackageFolderPath);
                }
                catch (resolveErr) {
                    // The virtual store link isn't guaranteed to exist, so ignore if it's missing
                    // NOTE: If you encounter this warning a lot, please report it to the Rush maintainers.
                    // eslint-disable-next-line no-console
                    console.log('Ignoring missing PNPM virtual store link for ' + packageJsonFolderPath);
                }
            }
            callback();
        }, {
            concurrency: 10
        });
    }
    _applyDependencyFilters(terminal, allDependencyNames, additionalDependenciesToInclude = [], dependenciesToExclude = []) {
        // Track packages that got added/removed for reporting purposes
        const extraIncludedPackageNames = [];
        const extraExcludedPackageNames = [];
        for (const patternWithStar of dependenciesToExclude) {
            for (const dependency of allDependencyNames) {
                if ((0, Utils_1.matchesWithStar)(patternWithStar, dependency)) {
                    if (allDependencyNames.delete(dependency)) {
                        extraExcludedPackageNames.push(dependency);
                    }
                }
            }
        }
        for (const dependencyToInclude of additionalDependenciesToInclude) {
            if (!allDependencyNames.has(dependencyToInclude)) {
                allDependencyNames.add(dependencyToInclude);
                extraIncludedPackageNames.push(dependencyToInclude);
            }
        }
        if (extraIncludedPackageNames.length > 0) {
            extraIncludedPackageNames.sort();
            terminal.writeLine(`Extra dependencies included by settings: ${extraIncludedPackageNames.join(', ')}`);
        }
        if (extraExcludedPackageNames.length > 0) {
            extraExcludedPackageNames.sort();
            terminal.writeLine(`Extra dependencies excluded by settings: ${extraExcludedPackageNames.join(', ')}`);
        }
        return allDependencyNames;
    }
    /**
     * Maps a file path from IExtractorOptions.sourceRootFolder to IExtractorOptions.targetRootFolder
     *
     * Example input: "C:\\MyRepo\\libraries\\my-lib"
     * Example output: "C:\\MyRepo\\common\\deploy\\libraries\\my-lib"
     */
    _remapPathForExtractorFolder(absolutePathInSourceFolder, options) {
        const { sourceRootFolder, targetRootFolder } = options;
        const relativePath = path.relative(sourceRootFolder, absolutePathInSourceFolder);
        if (relativePath.startsWith('..')) {
            throw new Error(`Source path "${absolutePathInSourceFolder}" is not under "${sourceRootFolder}"`);
        }
        const absolutePathInTargetFolder = path.join(targetRootFolder, relativePath);
        return absolutePathInTargetFolder;
    }
    /**
     * Maps a file path from IExtractorOptions.sourceRootFolder to relative path
     *
     * Example input: "C:\\MyRepo\\libraries\\my-lib"
     * Example output: "libraries/my-lib"
     */
    _remapPathForExtractorMetadata(absolutePathInSourceFolder, options) {
        const { sourceRootFolder } = options;
        const relativePath = path.relative(sourceRootFolder, absolutePathInSourceFolder);
        if (relativePath.startsWith('..')) {
            throw new Error(`Source path "${absolutePathInSourceFolder}" is not under "${sourceRootFolder}"`);
        }
        return node_core_library_1.Path.convertToSlashes(relativePath);
    }
    /**
     * Copy one package folder to the extractor target folder.
     */
    async _extractFolderAsync(sourceFolderPath, options, state) {
        const { includeNpmIgnoreFiles, targetRootFolder } = options;
        const { projectConfigurationsByPath, packageJsonByPath, dependencyConfigurationsByName, archiver } = state;
        let useNpmIgnoreFilter = false;
        const sourceFolderRealPath = await node_core_library_1.FileSystem.getRealPathAsync(sourceFolderPath);
        const sourceProjectConfiguration = projectConfigurationsByPath.get(sourceFolderRealPath);
        const packagesJson = packageJsonByPath.get(sourceFolderRealPath);
        // As this function will be used to copy folder for both project inside monorepo and third party dependencies insides node_modules
        // Third party dependencies won't have project configurations
        const isLocalProject = !!sourceProjectConfiguration;
        // Function to filter files inside local project or third party dependencies.
        const isFileExcluded = (filePath) => {
            // Encapsulate exclude logic into a function, so it can be reused.
            const excludeFileByPatterns = (patternsToInclude, patternsToExclude) => {
                let includeFilters;
                let excludeFilters;
                if (patternsToInclude === null || patternsToInclude === void 0 ? void 0 : patternsToInclude.length) {
                    includeFilters = patternsToInclude === null || patternsToInclude === void 0 ? void 0 : patternsToInclude.map((p) => new minimatch_1.Minimatch(p, { dot: true }));
                }
                if (patternsToExclude === null || patternsToExclude === void 0 ? void 0 : patternsToExclude.length) {
                    excludeFilters = patternsToExclude === null || patternsToExclude === void 0 ? void 0 : patternsToExclude.map((p) => new minimatch_1.Minimatch(p, { dot: true }));
                }
                // If there are no filters, then we can't exclude anything.
                if (!includeFilters && !excludeFilters) {
                    return false;
                }
                const isIncluded = !includeFilters || includeFilters.some((m) => m.match(filePath));
                // If the file is not included, then we don't need to check the excludeFilter. If it is included
                // and there is no exclude filter, then we know that the file is not excluded. If it is included
                // and there is an exclude filter, then we need to check for a match.
                return !isIncluded || !!(excludeFilters === null || excludeFilters === void 0 ? void 0 : excludeFilters.some((m) => m.match(filePath)));
            };
            if (isLocalProject) {
                return excludeFileByPatterns(sourceProjectConfiguration === null || sourceProjectConfiguration === void 0 ? void 0 : sourceProjectConfiguration.patternsToInclude, sourceProjectConfiguration === null || sourceProjectConfiguration === void 0 ? void 0 : sourceProjectConfiguration.patternsToExclude);
            }
            else {
                if (!packagesJson) {
                    return false;
                }
                const dependenciesConfigurations = dependencyConfigurationsByName.get(packagesJson.name);
                if (!dependenciesConfigurations) {
                    return false;
                }
                const matchedDependenciesConfigurations = dependenciesConfigurations.filter((d) => semver_1.default.satisfies(packagesJson.version, d.dependencyVersionRange));
                return matchedDependenciesConfigurations.some((d) => excludeFileByPatterns(d.patternsToInclude, d.patternsToExclude));
            }
        };
        if (sourceProjectConfiguration && !includeNpmIgnoreFiles) {
            // Only use the npmignore filter if the project configuration explicitly asks for it
            useNpmIgnoreFilter = true;
        }
        const targetFolderPath = this._remapPathForExtractorFolder(sourceFolderPath, options);
        if (useNpmIgnoreFilter) {
            const npmPackFiles = await PackageExtractor.getPackageIncludedFilesAsync(sourceFolderPath);
            const alreadyCopiedSourcePaths = new Set();
            await node_core_library_1.Async.forEachAsync(npmPackFiles, async (npmPackFile) => {
                // In issue https://github.com/microsoft/rushstack/issues/2121 we found that npm-packlist sometimes returns
                // duplicate file paths, for example:
                //
                //   'dist//index.js'
                //   'dist/index.js'
                //
                // Filter out files that are excluded by the project configuration or dependency configuration.
                if (isFileExcluded(npmPackFile)) {
                    return;
                }
                // We can detect the duplicates by comparing the path.resolve() result.
                const copySourcePath = path.resolve(sourceFolderPath, npmPackFile);
                if (alreadyCopiedSourcePaths.has(copySourcePath)) {
                    return;
                }
                alreadyCopiedSourcePaths.add(copySourcePath);
                const copyDestinationPath = path.join(targetFolderPath, npmPackFile);
                const copySourcePathNode = await state.symlinkAnalyzer.analyzePathAsync(copySourcePath);
                if (copySourcePathNode.kind !== 'link') {
                    if (!options.createArchiveOnly) {
                        await node_core_library_1.FileSystem.ensureFolderAsync(path.dirname(copyDestinationPath));
                        // Use the fs.copyFile API instead of FileSystem.copyFileAsync() since copyFileAsync performs
                        // a needless stat() call to determine if it's a file or folder, and we already know it's a file.
                        await fs.promises.copyFile(copySourcePath, copyDestinationPath, fs.constants.COPYFILE_EXCL);
                    }
                    if (archiver) {
                        const archivePath = path.relative(targetRootFolder, copyDestinationPath);
                        await archiver.addToArchiveAsync({
                            filePath: copySourcePath,
                            archivePath,
                            stats: copySourcePathNode.linkStats
                        });
                    }
                }
            }, {
                concurrency: 10
            });
        }
        else {
            // use a simplistic "ignore" ruleset to filter the files
            const ignoreFilter = (0, ignore_1.default)();
            ignoreFilter.add([
                // The top-level node_modules folder is always excluded
                '/node_modules',
                // Also exclude well-known folders that can contribute a lot of unnecessary files
                '**/.git',
                '**/.svn',
                '**/.hg',
                '**/.DS_Store'
            ]);
            // Do a breadth-first search of the source folder, copying each file to the target folder
            const queue = new node_core_library_1.AsyncQueue([sourceFolderPath]);
            await node_core_library_1.Async.forEachAsync(queue, async ([sourcePath, callback]) => {
                const relativeSourcePath = path.relative(sourceFolderPath, sourcePath);
                if (relativeSourcePath !== '' && ignoreFilter.ignores(relativeSourcePath)) {
                    callback();
                    return;
                }
                const sourcePathNode = await state.symlinkAnalyzer.analyzePathAsync(sourcePath);
                if (sourcePathNode.kind === 'file') {
                    // Only ignore files and not folders to ensure that we traverse the contents of all folders. This is
                    // done so that we can match against subfolder patterns, ex. "src/subfolder/**/*"
                    if (relativeSourcePath !== '' && isFileExcluded(relativeSourcePath)) {
                        callback();
                        return;
                    }
                    const targetPath = path.join(targetFolderPath, relativeSourcePath);
                    if (!options.createArchiveOnly) {
                        // Manually call fs.copyFile to avoid unnecessary stat calls.
                        const targetParentPath = path.dirname(targetPath);
                        await node_core_library_1.FileSystem.ensureFolderAsync(targetParentPath);
                        await fs.promises.copyFile(sourcePath, targetPath, fs.constants.COPYFILE_EXCL);
                    }
                    // Add the file to the archive. Only need to add files since directories will be auto-created
                    if (archiver) {
                        const archivePath = path.relative(targetRootFolder, targetPath);
                        await archiver.addToArchiveAsync({
                            filePath: sourcePath,
                            archivePath: archivePath,
                            stats: sourcePathNode.linkStats
                        });
                    }
                }
                else if (sourcePathNode.kind === 'folder') {
                    const children = await node_core_library_1.FileSystem.readFolderItemNamesAsync(sourcePath);
                    for (const child of children) {
                        queue.push(path.join(sourcePath, child));
                    }
                }
                callback();
            }, {
                concurrency: 10
            });
        }
    }
    /**
     * Create a symlink as described by the ILinkInfo object.
     */
    async _extractSymlinkAsync(originalLinkInfo, options, state) {
        var _a;
        const linkInfo = {
            kind: originalLinkInfo.kind,
            linkPath: this._remapPathForExtractorFolder(originalLinkInfo.linkPath, options),
            targetPath: this._remapPathForExtractorFolder(originalLinkInfo.targetPath, options)
        };
        const newLinkFolder = path.dirname(linkInfo.linkPath);
        await node_core_library_1.FileSystem.ensureFolderAsync(newLinkFolder);
        // Link to the relative path for symlinks
        const relativeTargetPath = path.relative(newLinkFolder, linkInfo.targetPath);
        // NOTE: This logic is based on NpmLinkManager._createSymlink()
        if (linkInfo.kind === 'fileLink') {
            // For files, we use a Windows "hard link", because creating a symbolic link requires
            // administrator permission. However hard links seem to cause build failures on Mac,
            // so for all other operating systems we use symbolic links for this case.
            if (process.platform === 'win32') {
                await node_core_library_1.FileSystem.createHardLinkAsync({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
            else {
                await node_core_library_1.FileSystem.createSymbolicLinkFileAsync({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
        }
        else {
            // Junctions are only supported on Windows. This will create a symbolic link on other platforms.
            await node_core_library_1.FileSystem.createSymbolicLinkJunctionAsync({
                linkTargetPath: relativeTargetPath,
                newLinkPath: linkInfo.linkPath
            });
        }
        // Since the created symlinks have the required relative paths, they can be added directly to
        // the archive.
        await ((_a = state.archiver) === null || _a === void 0 ? void 0 : _a.addToArchiveAsync({
            filePath: linkInfo.linkPath,
            archivePath: path.relative(options.targetRootFolder, linkInfo.linkPath)
        }));
    }
    /**
     * Write the common/deploy/deploy-metadata.json file.
     */
    async _writeExtractorMetadataAsync(options, state) {
        var _a;
        const { mainProjectName, targetRootFolder } = options;
        const { projectConfigurationsByPath } = state;
        const extractorMetadataFileName = 'extractor-metadata.json';
        const extractorMetadataFilePath = path.join(targetRootFolder, extractorMetadataFileName);
        const extractorMetadataJson = {
            mainProjectName,
            projects: [],
            links: []
        };
        for (const { projectFolder, projectName } of projectConfigurationsByPath.values()) {
            if (state.foldersToCopy.has(projectFolder)) {
                extractorMetadataJson.projects.push({
                    projectName,
                    path: this._remapPathForExtractorMetadata(projectFolder, options)
                });
            }
        }
        // Remap the links to be relative to target folder
        for (const absoluteLinkInfo of state.symlinkAnalyzer.reportSymlinks()) {
            const relativeInfo = {
                kind: absoluteLinkInfo.kind,
                linkPath: this._remapPathForExtractorMetadata(absoluteLinkInfo.linkPath, options),
                targetPath: this._remapPathForExtractorMetadata(absoluteLinkInfo.targetPath, options)
            };
            extractorMetadataJson.links.push(relativeInfo);
        }
        const extractorMetadataFileContent = JSON.stringify(extractorMetadataJson, undefined, 0);
        if (!options.createArchiveOnly) {
            await node_core_library_1.FileSystem.writeFileAsync(extractorMetadataFilePath, extractorMetadataFileContent);
        }
        await ((_a = state.archiver) === null || _a === void 0 ? void 0 : _a.addToArchiveAsync({
            fileData: extractorMetadataFileContent,
            archivePath: extractorMetadataFileName
        }));
    }
    async _makeBinLinksAsync(options, state) {
        const { terminal } = options;
        const extractedProjectFolders = Array.from(state.projectConfigurationsByPath.keys()).filter((folderPath) => state.foldersToCopy.has(folderPath));
        await node_core_library_1.Async.forEachAsync(extractedProjectFolders, async (projectFolder) => {
            const extractedProjectFolder = this._remapPathForExtractorFolder(projectFolder, options);
            const extractedProjectNodeModulesFolder = path.join(extractedProjectFolder, 'node_modules');
            const extractedProjectBinFolder = path.join(extractedProjectNodeModulesFolder, '.bin');
            const linkedBinPackageNames = await (0, link_bins_1.default)(extractedProjectNodeModulesFolder, extractedProjectBinFolder, {
                warn: (msg) => terminal.writeLine(node_core_library_1.Colors.yellow(msg))
            });
            if (linkedBinPackageNames.length && state.archiver) {
                const binFolderItems = await node_core_library_1.FileSystem.readFolderItemNamesAsync(extractedProjectBinFolder);
                for (const binFolderItem of binFolderItems) {
                    const binFilePath = path.join(extractedProjectBinFolder, binFolderItem);
                    await state.archiver.addToArchiveAsync({
                        filePath: binFilePath,
                        archivePath: path.relative(options.targetRootFolder, binFilePath)
                    });
                }
            }
        }, {
            concurrency: 10
        });
    }
}
exports.PackageExtractor = PackageExtractor;
//# sourceMappingURL=PackageExtractor.js.map