{
  "name": "@rushstack/tree-pattern",
  "version": "0.2.4",
  "description": "A fast, lightweight pattern matcher for tree structures such as an Abstract Syntax Tree (AST)",
  "main": "lib/index.js",
  "typings": "dist/tree-pattern.d.ts",
  "license": "MIT",
  "repository": {
    "url": "https://github.com/microsoft/rushstack.git",
    "type": "git",
    "directory": "libraries/tree-pattern"
  },
  "devDependencies": {
    "@rushstack/eslint-config": "2.6.0",
    "@rushstack/heft": "0.45.6",
    "@rushstack/heft-node-rig": "1.9.7",
    "@types/heft-jest": "1.0.1",
    "@types/node": "12.20.24",
    "eslint": "~7.30.0",
    "typescript": "~4.6.3"
  },
  "scripts": {
    "build": "heft build --clean",
    "_phase:build": "heft build --clean",
    "_phase:test": "heft test --no-build"
  },
  "readme": "# @rushstack/tree-pattern\n\nThis is a simple, fast pattern matcher for JavaScript tree structures.  It was designed for ESLint rules and\ntransforms that match parse trees such as produced by [Esprima](https://esprima.org/). However, it can be used\nwith any JSON-like data structure.\n\n## Usage\n\nSuppose we are fixing up obsolete `Promise` calls, and we need to match an input like this:\n\n```ts\nPromise.fulfilled(123);\n```\n\nThe parsed subtree looks like this:\n```js\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"expression\": {  // <---- expressionNode\n        \"type\": \"CallExpression\",\n        \"callee\": {\n          \"type\": \"MemberExpression\",\n          \"object\": {\n            \"type\": \"Identifier\",\n            \"name\": \"Promise\"\n          },\n          \"property\": {\n            \"type\": \"Identifier\",\n            \"name\": \"fulfilled\"\n          },\n          \"computed\": false,\n          \"optional\": false\n        },\n        \"arguments\": [\n          {\n            \"type\": \"Literal\",\n            \"value\": 123,\n            \"raw\": \"123\"\n          }\n        ],\n        \"optional\": false\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\nThrowing away the details that we don't care about, we can specify a pattern expression with the parts\nthat need to be present:\n```js\nconst pattern1: TreePattern = new TreePattern({\n  type: 'CallExpression',\n  callee: {\n    type: 'MemberExpression',\n    object: {\n      type: 'Identifier',\n      name: 'Promise'\n    },\n    property: {\n      type: 'Identifier',\n      name: 'fulfilled'\n    },\n    computed: false\n  }\n});\n```\n\nThen when our visitor encounters an `ExpressionStatement`, we can match the `expressionNode` like this:\n```js\nif (pattern1.match(expressionNode)) {\n  console.log('Success!');\n}\n```\n\n## Capturing matched subtrees\n\nSuppose we want to generalize this to match any API such as `Promise.thing(123);` or `Promise.otherThing(123);`.\nWe can use a \"tag\" to extract the matching identifier:\n\n```js\nconst pattern2: TreePattern = new TreePattern({\n  type: 'CallExpression',\n  callee: {\n    type: 'MemberExpression',\n    object: {\n      type: 'Identifier',\n      name: 'Promise'\n    },\n    property: TreePattern.tag('promiseMethod', {\n      type: 'Identifier'\n    }),\n    computed: false\n  }\n});\n```\n\nOn a successful match, the tagged `promiseMethod` subtree can be retrieved like this:\n```ts\ninterface IMyCaptures {\n  // Captures the \"promiseMethod\" tag specified using TreePattern.tag()\n  promiseMethod?: { name?: string }; // <--- substitute your real AST interface here\n}\n\nconst captures: IMyCaptures = {};\n\nif (pattern2.match(node, captures)) {\n  // Prints: \"Matched fulfilled\"\n  console.log('Matched ' + captures?.promiseMethod?.name);\n}\n```\n\n## Alternative subtrees\n\nThe `oneOf` API enables you to write patterns that match alternative subtrees.\n\n```ts\nconst pattern3: TreePattern = new TreePattern({\n  animal: TreePattern.oneOf([\n    { kind: 'dog', bark: 'loud' },\n    { kind: 'cat', meow: 'quiet' }\n  ])\n});\n\nif (pattern3.match({ animal: { kind: 'dog', bark: 'loud' } })) {\n  console.log('I can match dog.');\n}\n\nif (pattern3.match({ animal: { kind: 'cat', meow: 'quiet' } })) {\n  console.log('I can match cat, too.');\n}\n```\n\nFor example, maybe we want to match `Promise['fulfilled'](123);` as well as `Promise.fulfilled(123);`.\nIf the structure of the expressions is similar enough, `TreePattern.oneOf` avoids having to create two\nseparate patterns.\n\n## Links\n\n- [CHANGELOG.md](\n  https://github.com/microsoft/rushstack/blob/main/libraries/tree-pattern/CHANGELOG.md) - Find\n  out what's new in the latest version\n- [API Reference](https://rushstack.io/pages/api/tree-pattern/)\n\n`@rushstack/tree-pattern` is part of the [Rush Stack](https://rushstack.io/) family of projects.\n"
}