{"version":3,"file":"PackageExtractor.js","sourceRoot":"","sources":["../src/PackageExtractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { type IMinimatch, Minimatch } from 'minimatch';\nimport semver from 'semver';\nimport npmPacklist from 'npm-packlist';\nimport pnpmLinkBins from '@pnpm/link-bins';\nimport ignore, { type Ignore } from 'ignore';\nimport {\n  Async,\n  AsyncQueue,\n  Path,\n  FileSystem,\n  Import,\n  Colors,\n  JsonFile,\n  AlreadyExistsBehavior,\n  type IPackageJson,\n  type ITerminal\n} from '@rushstack/node-core-library';\n\nimport { ArchiveManager } from './ArchiveManager';\nimport { SymlinkAnalyzer, type ILinkInfo, type PathNode } from './SymlinkAnalyzer';\nimport { matchesWithStar } from './Utils';\nimport { createLinksScriptFilename, scriptsFolderPath } from './PathConstants';\n\n// (@types/npm-packlist is missing this API)\ndeclare module 'npm-packlist' {\n  export class Walker {\n    public readonly result: string[];\n    public constructor(opts: { path: string });\n    public on(event: 'done', callback: (result: string[]) => void): Walker;\n    public on(event: 'error', callback: (error: Error) => void): Walker;\n    public start(): void;\n  }\n}\n\n/**\n * Part of the extractor-matadata.json file format. Represents an extracted project.\n *\n * @public\n */\nexport interface IProjectInfoJson {\n  /**\n   * The name of the project as specified in its package.json file.\n   */\n  projectName: string;\n  /**\n   * This path is relative to the root of the extractor output folder\n   */\n  path: string;\n}\n\n/**\n * The extractor-metadata.json file format.\n *\n * @public\n */\nexport interface IExtractorMetadataJson {\n  /**\n   * The name of the main project the extraction was performed for.\n   */\n  mainProjectName: string;\n  /**\n   * A list of all projects that were extracted.\n   */\n  projects: IProjectInfoJson[];\n  /**\n   * A list of all links that are part of the extracted project.\n   */\n  links: ILinkInfo[];\n}\n\ninterface IExtractorState {\n  foldersToCopy: Set<string>;\n  packageJsonByPath: Map<string, IPackageJson>;\n  projectConfigurationsByPath: Map<string, IExtractorProjectConfiguration>;\n  projectConfigurationsByName: Map<string, IExtractorProjectConfiguration>;\n  dependencyConfigurationsByName: Map<string, IExtractorDependencyConfiguration[]>;\n  symlinkAnalyzer: SymlinkAnalyzer;\n  archiver?: ArchiveManager;\n}\n\n/**\n * The extractor configuration for individual projects.\n *\n * @public\n */\nexport interface IExtractorProjectConfiguration {\n  /**\n   * The name of the project.\n   */\n  projectName: string;\n  /**\n   * The absolute path to the project.\n   */\n  projectFolder: string;\n  /**\n   * A list of glob patterns to include when extracting this project. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, all paths will be included.\n   */\n  patternsToInclude?: string[];\n  /**\n   * A list of glob patterns to exclude when extracting this project. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, no paths will be excluded.\n   */\n  patternsToExclude?: string[];\n  /**\n   * The names of additional projects to include when extracting this project.\n   */\n  additionalProjectsToInclude?: string[];\n  /**\n   * The names of additional dependencies to include when extracting this project.\n   */\n  additionalDependenciesToInclude?: string[];\n  /**\n   * The names of additional dependencies to exclude when extracting this project.\n   */\n  dependenciesToExclude?: string[];\n}\n\n/**\n * The extractor configuration for individual dependencies.\n *\n * @public\n */\nexport interface IExtractorDependencyConfiguration {\n  /**\n   * The name of dependency\n   */\n  dependencyName: string;\n  /**\n   * The semver version range of dependency\n   */\n  dependencyVersionRange: string;\n  /**\n   * A list of glob patterns to exclude when extracting this dependency. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, no paths will be excluded.\n   */\n  patternsToExclude?: string[];\n  /**\n   * A list of glob patterns to include when extracting this dependency. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, all paths will be included.\n   */\n  patternsToInclude?: string[];\n}\n\n/**\n * Options that can be provided to the extractor.\n *\n * @public\n */\nexport interface IExtractorOptions {\n  /**\n   * A terminal to log extraction progress.\n   */\n  terminal: ITerminal;\n\n  /**\n   * The main project to include in the extraction operation.\n   */\n  mainProjectName: string;\n\n  /**\n   * The source folder that copying originates from.  Generally it is the repo root folder.\n   */\n  sourceRootFolder: string;\n\n  /**\n   * The target folder for the extraction.\n   */\n  targetRootFolder: string;\n\n  /**\n   * Whether to overwrite the target folder if it already exists.\n   */\n  overwriteExisting: boolean;\n\n  /**\n   * The desired path to be used when archiving the target folder. Supported file extensions: .zip.\n   */\n  createArchiveFilePath?: string;\n\n  /**\n   * Whether to skip copying files to the extraction target directory, and only create an extraction\n   * archive. This is only supported when linkCreation is 'script' or 'none'.\n   */\n  createArchiveOnly?: boolean;\n\n  /**\n   * The pnpmfile configuration if using PNPM, otherwise undefined. The configuration will be used to\n   * transform the package.json prior to extraction.\n   */\n  transformPackageJson?: (packageJson: IPackageJson) => IPackageJson | undefined;\n\n  /**\n   * If dependencies from the \"devDependencies\" package.json field should be included in the extraction.\n   */\n  includeDevDependencies?: boolean;\n\n  /**\n   * If files ignored by the .npmignore file should be included in the extraction.\n   */\n  includeNpmIgnoreFiles?: boolean;\n\n  /**\n   * The folder where the PNPM \"node_modules\" folder is located. This is used to resolve packages linked\n   * to the PNPM virtual store.\n   */\n  pnpmInstallFolder?: string;\n\n  /**\n   * The link creation mode to use.\n   * \"default\": Create the links while copying the files; this is the default behavior. Use this setting\n   * if your file copy tool can handle links correctly.\n   * \"script\": A Node.js script called create-links.js will be written to the target folder. Use this setting\n   * to create links on the server machine, after the files have been uploaded.\n   * \"none\": Do nothing; some other tool may create the links later, based on the extractor-metadata.json file.\n   */\n  linkCreation?: 'default' | 'script' | 'none';\n\n  /**\n   * An additional folder containing files which will be copied into the root of the extraction.\n   */\n  folderToCopy?: string;\n\n  /**\n   * Configurations for individual projects, keyed by the project path relative to the sourceRootFolder.\n   */\n  projectConfigurations: IExtractorProjectConfiguration[];\n\n  /**\n   * Configurations for individual dependencies.\n   */\n  dependencyConfigurations?: IExtractorDependencyConfiguration[];\n}\n\n/**\n * Manages the business logic for the \"rush deploy\" command.\n *\n * @public\n */\nexport class PackageExtractor {\n  /**\n   * Get a list of files that would be included in a package created from the provided package root path.\n   *\n   * @beta\n   */\n  public static async getPackageIncludedFilesAsync(packageRootPath: string): Promise<string[]> {\n    // Use npm-packlist to filter the files.  Using the Walker class (instead of the default API) ensures\n    // that \"bundledDependencies\" are not included.\n    const walkerPromise: Promise<string[]> = new Promise<string[]>(\n      (resolve: (result: string[]) => void, reject: (error: Error) => void) => {\n        const walker: npmPacklist.Walker = new npmPacklist.Walker({\n          path: packageRootPath\n        });\n        walker.on('done', resolve).on('error', reject).start();\n      }\n    );\n    const npmPackFiles: string[] = await walkerPromise;\n    return npmPackFiles;\n  }\n\n  /**\n   * Extract a package using the provided options\n   */\n  public async extractAsync(options: IExtractorOptions): Promise<void> {\n    const {\n      terminal,\n      projectConfigurations,\n      sourceRootFolder,\n      targetRootFolder,\n      mainProjectName,\n      overwriteExisting,\n      createArchiveFilePath,\n      createArchiveOnly,\n      dependencyConfigurations\n    } = options;\n\n    if (createArchiveOnly) {\n      if (options.linkCreation !== 'script' && options.linkCreation !== 'none') {\n        throw new Error('createArchiveOnly is only supported when linkCreation is \"script\" or \"none\"');\n      }\n      if (!createArchiveFilePath) {\n        throw new Error('createArchiveOnly is only supported when createArchiveFilePath is specified');\n      }\n    }\n\n    let archiver: ArchiveManager | undefined;\n    let archiveFilePath: string | undefined;\n    if (createArchiveFilePath) {\n      if (path.extname(createArchiveFilePath) !== '.zip') {\n        throw new Error('Only archives with the .zip file extension are currently supported.');\n      }\n\n      archiveFilePath = path.resolve(targetRootFolder, createArchiveFilePath);\n      archiver = new ArchiveManager();\n    }\n\n    await FileSystem.ensureFolderAsync(targetRootFolder);\n\n    terminal.writeLine(Colors.cyan(`Extracting to target folder:  ${targetRootFolder}`));\n    terminal.writeLine(Colors.cyan(`Main project for extraction: ${mainProjectName}`));\n\n    try {\n      const existingExtraction: boolean =\n        (await FileSystem.readFolderItemNamesAsync(targetRootFolder)).length > 0;\n      if (existingExtraction) {\n        if (!overwriteExisting) {\n          throw new Error(\n            'The extraction target folder is not empty. Overwrite must be explicitly requested'\n          );\n        } else {\n          terminal.writeLine('Deleting target folder contents...');\n          terminal.writeLine('');\n          await FileSystem.ensureEmptyFolderAsync(targetRootFolder);\n        }\n      }\n    } catch (error: unknown) {\n      if (!FileSystem.isFolderDoesNotExistError(error as Error)) {\n        throw error;\n      }\n    }\n\n    // Create a new state for each run\n    const state: IExtractorState = {\n      foldersToCopy: new Set(),\n      packageJsonByPath: new Map(),\n      projectConfigurationsByName: new Map(projectConfigurations.map((p) => [p.projectName, p])),\n      projectConfigurationsByPath: new Map(projectConfigurations.map((p) => [p.projectFolder, p])),\n      dependencyConfigurationsByName: new Map(),\n      symlinkAnalyzer: new SymlinkAnalyzer({ requiredSourceParentPath: sourceRootFolder }),\n      archiver\n    };\n    // set state dependencyConfigurationsByName\n    for (const dependencyConfiguration of dependencyConfigurations || []) {\n      const { dependencyName } = dependencyConfiguration;\n      let existingDependencyConfigurations: IExtractorDependencyConfiguration[] | undefined =\n        state.dependencyConfigurationsByName.get(dependencyName);\n      if (!existingDependencyConfigurations) {\n        existingDependencyConfigurations = [];\n        state.dependencyConfigurationsByName.set(dependencyName, existingDependencyConfigurations);\n      }\n      existingDependencyConfigurations.push(dependencyConfiguration);\n    }\n\n    await this._performExtractionAsync(options, state);\n    if (archiver && archiveFilePath) {\n      terminal.writeLine(`Creating archive at \"${archiveFilePath}\"`);\n      await archiver.createArchiveAsync(archiveFilePath);\n    }\n  }\n\n  private async _performExtractionAsync(options: IExtractorOptions, state: IExtractorState): Promise<void> {\n    const {\n      terminal,\n      mainProjectName,\n      sourceRootFolder,\n      targetRootFolder,\n      folderToCopy: addditionalFolderToCopy,\n      linkCreation\n    } = options;\n    const { projectConfigurationsByName, foldersToCopy, symlinkAnalyzer } = state;\n\n    const mainProjectConfiguration: IExtractorProjectConfiguration | undefined =\n      projectConfigurationsByName.get(mainProjectName);\n    if (!mainProjectConfiguration) {\n      throw new Error(`Main project \"${mainProjectName}\" was not found in the list of projects`);\n    }\n\n    // Calculate the set with additionalProjectsToInclude\n    const includedProjectsSet: Set<IExtractorProjectConfiguration> = new Set([mainProjectConfiguration]);\n    for (const { additionalProjectsToInclude } of includedProjectsSet) {\n      if (additionalProjectsToInclude) {\n        for (const additionalProjectNameToInclude of additionalProjectsToInclude) {\n          const additionalProjectToInclude: IExtractorProjectConfiguration | undefined =\n            projectConfigurationsByName.get(additionalProjectNameToInclude);\n          if (!additionalProjectToInclude) {\n            throw new Error(\n              `Project \"${additionalProjectNameToInclude}\" was not found in the list of projects.`\n            );\n          }\n          includedProjectsSet.add(additionalProjectToInclude);\n        }\n      }\n    }\n\n    for (const { projectName, projectFolder } of includedProjectsSet) {\n      terminal.writeLine(Colors.cyan(`Analyzing project: ${projectName}`));\n      await this._collectFoldersAsync(projectFolder, options, state);\n    }\n\n    if (!options.createArchiveOnly) {\n      terminal.writeLine(`Copying folders to target folder \"${targetRootFolder}\"`);\n    }\n    await Async.forEachAsync(\n      foldersToCopy,\n      async (folderToCopy: string) => {\n        await this._extractFolderAsync(folderToCopy, options, state);\n      },\n      {\n        concurrency: 10\n      }\n    );\n\n    switch (linkCreation) {\n      case 'script': {\n        const sourceFilePath: string = path.join(scriptsFolderPath, createLinksScriptFilename);\n        if (!options.createArchiveOnly) {\n          terminal.writeLine(`Creating ${createLinksScriptFilename}`);\n          await FileSystem.copyFileAsync({\n            sourcePath: sourceFilePath,\n            destinationPath: path.join(targetRootFolder, createLinksScriptFilename),\n            alreadyExistsBehavior: AlreadyExistsBehavior.Error\n          });\n        }\n        await state.archiver?.addToArchiveAsync({\n          filePath: sourceFilePath,\n          archivePath: createLinksScriptFilename\n        });\n        break;\n      }\n      case 'default': {\n        terminal.writeLine('Creating symlinks');\n        const linksToCopy: ILinkInfo[] = symlinkAnalyzer.reportSymlinks();\n        await Async.forEachAsync(linksToCopy, async (linkToCopy: ILinkInfo) => {\n          await this._extractSymlinkAsync(linkToCopy, options, state);\n        });\n        await this._makeBinLinksAsync(options, state);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n\n    terminal.writeLine('Creating extractor-metadata.json');\n    await this._writeExtractorMetadataAsync(options, state);\n\n    if (addditionalFolderToCopy) {\n      const sourceFolderPath: string = path.resolve(sourceRootFolder, addditionalFolderToCopy);\n      await FileSystem.copyFilesAsync({\n        sourcePath: sourceFolderPath,\n        destinationPath: targetRootFolder,\n        alreadyExistsBehavior: AlreadyExistsBehavior.Error\n      });\n    }\n  }\n\n  /**\n   * Recursively crawl the node_modules dependencies and collect the result in IExtractorState.foldersToCopy.\n   */\n  private async _collectFoldersAsync(\n    packageJsonFolder: string,\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { terminal, pnpmInstallFolder, transformPackageJson } = options;\n    const { projectConfigurationsByPath } = state;\n\n    const packageJsonFolderPathQueue: AsyncQueue<string> = new AsyncQueue([packageJsonFolder]);\n\n    await Async.forEachAsync(\n      packageJsonFolderPathQueue,\n      async ([packageJsonFolderPath, callback]: [string, () => void]) => {\n        const packageJsonRealFolderPath: string = await FileSystem.getRealPathAsync(packageJsonFolderPath);\n        if (state.foldersToCopy.has(packageJsonRealFolderPath)) {\n          // we've already seen this folder\n          callback();\n          return;\n        }\n        state.foldersToCopy.add(packageJsonRealFolderPath);\n\n        const originalPackageJson: IPackageJson = await JsonFile.loadAsync(\n          path.join(packageJsonRealFolderPath, 'package.json')\n        );\n\n        // Transform packageJson using the provided transformer, if requested\n        const packageJson: IPackageJson = transformPackageJson?.(originalPackageJson) ?? originalPackageJson;\n\n        state.packageJsonByPath.set(packageJsonRealFolderPath, packageJson);\n        // Union of keys from regular dependencies, peerDependencies, optionalDependencies\n        // (and possibly devDependencies if includeDevDependencies=true)\n        const dependencyNamesToProcess: Set<string> = new Set<string>();\n\n        // Just the keys from optionalDependencies and peerDependencies\n        const optionalDependencyNames: Set<string> = new Set<string>();\n\n        for (const name of Object.keys(packageJson.dependencies || {})) {\n          dependencyNamesToProcess.add(name);\n        }\n        for (const name of Object.keys(packageJson.peerDependencies || {})) {\n          dependencyNamesToProcess.add(name);\n          optionalDependencyNames.add(name); // consider peers optional, since they are so frequently broken\n        }\n        for (const name of Object.keys(packageJson.optionalDependencies || {})) {\n          dependencyNamesToProcess.add(name);\n          optionalDependencyNames.add(name);\n        }\n\n        // Check to see if this is a local project\n        const projectConfiguration: IExtractorProjectConfiguration | undefined =\n          projectConfigurationsByPath.get(packageJsonRealFolderPath);\n\n        if (projectConfiguration) {\n          if (options.includeDevDependencies) {\n            for (const name of Object.keys(packageJson.devDependencies || {})) {\n              dependencyNamesToProcess.add(name);\n            }\n          }\n\n          this._applyDependencyFilters(\n            terminal,\n            dependencyNamesToProcess,\n            projectConfiguration.additionalDependenciesToInclude,\n            projectConfiguration.dependenciesToExclude\n          );\n        }\n\n        for (const dependencyPackageName of dependencyNamesToProcess) {\n          try {\n            const dependencyPackageFolderPath: string = await Import.resolvePackageAsync({\n              packageName: dependencyPackageName,\n              baseFolderPath: packageJsonRealFolderPath,\n              getRealPathAsync: async (filePath: string) => {\n                try {\n                  return (await state.symlinkAnalyzer.analyzePathAsync(filePath)).nodePath;\n                } catch (error: unknown) {\n                  if (FileSystem.isFileDoesNotExistError(error as Error)) {\n                    return filePath;\n                  }\n                  throw error;\n                }\n              }\n            });\n            packageJsonFolderPathQueue.push(dependencyPackageFolderPath);\n          } catch (resolveErr) {\n            if (optionalDependencyNames.has(dependencyPackageName)) {\n              // Ignore missing optional dependency\n              continue;\n            }\n            throw resolveErr;\n          }\n        }\n\n        // Replicate the links to the virtual store. Note that if the package has not been hoisted by\n        // PNPM, the package will not be resolvable from here.\n        // Only apply this logic for packages that were actually installed under the common/temp folder.\n        if (pnpmInstallFolder && Path.isUnder(packageJsonFolderPath, pnpmInstallFolder)) {\n          try {\n            // The PNPM virtual store links are created in this folder.  We will resolve the current package\n            // from that location and collect any additional links encountered along the way.\n            // TODO: This can be configured via NPMRC. We should support that.\n            const pnpmDotFolderPath: string = path.join(pnpmInstallFolder, 'node_modules', '.pnpm');\n\n            // TODO: Investigate how package aliases are handled by PNPM in this case.  For example:\n            //\n            // \"dependencies\": {\n            //   \"alias-name\": \"npm:real-name@^1.2.3\"\n            // }\n            const dependencyPackageFolderPath: string = await Import.resolvePackageAsync({\n              packageName: packageJson.name,\n              baseFolderPath: pnpmDotFolderPath,\n              getRealPathAsync: async (filePath: string) => {\n                try {\n                  return (await state.symlinkAnalyzer.analyzePathAsync(filePath)).nodePath;\n                } catch (error: unknown) {\n                  if (FileSystem.isFileDoesNotExistError(error as Error)) {\n                    return filePath;\n                  }\n                  throw error;\n                }\n              }\n            });\n            packageJsonFolderPathQueue.push(dependencyPackageFolderPath);\n          } catch (resolveErr) {\n            // The virtual store link isn't guaranteed to exist, so ignore if it's missing\n            // NOTE: If you encounter this warning a lot, please report it to the Rush maintainers.\n            // eslint-disable-next-line no-console\n            console.log('Ignoring missing PNPM virtual store link for ' + packageJsonFolderPath);\n          }\n        }\n\n        callback();\n      },\n      {\n        concurrency: 10\n      }\n    );\n  }\n\n  private _applyDependencyFilters(\n    terminal: ITerminal,\n    allDependencyNames: Set<string>,\n    additionalDependenciesToInclude: string[] = [],\n    dependenciesToExclude: string[] = []\n  ): Set<string> {\n    // Track packages that got added/removed for reporting purposes\n    const extraIncludedPackageNames: string[] = [];\n    const extraExcludedPackageNames: string[] = [];\n\n    for (const patternWithStar of dependenciesToExclude) {\n      for (const dependency of allDependencyNames) {\n        if (matchesWithStar(patternWithStar, dependency)) {\n          if (allDependencyNames.delete(dependency)) {\n            extraExcludedPackageNames.push(dependency);\n          }\n        }\n      }\n    }\n\n    for (const dependencyToInclude of additionalDependenciesToInclude) {\n      if (!allDependencyNames.has(dependencyToInclude)) {\n        allDependencyNames.add(dependencyToInclude);\n        extraIncludedPackageNames.push(dependencyToInclude);\n      }\n    }\n\n    if (extraIncludedPackageNames.length > 0) {\n      extraIncludedPackageNames.sort();\n      terminal.writeLine(`Extra dependencies included by settings: ${extraIncludedPackageNames.join(', ')}`);\n    }\n\n    if (extraExcludedPackageNames.length > 0) {\n      extraExcludedPackageNames.sort();\n      terminal.writeLine(`Extra dependencies excluded by settings: ${extraExcludedPackageNames.join(', ')}`);\n    }\n\n    return allDependencyNames;\n  }\n\n  /**\n   * Maps a file path from IExtractorOptions.sourceRootFolder to IExtractorOptions.targetRootFolder\n   *\n   * Example input: \"C:\\\\MyRepo\\\\libraries\\\\my-lib\"\n   * Example output: \"C:\\\\MyRepo\\\\common\\\\deploy\\\\libraries\\\\my-lib\"\n   */\n  private _remapPathForExtractorFolder(\n    absolutePathInSourceFolder: string,\n    options: IExtractorOptions\n  ): string {\n    const { sourceRootFolder, targetRootFolder } = options;\n    const relativePath: string = path.relative(sourceRootFolder, absolutePathInSourceFolder);\n    if (relativePath.startsWith('..')) {\n      throw new Error(`Source path \"${absolutePathInSourceFolder}\" is not under \"${sourceRootFolder}\"`);\n    }\n    const absolutePathInTargetFolder: string = path.join(targetRootFolder, relativePath);\n    return absolutePathInTargetFolder;\n  }\n\n  /**\n   * Maps a file path from IExtractorOptions.sourceRootFolder to relative path\n   *\n   * Example input: \"C:\\\\MyRepo\\\\libraries\\\\my-lib\"\n   * Example output: \"libraries/my-lib\"\n   */\n  private _remapPathForExtractorMetadata(\n    absolutePathInSourceFolder: string,\n    options: IExtractorOptions\n  ): string {\n    const { sourceRootFolder } = options;\n    const relativePath: string = path.relative(sourceRootFolder, absolutePathInSourceFolder);\n    if (relativePath.startsWith('..')) {\n      throw new Error(`Source path \"${absolutePathInSourceFolder}\" is not under \"${sourceRootFolder}\"`);\n    }\n    return Path.convertToSlashes(relativePath);\n  }\n\n  /**\n   * Copy one package folder to the extractor target folder.\n   */\n  private async _extractFolderAsync(\n    sourceFolderPath: string,\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { includeNpmIgnoreFiles, targetRootFolder } = options;\n    const { projectConfigurationsByPath, packageJsonByPath, dependencyConfigurationsByName, archiver } =\n      state;\n    let useNpmIgnoreFilter: boolean = false;\n\n    const sourceFolderRealPath: string = await FileSystem.getRealPathAsync(sourceFolderPath);\n    const sourceProjectConfiguration: IExtractorProjectConfiguration | undefined =\n      projectConfigurationsByPath.get(sourceFolderRealPath);\n\n    const packagesJson: IPackageJson | undefined = packageJsonByPath.get(sourceFolderRealPath);\n    // As this function will be used to copy folder for both project inside monorepo and third party dependencies insides node_modules\n    // Third party dependencies won't have project configurations\n    const isLocalProject: boolean = !!sourceProjectConfiguration;\n\n    // Function to filter files inside local project or third party dependencies.\n    const isFileExcluded = (filePath: string): boolean => {\n      // Encapsulate exclude logic into a function, so it can be reused.\n      const excludeFileByPatterns = (\n        patternsToInclude: string[] | undefined,\n        patternsToExclude: string[] | undefined\n      ): boolean => {\n        let includeFilters: IMinimatch[] | undefined;\n        let excludeFilters: IMinimatch[] | undefined;\n        if (patternsToInclude?.length) {\n          includeFilters = patternsToInclude?.map((p) => new Minimatch(p, { dot: true }));\n        }\n        if (patternsToExclude?.length) {\n          excludeFilters = patternsToExclude?.map((p) => new Minimatch(p, { dot: true }));\n        }\n        // If there are no filters, then we can't exclude anything.\n        if (!includeFilters && !excludeFilters) {\n          return false;\n        }\n\n        const isIncluded: boolean = !includeFilters || includeFilters.some((m) => m.match(filePath));\n\n        // If the file is not included, then we don't need to check the excludeFilter. If it is included\n        // and there is no exclude filter, then we know that the file is not excluded. If it is included\n        // and there is an exclude filter, then we need to check for a match.\n        return !isIncluded || !!excludeFilters?.some((m) => m.match(filePath));\n      };\n\n      if (isLocalProject) {\n        return excludeFileByPatterns(\n          sourceProjectConfiguration?.patternsToInclude,\n          sourceProjectConfiguration?.patternsToExclude\n        );\n      } else {\n        if (!packagesJson) {\n          return false;\n        }\n        const dependenciesConfigurations: IExtractorDependencyConfiguration[] | undefined =\n          dependencyConfigurationsByName.get(packagesJson.name);\n        if (!dependenciesConfigurations) {\n          return false;\n        }\n        const matchedDependenciesConfigurations: IExtractorDependencyConfiguration[] =\n          dependenciesConfigurations.filter((d) =>\n            semver.satisfies(packagesJson.version, d.dependencyVersionRange)\n          );\n        return matchedDependenciesConfigurations.some((d) =>\n          excludeFileByPatterns(d.patternsToInclude, d.patternsToExclude)\n        );\n      }\n    };\n\n    if (sourceProjectConfiguration && !includeNpmIgnoreFiles) {\n      // Only use the npmignore filter if the project configuration explicitly asks for it\n      useNpmIgnoreFilter = true;\n    }\n\n    const targetFolderPath: string = this._remapPathForExtractorFolder(sourceFolderPath, options);\n\n    if (useNpmIgnoreFilter) {\n      const npmPackFiles: string[] = await PackageExtractor.getPackageIncludedFilesAsync(sourceFolderPath);\n\n      const alreadyCopiedSourcePaths: Set<string> = new Set();\n\n      await Async.forEachAsync(\n        npmPackFiles,\n        async (npmPackFile: string) => {\n          // In issue https://github.com/microsoft/rushstack/issues/2121 we found that npm-packlist sometimes returns\n          // duplicate file paths, for example:\n          //\n          //   'dist//index.js'\n          //   'dist/index.js'\n          //\n\n          // Filter out files that are excluded by the project configuration or dependency configuration.\n          if (isFileExcluded(npmPackFile)) {\n            return;\n          }\n\n          // We can detect the duplicates by comparing the path.resolve() result.\n          const copySourcePath: string = path.resolve(sourceFolderPath, npmPackFile);\n\n          if (alreadyCopiedSourcePaths.has(copySourcePath)) {\n            return;\n          }\n          alreadyCopiedSourcePaths.add(copySourcePath);\n\n          const copyDestinationPath: string = path.join(targetFolderPath, npmPackFile);\n\n          const copySourcePathNode: PathNode = await state.symlinkAnalyzer.analyzePathAsync(copySourcePath);\n          if (copySourcePathNode.kind !== 'link') {\n            if (!options.createArchiveOnly) {\n              await FileSystem.ensureFolderAsync(path.dirname(copyDestinationPath));\n              // Use the fs.copyFile API instead of FileSystem.copyFileAsync() since copyFileAsync performs\n              // a needless stat() call to determine if it's a file or folder, and we already know it's a file.\n              await fs.promises.copyFile(copySourcePath, copyDestinationPath, fs.constants.COPYFILE_EXCL);\n            }\n\n            if (archiver) {\n              const archivePath: string = path.relative(targetRootFolder, copyDestinationPath);\n              await archiver.addToArchiveAsync({\n                filePath: copySourcePath,\n                archivePath,\n                stats: copySourcePathNode.linkStats\n              });\n            }\n          }\n        },\n        {\n          concurrency: 10\n        }\n      );\n    } else {\n      // use a simplistic \"ignore\" ruleset to filter the files\n      const ignoreFilter: Ignore = ignore();\n      ignoreFilter.add([\n        // The top-level node_modules folder is always excluded\n        '/node_modules',\n        // Also exclude well-known folders that can contribute a lot of unnecessary files\n        '**/.git',\n        '**/.svn',\n        '**/.hg',\n        '**/.DS_Store'\n      ]);\n\n      // Do a breadth-first search of the source folder, copying each file to the target folder\n      const queue: AsyncQueue<string> = new AsyncQueue([sourceFolderPath]);\n      await Async.forEachAsync(\n        queue,\n        async ([sourcePath, callback]: [string, () => void]) => {\n          const relativeSourcePath: string = path.relative(sourceFolderPath, sourcePath);\n          if (relativeSourcePath !== '' && ignoreFilter.ignores(relativeSourcePath)) {\n            callback();\n            return;\n          }\n\n          const sourcePathNode: PathNode = await state.symlinkAnalyzer.analyzePathAsync(sourcePath);\n          if (sourcePathNode.kind === 'file') {\n            // Only ignore files and not folders to ensure that we traverse the contents of all folders. This is\n            // done so that we can match against subfolder patterns, ex. \"src/subfolder/**/*\"\n            if (relativeSourcePath !== '' && isFileExcluded(relativeSourcePath)) {\n              callback();\n              return;\n            }\n\n            const targetPath: string = path.join(targetFolderPath, relativeSourcePath);\n            if (!options.createArchiveOnly) {\n              // Manually call fs.copyFile to avoid unnecessary stat calls.\n              const targetParentPath: string = path.dirname(targetPath);\n              await FileSystem.ensureFolderAsync(targetParentPath);\n              await fs.promises.copyFile(sourcePath, targetPath, fs.constants.COPYFILE_EXCL);\n            }\n\n            // Add the file to the archive. Only need to add files since directories will be auto-created\n            if (archiver) {\n              const archivePath: string = path.relative(targetRootFolder, targetPath);\n              await archiver.addToArchiveAsync({\n                filePath: sourcePath,\n                archivePath: archivePath,\n                stats: sourcePathNode.linkStats\n              });\n            }\n          } else if (sourcePathNode.kind === 'folder') {\n            const children: string[] = await FileSystem.readFolderItemNamesAsync(sourcePath);\n            for (const child of children) {\n              queue.push(path.join(sourcePath, child));\n            }\n          }\n\n          callback();\n        },\n        {\n          concurrency: 10\n        }\n      );\n    }\n  }\n\n  /**\n   * Create a symlink as described by the ILinkInfo object.\n   */\n  private async _extractSymlinkAsync(\n    originalLinkInfo: ILinkInfo,\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const linkInfo: ILinkInfo = {\n      kind: originalLinkInfo.kind,\n      linkPath: this._remapPathForExtractorFolder(originalLinkInfo.linkPath, options),\n      targetPath: this._remapPathForExtractorFolder(originalLinkInfo.targetPath, options)\n    };\n\n    const newLinkFolder: string = path.dirname(linkInfo.linkPath);\n    await FileSystem.ensureFolderAsync(newLinkFolder);\n\n    // Link to the relative path for symlinks\n    const relativeTargetPath: string = path.relative(newLinkFolder, linkInfo.targetPath);\n\n    // NOTE: This logic is based on NpmLinkManager._createSymlink()\n    if (linkInfo.kind === 'fileLink') {\n      // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n      // administrator permission. However hard links seem to cause build failures on Mac,\n      // so for all other operating systems we use symbolic links for this case.\n      if (process.platform === 'win32') {\n        await FileSystem.createHardLinkAsync({\n          linkTargetPath: relativeTargetPath,\n          newLinkPath: linkInfo.linkPath\n        });\n      } else {\n        await FileSystem.createSymbolicLinkFileAsync({\n          linkTargetPath: relativeTargetPath,\n          newLinkPath: linkInfo.linkPath\n        });\n      }\n    } else {\n      // Junctions are only supported on Windows. This will create a symbolic link on other platforms.\n      await FileSystem.createSymbolicLinkJunctionAsync({\n        linkTargetPath: relativeTargetPath,\n        newLinkPath: linkInfo.linkPath\n      });\n    }\n\n    // Since the created symlinks have the required relative paths, they can be added directly to\n    // the archive.\n    await state.archiver?.addToArchiveAsync({\n      filePath: linkInfo.linkPath,\n      archivePath: path.relative(options.targetRootFolder, linkInfo.linkPath)\n    });\n  }\n\n  /**\n   * Write the common/deploy/deploy-metadata.json file.\n   */\n  private async _writeExtractorMetadataAsync(\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { mainProjectName, targetRootFolder } = options;\n    const { projectConfigurationsByPath } = state;\n\n    const extractorMetadataFileName: string = 'extractor-metadata.json';\n    const extractorMetadataFilePath: string = path.join(targetRootFolder, extractorMetadataFileName);\n    const extractorMetadataJson: IExtractorMetadataJson = {\n      mainProjectName,\n      projects: [],\n      links: []\n    };\n\n    for (const { projectFolder, projectName } of projectConfigurationsByPath.values()) {\n      if (state.foldersToCopy.has(projectFolder)) {\n        extractorMetadataJson.projects.push({\n          projectName,\n          path: this._remapPathForExtractorMetadata(projectFolder, options)\n        });\n      }\n    }\n\n    // Remap the links to be relative to target folder\n    for (const absoluteLinkInfo of state.symlinkAnalyzer.reportSymlinks()) {\n      const relativeInfo: ILinkInfo = {\n        kind: absoluteLinkInfo.kind,\n        linkPath: this._remapPathForExtractorMetadata(absoluteLinkInfo.linkPath, options),\n        targetPath: this._remapPathForExtractorMetadata(absoluteLinkInfo.targetPath, options)\n      };\n      extractorMetadataJson.links.push(relativeInfo);\n    }\n\n    const extractorMetadataFileContent: string = JSON.stringify(extractorMetadataJson, undefined, 0);\n    if (!options.createArchiveOnly) {\n      await FileSystem.writeFileAsync(extractorMetadataFilePath, extractorMetadataFileContent);\n    }\n    await state.archiver?.addToArchiveAsync({\n      fileData: extractorMetadataFileContent,\n      archivePath: extractorMetadataFileName\n    });\n  }\n\n  private async _makeBinLinksAsync(options: IExtractorOptions, state: IExtractorState): Promise<void> {\n    const { terminal } = options;\n\n    const extractedProjectFolders: string[] = Array.from(state.projectConfigurationsByPath.keys()).filter(\n      (folderPath: string) => state.foldersToCopy.has(folderPath)\n    );\n\n    await Async.forEachAsync(\n      extractedProjectFolders,\n      async (projectFolder: string) => {\n        const extractedProjectFolder: string = this._remapPathForExtractorFolder(projectFolder, options);\n        const extractedProjectNodeModulesFolder: string = path.join(extractedProjectFolder, 'node_modules');\n        const extractedProjectBinFolder: string = path.join(extractedProjectNodeModulesFolder, '.bin');\n\n        const linkedBinPackageNames: string[] = await pnpmLinkBins(\n          extractedProjectNodeModulesFolder,\n          extractedProjectBinFolder,\n          {\n            warn: (msg: string) => terminal.writeLine(Colors.yellow(msg))\n          }\n        );\n\n        if (linkedBinPackageNames.length && state.archiver) {\n          const binFolderItems: string[] = await FileSystem.readFolderItemNamesAsync(\n            extractedProjectBinFolder\n          );\n          for (const binFolderItem of binFolderItems) {\n            const binFilePath: string = path.join(extractedProjectBinFolder, binFolderItem);\n            await state.archiver.addToArchiveAsync({\n              filePath: binFilePath,\n              archivePath: path.relative(options.targetRootFolder, binFilePath)\n            });\n          }\n        }\n      },\n      {\n        concurrency: 10\n      }\n    );\n  }\n}\n"]}