"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LoadComponentExecutor = /** @class */ (function () {
    function LoadComponentExecutor(loadFunction) {
        this._pendingLoads = [];
        this._loadFunction = loadFunction;
    }
    LoadComponentExecutor.prototype.setAlternativeExecutor = function (executor) {
        this._alternativeExecutor = executor;
        executor._alternativeExecutor = this;
    };
    LoadComponentExecutor.prototype.loadComponent = function (manifest, retryCount) {
        var _this = this;
        if (!this._canRunLoad()) {
            return new Promise(function (resolve, reject) {
                _this._pendingLoads.push(function () {
                    _this.loadComponent(manifest, retryCount).then(resolve, reject);
                });
            });
        }
        this._incrementActiveLoads();
        return this._loadFunction(manifest, retryCount)
            .then(function (module) {
            _this._decrementActiveLoads();
            return module;
        })
            .catch(function (error) {
            _this._decrementActiveLoads();
            throw error;
        });
    };
    Object.defineProperty(LoadComponentExecutor.prototype, "isRunning", {
        /**
         * Returns true if SystemJS is currently running any loadComponent() call.
         *
         * @remarks
         * This is used to ensure that SystemJS will not run while RequireJS is not done with all loads.
         */
        get: function () {
            return this._activeLoads > 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * When called, executes all the loadComponent() calls that couldn't be executed before.
     *
     * @remarks
     * This is used to ensure that we don't run SystemJS while RequireJS is not done trying to load a component.
     */
    LoadComponentExecutor.prototype.processPendingLoads = function () {
        var _loadsToRun = this._pendingLoads;
        this._pendingLoads = [];
        _loadsToRun.forEach(function (load) { return load(); });
    };
    /**
     * Returns true if loadComponent() can be executed.
     *
     * @remarks
     * It just checks that RequireJS is not running at the time, as both can't work at the same time.
     */
    LoadComponentExecutor.prototype._canRunLoad = function () {
        return !this._alternativeExecutor || !this._alternativeExecutor.isRunning;
    };
    /**
     * Increments the number of active loads.
     */
    LoadComponentExecutor.prototype._incrementActiveLoads = function () {
        this._activeLoads++;
    };
    /**
     * Decrements the number of active loads.
     * When there are no active loads, it tries to load any pending request in RequireJS.
     */
    LoadComponentExecutor.prototype._decrementActiveLoads = function () {
        this._activeLoads--;
        if (this._activeLoads === 0 && this._alternativeExecutor) {
            this._alternativeExecutor.processPendingLoads();
        }
    };
    return LoadComponentExecutor;
}());
exports.default = LoadComponentExecutor;
//# sourceMappingURL=LoadComponentExecutor.js.map