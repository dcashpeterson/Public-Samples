"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsalBrowserTokenProvider = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var msalBrowserLegacy_1 = require("msalBrowserLegacy");
var AadConstants_1 = tslib_1.__importDefault(require("../../../AadConstants"));
var AadErrorHandler_1 = require("../../../AadErrorHandler");
var AadKillSwitches_1 = require("../../../AadKillSwitches");
var AadTokenProvider_1 = tslib_1.__importStar(require("../../../AadTokenProvider"));
var MsalInteractionManager_1 = require("../MsalInteractionManager");
var MsalMonitor_1 = require("../MsalMonitor");
var MsalRedirectManager_1 = require("../MsalRedirectManager");
var MsalUtilities_1 = require("../MsalUtilities");
var MsalBrowserClientManager_1 = require("./MsalBrowserClientManager");
var MsalSessionIdManager_1 = require("./MsalSessionIdManager");
/**
 * List of different login hint strategies that should be tried (generally in order) for ssoSilent.
 * AAD's recommended order is LOGIN_HINT_CLAIM -\> SESSION_ID -\> UPN.
 *
 * If none are available, ssoSilent may be tried with no login hint. It will be successful when
 * exactly one valid session exists in AAD for that user.
 * @Internal
 */
var MsalBrowserLoginHint;
(function (MsalBrowserLoginHint) {
    MsalBrowserLoginHint[MsalBrowserLoginHint["LOGIN_HINT_CLAIM"] = 0] = "LOGIN_HINT_CLAIM";
    MsalBrowserLoginHint[MsalBrowserLoginHint["SESSION_ID"] = 1] = "SESSION_ID";
    MsalBrowserLoginHint[MsalBrowserLoginHint["UPN"] = 2] = "UPN";
    MsalBrowserLoginHint[MsalBrowserLoginHint["NONE"] = 3] = "NONE";
})(MsalBrowserLoginHint || (MsalBrowserLoginHint = {}));
/**
 * Class that wraps the MSAL Browser's authentication class in order to acquire tokens.
 *
 * MsalBrowserTokenProvider provides two methods to acquire tokens:
 *   1. getToken: returns a promise containing only the access token string.
 *   2. getTokenData: returns a promise containing the entire token object.
 *
 * @internal
 */
var MsalBrowserTokenProvider = /** @class */ (function () {
    function MsalBrowserTokenProvider(configuration) {
        this._ALLOWED_NETWORK_RETRY_ATTEMPTS = 1;
        this._defaultConfiguration = configuration;
        this._redirectManager = new MsalRedirectManager_1.MsalRedirectManager(this._getAuthority(), this._getClientId(), true);
        this._shouldPrintDebugLogs = MsalUtilities_1.MsalUtilities.shouldPrintMsalLogsToConsole();
        MsalBrowserClientManager_1.MsalBrowserClientManager.registerMsalBrowserClient(this._getAuthority(), this._getClientId(), this._getRedirectUri());
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            MsalSessionIdManager_1.MsalSessionIdManager.initialize();
        }
    }
    MsalBrowserTokenProvider.prototype.getToken = function (resourceEndpoint, optionsOrUseCachedToken) {
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? tslib_1.__assign({}, optionsOrUseCachedToken) : {
            useCachedToken: optionsOrUseCachedToken
        };
        return this.getTokenData(resourceEndpoint, options).then(function (tokenData) { return tokenData.accessToken; });
    };
    MsalBrowserTokenProvider.prototype.getTokenData = function (resourceEndpoint, optionsOrUseCachedToken, skipLoggingAndDisableRedirects) {
        var _this = this;
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        if (skipLoggingAndDisableRedirects === void 0) { skipLoggingAndDisableRedirects = false; }
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? optionsOrUseCachedToken
            : {
                skipLoggingAndDisableRedirects: skipLoggingAndDisableRedirects,
                useCachedToken: optionsOrUseCachedToken,
                claims: undefined
            };
        var _a = options.skipLoggingAndDisableRedirects, shouldNotLogOrRedirect = _a === void 0 ? false : _a, _b = options.useCachedToken, useCachedToken = _b === void 0 ? true : _b, claims = options.claims, scopes = options.scopes;
        this._shouldPrintDebugLogs = MsalUtilities_1.MsalUtilities.shouldPrintMsalLogsToConsole();
        var requestContext = {
            resourceEndpoint: resourceEndpoint,
            claims: claims,
            useCachedToken: useCachedToken,
            loginHintType: MsalBrowserLoginHint.SESSION_ID,
            shouldNotLogOrRedirect: shouldNotLogOrRedirect,
            telemetryData: this._generateTelemetryData(resourceEndpoint),
            scopes: scopes
        };
        return this._ensureMsalClientIsInitialized(requestContext)
            .then(function () {
            _this._logger('getTokenData', 'msal-browser.js client initialized. Waiting for acquireControl().');
            return MsalInteractionManager_1.MsalInteractionManager.acquireControl();
        })
            .then(function () {
            _this._logger('getTokenData', 'acquireControl() successful, continuing.');
            var getTokenDataMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.GetTokenData', shouldNotLogOrRedirect);
            var tokenPromise;
            if (_this._isCurrentUserLoggedInToMsal()) {
                var acquireTokenSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.AcquireTokenSilent', shouldNotLogOrRedirect);
                _this._logger('getTokenData', 'User is logged in, calling acquireTokenSilent().');
                tokenPromise = _this._acquireTokenSilent(requestContext, acquireTokenSilentMonitor);
            }
            else {
                var ssoSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.SsoSilent', shouldNotLogOrRedirect);
                _this._logger('getTokenData', 'No user is logged in, calling ssoSilent().');
                tokenPromise = _this._ssoSilent(requestContext, ssoSilentMonitor);
            }
            return tokenPromise
                .then(function (tokenData) {
                _this._logger('getTokenData', 'Token retrieved. Exiting.');
                requestContext.telemetryData.alias = (!!tokenData.fromCache).toString();
                getTokenDataMonitor.writeSuccess(requestContext.telemetryData);
                MsalInteractionManager_1.MsalInteractionManager.releaseControl();
                return tokenData;
            })
                .catch(function (error) {
                _this._logger('getTokenData', 'Caught an error.', error);
                if (_this._isInteractionRequiredError(error)) {
                    var popupMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.Popup', shouldNotLogOrRedirect);
                    var pendingPopup = _this._acquireTokenPopup(requestContext, popupMonitor);
                    if (pendingPopup) {
                        return pendingPopup;
                    }
                }
                var canRedirect = _this._isErrorEligibleForRedirect(error) &&
                    _this._redirectManager.isAllowedToRedirect() &&
                    !shouldNotLogOrRedirect;
                if (canRedirect) {
                    _this._logger('getTokenData', 'Calling _loginRedirect()');
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    /* eslint-disable-next-line @typescript-eslint/no-floating-promises */
                    _this._loginRedirect(requestContext);
                }
                else if (_this._isExpectedFailure(error)) {
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, requestContext.telemetryData);
                }
                else {
                    getTokenDataMonitor.writeUnexpectedFailure(error.errorCode, error, requestContext.telemetryData);
                }
                _this._logger('getTokenData', 'Throwing the error back to caller. Exiting.');
                MsalInteractionManager_1.MsalInteractionManager.releaseControl();
                throw error;
            });
        });
    };
    /**
     * Returns a promise that only resolves once the Msal Browser client has been initialized and assigned.
     * If the client hasn't been initialized, MsalBrowserClientManager will provide an initialized one.
     *
     * @param requestContext - The request context for this call.
     * @returns The promise fulfils when this._msalBrowserClient has been initialized for use.
     */
    MsalBrowserTokenProvider.prototype._ensureMsalClientIsInitialized = function (requestContext) {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._msalBrowserClient) {
                resolve();
            }
            else {
                MsalBrowserClientManager_1.MsalBrowserClientManager.getMsalBrowserClient(_this._getAuthority(), _this._getClientId(), _this._getRedirectUri())
                    .then(function (msalBrowserClient) {
                    _this._msalBrowserClient = msalBrowserClient;
                    resolve();
                })
                    .catch(function (error) {
                    var msalClientInitQos = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider._ensureMsalClientIsInitialized');
                    msalClientInitQos.writeUnexpectedFailure('msalClientInit', error, requestContext.telemetryData);
                });
            }
        });
    };
    /**
     * Wrapper method for msalBrowser.acquireTokenSilent(). This method is used when the current user is arleady
     * logged into to the msal-browser framework. It will retry if there are any detectable network issues
     * during msalBrowser.acquireTokenSilent().
     *
     * The token will be acquired from the cache or from the network using a refresh token. If this fails, the
     * error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on retries and is considered failed each time an error has raised. The
     * acquireTokenSilentMonitor will be re-used on each retry.
     *
     * @param requestContext - The request context.
     * @param acquireTokenSilentMonitor - The monitor tracking the request.
     * @param attempt - The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._acquireTokenSilent = function (requestContext, acquireTokenSilentMonitor, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var extraData = requestContext.telemetryData, shouldNotLog = requestContext.shouldNotLogOrRedirect;
        var retryAcquireTokenSilentMonitor;
        var isFirstAttempt = attempt === 0;
        if (!isFirstAttempt) {
            retryAcquireTokenSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.RetryAcquireTokenSilent', shouldNotLog);
        }
        var silentRequest = this._generateSilentRequest(requestContext);
        this._logger('_acquireTokenSilent', 'Calling acquireTokenSilent with parameters:', silentRequest);
        return this._msalBrowserClient
            .acquireTokenSilent(silentRequest)
            .then(function (authResult) {
            _this._logger('_acquireTokenSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            acquireTokenSilentMonitor.writeSuccess(extraData);
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_acquireTokenSilent', 'Caught an error:', error);
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
                if (_this._isExpectedFailure(error)) {
                    acquireTokenSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
                }
                else {
                    acquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
                }
            }
            else {
                var hasRetriesLeft = attempt < _this._ALLOWED_NETWORK_RETRY_ATTEMPTS;
                var isAllowedToRetry = _this._isRetriableNetworkError(error) && hasRetriesLeft;
                // Remove this retry code when graduating this killswitch
                if ((0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)() && isAllowedToRetry) {
                    attempt++;
                    _this._logger('_acquireTokenSilent', 'Retrying.');
                    return _this._acquireTokenSilent(requestContext, acquireTokenSilentMonitor, attempt);
                }
                else if (_this._isExpectedFailure(error)) {
                    acquireTokenSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
                }
                else {
                    acquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
                }
            }
            _this._logger('_acquireTokenSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * Wrapper method for msalBrowser.ssoSilent(). This method is used when the current user is not logged
     * into to the msal-browser framework. It will retry if there are any detectable network issues during
     * msalBrowser.ssoSilent().
     *
     * The token will be acquired over the network and will use the current session ID if possible. If this
     * fails, the error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on later attempts and is considered failed each time an error has
     * raised. The ssoSilentMonitor will be re-used on each retry.
     *
     * @param requestContext - The request context.
     * @param ssoSilentMonitor - The monitor tracking the request.
     * @param attempt - The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._ssoSilent = function (requestContext, ssoSilentMonitor, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var shouldNotLog = requestContext.shouldNotLogOrRedirect, extraData = requestContext.telemetryData;
        var retrySsoSilentMonitor;
        var isFirstAttempt = attempt === 0;
        if (!isFirstAttempt) {
            retrySsoSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.RetrySsoSilent', shouldNotLog);
        }
        var ssoSilentRequest = this._generateSsoSilentRequest(requestContext);
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            this._logger('_ssoSilent', 'Calling RedirectManager.prepareForSsoSilent().');
            this._redirectManager.prepareForSsoSilent();
        }
        this._logger('_ssoSilent', 'Calling ssoSilent with parameters:', ssoSilentRequest);
        return this._msalBrowserClient
            .ssoSilent(ssoSilentRequest)
            .then(function (authResult) {
            _this._logger('_ssoSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            ssoSilentMonitor.writeSuccess(extraData);
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeSuccess(extraData);
            _this._redirectManager.completeSsoSilent();
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_ssoSilent', 'Caught an error:', error);
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
                if (ssoSilentRequest.sid &&
                    requestContext.loginHintType === MsalBrowserLoginHint.SESSION_ID &&
                    AadErrorHandler_1.AadErrorHandler._isSessionDoesNotExistError(error.errorMessage, error.errorCode)) {
                    MsalSessionIdManager_1.MsalSessionIdManager.addInvalidSessionId(ssoSilentRequest.sid);
                    _this._logger('_ssoSilent', 'Invalid session ID. Retrying with loginHint as UPN.');
                    attempt++;
                    return _this._ssoSilent(requestContext, ssoSilentMonitor, attempt);
                }
            }
            var hasRetriesLeft = attempt < _this._ALLOWED_NETWORK_RETRY_ATTEMPTS;
            var isAllowedToRetry = _this._isRetriableNetworkError(error) && hasRetriesLeft;
            if (isAllowedToRetry) {
                attempt++;
                _this._logger('_ssoSilent', 'Retrying.');
                return _this._ssoSilent(requestContext, ssoSilentMonitor, attempt);
            }
            else if (_this._isExpectedFailure(error)) {
                ssoSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                ssoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            _this._redirectManager.completeSsoSilent();
            _this._logger('_ssoSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * This method wraps msal-browser's loginRedirect method. This method must call
     * MalBrowserRedirectManager.prepareForRedirect(). This ensures that the redirect page,
     * spfxsinglesignon.aspx, will know how to properly instantiate and configure msal-browser.
     *
     * This method returns nothing and immediately redirects.
     *
     * @param requestContext - The request context.
     * @returns Nothing. This method will immediately perform a redirect.
     */
    MsalBrowserTokenProvider.prototype._loginRedirect = function (requestContext) {
        var _this = this;
        var extraData = requestContext.telemetryData;
        var loginRedirectRequestData = this._generateLoginRedirectRequest(requestContext);
        this._logger('_loginRedirect', 'Calling prepareForRedirect().');
        this._redirectManager.prepareForRedirect();
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            MsalSessionIdManager_1.MsalSessionIdManager.saveInvalidSessionIdsToStorage();
        }
        this._logger('_loginRedirect', 'Calling loginRedirect.');
        return this._msalBrowserClient.loginRedirect(loginRedirectRequestData).catch(function (error) {
            _this._logger('_loginRedirect', 'Failed to redirect with error:', error);
            var loginRedirectMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider._loginRedirect');
            loginRedirectMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            throw error;
        });
    };
    MsalBrowserTokenProvider.prototype._acquireTokenPopup = function (requestContext, popupMonitor) {
        var _this = this;
        var resourceEndpoint = requestContext.resourceEndpoint;
        var resolveAuthData;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var rejectAuthData;
        var promise;
        var requestPopup = function () {
            if (promise) {
                return;
            }
            promise = new Promise(function (resolve, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            reject) {
                resolveAuthData = resolve;
                rejectAuthData = reject;
            });
        };
        var showPopup = function () {
            if (!promise) {
                requestPopup();
            }
            var extraData = _this._generateTelemetryData(resourceEndpoint);
            var popupRequest = _this._generatePopupRequest(requestContext);
            _this._logger('_acquireTokenPopup', 'Calling acquireTokenPopup with parameters:', popupRequest);
            if (resolveAuthData) {
                resolveAuthData(_this._msalBrowserClient
                    .acquireTokenPopup(popupRequest)
                    .then(function (authResult) {
                    _this._logger('_acquireTokenPopup', 'Successfully got a token.');
                    extraData.alias = (!!authResult.fromCache).toString();
                    popupMonitor.writeSuccess(extraData);
                    return authResult;
                })
                    .catch(function (error) {
                    _this._logger('_acquireTokenPopup', 'Caught an error.', error);
                    if (_this._isExpectedFailure(error)) {
                        popupMonitor.writeExpectedFailure(error.errorCode, error, extraData);
                    }
                    else {
                        popupMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
                    }
                    return Promise.reject(error);
                }));
            }
        };
        var cancel = function (error) {
            if (!promise) {
                requestPopup();
            }
            if (rejectAuthData) {
                rejectAuthData(error);
            }
        };
        sp_core_library_1._SPEventManager.instance.raiseEvent(AadTokenProvider_1.default._popupEventId, new AadTokenProvider_1.PopupEventArgs(cancel, requestPopup, showPopup));
        if (promise) {
            return promise;
        }
    };
    /**
     * Generates an MSAL SilentRequest to be used with the loginSilent method.
     *
     * @param requestContext - The request context.
     * @returns An MSAL SilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSilentRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, correlationId = requestContext.telemetryData.CorrelationId, scopes = requestContext.scopes;
        var silentRequestData = tslib_1.__assign({ account: this._getCurrentAccount(), authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (claims
            ? {
                claims: claims
            }
            : {}));
        return silentRequestData;
    };
    /**
     * Generates an MSAL SsoSilentRequest to be used with the ssoSilent method.
     * Note: SID and login hint may be undefined if they are non-existant or invalid. This
     *       may cause the request to fail and be handled by a redirect instead.
     *
     * @param requestContext - The request context.
     * @returns An MSAL SsoSilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSsoSilentRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, correlationId = requestContext.telemetryData.CorrelationId, scopes = requestContext.scopes;
        var ssoSilentRequestData;
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            ssoSilentRequestData = tslib_1.__assign({ authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (claims
                ? {
                    claims: claims
                }
                : {}));
            if (requestContext.loginHintType === MsalBrowserLoginHint.SESSION_ID) {
                var sessionId = this._getSessionId();
                if (sessionId && !MsalSessionIdManager_1.MsalSessionIdManager.isSessionIdInvalid(sessionId)) {
                    ssoSilentRequestData.loginHint = undefined;
                    ssoSilentRequestData.sid = sessionId;
                }
                else {
                    requestContext.loginHintType = MsalBrowserLoginHint.UPN;
                }
            }
            if (requestContext.loginHintType === MsalBrowserLoginHint.UPN) {
                var upn = this._getUPN();
                if (upn) {
                    ssoSilentRequestData.loginHint = upn;
                    ssoSilentRequestData.sid = undefined;
                }
                else {
                    requestContext.loginHintType = MsalBrowserLoginHint.NONE;
                }
            }
            if (requestContext.loginHintType === MsalBrowserLoginHint.NONE) {
                ssoSilentRequestData.loginHint = undefined;
                ssoSilentRequestData.sid = undefined;
            }
        }
        else {
            ssoSilentRequestData = tslib_1.__assign({ authority: this._getAuthority(), correlationId: correlationId, loginHint: this._getUPN(), scopes: scopes || this._getScopes(resourceEndpoint), sid: this._getSessionId() }, (claims
                ? {
                    claims: claims
                }
                : {}));
        }
        return ssoSilentRequestData;
    };
    /**
     * Generates an MSAL SilentRequest to be used with the loginSilent method.
     *
     * @param requestContext - The request context.
     * @returns An MSAL SilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generatePopupRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, correlationId = requestContext.telemetryData.CorrelationId, scopes = requestContext.scopes;
        var popupRequestData = tslib_1.__assign({ account: this._getCurrentAccount(), authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (claims
            ? {
                claims: claims
            }
            : {}));
        return popupRequestData;
    };
    /**
     * Generates telemetry data to be added to QoS Monitors. We track:
     * - alias: Marks cache hits. This will be true if the request came from the cache.
     * - aadSessionId: AAD Session ID used in ssoSilent scenarios.
     * - CorrelationId: The correlation ID of the token request.
     * - isInternal: True if first party application ID.
     * - isPageVisibleStart: True if page is visible at scenario start.
     * - isPageVisibleEnd: True if page is visible at scenario end.
     * - redirectUri: redirect URI used in redirect and ssoSilent scenarios
     *
     * @param resourceEndpoint - The resource a token is being requested for.
     * @returns An IMsalBrowserTokenProviderExtraData object that can be added to QoS Monitor writes.
     */
    MsalBrowserTokenProvider.prototype._generateTelemetryData = function (resourceEndpoint) {
        var isInternal = this._defaultConfiguration.servicePrincipalId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID;
        var telemetryData;
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            telemetryData = {
                alias: 'false',
                aadSessionId: this._getSessionId(),
                CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
                isInternal: isInternal,
                isPageVisibleStart: document.visibilityState === 'visible',
                isPageVisibleEnd: false,
                redirectUri: this._getRedirectUri(),
                msalVersion: '2.22.0'
            };
        }
        else {
            telemetryData = {
                alias: 'false',
                CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
                isInternal: isInternal
            };
        }
        if (telemetryData.isInternal) {
            telemetryData.name = resourceEndpoint;
        }
        return telemetryData;
    };
    /**
     * Given an error, this method will return true if the token provider is allowed to redirect
     * and the error can be solved with a redirect.
     *
     * Note: Redirects are not performed for IE.
     *
     * @param error - An msalBrowser AuthError.
     * @returns True if the error can be solved with a redirect and there are remaining redirects.
     */
    MsalBrowserTokenProvider.prototype._isErrorEligibleForRedirect = function (error) {
        var hasMoreRedirectAttempts = this._redirectManager.hasRedirectAttemptsLeft();
        var isInteractionRequiredError = this._isInteractionRequiredError(error);
        var isBrowserIE = sp_core_library_1._BrowserDetection.getBrowserInformation().browser === sp_core_library_1._Browser.IE;
        var isAbleToRedirect = isInteractionRequiredError && hasMoreRedirectAttempts && !isBrowserIE;
        return isAbleToRedirect;
    };
    /**
     * Given an error, this method will return true if the provided error is any type of 'Interaction Required'
     * error. These errors can be solved by invoking a full-page redirect (interaction).
     *
     * @param error - An msal-browser AuthError.
     * @returns True if the error provided can be solved by a redirect and false otherwise.
     */
    MsalBrowserTokenProvider.prototype._isInteractionRequiredError = function (error) {
        return (error instanceof msalBrowserLegacy_1.InteractionRequiredAuthError ||
            AadErrorHandler_1.AadErrorHandler._isInteractionRequired(error.message, error.errorCode) ||
            error.errorCode === 'no_account_error');
    };
    /**
     * Given an msal-browser AuthError, returns true if the error is an expected failure for QoS Monitors.
     * These errors can either be ignored (i.e., TabStop test) or solved by a full-page redirect (as long as
     * there are redirect attempts remaining).
     *
     * @param error - An msal-browser AuthError.
     * @returns True if the error is expected and be recorded as successful for QoS Monitors.
     */
    MsalBrowserTokenProvider.prototype._isExpectedFailure = function (error) {
        var canAttemptRedirect = this._isErrorEligibleForRedirect(error);
        var doesAadErrorCodeExist = AadErrorHandler_1.AadErrorHandler._doesAadErrorCodeExist(error.message, AadConstants_1.default.EXPECTED_AAD_ERRORS);
        var isTabStopTest = this._isTabStopTest();
        return canAttemptRedirect || doesAadErrorCodeExist || isTabStopTest;
    };
    /**
     * This method returns true if a TabStop test is currently being run. TabStop tests are
     * known to cause issues and so they are generally recorded as expected failures.
     *
     * @returns True if a TabStop test is running.
     */
    MsalBrowserTokenProvider.prototype._isTabStopTest = function () {
        var userAgentString = sp_core_library_1._BrowserDetection.getBrowserInformation().userAgent || '';
        var isTabStopTest = userAgentString.indexOf('TabStop/1.0') > -1;
        return isTabStopTest;
    };
    /**
     * Generates an MSAL RedirectRequest to be used with the loginRedirect method.
     *
     * @param requestContext - The request context.
     * @returns An MSAL RedirectRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateLoginRedirectRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, correlationId = requestContext.telemetryData.CorrelationId;
        var redirectRequestData = {
            authority: this._getAuthority(),
            correlationId: correlationId,
            onRedirectNavigate: this._getOnRedirectNavigate(),
            redirectUri: this._getRedirectUri(),
            scopes: this._getScopes(resourceEndpoint),
            state: window.location.href
        };
        return redirectRequestData;
    };
    /**
     * This method is used to retrieve the callback for the onRedirectNagivate option on MSAL RedirectRequests.
     * If this method returns false, then MSAL will cancel the redirect. This method raises an event
     * that gives the method requesting a token the opportunity to cancel the redirect.
     *
     * Note: This method returns a method in order to correctly bind 'this'. If
     *       onRedirectNavigateCallback was a class-level method and included
     *       in a RedirectRequest as a parameter, 'this' fails to bind and
     *       throw a runtime error.
     *
     * @returns Returning false will cancel the redirect.
     */
    MsalBrowserTokenProvider.prototype._getOnRedirectNavigate = function () {
        var _this = this;
        var onRedirectNagivateCallback = function (url) {
            _this._redirectCancelled = false;
            sp_core_library_1._SPEventManager.instance.raiseEvent(AadTokenProvider_1.default._onBeforeRedirectEventId, new AadTokenProvider_1.BeforeRedirectEventArgs(url, _this._cancelRedirect.bind(_this)));
            // If we are in tab cancel the redirect.
            if (window.sessionStorage.getItem('_isRunningTABTest') === 'true') {
                _this._redirectCancelled = true;
            }
            if (_this._redirectCancelled) {
                _this._redirectManager.cancelRedirect();
            }
            return !_this._redirectCancelled;
        };
        return onRedirectNagivateCallback;
    };
    /**
     * Attempts to retrieve the current user account logged into the MSAL framework. The userPrincipalName
     * from the configuration object is used to determine if the account is logged in. This will return
     * undefined if no account is logged in.
     *
     * @returns An MSAL AccountInfo object of the currently logged in user or undefined if there is no
     *          logged in user.
     */
    MsalBrowserTokenProvider.prototype._getCurrentAccount = function () {
        var userName = this._defaultConfiguration.userPrincipalName || '';
        var localId = this._defaultConfiguration.aadUserId || '';
        var currentAccountByUsername = this._msalBrowserClient.getAccountByUsername(userName);
        var currentAccountByLocalId = this._msalBrowserClient.getAccountByLocalId(localId);
        var currentActiveAccount = this._msalBrowserClient.getActiveAccount();
        if (currentAccountByUsername || currentAccountByLocalId) {
            this._logger('_getCurrentAccount', 'Found an account', {
                currentAccountByLocalId: currentAccountByLocalId,
                currentAccountByUsername: currentAccountByUsername
            });
        }
        else {
            this._logger('_getCurrentAccount', 'No account found');
        }
        return currentAccountByUsername || currentAccountByLocalId || currentActiveAccount || undefined;
    };
    /**
     * This method is used to cancel redirects. It is binded to an event raised before full page redirects
     * so that the method requesting a token may choose to cancel the redirect if necessary by calling this.
     * By default redirects are turned on.
     */
    MsalBrowserTokenProvider.prototype._cancelRedirect = function () {
        this._redirectCancelled = true;
    };
    /**
     * This method returns whether or not a given error is a retriable network related error.
     *
     * @param error - An MSAL error code.
     * @returns Whether or not the error is network related.
     */
    MsalBrowserTokenProvider.prototype._isRetriableNetworkError = function (error) {
        if (!(0, AadKillSwitches_1.isMsalBrowserRetryAndSsoSilentImprovementsKsActivated)()) {
            return AadErrorHandler_1.AadErrorHandler._isTokenRenewalTimeout(error === null || error === void 0 ? void 0 : error.errorCode);
        }
        else {
            return (AadErrorHandler_1.AadErrorHandler._isEndpointsResolutionError(error === null || error === void 0 ? void 0 : error.errorCode) ||
                AadErrorHandler_1.AadErrorHandler._isTokenRenewalTimeout(error === null || error === void 0 ? void 0 : error.errorCode));
        }
    };
    /**
     * Using the userPrincipalName from the configuration object, returns whether or not the user is logged
     * into the MSAL framework.
     *
     * @returns True if the current user is logged into the MSAL framework.
     */
    MsalBrowserTokenProvider.prototype._isCurrentUserLoggedInToMsal = function () {
        return this._getCurrentAccount() !== undefined;
    };
    /**
     * Using the configuration object passed to the token provider, assembles and returns the 'authority' string
     * to be used in MSAL requests.
     *
     * @returns The 'authority' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getAuthority = function () {
        return this._defaultConfiguration.aadInstanceUrl + '/' + this._defaultConfiguration.aadTenantId;
    };
    /**
     * Using the userPrincipalName from the configuration object passed to the token provider, returns the
     * 'upn' string to be used in MSAL requests.
     *
     * @returns The 'loginHint' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getUPN = function () {
        return this._defaultConfiguration.userPrincipalName;
    };
    /**
     * Given the resource a token is being requested for, returns the 'scopes' array to be used in MSAL
     * requests. Scopes are always returned as a single string in an array, where the scope requested is the
     * default scope.
     *
     * This scope will provide access to all preauthorized scopes and does not provide granular scope access.
     *
     * Example:
     *   resourceEndpoint: contoso.sharepoint.com
     *   returns: ['contoso.sharepoint.com/.default']
     *
     * @param resourceEndpoint - The resource a token is being requested for
     * @returns A scope array to be used with MSAL requests for the given resource.
     */
    MsalBrowserTokenProvider.prototype._getScopes = function (resourceEndpoint) {
        return [resourceEndpoint + '/.default'];
    };
    /**
     * Using the aadSessionId from the configuration object passed to the token provider, returns the 'sid'
     * string to be used in MSAL requests. If the session ID is not a valid GUID or does not exist, this
     * will return undefined.
     *
     * Note: A value of undefined may result in requiring a full page redirect.
     *
     * @returns The 'sid' field to be used in MSAL requests or undefined.
     */
    MsalBrowserTokenProvider.prototype._getSessionId = function () {
        var sessionId = this._defaultConfiguration.aadSessionId;
        var isValidSessionId = !!sp_core_library_1.Guid.tryParse(sessionId);
        if (!isValidSessionId) {
            sessionId = undefined;
        }
        if (sessionId) {
            this._logger('_getSessionId', 'Found session ID', sessionId);
        }
        else {
            this._logger('_getSessionId', 'No session ID was found');
        }
        return sessionId;
    };
    /**
     * Using the servicePrincipalId from the configuration object passed to the token provider, returns the
     * 'clientId' string to be used in MSAL requests.
     *
     * @returns The 'clientId' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getClientId = function () {
        return this._defaultConfiguration.servicePrincipalId;
    };
    /**
     * Using the redirectUri from the configuration object passed to the token provider, returns the
     * 'redirectUri' string to be used in MSAL requests.
     *
     * @returns The 'redirectUri' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getRedirectUri = function () {
        return this._defaultConfiguration.redirectUri;
    };
    /**
     * Logger for debugging. If the query string parameter 'msalLogging=true' is present,
     * logs will be printed to the console.
     */
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    MsalBrowserTokenProvider.prototype._logger = function (fnName, message, extraData) {
        /* eslint-disable no-console */
        if (this._shouldPrintDebugLogs) {
            console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][1]: ' + message);
            if (extraData) {
                console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][2] Extra Data: ');
                console.log(extraData);
            }
        }
        /* eslint-enable no-console */
    };
    return MsalBrowserTokenProvider;
}());
exports.MsalBrowserTokenProvider = MsalBrowserTokenProvider;
//# sourceMappingURL=MsalBrowserTokenProvider.js.map