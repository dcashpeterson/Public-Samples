import { type ITerminal } from '@rushstack/node-core-library';
import type XmlGenerator from 'xml';
import type { default as ISolution } from './packageSolution/models/packageDefinition/ISolution';
export interface IPackageSolutionConfigJson extends Partial<Omit<IPackageSolutionConfig, 'paths'>> {
    paths: Partial<IPackageSolutionConfigPaths>;
}
/**
 * @public
 */
export interface IPackageSolutionConfigPaths {
    /**
     * The packaging root folder. Defaults to './sharepoint'. All other paths are relative to this folder.
     */
    packageDir: string;
    /**
     * The folder to write the raw package to disk for debugging. Defaults to 'solution/debug'
     */
    debugDir: string;
    /**
     * The name of the sppkg to create (including extension) Defaults to 'ClientSolution.sppkg'
     */
    zippedPackage: string;
    /**
     * The folder containing the custom feature xml to import into the package. Defaults to 'feature_xml'.
     * Note that all files in this folder will be included in the SPPKG, however, you must create a .rels
     * file for your custom feature for it to be included in the package manifest.
     */
    featureXmlDir: string;
    /**
     * The directory containing Sharepoint assets (such as feature elements, element manifests, and upgrade actions),
     * which will be automatically included in the sharepoint package. Defaults to 'assets'.
     */
    sharepointAssetDir: string;
    /**
     * The directory containing teams assets (such as icons)
     */
    teamsDir: string;
}
/**
 * @public
 */
export interface IPackageSolutionConfig {
    paths: IPackageSolutionConfigPaths;
    /** A mapping of extensions to content types for resources included in the package */
    contentTypes: Record<string, string>;
    /**
     * The definition of this solution's package, features, and components
     */
    solution: ISolution;
}
export declare type XmlSerializationOptions = NonNullable<Parameters<typeof XmlGenerator>[1]>;
/**
 * @internal
 */
export interface ISolutionPackagerOptions {
    buildFolder: string;
    terminal: ITerminal;
    emitError: (error: Error) => void;
    emitWarning: (warning: Error) => void;
}
/**
 * @internal
 */
export declare class SolutionPackager {
    private static readonly _configFile;
    private readonly _buildFolder;
    private readonly _webpackOutputFolderPaths;
    private readonly _terminal;
    private readonly _emitError;
    private readonly _emitWarning;
    private _alreadyTriedToLoadConfig;
    private _config;
    constructor(options: ISolutionPackagerOptions);
    packageSolutionAsync(production: boolean, prettyPrintXml?: boolean, noSpppkg?: boolean): Promise<void>;
    getCleanPathsAsync(): Promise<string[]>;
    private _ensureConfigFileAsync;
    private _updateContentTypes;
    private _getFilesExtensions;
}
//# sourceMappingURL=SolutionPackager.d.ts.map