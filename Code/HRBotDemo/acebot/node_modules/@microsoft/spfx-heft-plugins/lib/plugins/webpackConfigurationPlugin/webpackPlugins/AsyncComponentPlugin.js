"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncComponentPlugin = exports.CHUNK_COMPONENT_MAP = void 0;
const webpack_1 = require("webpack");
// eslint-disable-next-line @typescript-eslint/typedef
const ExternalModule = require('webpack/lib/ExternalModule');
const PLUGIN_NAME = 'async-component';
const GET_ASYNC_COMPONENTS_FUNCTION_NAME = 'getAsyncSpfxComponents';
const SPFX_LOADER_VARIABLE_NAME = 'spfxLoader';
const SPFX_LOADER_COMPONENT_NAME = '@microsoft/sp-loader';
const COMPONENT_MODULE_ID_PROPERTY_NAME = 'm';
const COMPONENT_ID_PROPERTY_NAME = 'i';
const COMPONENT_VERSION_PROPERTY_NAME = 'v';
const CHUNK_COMPONENT_IDS = Symbol('chunkComponents');
const RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS = Symbol('runtimeChunkHasAsyncComponents');
exports.CHUNK_COMPONENT_MAP = Symbol('chunkComponentMap');
class AsyncComponentPlugin {
    constructor(options) {
        this._externalComponents = new Map();
        this._options = options;
        for (const externalComponent of this._options.externalComponents) {
            this._externalComponents.set(externalComponent.componentName, externalComponent);
        }
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            const componentModuleCache = new Map();
            let spfxLoaderModule;
            compilation.hooks.optimizeChunkModules.tap(PLUGIN_NAME, (baseChunks, baseModules) => {
                const chunks = baseChunks;
                const modules = baseModules;
                for (const chunk of chunks) {
                    chunk[CHUNK_COMPONENT_IDS] = new Set();
                }
                for (const module of modules) {
                    const externalComponent = module.external && module.request ? this._externalComponents.get(module.request) : undefined;
                    if (externalComponent) {
                        componentModuleCache.set(externalComponent.componentId, {
                            ...externalComponent,
                            module: module
                        });
                        if (externalComponent.componentName === SPFX_LOADER_COMPONENT_NAME) {
                            spfxLoaderModule = module;
                        }
                        for (const chunk of chunks) {
                            if (module.hasReasonForChunk(chunk)) {
                                // This module is actually used in this chunk
                                chunk[CHUNK_COMPONENT_IDS].add(externalComponent.componentId);
                            }
                            else {
                                // This module isn't used in this chunk - defensively remove it
                                module.removeChunk(chunk);
                                chunk.removeModule(module);
                            }
                        }
                    }
                }
                if (!spfxLoaderModule) {
                    spfxLoaderModule = new ExternalModule(SPFX_LOADER_COMPONENT_NAME, compiler.options.output.libraryTarget, SPFX_LOADER_COMPONENT_NAME);
                    spfxLoaderModule.build(undefined, undefined, undefined, undefined, () => {
                        /* callback */
                    });
                    compilation.modules.push(spfxLoaderModule);
                }
                for (const runtimeChunk of chunks) {
                    if (runtimeChunk.hasRuntime()) {
                        let runtimeChunkHasAsyncComponents = false;
                        const runtimeChunkComponentIds = runtimeChunk[CHUNK_COMPONENT_IDS];
                        for (const asyncChunk of runtimeChunk.getAllAsyncChunks()) {
                            for (const chunkComponentId of asyncChunk[CHUNK_COMPONENT_IDS]) {
                                if (!runtimeChunkComponentIds.has(chunkComponentId)) {
                                    // Is this a component that's used in the async chunk but not int the runtime chunk?
                                    runtimeChunkHasAsyncComponents = true;
                                    break;
                                }
                            }
                            if (runtimeChunkHasAsyncComponents) {
                                spfxLoaderModule.addChunk(runtimeChunk);
                                runtimeChunk.addModule(spfxLoaderModule);
                            }
                        }
                    }
                }
            });
            compilation.mainTemplate.hooks.requireEnsure.tap(PLUGIN_NAME, (existingRequireEnsure, baseChunk) => {
                const chunk = baseChunk;
                if (!chunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS]) {
                    return existingRequireEnsure;
                }
                const PROMISES_VAR_NAME = 'promises';
                const CHUNK_ID_VAR_NAME = 'chunkId';
                const MODULES_VAR_NAME = 'modules';
                const extraCode = [
                    '// SPFx Component async loading',
                    '',
                    `var chunkAsyncComponents = ${GET_ASYNC_COMPONENTS_FUNCTION_NAME}(${CHUNK_ID_VAR_NAME});`,
                    'for (var i = 0; i < chunkAsyncComponents.length; i++) {',
                    webpack_1.Template.indent([
                        '// Has the component already been loaded into the modules object?',
                        `if (!${MODULES_VAR_NAME}[chunkAsyncComponents[i].${COMPONENT_MODULE_ID_PROPERTY_NAME}]) {`,
                        webpack_1.Template.indent([
                            '(function (chunkComponent){',
                            webpack_1.Template.indent([
                                `${PROMISES_VAR_NAME}.push(${SPFX_LOADER_VARIABLE_NAME}.SPComponentLoader.loadComponentById(`,
                                webpack_1.Template.indent([
                                    `chunkComponent.${COMPONENT_ID_PROPERTY_NAME},`,
                                    `chunkComponent.${COMPONENT_VERSION_PROPERTY_NAME}`
                                ]),
                                ').then(function (component) {',
                                webpack_1.Template.indent([
                                    `${MODULES_VAR_NAME}[chunkComponent.${COMPONENT_MODULE_ID_PROPERTY_NAME}] = function(module) {`,
                                    webpack_1.Template.indent(['module.exports = component;']),
                                    `};`
                                ]),
                                '}));'
                            ]),
                            '})(chunkAsyncComponents[i]);'
                        ]),
                        '}'
                    ]),
                    '}'
                ];
                return webpack_1.Template.asString([existingRequireEnsure, ...extraCode]);
            });
            compilation.mainTemplate.hooks.localVars.tap(PLUGIN_NAME, (existing, baseRuntimeChunk) => {
                const runtimeChunk = baseRuntimeChunk;
                if (!runtimeChunk.hasRuntime()) {
                    return existing;
                }
                const runtimeChunkComponentIds = runtimeChunk[CHUNK_COMPONENT_IDS] || new Set();
                let chunkVariableCounter = 0;
                const componentVariables = new Map(); // Key is the component ID
                const chunkComponentMap = new Map();
                for (const asyncChunk of runtimeChunk.getAllAsyncChunks()) {
                    const chunkComponentIds = asyncChunk[CHUNK_COMPONENT_IDS];
                    if (chunkComponentIds) {
                        const filteredChunkComponents = [];
                        for (const chunkComponentId of chunkComponentIds) {
                            if (!runtimeChunkComponentIds.has(chunkComponentId)) {
                                const chunkComponent = componentModuleCache.get(chunkComponentId);
                                filteredChunkComponents.push(chunkComponent);
                                if (!componentVariables.has(chunkComponent.componentId)) {
                                    componentVariables.set(chunkComponent.componentId, {
                                        ...chunkComponent,
                                        variableName: `component_${chunkVariableCounter++}`
                                    });
                                }
                            }
                        }
                        if (filteredChunkComponents.length > 0) {
                            chunkComponentMap.set(asyncChunk, filteredChunkComponents);
                        }
                    }
                }
                runtimeChunk[exports.CHUNK_COMPONENT_MAP] = chunkComponentMap;
                if (chunkComponentMap.size === 0) {
                    runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS] = false;
                    return existing;
                }
                else {
                    runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS] = true;
                    const chunkComponentVariables = [];
                    for (const [{ id }, externalComponents] of chunkComponentMap.entries()) {
                        const componentIdVariablesArray = externalComponents
                            .map(({ componentId }) => componentVariables.get(componentId).variableName)
                            .join(', ');
                        chunkComponentVariables.push(`${JSON.stringify(id)}: [${componentIdVariablesArray}]`);
                    }
                    const extraCode = [
                        '',
                        '// Returns a list of SPFx components used in a given chunk but not used in the runtime chunk',
                        `function ${GET_ASYNC_COMPONENTS_FUNCTION_NAME}(chunkId) {`,
                        webpack_1.Template.indent([
                            ...Array.from(componentVariables.values()).map((component) => webpack_1.Template.asString([
                                `var ${component.variableName} = { // ${component.componentName}`,
                                webpack_1.Template.indent([
                                    `${COMPONENT_ID_PROPERTY_NAME}: ${JSON.stringify(component.componentId)},`,
                                    component.componentVersion
                                        ? // Omit this property if we don't have a version
                                            `${COMPONENT_VERSION_PROPERTY_NAME}: ${JSON.stringify(component.componentVersion)},`
                                        : '',
                                    `${COMPONENT_MODULE_ID_PROPERTY_NAME}: ${JSON.stringify(component.module.id)}`
                                ]),
                                '};'
                            ])),
                            '',
                            `return {${chunkComponentVariables.join(',')}}[chunkId] || [];`
                        ]),
                        '}'
                    ];
                    return webpack_1.Template.asString([existing, ...extraCode]);
                }
            });
            compilation.mainTemplate.hooks.requireExtensions.tap(PLUGIN_NAME, (existing, baseRuntimeChunk) => {
                const runtimeChunk = baseRuntimeChunk;
                if (!runtimeChunk.hasRuntime() || !runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS]) {
                    return existing;
                }
                let spfxLoaderModuleId = undefined;
                if (spfxLoaderModule) {
                    spfxLoaderModuleId = spfxLoaderModule.id || undefined;
                }
                else {
                    compilation.errors.push(new Error(`Missing ${SPFX_LOADER_COMPONENT_NAME} external.`));
                }
                const extraCode = [
                    '',
                    `var ${SPFX_LOADER_VARIABLE_NAME} = ${compilation.mainTemplate.requireFn}(${JSON.stringify(spfxLoaderModuleId)});`
                ];
                return webpack_1.Template.asString([existing, ...extraCode]);
            });
        });
    }
}
exports.AsyncComponentPlugin = AsyncComponentPlugin;
//# sourceMappingURL=AsyncComponentPlugin.js.map