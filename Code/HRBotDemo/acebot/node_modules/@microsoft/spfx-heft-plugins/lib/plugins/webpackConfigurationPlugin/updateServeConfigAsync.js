"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateServeConfigAsync = exports.TENANT_DOMAIN_PLACEHOLDER = void 0;
const path = __importStar(require("node:path"));
const express_1 = __importDefault(require("express"));
const ConfigureServe_1 = require("./ConfigureServe");
const ServeInfoPlugin_1 = require("./webpackPlugins/ServeInfoPlugin");
const CumulativeManifestProcessor_1 = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const constants_1 = require("../../utilities/constants");
exports.TENANT_DOMAIN_PLACEHOLDER = '{tenantdomain}';
async function updateServeConfigAsync(taskSession, heftConfiguration, additionalServePathsFromAccessor, webpackConfiguration) {
    const logger = taskSession.logger;
    const terminal = logger.terminal;
    const { buildFolderPath } = heftConfiguration;
    // Webpack Dev Server will only consider the first config if multiple are defined.
    if (Array.isArray(webpackConfiguration)) {
        webpackConfiguration = webpackConfiguration[0];
    }
    const serve = new ConfigureServe_1.ConfigureServe(heftConfiguration, terminal);
    const serveConfig = serve.generateServeConfig();
    // Project serve paths
    const projectServeMap = new Map();
    const { contentBasePublicPath = '/' } = serveConfig;
    if (serveConfig.contentBase) {
        if (Array.isArray(serveConfig.contentBase)) {
            for (const contentPath of serveConfig.contentBase) {
                projectServeMap.set(path.resolve(buildFolderPath, contentPath), contentBasePublicPath);
            }
        }
        else {
            projectServeMap.set(path.resolve(buildFolderPath, serveConfig.contentBase), contentBasePublicPath);
        }
    }
    else {
        projectServeMap.set(path.resolve(buildFolderPath), contentBasePublicPath);
    }
    // Additional serve paths
    const dependencyServeMap = _getDependencyServeMap(buildFolderPath, terminal);
    const serveMap = new Map([
        ...projectServeMap,
        ...dependencyServeMap,
        ...(additionalServePathsFromAccessor || [])
    ]);
    // eslint-disable-next-line @rushstack/security/no-unsafe-regexp
    const tenantDomainRegEx = new RegExp(exports.TENANT_DOMAIN_PLACEHOLDER, 'i');
    if ((serveConfig === null || serveConfig === void 0 ? void 0 : serveConfig.initialPage) &&
        tenantDomainRegEx.test(serveConfig.initialPage) &&
        process.env.SPFX_SERVE_TENANT_DOMAIN) {
        serveConfig.initialPage = serveConfig.initialPage.replace(tenantDomainRegEx, process.env.SPFX_SERVE_TENANT_DOMAIN);
    }
    // Webpack Dev Server config
    // eslint-disable-next-line require-atomic-updates
    webpackConfiguration.devServer = {
        static: false,
        devMiddleware: {
            publicPath: '/dist',
            stats: {
                assets: false,
                chunks: false,
                modules: false,
                warningsFilter: [/export .* was not found in/]
            },
            writeToDisk: true
        },
        host: '127.0.0.1',
        port: serveConfig.port,
        hot: true,
        historyApiFallback: false,
        compress: true,
        allowedHosts: 'all',
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'HEAD, GET, OPTIONS'
        },
        setupMiddlewares: (middlewares, server) => {
            const { app } = server;
            if (serveConfig.apiMap) {
                for (const [route, handler] of Object.entries(serveConfig.apiMap)) {
                    // Don't include universal route handlers.
                    if (route.startsWith('*')) {
                        continue;
                    }
                    app.get(route, handler);
                }
            }
            middlewares.unshift(serve.logRequestsMiddleware());
            for (const [contentPath, route] of serveMap) {
                middlewares.push({
                    name: 'express-static',
                    path: route,
                    middleware: express_1.default.static(contentPath, { index: false })
                });
            }
            return middlewares;
        },
        open: serveConfig.initialPage
    };
    // Webpack Dev Server plugins
    webpackConfiguration.plugins = [
        ...(webpackConfiguration.plugins ? webpackConfiguration.plugins : []),
        new ServeInfoPlugin_1.ServeInfoPlugin({
            terminal,
            port: serveConfig.port,
            tempFolderName: constants_1.DEFAULT_TEMP_FOLDER
        })
    ];
    return webpackConfiguration;
}
exports.updateServeConfigAsync = updateServeConfigAsync;
function _getDependencyServeMap(buildFolder, terminal) {
    const dependencyServeMap = new Map();
    const referencedProjects = _getReferencedProjects(buildFolder, terminal);
    for (const versionMap of Object.values(referencedProjects)) {
        for (const referencedProject of Object.values(versionMap)) {
            if (referencedProject.packageName && !referencedProject.isAssembly) {
                const projectOutputPath = path.dirname(referencedProject.manifestPath);
                if (referencedProject.manifestPath) {
                    dependencyServeMap.set(projectOutputPath, '/');
                }
                else {
                    terminal.writeWarning(referencedProject.packageName + ' not found.');
                }
            }
        }
    }
    return dependencyServeMap;
}
function _getReferencedProjects(buildFolder, terminal) {
    const cumulativeManifestProcessor = new CumulativeManifestProcessor_1.CumulativeManifestProcessor({
        explicitInclude: [constants_1.SP_LOADER_ASSEMBLY_ID],
        rootPath: buildFolder,
        tempFolderName: constants_1.DEFAULT_TEMP_FOLDER,
        distFolderName: constants_1.DEFAULT_OUTPUT_FOLDER,
        includeAssemblies: true,
        terminal
    });
    const referencedProjects = cumulativeManifestProcessor.discoverManifests(buildFolder, CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
    return referencedProjects;
}
//# sourceMappingURL=updateServeConfigAsync.js.map