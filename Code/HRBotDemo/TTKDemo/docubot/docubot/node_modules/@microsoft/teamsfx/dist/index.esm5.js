import jwt_decode from 'jwt-decode';
import { app, authentication } from '@microsoft/teams-js';
import { PublicClientApplication } from '@azure/msal-browser';
import { Client } from '@microsoft/microsoft-graph-client';
import axios from 'axios';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error code to trace the error types.
 */
var ErrorCode;
(function (ErrorCode) {
    /**
     * Invalid parameter error.
     */
    ErrorCode["InvalidParameter"] = "InvalidParameter";
    /**
     * Invalid configuration error.
     */
    ErrorCode["InvalidConfiguration"] = "InvalidConfiguration";
    /**
     * Invalid certificate error.
     */
    ErrorCode["InvalidCertificate"] = "InvalidCertificate";
    /**
     * Internal error.
     */
    ErrorCode["InternalError"] = "InternalError";
    /**
     * Channel is not supported error.
     */
    ErrorCode["ChannelNotSupported"] = "ChannelNotSupported";
    /**
     * Failed to retrieve sso token
     */
    ErrorCode["FailedToRetrieveSsoToken"] = "FailedToRetrieveSsoToken";
    /**
     * Failed to process sso handler
     */
    ErrorCode["FailedToProcessSsoHandler"] = "FailedToProcessSsoHandler";
    /**
     * Cannot find command
     */
    ErrorCode["CannotFindCommand"] = "CannotFindCommand";
    /**
     * Failed to run sso step
     */
    ErrorCode["FailedToRunSsoStep"] = "FailedToRunSsoStep";
    /**
     * Failed to run dedup step
     */
    ErrorCode["FailedToRunDedupStep"] = "FailedToRunDedupStep";
    /**
     * Sso activity handler is undefined
     */
    ErrorCode["SsoActivityHandlerIsUndefined"] = "SsoActivityHandlerIsUndefined";
    /**
     * Runtime is not supported error.
     */
    ErrorCode["RuntimeNotSupported"] = "RuntimeNotSupported";
    /**
     * User failed to finish the AAD consent flow failed.
     */
    ErrorCode["ConsentFailed"] = "ConsentFailed";
    /**
     * The user or administrator has not consented to use the application error.
     */
    ErrorCode["UiRequiredError"] = "UiRequiredError";
    /**
     * Token is not within its valid time range error.
     */
    ErrorCode["TokenExpiredError"] = "TokenExpiredError";
    /**
     * Call service (AAD or simple authentication server) failed.
     */
    ErrorCode["ServiceError"] = "ServiceError";
    /**
     * Operation failed.
     */
    ErrorCode["FailedOperation"] = "FailedOperation";
    /**
     * Invalid response error.
     */
    ErrorCode["InvalidResponse"] = "InvalidResponse";
    /**
     * Identity type error.
     */
    ErrorCode["IdentityTypeNotSupported"] = "IdentityTypeNotSupported";
    /**
     * Authentication info already exists error.
     */
    ErrorCode["AuthorizationInfoAlreadyExists"] = "AuthorizationInfoAlreadyExists";
})(ErrorCode || (ErrorCode = {}));
/**
 * @internal
 */
class ErrorMessage {
}
// InvalidConfiguration Error
ErrorMessage.InvalidConfiguration = "{0} in configuration is invalid: {1}.";
ErrorMessage.ConfigurationNotExists = "Configuration does not exist. {0}";
ErrorMessage.ResourceConfigurationNotExists = "{0} resource configuration does not exist.";
ErrorMessage.MissingResourceConfiguration = "Missing resource configuration with type: {0}, name: {1}.";
ErrorMessage.AuthenticationConfigurationNotExists = "Authentication configuration does not exist.";
// RuntimeNotSupported Error
ErrorMessage.BrowserRuntimeNotSupported = "{0} is not supported in browser.";
ErrorMessage.NodejsRuntimeNotSupported = "{0} is not supported in Node.";
// Internal Error
ErrorMessage.FailToAcquireTokenOnBehalfOfUser = "Failed to acquire access token on behalf of user: {0}";
// ChannelNotSupported Error
ErrorMessage.OnlyMSTeamsChannelSupported = "{0} is only supported in MS Teams Channel";
ErrorMessage.FailedToProcessSsoHandler = "Failed to process sso handler: {0}";
// FailedToRetrieveSsoToken Error
ErrorMessage.FailedToRetrieveSsoToken = "Failed to retrieve sso token, user failed to finish the AAD consent flow.";
// CannotFindCommand Error
ErrorMessage.CannotFindCommand = "Cannot find command: {0}";
ErrorMessage.FailedToRunSsoStep = "Failed to run dialog to retrieve sso token: {0}";
ErrorMessage.FailedToRunDedupStep = "Failed to run dialog to remove duplicated messages: {0}";
// SsoActivityHandlerIsUndefined Error
ErrorMessage.SsoActivityHandlerIsNull = "Sso command can only be used or added when sso activity handler is not undefined";
// IdentityTypeNotSupported Error
ErrorMessage.IdentityTypeNotSupported = "{0} identity is not supported in {1}";
// AuthorizationInfoError
ErrorMessage.AuthorizationHeaderAlreadyExists = "Authorization header already exists!";
ErrorMessage.BasicCredentialAlreadyExists = "Basic credential already exists!";
// InvalidParameter Error
ErrorMessage.EmptyParameter = "Parameter {0} is empty";
ErrorMessage.DuplicateHttpsOptionProperty = "Axios HTTPS agent already defined value for property {0}";
ErrorMessage.DuplicateApiKeyInHeader = "The request already defined api key in request header with name {0}.";
ErrorMessage.DuplicateApiKeyInQueryParam = "The request already defined api key in query parameter with name {0}.";
ErrorMessage.OnlySupportInQueryActivity = "The handleMessageExtensionQueryWithToken only support in handleTeamsMessagingExtensionQuery with composeExtension/query type.";
ErrorMessage.OnlySupportInLinkQueryActivity = "The handleMessageExtensionLinkQueryWithSSO only support in handleTeamsAppBasedLinkQuery with composeExtension/queryLink type.";
/**
 * Error class with code and message thrown by the SDK.
 */
class ErrorWithCode extends Error {
    /**
     * Constructor of ErrorWithCode.
     *
     * @param {string} message - error message.
     * @param {ErrorCode} code - error code.
     */
    constructor(message, code) {
        if (!code) {
            super(message);
            return this;
        }
        super(message);
        Object.setPrototypeOf(this, ErrorWithCode.prototype);
        this.name = `${new.target.name}.${code}`;
        this.code = code;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Log level.
 */
var LogLevel;
(function (LogLevel) {
    /**
     * Show verbose, information, warning and error message.
     */
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    /**
     * Show information, warning and error message.
     */
    LogLevel[LogLevel["Info"] = 1] = "Info";
    /**
     * Show warning and error message.
     */
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    /**
     * Show error message.
     */
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
/**
 * Update log level helper.
 *
 * @param { LogLevel } level - log level in configuration
 */
function setLogLevel(level) {
    internalLogger.level = level;
}
/**
 * Get log level.
 *
 * @returns Log level
 */
function getLogLevel() {
    return internalLogger.level;
}
class InternalLogger {
    constructor(name, logLevel) {
        this.level = undefined;
        this.defaultLogger = {
            verbose: console.debug,
            info: console.info,
            warn: console.warn,
            error: console.error,
        };
        this.name = name;
        this.level = logLevel;
    }
    error(message) {
        this.log(LogLevel.Error, (x) => x.error, message);
    }
    warn(message) {
        this.log(LogLevel.Warn, (x) => x.warn, message);
    }
    info(message) {
        this.log(LogLevel.Info, (x) => x.info, message);
    }
    verbose(message) {
        this.log(LogLevel.Verbose, (x) => x.verbose, message);
    }
    log(logLevel, logFunction, message) {
        if (message.trim() === "") {
            return;
        }
        const timestamp = new Date().toUTCString();
        let logHeader;
        if (this.name) {
            logHeader = `[${timestamp}] : @microsoft/teamsfx - ${this.name} : ${LogLevel[logLevel]} - `;
        }
        else {
            logHeader = `[${timestamp}] : @microsoft/teamsfx : ${LogLevel[logLevel]} - `;
        }
        const logMessage = `${logHeader}${message}`;
        if (this.level !== undefined && this.level <= logLevel) {
            if (this.customLogger) {
                logFunction(this.customLogger)(logMessage);
            }
            else if (this.customLogFunction) {
                this.customLogFunction(logLevel, logMessage);
            }
            else {
                logFunction(this.defaultLogger)(logMessage);
            }
        }
    }
}
/**
 * Logger instance used internally
 *
 * @internal
 */
const internalLogger = new InternalLogger();
/**
 * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
 *
 * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
 *
 * @example
 * ```typescript
 * setLogger({
 *   verbose: console.debug,
 *   info: console.info,
 *   warn: console.warn,
 *   error: console.error,
 * });
 * ```
 */
function setLogger(logger) {
    internalLogger.customLogger = logger;
}
/**
 * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
 *
 * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
 *
 * @example
 * ```typescript
 * setLogFunction((level: LogLevel, message: string) => {
 *   if (level === LogLevel.Error) {
 *     console.log(message);
 *   }
 * });
 * ```
 */
function setLogFunction(logFunction) {
    internalLogger.customLogFunction = logFunction;
}

// Copyright (c) Microsoft Corporation.
/**
 * Parse jwt token payload
 *
 * @param token
 *
 * @returns Payload object
 *
 * @internal
 */
function parseJwt(token) {
    try {
        const tokenObj = jwt_decode(token);
        if (!tokenObj || !tokenObj.exp) {
            throw new ErrorWithCode("Decoded token is null or exp claim does not exists.", ErrorCode.InternalError);
        }
        return tokenObj;
    }
    catch (err) {
        const errorMsg = "Parse jwt token failed in node env with error: " + err.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
    }
}
/**
 * @internal
 */
function getUserInfoFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        displayName: tokenObject.name,
        objectId: tokenObject.oid,
        tenantId: tokenObject.tid,
        preferredUserName: "",
    };
    if (tokenObject.ver === "2.0") {
        userInfo.preferredUserName = tokenObject.preferred_username;
    }
    else if (tokenObject.ver === "1.0") {
        userInfo.preferredUserName = tokenObject.upn;
    }
    return userInfo;
}
/**
 * @internal
 */
function getTenantIdAndLoginHintFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        tid: tokenObject.tid,
        loginHint: tokenObject.ver === "2.0"
            ? tokenObject.preferred_username
            : tokenObject.upn,
    };
    return userInfo;
}
/**
 * @internal
 */
function parseAccessTokenFromAuthCodeTokenResponse(tokenResponse) {
    try {
        const tokenResponseObject = typeof tokenResponse == "string"
            ? JSON.parse(tokenResponse)
            : tokenResponse;
        if (!tokenResponseObject || !tokenResponseObject.accessToken) {
            const errorMsg = "Get empty access token from Auth Code token response.";
            internalLogger.error(errorMsg);
            throw new Error(errorMsg);
        }
        const token = tokenResponseObject.accessToken;
        const tokenObject = parseJwt(token);
        if (tokenObject.ver !== "1.0" && tokenObject.ver !== "2.0") {
            const errorMsg = "SSO token is not valid with an unknown version: " + tokenObject.ver;
            internalLogger.error(errorMsg);
            throw new Error(errorMsg);
        }
        const accessToken = {
            token: token,
            expiresOnTimestamp: tokenObject.exp * 1000,
        };
        return accessToken;
    }
    catch (error) {
        const errorMsg = "Parse access token failed from Auth Code token response in node env with error: " +
            error.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
    }
}
/**
 * Format string template with replacements
 *
 * ```typescript
 * const template = "{0} and {1} are fruit. {0} is my favorite one."
 * const formattedStr = formatString(template, "apple", "pear"); // formattedStr: "apple and pear are fruit. apple is my favorite one."
 * ```
 *
 * @param str string template
 * @param replacements replacement string array
 * @returns Formatted string
 *
 * @internal
 */
function formatString(str, ...replacements) {
    const args = replacements;
    return str.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != "undefined" ? args[number] : match;
    });
}
/**
 * @internal
 */
function validateScopesType(value) {
    // string
    if (typeof value === "string" || value instanceof String) {
        return;
    }
    // empty array
    if (Array.isArray(value) && value.length === 0) {
        return;
    }
    // string array
    if (Array.isArray(value) && value.length > 0 && value.every((item) => typeof item === "string")) {
        return;
    }
    const errorMsg = "The type of scopes is not valid, it must be string or string array";
    internalLogger.error(errorMsg);
    throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved.
 *
 * @remarks
 * Only works in in server side.
 */
class AppCredential {
    constructor(authConfig) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "AppCredential"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get access token for credential.
     *
     * @remarks
     * Only works in in server side.
     */
    getToken(scopes, options) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "AppCredential"), ErrorCode.RuntimeNotSupported));
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent on-behalf-of flow to get user identity, and it is designed to be used in Azure Function or Bot scenarios.
 *
 * @remarks
 * Can only be used in server side.
 */
class OnBehalfOfUserCredential {
    constructor(ssoToken, config) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get access token from credential.
     * @remarks
     * Can only be used in server side.
     */
    getToken(scopes, options) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get basic user info from SSO token.
     * @remarks
     * Can only be used in server side.
     */
    getUserInfo() {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported));
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// Copyright (c) Microsoft Corporation.
const tokenRefreshTimeSpanInMillisecond = 5 * 60 * 1000;
const loginPageWidth = 600;
const loginPageHeight = 535;
/**
 * Represent Teams current user's identity, and it is used within Teams tab application.
 *
 * @remarks
 * Can only be used within Teams.
 */
class TeamsUserCredential {
    constructor(authConfig) {
        internalLogger.info("Create teams user credential");
        this.config = this.loadAndValidateConfig(authConfig);
        this.ssoToken = null;
        this.initialized = false;
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await credential.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await credential.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await credential.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await credential.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     * @param { string[] } resources - The optional list of resources for full trust Teams apps.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes, resources) {
        return __awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            internalLogger.info(`Popup login page to get user's access token with scopes: ${scopesStr}`);
            if (!this.initialized) {
                yield this.init(resources);
            }
            yield app.initialize();
            let result;
            try {
                const params = {
                    url: `${this.config.initiateLoginEndpoint ? this.config.initiateLoginEndpoint : ""}?clientId=${this.config.clientId ? this.config.clientId : ""}&scope=${encodeURI(scopesStr)}&loginHint=${this.loginHint ? this.loginHint : ""}`,
                    width: loginPageWidth,
                    height: loginPageHeight,
                };
                result = yield authentication.authenticate(params);
                if (!result) {
                    const errorMsg = "Get empty authentication result from MSAL";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
                }
            }
            catch (err) {
                const errorMsg = `Consent failed for the scope ${scopesStr} with error: ${err.message}`;
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, ErrorCode.ConsentFailed);
            }
            let resultJson = {};
            try {
                resultJson = typeof result == "string" ? JSON.parse(result) : result;
            }
            catch (error) {
                // If can not parse result as Json, will throw error.
                const failedToParseResult = "Failed to parse response to Json.";
                internalLogger.error(failedToParseResult);
                throw new ErrorWithCode(failedToParseResult, ErrorCode.InvalidResponse);
            }
            // If code exists in result, user may using previous auth-start and auth-end page.
            if (resultJson.code) {
                const helpLink = "https://aka.ms/teamsfx-auth-code-flow";
                const usingPreviousAuthPage = "Found auth code in response. Auth code is not support for current version of SDK. " +
                    `Please refer to the help link for how to fix the issue: ${helpLink}.`;
                internalLogger.error(usingPreviousAuthPage);
                throw new ErrorWithCode(usingPreviousAuthPage, ErrorCode.InvalidResponse);
            }
            // If sessionStorage exists in result, set the values in current session storage.
            if (resultJson.sessionStorage) {
                this.setSessionStorage(resultJson.sessionStorage);
            }
        });
    }
    /**
     * Get access token from credential.
     *
     * Important: Access tokens are stored in sessionStorage, read more here: https://aka.ms/teamsfx-session-storage-notice
     * Important: Full trust applications do not read the resource information from the webApplicationInfo section of the app
     * manifest. Instead, this resource (along with any additional resources from which to request tokens) must be provided
     * as a list of resources to the getToken() method through a GetTeamsUserTokenOptions object.
     *
     * @example
     * ```typescript
     * await credential.getToken([]) // Get SSO token using empty string array
     * await credential.getToken("") // Get SSO token using empty string
     * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
     * await credential.getToken(".default") // Get Graph access token with default scope using string
     * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     *
     * const options: GetTeamsUserTokenOptions = { resources: ["https://domain.example.com"] }; // set up resources for full trust apps.
     * await credential.getToken([], options) // Get sso token from teams client - only use this approach for full trust apps.
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns User access token of defined scopes.
     * If scopes is empty string or array, it returns SSO token.
     * If scopes is non-empty, it returns access token for target scope.
     * Throw error if get access token failed.
     */
    getToken(scopes, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const resources = (_a = options) === null || _a === void 0 ? void 0 : _a.resources;
            const ssoToken = yield this.getSSOToken(resources);
            const scopeStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopeStr === "") {
                internalLogger.info("Get SSO token");
                return ssoToken;
            }
            else {
                internalLogger.info("Get access token with scopes: " + scopeStr);
                if (!this.initialized) {
                    yield this.init(resources);
                }
                let tokenResponse;
                const scopesArray = typeof scopes === "string" ? scopes.split(" ") : scopes;
                const domain = window.location.origin;
                // First try to get Access Token from cache.
                try {
                    const account = this.msalInstance.getAccountByUsername(this.loginHint);
                    const scopesRequestForAcquireTokenSilent = {
                        scopes: scopesArray,
                        account: account !== null && account !== void 0 ? account : undefined,
                        redirectUri: `${domain}/blank-auth-end.html`,
                    };
                    tokenResponse = yield this.msalInstance.acquireTokenSilent(scopesRequestForAcquireTokenSilent);
                }
                catch (error) {
                    const acquireTokenSilentFailedMessage = `Failed to call acquireTokenSilent. Reason: ${error === null || error === void 0 ? void 0 : error.message}. `;
                    internalLogger.verbose(acquireTokenSilentFailedMessage);
                }
                if (!tokenResponse) {
                    // If fail to get Access Token from cache, try to get Access token by silent login.
                    try {
                        const scopesRequestForSsoSilent = {
                            scopes: scopesArray,
                            loginHint: this.loginHint,
                            redirectUri: `${domain}/blank-auth-end.html`,
                        };
                        tokenResponse = yield this.msalInstance.ssoSilent(scopesRequestForSsoSilent);
                    }
                    catch (error) {
                        const ssoSilentFailedMessage = `Failed to call ssoSilent. Reason: ${error === null || error === void 0 ? void 0 : error.message}. `;
                        internalLogger.verbose(ssoSilentFailedMessage);
                    }
                }
                if (!tokenResponse) {
                    const errorMsg = `Failed to get access token cache silently, please login first: you need login first before get access token.`;
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, ErrorCode.UiRequiredError);
                }
                const accessToken = parseAccessTokenFromAuthCodeTokenResponse(tokenResponse);
                return accessToken;
            }
        });
    }
    /**
     * Get basic user info from SSO token
     *
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     *
     * @example
     * ```typescript
     * const currentUser = await credential.getUserInfo();
     * ```
     *
     * @throws {@link ErrorCode|InternalError} when SSO token from Teams client is not valid.
     * @throws {@link ErrorCode|InvalidParameter} when SSO token from Teams client is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Basic user info with user displayName, objectId and preferredUserName.
     */
    getUserInfo(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Get basic user info from SSO token");
            const ssoToken = yield this.getSSOToken(resources);
            return getUserInfoFromSsoToken(ssoToken.token);
        });
    }
    init(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            const ssoToken = yield this.getSSOToken(resources);
            const info = getTenantIdAndLoginHintFromSsoToken(ssoToken.token);
            this.loginHint = info.loginHint;
            this.tid = info.tid;
            const msalConfig = {
                auth: {
                    clientId: this.config.clientId,
                    authority: `https://login.microsoftonline.com/${this.tid}`,
                },
                cache: {
                    cacheLocation: "sessionStorage",
                },
            };
            this.msalInstance = new PublicClientApplication(msalConfig);
            this.initialized = true;
        });
    }
    /**
     * Get SSO token using teams SDK
     * It will try to get SSO token from memory first, if SSO token doesn't exist or about to expired, then it will using teams SDK to get SSO token
     *
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     *
     * @returns SSO token
     */
    getSSOToken(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ssoToken) {
                if (this.ssoToken.expiresOnTimestamp - Date.now() > tokenRefreshTimeSpanInMillisecond) {
                    internalLogger.verbose("Get SSO token from memory cache");
                    return this.ssoToken;
                }
            }
            const params = { resources: resources !== null && resources !== void 0 ? resources : [] };
            let token;
            try {
                yield app.initialize();
            }
            catch (err) {
                const errorMsg = "Initialize teams sdk failed due to not running inside Teams environment";
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
            }
            try {
                token = yield authentication.getAuthToken(params);
            }
            catch (err) {
                const errorMsg = "Get SSO token failed with error: " + err.message;
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
            }
            if (!token) {
                const errorMsg = "Get empty SSO token from Teams";
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
            }
            const tokenObject = parseJwt(token);
            if (tokenObject.ver !== "1.0" && tokenObject.ver !== "2.0") {
                const errorMsg = "SSO token is not valid with an unknown version: " + tokenObject.ver;
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
            }
            const ssoToken = {
                token,
                expiresOnTimestamp: tokenObject.exp * 1000,
            };
            this.ssoToken = ssoToken;
            return ssoToken;
        });
    }
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration?} config - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    loadAndValidateConfig(config) {
        internalLogger.verbose("Validate authentication configuration");
        if (config.initiateLoginEndpoint && config.clientId) {
            return config;
        }
        const missingValues = [];
        if (!config.initiateLoginEndpoint) {
            missingValues.push("initiateLoginEndpoint");
        }
        if (!config.clientId) {
            missingValues.push("clientId");
        }
        const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingValues.join(", "), "undefined");
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidConfiguration);
    }
    setSessionStorage(sessionStorageValues) {
        try {
            const sessionStorageKeys = Object.keys(sessionStorageValues);
            sessionStorageKeys.forEach((key) => {
                sessionStorage.setItem(key, sessionStorageValues[key]);
            });
        }
        catch (error) {
            // Values in result.sessionStorage can not be set into session storage.
            // Throw error since this may block user.
            const errorMessage = `Failed to set values in session storage. Error: ${error.message}`;
            internalLogger.error(errorMessage);
            throw new ErrorWithCode(errorMessage, ErrorCode.InternalError);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const defaultScope = "https://graph.microsoft.com/.default";
// eslint-disable-next-line no-secrets/no-secrets
/**
 * Microsoft Graph auth provider for Teams Framework
 * @deprecated Use `TokenCredentialAuthenticationProvider` from `@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials` instead.
 */
class MsGraphAuthProvider {
    constructor(credentialOrTeamsFx, scopes) {
        this.credentialOrTeamsFx = credentialOrTeamsFx;
        let scopesStr = defaultScope;
        if (scopes) {
            validateScopesType(scopes);
            scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopesStr === "") {
                scopesStr = defaultScope;
            }
        }
        internalLogger.info(`Create Microsoft Graph Authentication Provider with scopes: '${scopesStr}'`);
        this.scopes = scopesStr;
    }
    /**
     * Get access token for Microsoft Graph API requests.
     *
     * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns Access token from the credential.
     *
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info(`Get Graph Access token with scopes: '${this.scopes.toString()}'`);
            let accessToken;
            if (this.credentialOrTeamsFx.getCredential) {
                accessToken = yield this.credentialOrTeamsFx
                    .getCredential()
                    .getToken(this.scopes);
            }
            else {
                accessToken = yield this.credentialOrTeamsFx.getToken(this.scopes);
            }
            return new Promise((resolve, reject) => {
                if (accessToken) {
                    resolve(accessToken.token);
                }
                else {
                    const errorMsg = "Graph access token is undefined or empty";
                    internalLogger.error(errorMsg);
                    reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                }
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Get Microsoft graph client.
 * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
 * ```typescript
 * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
 * const graph = Client.initWithMiddleware({
 *   authProvider: authProvider,
 * });
 * ```
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // Sso token example (Azure Function)
 * const ssoToken = "YOUR_TOKEN_STRING";
 * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
 * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
 * const graphClient = await createMicrosoftGraphClient(credential);
 * const profile = await graphClient.api("/me").get();
 *
 * // TeamsBotSsoPrompt example (Bot Application)
 * const requiredScopes = ["User.Read"];
 * const config: Configuration = {
 *    loginUrl: loginUrl,
 *    clientId: clientId,
 *    clientSecret: clientSecret,
 *    tenantId: tenantId
 * };
 * const prompt = new TeamsBotSsoPrompt(dialogId, {
 *    config: config
 *    scopes: ["User.Read"],
 * });
 * this.addDialog(prompt);
 *
 * const oboCredential = new OnBehalfOfAADUserCredential(
 *  getUserId(dialogContext),
 *  {
 *    clientId: "AAD_APP_ID",
 *    clientSecret: "AAD_APP_SECRET"
 *  });
 * try {
 *    const graphClient = await createMicrosoftGraphClient(credential);
 *    const profile = await graphClient.api("/me").get();
 * } catch (e) {
 *    dialogContext.beginDialog(dialogId);
 *    return Dialog.endOfTurn();
 * }
 * ```
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClient(teamsfx, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(teamsfx, scopes);
    const graphClient = Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}
// eslint-disable-next-line no-secrets/no-secrets
/**
 * Get Microsoft graph client.
 * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
 * ```typescript
 * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
 * const graph = Client.initWithMiddleware({
 *   authProvider: authProvider,
 * });
 * ```
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // In browser: TeamsUserCredential
 * const authConfig: TeamsUserCredentialAuthConfig = {
 *   clientId: "xxx",
    initiateLoginEndpoint: "https://xxx/auth-start.html",
 * };

 * const credential = new TeamsUserCredential(authConfig);

 * const scope = "User.Read";
 * await credential.login(scope);

 * const client = createMicrosoftGraphClientWithCredential(credential, scope);

 * // In node: OnBehalfOfUserCredential
 * const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
 *   authorityHost: "xxx",
 *   clientId: "xxx",
 *   tenantId: "xxx",
 *   clientSecret: "xxx",
 * };

 * const oboCredential = new OnBehalfOfUserCredential(ssoToken, oboAuthConfig);
 * const scope = "User.Read";
 * const client = createMicrosoftGraphClientWithCredential(oboCredential, scope);

 * // In node: AppCredential
 * const appAuthConfig: AppCredentialAuthConfig = {
 *   authorityHost: "xxx",
 *   clientId: "xxx",
 *   tenantId: "xxx",
 *   clientSecret: "xxx",
 * };
 * const appCredential = new AppCredential(appAuthConfig);
 * const scope = "User.Read";
 * const client = createMicrosoftGraphClientWithCredential(appCredential, scope);
 *
 * const profile = await client.api("/me").get();
 * ```
 *
 * @param {TokenCredential} credential - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClientWithCredential(credential, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(credential, scopes);
    const graphClient = Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * Generate connection configuration consumed by tedious.
 *
 * @deprecated we recommend you compose your own Tedious configuration for better flexibility.
 *
 * @remarks
 * Only works in in server side.
 */
function getTediousConnectionConfig(teamsfx, databaseName) {
    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "DefaultTediousConnectionConfiguration"), ErrorCode.RuntimeNotSupported));
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
 * help receive oauth token, asks the user to consent if needed.
 *
 * @remarks
 * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
 * the token store.
 *
 * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
 * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
 *
 * @example
 * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
 * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
 * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
 * needed and their access token will be passed as an argument to the callers next waterfall step:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage } = require('botbuilder');
 * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
 * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 *
 * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
 *    scopes: ["User.Read"],
 * }));
 *
 * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
 *      async (step) => {
 *          return await step.beginDialog('TeamsBotSsoPrompt');
 *      },
 *      async (step) => {
 *          const token = step.result;
 *          if (token) {
 *
 *              // ... continue with task needing access token ...
 *
 *          } else {
 *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
 *              return await step.endDialog();
 *          }
 *      }
 * ]));
 * ```
 */
class TeamsBotSsoPrompt {
    /**
     * Constructor of TeamsBotSsoPrompt.
     *
     * @param dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
     * @param settings Settings used to configure the prompt.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(teamsfx, dialogId, settings) {
        this.teamsfx = teamsfx;
        this.settings = settings;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
     * @remarks
     * If the task is successful, the result indicates whether the prompt is still
     * active after the turn has been processed by the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Called when a prompt dialog is the active dialog and the user replied with a new activity.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     * The prompt generally continues to receive the user's replies until it accepts the
     * user's reply as valid input for the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @returns A `Promise` representing the asynchronous operation.
     *
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    continueDialog(dc) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported));
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Initializes new Axios instance with specific auth provider
 *
 * @param apiEndpoint - Base url of the API
 * @param authProvider - Auth provider that injects authentication info to each request
 * @returns axios instance configured with specfic auth provider
 *
 * @example
 * ```typescript
 * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
 * ```
 */
function createApiClient(apiEndpoint, authProvider) {
    // Add a request interceptor
    const instance = axios.create({
        baseURL: apiEndpoint,
    });
    instance.interceptors.request.use(function (config) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield authProvider.AddAuthenticationInfo(config));
        });
    });
    return instance;
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Bearer Token authentication
 */
class BearerTokenAuthProvider {
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken) {
        this.getToken = getToken;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getToken();
            if (!config.headers) {
                config.headers = {};
            }
            if (config.headers["Authorization"]) {
                throw new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, ErrorCode.AuthorizationInfoAlreadyExists);
            }
            config.headers["Authorization"] = `Bearer ${token}`;
            return config;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Basic authentication
 */
class BasicAuthProvider {
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName, password) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BasicAuthProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BasicAuthProvider"), ErrorCode.RuntimeNotSupported));
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles API Key authentication
 */
class ApiKeyProvider {
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName, keyValue, keyLocation) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ApiKeyProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ApiKeyProvider"), ErrorCode.RuntimeNotSupported));
    }
}
/**
 * Define available location for API Key location
 */
var ApiKeyLocation;
(function (ApiKeyLocation) {
    /**
     * The API Key is placed in request header
     */
    ApiKeyLocation[ApiKeyLocation["Header"] = 0] = "Header";
    /**
     * The API Key is placed in query parameter
     */
    ApiKeyLocation[ApiKeyLocation["QueryParams"] = 1] = "QueryParams";
})(ApiKeyLocation || (ApiKeyLocation = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Certificate authentication
 */
class CertificateAuthProvider {
    /**
     *
     * @param { SecureContextOptions } certOption - information about the cert used in http requests
     */
    constructor(certOption) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CertificateAuthProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests.
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CertificateAuthProvider"), ErrorCode.RuntimeNotSupported));
    }
}
/**
 * Helper to create SecureContextOptions from PEM format cert
 *
 * @param { string | Buffer } cert - The cert chain in PEM format
 * @param { string | Buffer } key - The private key for the cert chain
 * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 *
 */
function createPemCertOption(cert, key, options) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "createPemCertOption"), ErrorCode.RuntimeNotSupported);
}
/**
 * Helper to create SecureContextOptions from PFX format cert
 *
 * @param { string | Buffer } pfx - The content of .pfx file
 * @param { {passphrase?: string} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 *
 */
function createPfxCertOption(pfx, options) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "createPfxCertOption"), ErrorCode.RuntimeNotSupported);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Identity type to use in authentication.
 */
var IdentityType;
(function (IdentityType) {
    /**
     * Represents the current user of Teams.
     */
    IdentityType["User"] = "User";
    /**
     * Represents the application itself.
     */
    IdentityType["App"] = "Application";
})(IdentityType || (IdentityType = {}));

// Copyright (c) Microsoft Corporation.
/**
 * A class providing credential and configuration.
 * @deprecated Please use {@link TeamsUserCredential}
 * in browser environment and {@link OnBehalfOfUserCredential} or {@link AppCredential} in NodeJS.
 */
class TeamsFx {
    constructor(identityType, customConfig) {
        this.identityType = identityType !== null && identityType !== void 0 ? identityType : IdentityType.User;
        if (this.identityType !== IdentityType.User) {
            const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, this.identityType.toString(), "TeamsFx");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, ErrorCode.IdentityTypeNotSupported);
        }
        this.configuration = new Map();
        this.loadFromEnv();
        if (customConfig) {
            const myConfig = Object.assign({}, customConfig);
            for (const key of Object.keys(myConfig)) {
                const value = myConfig[key];
                if (value) {
                    this.configuration.set(key, value);
                }
            }
        }
        if (this.configuration.size === 0) {
            internalLogger.warn("No configuration is loaded, please pass required configs to TeamsFx constructor");
        }
    }
    loadFromEnv() {
        if (window && window.__env__) {
            // testing purpose
            const env = window.__env__;
            this.configuration.set("authorityHost", env.REACT_APP_AUTHORITY_HOST);
            this.configuration.set("tenantId", env.REACT_APP_TENANT_ID);
            this.configuration.set("clientId", env.REACT_APP_CLIENT_ID);
            this.configuration.set("initiateLoginEndpoint", env.REACT_APP_START_LOGIN_PAGE_URL);
            this.configuration.set("applicationIdUri", env.M365_APPLICATION_ID_URI);
            this.configuration.set("apiEndpoint", env.REACT_APP_FUNC_ENDPOINT);
            this.configuration.set("apiName", env.REACT_APP_FUNC_NAME);
        }
        else {
            // TODO: support common environment variable name
            try {
                this.configuration.set("authorityHost", process.env.REACT_APP_AUTHORITY_HOST);
                this.configuration.set("tenantId", process.env.REACT_APP_TENANT_ID);
                this.configuration.set("clientId", process.env.REACT_APP_CLIENT_ID);
                this.configuration.set("initiateLoginEndpoint", process.env.REACT_APP_START_LOGIN_PAGE_URL);
                this.configuration.set("applicationIdUri", process.env.M365_APPLICATION_ID_URI);
                this.configuration.set("apiEndpoint", process.env.REACT_APP_FUNC_ENDPOINT);
                this.configuration.set("apiName", process.env.REACT_APP_FUNC_NAME);
            }
            catch (_) {
                internalLogger.warn("Cannot read process.env, please use webpack if you want to use environment variables.");
                return;
            }
        }
    }
    getIdentityType() {
        return this.identityType;
    }
    getCredential() {
        if (!this.teamsUserCredential) {
            this.teamsUserCredential = new TeamsUserCredential(Object.fromEntries(this.configuration));
        }
        return this.teamsUserCredential;
    }
    getUserInfo(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getCredential().getUserInfo(resources);
        });
    }
    login(scopes, resources) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getCredential().login(scopes, resources);
        });
    }
    setSsoToken(ssoToken) {
        return this;
    }
    getConfig(key) {
        const value = this.configuration.get(key);
        if (!value) {
            throw new Error();
        }
        return value;
    }
    hasConfig(key) {
        const value = this.configuration.get(key);
        return !!value;
    }
    getConfigs() {
        const config = {};
        for (const key of this.configuration.keys()) {
            const value = this.configuration.get(key);
            if (value) {
                config[key] = value;
            }
        }
        return config;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The target type where the notification will be sent to.
 *
 * @remarks
 * - "Channel" means to a team channel. (By default, notification to a team will be sent to its "General" channel.)
 * - "Group" means to a group chat.
 * - "Person" means to a personal chat.
 */
var NotificationTargetType;
(function (NotificationTargetType) {
    /**
     * The notification will be sent to a team channel.
     * (By default, notification to a team will be sent to its "General" channel.)
     */
    NotificationTargetType["Channel"] = "Channel";
    /**
     * The notification will be sent to a group chat.
     */
    NotificationTargetType["Group"] = "Group";
    /**
     * The notification will be sent to a personal chat.
     */
    NotificationTargetType["Person"] = "Person";
})(NotificationTargetType || (NotificationTargetType = {}));
/**
 * Options used to control how the response card will be sent to users.
 */
var AdaptiveCardResponse;
(function (AdaptiveCardResponse) {
    /**
     * The response card will be replaced the current one for the interactor who trigger the action.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["ReplaceForInteractor"] = 0] = "ReplaceForInteractor";
    /**
     * The response card will be replaced the current one for all users in the chat.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["ReplaceForAll"] = 1] = "ReplaceForAll";
    /**
     * The response card will be sent as a new message for all users in the chat.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["NewForAll"] = 2] = "NewForAll";
})(AdaptiveCardResponse || (AdaptiveCardResponse = {}));
/**
 * Status code for an `application/vnd.microsoft.error` invoke response.
 */
var InvokeResponseErrorCode;
(function (InvokeResponseErrorCode) {
    /**
     * Invalid request.
     */
    InvokeResponseErrorCode[InvokeResponseErrorCode["BadRequest"] = 400] = "BadRequest";
    /**
     * Internal server error.
     */
    InvokeResponseErrorCode[InvokeResponseErrorCode["InternalServerError"] = 500] = "InternalServerError";
})(InvokeResponseErrorCode || (InvokeResponseErrorCode = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @remarks
 * Only work on server side.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.ConversationBot` instead.
 */
class ConversationBot$1 {
    /**
     * Creates new instance of the `ConversationBot`.
     *
     * @param options - initialize options
     *
     * @remarks
     * Only work on server side.
     */
    constructor(options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - an Express or Restify style request object.
     * @param res - an Express or Restify style response object.
     * @param logic - the additional function to handle bot context.
     *
     * @remarks
     * Only work on server side.
     */
    requestHandler(req, res, logic) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported);
    }
}

// Copyright (c) Microsoft Corporation.
/*
 * Sso execution dialog, use to handle sso command
 */
class BotSsoExecutionDialog {
    constructor(dedupStorage, ssoPromptSettings, authConfig, ...args) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BotSsoExecutionDialog"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Add TeamsFxBotSsoCommandHandler instance
     * @param handler {@link BotSsoExecutionDialogHandler} callback function
     * @param triggerPatterns The trigger pattern
     */
    addCommand(handler, triggerPatterns) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BotSsoExecutionDialog"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * The run method handles the incoming activity (in the form of a DialogContext) and passes it through the dialog system.
     *
     * @param context The context object for the current turn.
     * @param accessor The instance of StatePropertyAccessor for dialog system.
     */
    run(context, accessor) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BotSsoExecutionDialog"), ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Called when the component is ending.
     *
     * @param context Context for the current turn of conversation.
     */
    onEndDialog(context) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BotSsoExecutionDialog"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - the notification target.
 * @param text - the plain text message.
 * @param onError - an optional error handler that can catch exceptions during message sending.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendMessage$1(target, text, onError) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendMessage"), ErrorCode.RuntimeNotSupported);
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - the notification target.
 * @param card - the adaptive card raw JSON.
 * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendAdaptiveCard$1(target, card, onError) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendAdaptiveCard"), ErrorCode.RuntimeNotSupported);
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel$1 {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = NotificationTargetType.Channel;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member$1 {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = NotificationTargetType.Person;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.TeamsBotInstallation` instead.
 */
class TeamsBotInstallation$1 {
    /**
     * Constructor
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - the bound `BotFrameworkAdapter`.
     * @param conversationReference - the bound `ConversationReference`.
     */
    constructor(adapter, conversationReference) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get channels from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get members from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns an array of members from where the bot is installed.
     */
    members() {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get team details from this bot installation
     *
     * @returns the team details if bot is installed into a team, otherwise returns undefined.
     */
    getTeamDetails() {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
}
/**
 * Provide static utilities for bot notification.
 *
 * @remarks
 * Only work on server side.
 *
 * @example
 * Here's an example on how to send notification via Teams Bot.
 * ```typescript
 * // initialize (it's recommended to be called before handling any bot message)
 * const notificationBot = new NotificationBot(adapter);
 *
 * // get all bot installations and send message
 * for (const target of await notificationBot.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await notificationBot.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.NotificationBot` instead.
 */
class NotificationBot$1 {
    /**
     * constructor of the notification bot.
     *
     * @remarks
     * Only work on server side.
     *
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - the bound `BotFrameworkAdapter`
     * @param options - initialize options
     */
    constructor(adapter, options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * Only work on server side.
     *
     * The result is retrieving from the persisted storage.
     *
     * @returns - an array of {@link TeamsBotInstallation}.
     */
    static installations() {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Returns the first {@link Member} where predicate is true, and undefined otherwise.
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate find calls predicate once for each member of the installation,
     * until it finds one where predicate returns true. If such a member is found, find
     * immediately returns that member. Otherwise, find returns undefined.
     * @param scope the scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     * @returns the first {@link Member} where predicate is true, and undefined otherwise.
     */
    findMember(predicate, scope) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Returns the first {@link Channel} where predicate is true, and undefined otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate find calls predicate once for each channel of the installation,
     * until it finds one where predicate returns true. If such a channel is found, find
     * immediately returns that channel. Otherwise, find returns undefined.
     * @returns the first {@link Channel} where predicate is true, and undefined otherwise.
     */
    findChannel(predicate) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Returns all {@link Member} where predicate is true, and empty array otherwise.
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate find calls predicate for each member of the installation.
     * @param scope the scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     * @returns an array of {@link Member} where predicate is true, and empty array otherwise.
     */
    findAllMembers(predicate, scope) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Returns all {@link Channel} where predicate is true, and empty array otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate find calls predicate for each channel of the installation.
     * @returns an array of {@link Channel} where predicate is true, and empty array otherwise.
     */
    findAllChannels(predicate) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
}
/**
 * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
 * The search scope is a flagged enum and it can be combined with `|`.
 * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
 */
var SearchScope$1;
(function (SearchScope) {
    /**
     * Search members from the installations in personal chat only.
     */
    SearchScope[SearchScope["Person"] = 1] = "Person";
    /**
     * Search members from the installations in group chat only.
     */
    SearchScope[SearchScope["Group"] = 2] = "Group";
    /**
     * Search members from the installations in Teams channel only.
     */
    SearchScope[SearchScope["Channel"] = 4] = "Channel";
    /**
     * Search members from all installations including personal chat, group chat and Teams channel.
     */
    SearchScope[SearchScope["All"] = 7] = "All";
})(SearchScope$1 || (SearchScope$1 = {}));

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Only work on server side.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.CommandBot` instead.
 */
class CommandBot$1 {
    /**
     * Creates a new instance of the `CommandBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param commands The commands to registered with the command bot. Each command should implement the interface {@link TeamsFxBotCommandHandler} so that it can be correctly handled by this command bot.
     */
    constructor(adapter, commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers a command into the command bot.
     *
     * @param command The command to registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommand(command) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The command to registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommands(commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers a sso command into the command bot.
     *
     * @param command The command to register.
     */
    registerSsoCommand(ssoCommand) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The commands to register.
     */
    registerSsoCommands(ssoCommands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
}

/**
 * A card action bot to respond to adaptive card universal actions.
 *
 * @remarks
 * Only work on server side.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.CardActionBot` instead.
 */
class CardActionBot$1 {
    /**
     * Creates a new instance of the `CardActionBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param options - initialize options
     */
    constructor(adapter, options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers a card action handler to the bot.
     * @param actionHandler A card action handler to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerHandler(actionHandler) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers card action handlers to the bot.
     * @param actionHandlers A set of card action handlers to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerHandlers(actionHandlers) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported);
    }
}

// eslint-disable-next-line no-secrets/no-secrets
/**
 * Users execute query with SSO or Access Token.
 * @deprecated
 * @remarks
 * Only works in in server side.
 */
function handleMessageExtensionQueryWithToken(context, config, scopes, logic) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "queryWithToken in message extension"), ErrorCode.RuntimeNotSupported);
}
/**
 * Users execute query with SSO or Access Token.
 * @remarks
 * Only works in in server side.
 */
function handleMessageExtensionQueryWithSSO(context, config, initiateLoginEndpoint, scopes, logic) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "queryWithToken in message extension"), ErrorCode.RuntimeNotSupported);
}

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @remarks
 * Only work on server side.
 */
class ConversationBot {
    /**
     * Create new instance of the `ConversationBot`.
     *
     * @param options - The initialize options.
     *
     * @remarks
     * Only work on server side.
     */
    constructor(options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - An incoming HTTP [Request](xref:botbuilder.Request).
     * @param res - The corresponding HTTP [Response](xref:botbuilder.Response).
     * @param logic - The additional function to handle bot context.
     *
     * @remarks
     * Only work on server side.
     */
    requestHandler(req, res, logic) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported));
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - The notification target.
 * @param text - The plain text message.
 * @param onError - An optional error handler that can catch exceptions during message sending.
 *
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendMessage(target, text, onError) {
    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendMessage"), ErrorCode.RuntimeNotSupported));
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - The notification target.
 * @param card - The adaptive card raw JSON.
 * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
 *
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendAdaptiveCard(target, card, onError) {
    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendAdaptiveCard"), ErrorCode.RuntimeNotSupported));
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = NotificationTargetType.Channel;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported));
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = NotificationTargetType.Person;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return Promise.reject(Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported)));
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
class TeamsBotInstallation {
    /**
     * Constructor
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param conversationReference - The bound `ConversationReference`.
     */
    constructor(adapter, conversationReference) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get channels from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns An array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get members from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns An array of members from where the bot is installed.
     */
    members() {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get team details from this bot installation
     *
     * @returns The team details if bot is installed into a team, otherwise returns undefined.
     */
    getTeamDetails() {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported));
    }
}
/**
 * Provide static utilities for bot notification.
 *
 * @remarks
 * Only work on server side.
 *
 * @example
 * Here's an example on how to send notification via Teams Bot.
 * ```typescript
 * // initialize (it's recommended to be called before handling any bot message)
 * const notificationBot = new NotificationBot(adapter);
 *
 * // get all bot installations and send message
 * for (const target of await notificationBot.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await notificationBot.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 */
class NotificationBot {
    /**
     * Constructor of the notification bot.
     *
     * @remarks
     * Only work on server side.
     *
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - The bound `CloudAdapter`
     * @param options - The initialize options
     */
    constructor(adapter, options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * Only work on server side.
     *
     * The result is retrieving from the persisted storage.
     *
     * @returns An array of {@link TeamsBotInstallation}.
     */
    static installations() {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Return the first {@link Member} where predicate is true, and undefined otherwise.
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate find calls predicate once for each member of the installation,
     * until it finds one where predicate returns true. If such a member is found,
     * find immediately returns that member. Otherwise, find returns undefined.
     * @param scope the scope to find members from the installations (personal chat, group chat, Teams channel).
     *
     * @returns The first {@link Member} where predicate is true, and undefined otherwise.
     */
    findMember(predicate, scope) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Return the first {@link Channel} where predicate is true, and undefined otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate - Find calls predicate once for each channel of the installation,
     * until it finds one where predicate returns true. If such a channel is found, find
     * immediately returns that channel. Otherwise, find returns undefined.
     *
     * @returns The first {@link Channel} where predicate is true, and `undefined` otherwise.
     */
    findChannel(predicate) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Return all {@link Member} where predicate is true, and empty array otherwise.
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate - Find calls predicate for each member of the installation.
     * @param scope - The scope to find members from the installations.
     * (personal chat, group chat, Teams channel).
     *
     * @returns An array of {@link Member} where predicate is true, and empty array otherwise.
     */
    findAllMembers(predicate, scope) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Return all {@link Channel} where predicate is true, and empty array otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
     *
     * @remarks
     * Only work on server side.
     *
     * @param predicate - Find calls predicate for each channel of the installation.
     *
     * @returns An array of {@link Channel} where predicate is true, and empty array otherwise.
     */
    findAllChannels(predicate) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported));
    }
}
/**
 * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
 * The search scope is a flagged enum and it can be combined with `|`.
 * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
 */
var SearchScope;
(function (SearchScope) {
    /**
     * Search members from the installations in personal chat only.
     */
    SearchScope[SearchScope["Person"] = 1] = "Person";
    /**
     * Search members from the installations in group chat only.
     */
    SearchScope[SearchScope["Group"] = 2] = "Group";
    /**
     * Search members from the installations in Teams channel only.
     */
    SearchScope[SearchScope["Channel"] = 4] = "Channel";
    /**
     * Search members from all installations including personal chat, group chat and Teams channel.
     */
    SearchScope[SearchScope["All"] = 7] = "All";
})(SearchScope || (SearchScope = {}));

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Only work on server side.
 */
class CommandBot {
    /**
     * Create a new instance of the `CommandBot`.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param commands - The commands to be registered with the command bot. Each command should implement the interface {@link TeamsFxBotCommandHandler} so that it can be correctly handled by this command bot.
     */
    constructor(adapter, commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Register a command into the command bot.
     *
     * @param command - The command to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommand(command) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Register commands into the command bot.
     *
     * @param commands - The commands to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommands(commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Register a sso command into the command bot.
     *
     * @param ssoCommand - The sso command to be registered.
     */
    registerSsoCommand(ssoCommand) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Register sso commands into the command bot.
     *
     * @param ssoCommands - The sso commands to be registered.
     */
    registerSsoCommands(ssoCommands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
}

/**
 * A card action bot to respond to adaptive card universal actions.
 *
 * @remarks
 * Only work on server side.
 */
class CardActionBot {
    /**
     * Create a new instance of the `CardActionBot`.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param options - The initialize options.
     */
    constructor(adapter, options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Register a card action handler to the bot.
     *
     * @param actionHandler - A card action handler to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerHandler(actionHandler) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported));
    }
    /**
     * Register card action handlers to the bot.
     *
     * @param actionHandlers - A set of card action handlers to be registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerHandlers(actionHandlers) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CardActionBot"), ErrorCode.RuntimeNotSupported));
    }
}

var conversationWithCloudAdapter_browser = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ConversationBot: ConversationBot,
  BotSsoExecutionDialog: BotSsoExecutionDialog,
  Channel: Channel,
  Member: Member,
  NotificationBot: NotificationBot,
  sendAdaptiveCard: sendAdaptiveCard,
  sendMessage: sendMessage,
  TeamsBotInstallation: TeamsBotInstallation,
  CommandBot: CommandBot,
  CardActionBot: CardActionBot
});

export { AdaptiveCardResponse, ApiKeyLocation, ApiKeyProvider, AppCredential, BasicAuthProvider, BearerTokenAuthProvider, conversationWithCloudAdapter_browser as BotBuilderCloudAdapter, BotSsoExecutionDialog, CardActionBot$1 as CardActionBot, CertificateAuthProvider, Channel$1 as Channel, CommandBot$1 as CommandBot, ConversationBot$1 as ConversationBot, ErrorCode, ErrorWithCode, IdentityType, InvokeResponseErrorCode, LogLevel, Member$1 as Member, MsGraphAuthProvider, NotificationBot$1 as NotificationBot, NotificationTargetType, OnBehalfOfUserCredential, TeamsBotInstallation$1 as TeamsBotInstallation, TeamsBotSsoPrompt, TeamsFx, TeamsUserCredential, createApiClient, createMicrosoftGraphClient, createMicrosoftGraphClientWithCredential, createPemCertOption, createPfxCertOption, getLogLevel, getTediousConnectionConfig, handleMessageExtensionQueryWithSSO, handleMessageExtensionQueryWithToken, sendAdaptiveCard$1 as sendAdaptiveCard, sendMessage$1 as sendMessage, setLogFunction, setLogLevel, setLogger };
//# sourceMappingURL=index.esm5.js.map
