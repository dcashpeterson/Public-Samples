import * as Enums from "./enums";
import { CarouselEvent } from "./carousel";
import { PaddingDefinition, SizeAndUnit, ISeparationDefinition, Dictionary, StringWithSubstitutions, IInput, IResourceInformation } from "./shared";
import { HostConfig, BaseTextDefinition, FontTypeDefinition, ColorSetDefinition, TextColorDefinition, ContainerStyleDefinition, TextStyleDefinition } from "./host-config";
import { CardObject, ValidationResults } from "./card-object";
import { Version, BaseSerializationContext, SerializableObject, SerializableObjectSchema, StringProperty, BoolProperty, ValueSetProperty, EnumProperty, SerializableObjectCollectionProperty, SerializableObjectProperty, PixelSizeProperty, NumProperty, PropertyBag, CustomProperty, PropertyDefinition, StringArrayProperty } from "./serialization";
import { CardObjectRegistry } from "./registry";
export declare function renderSeparation(hostConfig: HostConfig, separationDefinition: ISeparationDefinition, orientation: Enums.Orientation): HTMLElement | undefined;
export declare type CardElementHeight = "auto" | "stretch";
export declare abstract class CardElement extends CardObject {
    static readonly langProperty: StringProperty;
    static readonly isVisibleProperty: BoolProperty;
    static readonly separatorProperty: BoolProperty;
    static readonly heightProperty: ValueSetProperty;
    static readonly horizontalAlignmentProperty: EnumProperty<typeof Enums.HorizontalAlignment>;
    static readonly spacingProperty: EnumProperty<typeof Enums.Spacing>;
    horizontalAlignment?: Enums.HorizontalAlignment;
    spacing: Enums.Spacing;
    separator: boolean;
    height: CardElementHeight;
    get lang(): string | undefined;
    set lang(value: string | undefined);
    get isVisible(): boolean;
    set isVisible(value: boolean);
    private _hostConfig?;
    private _separatorElement?;
    private _truncatedDueToOverflow;
    private _defaultRenderedElementDisplayMode?;
    private _padding?;
    private internalRenderSeparator;
    private updateRenderedElementVisibility;
    private hideElementDueToOverflow;
    private showElementHiddenDueToOverflow;
    private handleOverflow;
    private resetOverflow;
    protected getDefaultSerializationContext(): BaseSerializationContext;
    protected createPlaceholderElement(): HTMLElement;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected updateInputsVisualState(hover: boolean): void;
    protected isDisplayed(): boolean;
    protected abstract internalRender(): HTMLElement | undefined;
    protected overrideInternalRender(): HTMLElement | undefined;
    protected applyPadding(): void;
    protected truncateOverflow(_maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected getDefaultPadding(): PaddingDefinition;
    protected getHasBackground(ignoreBackgroundImages?: boolean): boolean;
    protected getHasBorder(): boolean;
    protected getPadding(): PaddingDefinition | undefined;
    protected setPadding(value: PaddingDefinition | undefined): void;
    protected shouldSerialize(context: SerializationContext): boolean;
    protected get useDefaultSizing(): boolean;
    protected get separatorOrientation(): Enums.Orientation;
    protected get defaultStyle(): string;
    customCssSelector?: string;
    parse(source: any, context?: SerializationContext): void;
    asString(): string | undefined;
    isBleeding(): boolean;
    getEffectiveStyle(): string;
    getEffectiveStyleDefinition(): ContainerStyleDefinition;
    getEffectiveTextStyleDefinition(): TextStyleDefinition;
    getForbiddenActionTypes(): ActionType[];
    getImmediateSurroundingPadding(result: PaddingDefinition, processTop?: boolean, processRight?: boolean, processBottom?: boolean, processLeft?: boolean): void;
    getActionCount(): number;
    getActionAt(index: number): Action | undefined;
    indexOfAction(action: Action): number;
    remove(): boolean;
    render(): HTMLElement | undefined;
    updateLayout(_processChildren?: boolean): void;
    updateActionsEnabledState(): void;
    indexOf(_cardElement: CardElement): number;
    isDesignMode(): boolean;
    isFirstElement(_element: CardElement): boolean;
    isLastElement(_element: CardElement): boolean;
    isAtTheVeryLeft(): boolean;
    isAtTheVeryRight(): boolean;
    isAtTheVeryTop(): boolean;
    isAtTheVeryBottom(): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    isLeftMostElement(_element: CardElement): boolean;
    isRightMostElement(_element: CardElement): boolean;
    isTopElement(element: CardElement): boolean;
    isBottomElement(element: CardElement): boolean;
    isHiddenDueToOverflow(): boolean;
    getRootElement(): CardElement;
    getParentContainer(): Container | undefined;
    getAllInputs(processActions?: boolean): Input[];
    getAllActions(): Action[];
    getResourceInformation(): IResourceInformation[];
    getElementById(id: string): CardElement | undefined;
    getActionById(_id: string): Action | undefined;
    getElementByIdFromAction(id: string): CardElement | undefined;
    getEffectivePadding(): PaddingDefinition;
    getEffectiveHorizontalAlignment(): Enums.HorizontalAlignment;
    get hostConfig(): HostConfig;
    set hostConfig(value: HostConfig);
    get index(): number;
    get isInteractive(): boolean;
    get isStandalone(): boolean;
    get isInline(): boolean;
    get hasVisibleSeparator(): boolean;
    get separatorElement(): HTMLElement | undefined;
    get parent(): CardElement | undefined;
}
export declare class ActionProperty extends PropertyDefinition {
    readonly targetVersion: Version;
    readonly name: string;
    readonly forbiddenActionTypes: string[];
    parse(sender: SerializableObject, source: PropertyBag, context: SerializationContext): Action | undefined;
    toJSON(sender: SerializableObject, target: PropertyBag, value: Action | undefined, context: SerializationContext): void;
    constructor(targetVersion: Version, name: string, forbiddenActionTypes?: string[]);
}
export declare abstract class BaseTextBlock extends CardElement {
    static readonly textProperty: StringProperty;
    static readonly sizeProperty: EnumProperty<typeof Enums.TextSize>;
    static readonly weightProperty: EnumProperty<typeof Enums.TextWeight>;
    static readonly colorProperty: EnumProperty<typeof Enums.TextColor>;
    static readonly isSubtleProperty: BoolProperty;
    static readonly fontTypeProperty: EnumProperty<typeof Enums.FontType>;
    static readonly selectActionProperty: ActionProperty;
    protected populateSchema(schema: SerializableObjectSchema): void;
    size?: Enums.TextSize;
    weight?: Enums.TextWeight;
    color?: Enums.TextColor;
    fontType?: Enums.FontType;
    isSubtle?: boolean;
    get text(): string | undefined;
    set text(value: string | undefined);
    selectAction?: Action;
    protected getFontSize(fontType: FontTypeDefinition): number;
    protected getColorDefinition(colorSet: ColorSetDefinition, color: Enums.TextColor): TextColorDefinition;
    protected setText(value: string | undefined): void;
    ariaHidden: boolean;
    constructor(text?: string);
    init(textDefinition: BaseTextDefinition): void;
    asString(): string | undefined;
    applyStylesTo(targetElement: HTMLElement): void;
    getAllActions(): Action[];
    get effectiveColor(): Enums.TextColor;
    get effectiveFontType(): Enums.FontType;
    get effectiveIsSubtle(): boolean;
    get effectiveSize(): Enums.TextSize;
    get effectiveWeight(): Enums.TextWeight;
}
export declare type TextBlockStyle = "default" | "heading" | "columnHeader";
export declare class TextBlock extends BaseTextBlock {
    static readonly wrapProperty: BoolProperty;
    static readonly maxLinesProperty: NumProperty;
    static readonly styleProperty: ValueSetProperty;
    wrap: boolean;
    maxLines?: number;
    style?: TextBlockStyle;
    private _computedLineHeight;
    private _originalInnerHtml;
    private _processedText?;
    private _treatAsPlainText;
    private restoreOriginalContent;
    private truncateIfSupported;
    private static readonly _ttMarkdownPolicy;
    private static readonly _ttRoundtripPolicy;
    protected setText(value: string): void;
    protected internalRender(): HTMLElement | undefined;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    useMarkdown: boolean;
    forElementId?: string;
    applyStylesTo(targetElement: HTMLElement): void;
    getJsonTypeName(): string;
    getEffectiveTextStyleDefinition(): TextStyleDefinition;
    updateLayout(processChildren?: boolean): void;
}
export declare class TextRun extends BaseTextBlock {
    static readonly italicProperty: BoolProperty;
    static readonly strikethroughProperty: BoolProperty;
    static readonly highlightProperty: BoolProperty;
    static readonly underlineProperty: BoolProperty;
    protected populateSchema(schema: SerializableObjectSchema): void;
    italic: boolean;
    strikethrough: boolean;
    highlight: boolean;
    underline: boolean;
    protected internalRender(): HTMLElement | undefined;
    applyStylesTo(targetElement: HTMLElement): void;
    getJsonTypeName(): string;
    get isStandalone(): boolean;
    get isInline(): boolean;
}
export declare class RichTextBlock extends CardElement {
    private _inlines;
    private internalAddInline;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected internalRender(): HTMLElement | undefined;
    forElementId?: string;
    asString(): string | undefined;
    getJsonTypeName(): string;
    getInlineCount(): number;
    getInlineAt(index: number): CardElement;
    addInline(inline: CardElement | string): void;
    removeInline(inline: CardElement): boolean;
}
export declare class Fact extends SerializableObject {
    static readonly titleProperty: StringProperty;
    static readonly valueProperty: StringProperty;
    name?: string;
    value?: string;
    protected getSchemaKey(): string;
    constructor(name?: string, value?: string);
}
export declare class FactSet extends CardElement {
    static readonly factsProperty: SerializableObjectCollectionProperty;
    facts: Fact[];
    protected get useDefaultSizing(): boolean;
    protected internalRender(): HTMLElement | undefined;
    getJsonTypeName(): string;
}
declare class ImageDimensionProperty extends PropertyDefinition {
    readonly targetVersion: Version;
    readonly name: string;
    readonly internalName: string;
    readonly fallbackProperty?: ValueSetProperty | undefined;
    getInternalName(): string;
    parse(sender: SerializableObject, source: PropertyBag, context: BaseSerializationContext): number | undefined;
    toJSON(sender: SerializableObject, target: PropertyBag, value: number | undefined, context: BaseSerializationContext): void;
    constructor(targetVersion: Version, name: string, internalName: string, fallbackProperty?: ValueSetProperty | undefined);
}
export declare class Image extends CardElement {
    static readonly urlProperty: StringProperty;
    static readonly altTextProperty: StringProperty;
    static readonly backgroundColorProperty: StringProperty;
    static readonly styleProperty: EnumProperty<typeof Enums.ImageStyle>;
    static readonly sizeProperty: EnumProperty<typeof Enums.Size>;
    static readonly pixelWidthProperty: ImageDimensionProperty;
    static readonly pixelHeightProperty: ImageDimensionProperty;
    static readonly selectActionProperty: ActionProperty;
    static readonly shouldForceLoadProperty: BoolProperty;
    protected populateSchema(schema: SerializableObjectSchema): void;
    renderedImageElement?: HTMLElement;
    url?: string;
    altText?: string;
    backgroundColor?: string;
    size: Enums.Size;
    style: Enums.ImageStyle;
    pixelWidth?: number;
    pixelHeight?: number;
    selectAction?: Action;
    forceLoad: boolean;
    private applySize;
    protected get useDefaultSizing(): boolean;
    protected internalRender(): HTMLElement | undefined;
    maxHeight?: number;
    getJsonTypeName(): string;
    getAllActions(): Action[];
    getActionById(id: string): Action | undefined;
    getResourceInformation(): IResourceInformation[];
    private setImageSource;
}
export declare abstract class CardElementContainer extends CardElement {
    static readonly selectActionProperty: ActionProperty;
    protected populateSchema(schema: SerializableObjectSchema): void;
    protected _selectAction?: Action;
    protected isElementAllowed(element: CardElement): boolean;
    protected applyPadding(): void;
    protected get isSelectable(): boolean;
    protected forbiddenChildElements(): string[];
    abstract getItemCount(): number;
    abstract getItemAt(index: number): CardElement;
    abstract getFirstVisibleRenderedItem(): CardElement | undefined;
    abstract getLastVisibleRenderedItem(): CardElement | undefined;
    abstract removeItem(item: CardElement): boolean;
    allowVerticalOverflow: boolean;
    releaseDOMResources(): void;
    internalValidateProperties(context: ValidationResults): void;
    render(): HTMLElement | undefined;
    updateLayout(processChildren?: boolean): void;
    getAllInputs(processActions?: boolean): Input[];
    getAllActions(): Action[];
    getResourceInformation(): IResourceInformation[];
    getElementById(id: string): CardElement | undefined;
    /**
     * @inheritdoc
     */
    findDOMNodeOwner(node: Node): CardObject | undefined;
}
export declare class ImageSet extends CardElementContainer {
    static readonly imagesProperty: SerializableObjectCollectionProperty;
    static readonly imageSizeProperty: EnumProperty<typeof Enums.ImageSize>;
    static readonly imagePresentationStyle: EnumProperty<typeof Enums.ImageSetPresentationStyle>;
    static readonly pixelOffset: NumProperty;
    private _images;
    imageSize: Enums.ImageSize;
    presentationStyle: Enums.ImageSetPresentationStyle;
    pixelOffset: number;
    protected internalRender(): HTMLElement | undefined;
    applyStackedPresentationStyle(): void;
    getEffectiveBackgroundColor(): string | undefined;
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getFirstVisibleRenderedItem(): CardElement | undefined;
    getLastVisibleRenderedItem(): CardElement | undefined;
    removeItem(item: CardElement): boolean;
    getJsonTypeName(): string;
    addImage(image: Image): void;
    indexOf(cardElement: CardElement): number;
}
export declare abstract class ContentSource extends SerializableObject {
    static readonly mimeTypeProperty: StringProperty;
    static readonly urlProperty: StringProperty;
    mimeType?: string;
    url?: string;
    constructor(url?: string, mimeType?: string);
    isValid(): boolean;
}
export declare class CaptionSource extends ContentSource {
    static readonly labelProperty: StringProperty;
    label?: string;
    constructor(url?: string, mimeType?: string, label?: string);
    protected getSchemaKey(): string;
    render(): HTMLElement | undefined;
}
export declare class MediaSource extends ContentSource {
    protected getSchemaKey(): string;
    render(): HTMLElement | undefined;
}
export declare abstract class MediaPlayer {
    private _posterUrl?;
    abstract canPlay(): boolean;
    abstract render(): HTMLElement;
    abstract fetchVideoDetails(): Promise<void>;
    play(): void;
    get posterUrl(): string | undefined;
    protected set posterUrl(value: string | undefined);
    get selectedMediaType(): string | undefined;
}
export declare class HTML5MediaPlayer extends MediaPlayer {
    readonly owner: Media;
    private _selectedMediaType?;
    private _selectedSources;
    private _captionSources;
    private _mediaElement?;
    private processSources;
    static readonly supportedMediaTypes: string[];
    constructor(owner: Media);
    canPlay(): boolean;
    fetchVideoDetails(): Promise<void>;
    render(): HTMLElement;
    play(): void;
    get selectedMediaType(): string | undefined;
}
export declare abstract class CustomMediaPlayer extends MediaPlayer {
    constructor(matches: RegExpExecArray);
}
export declare abstract class IFrameMediaMediaPlayer extends CustomMediaPlayer {
    readonly iFrameTitle?: string | undefined;
    private _videoId?;
    constructor(matches: RegExpExecArray, iFrameTitle?: string | undefined);
    abstract getEmbedVideoUrl(): string;
    canPlay(): boolean;
    render(): HTMLElement;
    get videoId(): string | undefined;
}
export declare class VimeoPlayer extends IFrameMediaMediaPlayer {
    fetchVideoDetails(): Promise<void>;
    getEmbedVideoUrl(): string;
}
export declare class DailymotionPlayer extends IFrameMediaMediaPlayer {
    fetchVideoDetails(): Promise<void>;
    getEmbedVideoUrl(): string;
}
export declare class YouTubePlayer extends IFrameMediaMediaPlayer {
    readonly iFrameTitle?: string | undefined;
    private _startTimeIndex?;
    constructor(matches: RegExpExecArray, iFrameTitle?: string | undefined);
    fetchVideoDetails(): Promise<void>;
    getEmbedVideoUrl(): string;
}
export interface ICustomMediaPlayer {
    urlPatterns: RegExp[];
    createMediaPlayer: (matches: RegExpExecArray) => CustomMediaPlayer;
}
export declare class Media extends CardElement {
    static customMediaPlayers: ICustomMediaPlayer[];
    static readonly sourcesProperty: SerializableObjectCollectionProperty;
    static readonly captionSourcesProperty: SerializableObjectCollectionProperty;
    static readonly posterProperty: StringProperty;
    static readonly altTextProperty: StringProperty;
    sources: MediaSource[];
    captionSources: CaptionSource[];
    poster?: string;
    altText?: string;
    private _mediaPlayer;
    private createMediaPlayer;
    private handlePlayButtonInvoke;
    private displayPoster;
    protected internalRender(): HTMLElement | undefined;
    static onPlay?: (sender: Media) => void;
    render(): HTMLElement | undefined;
    releaseDOMResources(): void;
    getJsonTypeName(): string;
    getResourceInformation(): IResourceInformation[];
    get selectedMediaType(): string | undefined;
}
declare enum InputEventType {
    InitialRender = 0,
    MouseEnterOnCard = 1,
    MouseLeaveOnCard = 2,
    FocusLeave = 3
}
export declare abstract class Input extends CardElement implements IInput {
    static readonly labelProperty: StringProperty;
    static readonly isRequiredProperty: BoolProperty;
    static readonly errorMessageProperty: StringProperty;
    static readonly inputStyleProperty: EnumProperty<typeof Enums.InputStyle>;
    static readonly labelWidthProperty: CustomProperty<SizeAndUnit | undefined>;
    static readonly labelPositionProperty: EnumProperty<typeof Enums.InputLabelPosition>;
    label?: string;
    isRequired: boolean;
    errorMessage?: string;
    inputStyle: Enums.InputStyle;
    labelWidth?: SizeAndUnit;
    labelPosition?: Enums.InputLabelPosition;
    private _outerContainerElement;
    private _inputControlContainerElement;
    private _renderedErrorMessageElement?;
    private _renderedLabelElement?;
    private _renderedInputControlElement?;
    private _oldValue;
    protected getAllLabelIds(): string[];
    protected updateInputControlAriaLabelledBy(): void;
    protected get isNullable(): boolean;
    protected get renderedInputControlElement(): HTMLElement | undefined;
    protected get inputControlContainerElement(): HTMLElement;
    protected overrideInternalRender(): HTMLElement | undefined;
    protected valueChanged(): void;
    protected resetValidationFailureCue(): void;
    protected showValidationErrorMessage(): void;
    updateVisualState(eventType: InputEventType): void;
    onValueChanged: (sender: Input) => void;
    labelledBy?: string;
    abstract isSet(): boolean;
    focus(): void;
    isValid(): boolean;
    isDirty(): boolean;
    resetDirtyState(): void;
    internalValidateProperties(context: ValidationResults): void;
    validateValue(): boolean;
    getAllInputs(processActions?: boolean): Input[];
    render(): HTMLElement | undefined;
    abstract get value(): any;
    get isInteractive(): boolean;
}
export declare class TextInput extends Input {
    static readonly valueProperty: StringProperty;
    static readonly maxLengthProperty: NumProperty;
    static readonly isMultilineProperty: BoolProperty;
    static readonly placeholderProperty: StringProperty;
    static readonly styleProperty: EnumProperty<typeof Enums.InputTextStyle>;
    static readonly inlineActionProperty: ActionProperty;
    static readonly regexProperty: StringProperty;
    defaultValue?: string;
    maxLength?: number;
    isMultiline: boolean;
    placeholder?: string;
    style: Enums.InputTextStyle;
    inlineAction?: Action;
    regex?: string;
    private setupInput;
    protected internalRender(): HTMLElement | undefined;
    protected overrideInternalRender(): HTMLElement | undefined;
    updateVisualState(eventType: InputEventType): void;
    getJsonTypeName(): string;
    getAllActions(): Action[];
    getActionById(id: string): Action | undefined;
    isSet(): boolean;
    isValid(): boolean;
    get value(): string | undefined;
}
export declare class ToggleInput extends Input {
    static readonly valueProperty: StringProperty;
    static readonly titleProperty: StringProperty;
    static readonly valueOnProperty: StringProperty;
    static readonly valueOffProperty: StringProperty;
    static readonly wrapProperty: BoolProperty;
    defaultValue?: string;
    title?: string;
    valueOn: string;
    valueOff: string;
    wrap: boolean;
    private _checkboxInputElement;
    private _checkboxInputLabelElement;
    private _oldCheckboxValue;
    protected updateInputControlAriaLabelledBy(): void;
    protected internalRender(): HTMLElement | undefined;
    protected get isNullable(): boolean;
    updateVisualState(eventType: InputEventType): void;
    getJsonTypeName(): string;
    focus(): void;
    isSet(): boolean;
    isDirty(): boolean;
    get value(): string | undefined;
}
export declare class Choice extends SerializableObject {
    static readonly titleProperty: StringProperty;
    static readonly valueProperty: StringProperty;
    title?: string;
    value?: string;
    protected getSchemaKey(): string;
    constructor(title?: string, value?: string);
}
export declare class ChoiceSetInput extends Input {
    static readonly valueProperty: StringProperty;
    static readonly choicesProperty: SerializableObjectCollectionProperty;
    static readonly styleProperty: ValueSetProperty;
    static readonly isMultiSelectProperty: BoolProperty;
    static readonly placeholderProperty: StringProperty;
    static readonly wrapProperty: BoolProperty;
    defaultValue?: string;
    style?: "compact" | "expanded" | "filtered";
    get isCompact(): boolean;
    set isCompact(value: boolean);
    isMultiSelect: boolean;
    placeholder?: string;
    wrap: boolean;
    choices: Choice[];
    private static _uniqueCategoryCounter;
    private static getUniqueCategoryName;
    private _uniqueCategoryName;
    private _selectElement;
    private _textInput;
    private _toggleInputs;
    private _labels;
    private createPlaceholderOptionWhenValueDoesNotExist;
    private internalApplyAriaCurrent;
    private renderCompoundInput;
    protected updateInputControlAriaLabelledBy(): void;
    protected internalRender(): HTMLElement | undefined;
    updateVisualState(eventType: InputEventType): void;
    getJsonTypeName(): string;
    focus(): void;
    internalValidateProperties(context: ValidationResults): void;
    isSet(): boolean;
    isValid(): boolean;
    get value(): string | undefined;
}
export declare class NumberInput extends Input {
    static readonly valueProperty: NumProperty;
    static readonly placeholderProperty: StringProperty;
    static readonly minProperty: NumProperty;
    static readonly maxProperty: NumProperty;
    defaultValue?: number;
    min?: number;
    max?: number;
    placeholder?: string;
    private _numberInputElement;
    protected internalRender(): HTMLElement | undefined;
    getJsonTypeName(): string;
    isSet(): boolean;
    isValid(): boolean;
    get value(): number | undefined;
    set value(value: number | undefined);
}
export declare class DateInput extends Input {
    static readonly valueProperty: StringProperty;
    static readonly placeholderProperty: StringProperty;
    static readonly minProperty: StringProperty;
    static readonly maxProperty: StringProperty;
    defaultValue?: string;
    min?: string;
    max?: string;
    placeholder?: string;
    private _dateInputElement;
    protected internalRender(): HTMLElement | undefined;
    updateVisualState(eventType: InputEventType): void;
    getJsonTypeName(): string;
    isSet(): boolean;
    isValid(): boolean;
    get value(): string | undefined;
}
export declare class TimeProperty extends CustomProperty<string | undefined> {
    readonly targetVersion: Version;
    readonly name: string;
    constructor(targetVersion: Version, name: string);
}
export declare class TimeInput extends Input {
    private static convertTimeStringToDate;
    static readonly valueProperty: TimeProperty;
    static readonly placeholderProperty: StringProperty;
    static readonly minProperty: TimeProperty;
    static readonly maxProperty: TimeProperty;
    defaultValue?: string;
    min?: string;
    max?: string;
    placeholder?: string;
    private _timeInputElement;
    protected internalRender(): HTMLElement | undefined;
    updateVisualState(eventType: InputEventType): void;
    getJsonTypeName(): string;
    isSet(): boolean;
    isValid(): boolean;
    get value(): string | undefined;
}
export declare const enum ActionButtonState {
    Normal = 0,
    Expanded = 1,
    Subdued = 2
}
export declare type ActionType = {
    new (): Action;
};
export declare abstract class Action extends CardObject {
    static readonly titleProperty: StringProperty;
    static readonly iconUrlProperty: StringProperty;
    static readonly styleProperty: ValueSetProperty;
    static readonly modeProperty: ValueSetProperty;
    static readonly tooltipProperty: StringProperty;
    static readonly isEnabledProperty: BoolProperty;
    title?: string;
    iconUrl?: string;
    style: string;
    mode: string;
    tooltip?: string;
    isEnabled: boolean;
    private renderButtonContent;
    private getParentContainer;
    private _state;
    private _actionCollection?;
    private _isFocusable;
    isDesignMode(): boolean;
    protected updateCssClasses(): void;
    protected getDefaultSerializationContext(): BaseSerializationContext;
    protected internalGetReferencedInputs(): Dictionary<Input>;
    protected internalPrepareForExecution(_inputs: Dictionary<Input> | undefined): void;
    protected internalValidateInputs(referencedInputs: Dictionary<Input> | undefined): Input[];
    protected shouldSerialize(context: SerializationContext): boolean;
    protected raiseExecuteActionEvent(): void;
    protected internalAfterExecute(): void;
    onExecute: (sender: Action) => void;
    getHref(): string | undefined;
    getAriaRole(): string;
    setupElementForAccessibility(element: HTMLElement, promoteTooltipToLabel?: boolean): void;
    parse(source: any, context?: SerializationContext): void;
    render(): void;
    execute(): void;
    prepareForExecution(): boolean;
    remove(): boolean;
    getAllInputs(processActions?: boolean): Input[];
    getAllActions(): Action[];
    getResourceInformation(): IResourceInformation[];
    getActionById(id: string): Action | undefined;
    getReferencedInputs(): Dictionary<Input> | undefined;
    /**
     * Validates the inputs associated with this action.
     *
     * @returns A list of inputs that failed validation, or an empty array if no input failed validation.
     */
    validateInputs(): Input[];
    updateEnabledState(): void;
    isEffectivelyEnabled(): boolean;
    get isPrimary(): boolean;
    set isPrimary(value: boolean);
    get hostConfig(): HostConfig;
    get parent(): CardElement | undefined;
    get state(): ActionButtonState;
    set state(value: ActionButtonState);
    get isFocusable(): boolean;
    set isFocusable(value: boolean);
}
export declare abstract class SubmitActionBase extends Action {
    static readonly dataProperty: PropertyDefinition;
    static readonly associatedInputsProperty: CustomProperty<string | undefined>;
    static readonly disabledUnlessAssociatedInputsChangeProperty: BoolProperty;
    private _originalData?;
    associatedInputs?: "auto" | "none";
    disabledUnlessAssociatedInputsChange: boolean;
    private _isPrepared;
    private _processedData?;
    private _areReferencedInputsDirty;
    protected internalGetReferencedInputs(): Dictionary<Input>;
    protected internalPrepareForExecution(inputs: Dictionary<Input> | undefined): void;
    protected internalAfterExecute(): void;
    resetReferencedInputsDirtyState(): void;
    updateEnabledState(): void;
    isEffectivelyEnabled(): boolean;
    get data(): object | undefined;
    set data(value: object | undefined);
}
export declare class SubmitAction extends SubmitActionBase {
    static readonly JsonTypeName: "Action.Submit";
    getJsonTypeName(): string;
}
export declare class ExecuteAction extends SubmitActionBase {
    static readonly JsonTypeName: "Action.Execute";
    static readonly verbProperty: StringProperty;
    verb: string;
    getJsonTypeName(): string;
}
export declare class OpenUrlAction extends Action {
    static readonly urlProperty: StringProperty;
    url?: string;
    static readonly JsonTypeName: "Action.OpenUrl";
    getJsonTypeName(): string;
    getAriaRole(): string;
    internalValidateProperties(context: ValidationResults): void;
    getHref(): string | undefined;
}
export declare class ToggleVisibilityAction extends Action {
    static readonly targetElementsProperty: CustomProperty<PropertyBag>;
    targetElements: {
        [key: string]: any;
    };
    static readonly JsonTypeName: "Action.ToggleVisibility";
    private updateAriaControlsAttribute;
    internalValidateProperties(context: ValidationResults): void;
    getJsonTypeName(): string;
    render(): void;
    execute(): void;
    addTargetElement(elementId: string, isVisible?: boolean | undefined): void;
    removeTargetElement(elementId: string): void;
}
declare class StringWithSubstitutionProperty extends PropertyDefinition {
    readonly targetVersion: Version;
    readonly name: string;
    parse(sender: SerializableObject, source: PropertyBag, context: BaseSerializationContext): StringWithSubstitutions;
    toJSON(sender: SerializableObject, target: PropertyBag, value: StringWithSubstitutions, context: BaseSerializationContext): void;
    constructor(targetVersion: Version, name: string);
}
export declare class HttpHeader extends SerializableObject {
    static readonly nameProperty: StringProperty;
    static readonly valueProperty: StringWithSubstitutionProperty;
    protected getSchemaKey(): string;
    name: string;
    private _value;
    constructor(name?: string, value?: string);
    getReferencedInputs(inputs: Input[], referencedInputs: Dictionary<Input>): void;
    prepareForExecution(inputs: Dictionary<Input>): void;
    get value(): string | undefined;
    set value(newValue: string | undefined);
}
export declare class HttpAction extends Action {
    static readonly urlProperty: StringWithSubstitutionProperty;
    static readonly bodyProperty: StringWithSubstitutionProperty;
    static readonly methodProperty: StringProperty;
    static readonly headersProperty: SerializableObjectCollectionProperty;
    static readonly ignoreInputValidationProperty: BoolProperty;
    private _url;
    private _body;
    method?: string;
    headers: HttpHeader[];
    private _ignoreInputValidation;
    static readonly JsonTypeName: "Action.Http";
    protected internalGetReferencedInputs(): Dictionary<Input>;
    protected internalPrepareForExecution(inputs: Dictionary<Input> | undefined): void;
    getJsonTypeName(): string;
    internalValidateProperties(context: ValidationResults): void;
    get ignoreInputValidation(): boolean;
    set ignoreInputValidation(value: boolean);
    get url(): string | undefined;
    set url(value: string | undefined);
    get body(): string | undefined;
    set body(value: string | undefined);
}
export declare class ShowCardAction extends Action {
    static readonly JsonTypeName: "Action.ShowCard";
    protected updateCssClasses(): void;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected raiseExecuteActionEvent(): void;
    readonly card: AdaptiveCard;
    releaseDOMResources(): void;
    getJsonTypeName(): string;
    internalValidateProperties(context: ValidationResults): void;
    setParent(value: CardElement): void;
    getAllInputs(processActions?: boolean): Input[];
    getAllActions(): Action[];
    getResourceInformation(): IResourceInformation[];
    getActionById(id: string): Action | undefined;
}
export declare class ActionSet extends CardElement {
    static readonly orientationProperty: EnumProperty<typeof Enums.Orientation>;
    orientation?: Enums.Orientation;
    private _actionCollection;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected internalRender(): HTMLElement | undefined;
    constructor();
    releaseDOMResources(): void;
    isBleedingAtBottom(): boolean;
    getJsonTypeName(): string;
    getActionCount(): number;
    getActionAt(index: number): Action | undefined;
    getActionById(id: string): Action | undefined;
    getAllActions(): Action[];
    internalValidateProperties(context: ValidationResults): void;
    addAction(action: Action): void;
    getAllInputs(processActions?: boolean): Input[];
    getResourceInformation(): IResourceInformation[];
    /**
     * @inheritdoc
     */
    findDOMNodeOwner(node: Node): CardObject | undefined;
    getElementById(id: string): CardElement | undefined;
    get isInteractive(): boolean;
}
export declare class ContainerStyleProperty extends ValueSetProperty {
    readonly targetVersion: Version;
    readonly name: string;
    readonly defaultValue?: string | undefined;
    readonly onGetInitialValue?: ((sender: SerializableObject) => string) | undefined;
    constructor(targetVersion: Version, name: string, defaultValue?: string | undefined, onGetInitialValue?: ((sender: SerializableObject) => string) | undefined);
}
export declare abstract class StylableCardElementContainer extends CardElementContainer {
    static readonly styleProperty: ContainerStyleProperty;
    get style(): string | undefined;
    set style(value: string | undefined);
    protected get allowCustomStyle(): boolean;
    protected get hasExplicitStyle(): boolean;
    protected applyBorder(): void;
    protected applyBackground(): void;
    protected applyPadding(): void;
    protected getHasBackground(ignoreBackgroundImages?: boolean): boolean;
    protected getDefaultPadding(): PaddingDefinition;
    internalValidateProperties(context: ValidationResults): void;
    render(): HTMLElement | undefined;
    getEffectiveStyle(): string;
}
export declare abstract class ContainerBase extends StylableCardElementContainer {
    static readonly bleedProperty: BoolProperty;
    static readonly minHeightProperty: PixelSizeProperty;
    private _bleed;
    minPixelHeight?: number;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected getHasExpandedAction(): boolean;
    protected getBleed(): boolean;
    protected setBleed(value: boolean): void;
    protected get renderedActionCount(): number;
    isBleeding(): boolean;
}
export declare class BackgroundImage extends SerializableObject {
    static readonly urlProperty: StringProperty;
    static readonly fillModeProperty: EnumProperty<typeof Enums.FillMode>;
    static readonly horizontalAlignmentProperty: EnumProperty<typeof Enums.HorizontalAlignment>;
    static readonly verticalAlignmentProperty: EnumProperty<typeof Enums.VerticalAlignment>;
    url?: string;
    fillMode: Enums.FillMode;
    horizontalAlignment: Enums.HorizontalAlignment;
    verticalAlignment: Enums.VerticalAlignment;
    protected getSchemaKey(): string;
    protected internalParse(source: any, context: BaseSerializationContext): void;
    apply(element: CardElement): void;
    isValid(): boolean;
}
export declare class Container extends ContainerBase {
    static readonly backgroundImageProperty: SerializableObjectProperty;
    static readonly verticalContentAlignmentProperty: EnumProperty<typeof Enums.VerticalAlignment>;
    static readonly rtlProperty: BoolProperty;
    get backgroundImage(): BackgroundImage;
    verticalContentAlignment?: Enums.VerticalAlignment;
    rtl?: boolean;
    private _items;
    private _renderedItems;
    protected insertItemAt(item: CardElement, index: number, forceInsert: boolean): void;
    protected getItemsCollectionPropertyName(): string;
    protected applyBackground(): void;
    protected applyRTL(element: HTMLElement): void;
    protected internalRender(): HTMLElement | undefined;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected getHasBackground(ignoreBackgroundImages?: boolean): boolean;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected get isSelectable(): boolean;
    getEffectivePadding(): PaddingDefinition;
    getEffectiveVerticalContentAlignment(): Enums.VerticalAlignment;
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getFirstVisibleRenderedItem(): CardElement | undefined;
    getLastVisibleRenderedItem(): CardElement | undefined;
    getJsonTypeName(): string;
    isFirstElement(element: CardElement): boolean;
    isLastElement(element: CardElement): boolean;
    isRtl(): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    indexOf(cardElement: CardElement): number;
    addItem(item: CardElement): void;
    insertItemBefore(item: CardElement, insertBefore: CardElement): void;
    insertItemAfter(item: CardElement, insertAfter: CardElement): void;
    removeItem(item: CardElement): boolean;
    clear(): void;
    getResourceInformation(): IResourceInformation[];
    getActionById(id: string): Action | undefined;
    get padding(): PaddingDefinition | undefined;
    set padding(value: PaddingDefinition | undefined);
    get selectAction(): Action | undefined;
    set selectAction(value: Action | undefined);
    get bleed(): boolean;
    set bleed(value: boolean);
}
export declare type ColumnWidth = SizeAndUnit | "auto" | "stretch";
export declare class Column extends Container {
    static readonly widthProperty: CustomProperty<ColumnWidth>;
    width: ColumnWidth;
    private _computedWeight;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected shouldSerialize(_context: SerializationContext): boolean;
    protected get separatorOrientation(): Enums.Orientation;
    constructor(width?: ColumnWidth);
    getJsonTypeName(): string;
    get hasVisibleSeparator(): boolean;
    get isStandalone(): boolean;
}
export declare class ColumnSet extends ContainerBase {
    private _columns;
    private _renderedColumns;
    private createColumnInstance;
    protected internalRender(): HTMLElement | undefined;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected get isSelectable(): boolean;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    isFirstElement(element: CardElement): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    getItemCount(): number;
    getFirstVisibleRenderedItem(): CardElement | undefined;
    getLastVisibleRenderedItem(): CardElement | undefined;
    getColumnAt(index: number): Column;
    getItemAt(index: number): CardElement;
    getJsonTypeName(): string;
    internalValidateProperties(context: ValidationResults): void;
    addColumn(column: Column): void;
    removeItem(item: CardElement): boolean;
    indexOf(cardElement: CardElement): number;
    isLeftMostElement(element: CardElement): boolean;
    isRightMostElement(element: CardElement): boolean;
    isTopElement(element: CardElement): boolean;
    isBottomElement(element: CardElement): boolean;
    getActionById(id: string): Action | undefined;
    get bleed(): boolean;
    set bleed(value: boolean);
    get padding(): PaddingDefinition | undefined;
    set padding(value: PaddingDefinition | undefined);
    get selectAction(): Action | undefined;
    set selectAction(value: Action | undefined);
}
export declare abstract class ContainerWithActions extends Container {
    private _actionCollection;
    protected internalParse(source: any, context: SerializationContext): void;
    protected parseActions(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected internalRender(): HTMLElement | undefined;
    protected getHasExpandedAction(): boolean;
    protected get renderedActionCount(): number;
    protected get renderIfEmpty(): boolean;
    constructor();
    releaseDOMResources(): void;
    getActionCount(): number;
    getActionAt(index: number): Action | undefined;
    getActionById(id: string): Action | undefined;
    internalValidateProperties(context: ValidationResults): void;
    isLastElement(element: CardElement): boolean;
    addAction(action: Action): void;
    clear(): void;
    getAllInputs(processActions?: boolean): Input[];
    getResourceInformation(): IResourceInformation[];
    isBleedingAtBottom(): boolean;
    getForbiddenActionNames(): string[];
    getElementById(id: string): CardElement | undefined;
    get isStandalone(): boolean;
}
export interface IMarkdownProcessingResult {
    didProcess: boolean;
    outputHtml?: any;
}
export declare class RefreshActionProperty extends PropertyDefinition {
    readonly targetVersion: Version;
    readonly name: string;
    parse(sender: RefreshDefinition, source: PropertyBag, context: SerializationContext): ExecuteAction | undefined;
    toJSON(sender: SerializableObject, target: PropertyBag, value: ExecuteAction | undefined, context: SerializationContext): void;
    constructor(targetVersion: Version, name: string);
}
export declare class RefreshDefinition extends SerializableObject {
    static readonly actionProperty: RefreshActionProperty;
    static readonly userIdsProperty: StringArrayProperty;
    get action(): ExecuteAction;
    set action(value: ExecuteAction);
    userIds?: string[];
    protected getSchemaKey(): string;
    parent: CardElement;
}
export declare class AuthCardButton extends SerializableObject {
    static readonly typeProperty: StringProperty;
    static readonly titleProperty: StringProperty;
    static readonly imageProperty: StringProperty;
    static readonly valueProperty: StringProperty;
    protected getSchemaKey(): string;
    type: string;
    title?: string;
    image?: string;
    value: string;
}
export declare class TokenExchangeResource extends SerializableObject {
    static readonly idProperty: StringProperty;
    static readonly uriProperty: StringProperty;
    static readonly providerIdProperty: StringProperty;
    protected getSchemaKey(): string;
    id?: string;
    uri?: string;
    providerId?: string;
}
export declare class Authentication extends SerializableObject {
    static readonly textProperty: StringProperty;
    static readonly connectionNameProperty: StringProperty;
    static readonly buttonsProperty: SerializableObjectCollectionProperty;
    static readonly tokenExchangeResourceProperty: SerializableObjectProperty;
    protected getSchemaKey(): string;
    text?: string;
    connectionName?: string;
    buttons: AuthCardButton[];
    tokenExchangeResource?: TokenExchangeResource;
}
export declare class AdaptiveCard extends ContainerWithActions {
    static readonly schemaUrl = "http://adaptivecards.io/schemas/adaptive-card.json";
    protected static readonly $schemaProperty: CustomProperty<string>;
    static readonly versionProperty: CustomProperty<Version | undefined>;
    static readonly fallbackTextProperty: StringProperty;
    static readonly speakProperty: StringProperty;
    static readonly refreshProperty: SerializableObjectProperty;
    static readonly authenticationProperty: SerializableObjectProperty;
    version: Version;
    fallbackText?: string;
    speak?: string;
    get refresh(): RefreshDefinition | undefined;
    set refresh(value: RefreshDefinition | undefined);
    authentication?: Authentication;
    private static _haveWarnedAboutNoMarkdownProcessing;
    static onAnchorClicked?: (element: CardElement, anchor: HTMLAnchorElement, ev?: MouseEvent) => boolean;
    static onExecuteAction?: (action: Action) => void;
    static onElementVisibilityChanged?: (element: CardElement) => void;
    static onImageLoaded?: (image: Image) => void;
    static onInlineCardExpanded?: (action: ShowCardAction, isExpanded: boolean) => void;
    static onInputValueChanged?: (input: Input) => void;
    static onCarouselEvent?: (carouselEvent: CarouselEvent) => void;
    static onProcessMarkdown?: (text: string, result: IMarkdownProcessingResult) => void;
    static onDisplayOverflowActionMenu?: (actions: readonly Action[], target?: HTMLElement) => boolean;
    static onRenderOverflowActions?: (actions: readonly Action[], isRootLevelActions: boolean) => boolean;
    static get processMarkdown(): (text: string) => string;
    static set processMarkdown(_value: (text: string) => string);
    static applyMarkdown(text: string): IMarkdownProcessingResult;
    private _fallbackCard?;
    private isVersionSupported;
    protected getDefaultSerializationContext(): BaseSerializationContext;
    protected getItemsCollectionPropertyName(): string;
    protected internalParse(source: any, context: SerializationContext): void;
    protected internalToJSON(target: PropertyBag, context: SerializationContext): void;
    protected internalRender(): HTMLElement | undefined;
    protected getHasBackground(ignoreBackgroundImages?: boolean): boolean;
    protected getDefaultPadding(): PaddingDefinition;
    protected shouldSerialize(_context: SerializationContext): boolean;
    protected get renderIfEmpty(): boolean;
    protected get bypassVersionCheck(): boolean;
    protected get allowCustomStyle(): boolean;
    protected get hasBackground(): boolean;
    onAnchorClicked?: (element: CardElement, anchor: HTMLAnchorElement, ev?: MouseEvent) => boolean;
    onExecuteAction?: (action: Action) => void;
    onElementVisibilityChanged?: (element: CardElement) => void;
    onImageLoaded?: (image: Image) => void;
    onInlineCardExpanded?: (action: ShowCardAction, isExpanded: boolean) => void;
    onInputValueChanged?: (input: Input) => void;
    onCarouselEvent?: (carouselEvent: CarouselEvent) => void;
    onDisplayOverflowActionMenu?: (actions: readonly Action[], target?: HTMLElement) => boolean;
    onRenderOverflowActions?: (actions: readonly Action[], isRootLevelActions: boolean) => boolean;
    designMode: boolean;
    getJsonTypeName(): string;
    internalValidateProperties(context: ValidationResults): void;
    render(target?: HTMLElement): HTMLElement | undefined;
    updateLayout(processChildren?: boolean): void;
    shouldFallback(): boolean;
    get hasVisibleSeparator(): boolean;
}
export declare class SerializationContext extends BaseSerializationContext {
    private _elementRegistry?;
    private _actionRegistry?;
    private _forbiddenTypes;
    private internalParseCardObject;
    protected cardObjectParsed(o: SerializableObject, source: any): void;
    onParseAction?: (action: Action, source: any, context: SerializationContext) => void;
    onParseElement?: (element: CardElement, source: any, context: SerializationContext) => void;
    shouldSerialize(o: SerializableObject): boolean;
    parseCardObject<T extends CardObject>(parent: CardElement | undefined, source: any, forbiddenTypeNames: string[], allowFallback: boolean, createInstanceCallback: (typeName: string) => T | undefined, logParseEvent: (typeName: string, errorType: Enums.TypeErrorType) => void): T | undefined;
    parseElement(parent: CardElement | undefined, source: any, forbiddenTypes: string[], allowFallback: boolean): CardElement | undefined;
    parseAction(parent: CardElement, source: any, forbiddenActionTypes: string[], allowFallback: boolean): Action | undefined;
    get elementRegistry(): CardObjectRegistry<CardElement>;
    setElementRegistry(value: CardObjectRegistry<CardElement> | undefined): void;
    get actionRegistry(): CardObjectRegistry<Action>;
    setActionRegistry(value: CardObjectRegistry<Action> | undefined): void;
}
export {};
