{"version":3,"file":"chunks/InstallManagerFactory.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAC4D;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3EA;AACA;AACmF;AAC5E;AACP;AACA;AACA;AACA;AACA,uBAAuB,4FAAuB;AAC9C;AACA,+CAA+C,kPAED;AAC9C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACiC;AACR;AACI;AACI;AACA;AAC8H;AAC1G;AACgB;AACS;AACjD;AACsC;AACN;AACvB;AACW;AACgB;AACX;AACY;AACL;AACP;AACe;AACC;AACI;AAC1E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oFAAqC;AACxE,qCAAqC,iFAAuB;AAC5D,6BAA6B,kEAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,sBAAsB,8EAAoB;AAC1C;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA,2BAA2B,uDAAW,8BAA8B,wCAAwC;AAC5G;AACA;AACA;AACA;AACA,sCAAsC,0FAAwC,2BAA2B,sCAAsC;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,kFAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa,0DAA0D;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa,IAAI,4EAA+B,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,qCAAqC,sCAAS,0CAA0C,gFAAmC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2EAAiB;AACjC;AACA;AACA;AACA,eAAe,kFAAgC;AAC/C;AACA;AACA;AACA,cAAc,yEAAmC;AACjD;AACA,4CAA4C,8EAAuB;AACnE;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qGAAwC;AACtD;AACA;AACA;AACA;AACA,iCAAiC,4FAAuC;AACxE;AACA;AACA;AACA;AACA;AACA,kDAAkD,4CAA4C,IAAI,WAAW;AAC7G;AACA;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAa;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,uDAAW,mBAAmB,qBAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAW;AACnC;AACA;AACA;AACA;AACA,0BAA0B,qEAAmB;AAC7C;AACA;AACA,cAAc,8CAAiB;AAC/B;AACA;AACA;AACA,mDAAmD,wCAAwC,GAAG,gFAAmC,CAAC;AAClI,6CAA6C,oCAAoC,QAAQ,gFAAmC,CAAC;AAC7H,gBAAgB,2EAAiB;AACjC,gBAAgB,8EAAoB;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB,gHAAsD;AACxE;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa,CAAC,yEAAwB,QAAQ,6CAA6C;AACnH;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU,QAAQ,6CAA6C;AAC3F,0BAA0B,8EAAoB;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC,wBAAwB,sCAAG;AAC3B;AACA,YAAY,2EAAiB;AAC7B,qCAAqC,wFAA8B;AACnE;AACA;AACA;AACA;AACA,mCAAmC,uDAAW;AAC9C;AACA,8DAA8D,2DAAa,GAAG,wDAAU;AACxF;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mFAAsC,CAAC;AACvE;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA,gBAAgB,sFAA4B;AAC5C;AACA,yCAAyC,+EAAqB,CAAC,0CAAa;AAC5E;AACA;AACA;AACA,4CAA4C,WAAW,GAAG,SAAS;AACnE;AACA,oDAAoD,6EAAmB;AACvE,oBAAoB,8EAAoB;AACxC,4CAA4C,wEAAc;AAC1D,qBAAqB;AACrB;AACA,kDAAkD,qFAA2B;AAC7E,oBAAoB,wFAA8B;AAClD;AACA,4CAA4C,gFAAsB,GAAG,mFAAyB;AAC9F;AACA;AACA;AACA,oCAAoC;AACpC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD,0CAA0C,iBAAiB,GAAG,SAAS;;AAEvE,2CAA2C;AAC3C;AACA;AACA,cAAc,UAAU;AACxB;AACA,EAAE;AACF;AACA;AACA,oBAAoB,8EAAoB,CAAC,sCAAS;AAClD,4CAA4C,wEAAc;AAC1D,qBAAqB;AACrB,oBAAoB,wFAA8B,CAAC,sCAAS;AAC5D;AACA,oBAAoB,gFAAsB,GAAG,mFAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0GAA8C;AAC9D;AACA,oBAAoB,uCAAU;AAC9B,iCAAiC,sBAAsB,GAAG,iDAAiD;AAC3G,iCAAiC,sBAAsB,GAAG,iDAAiD;AAC3G;AACA;AACA,oBAAoB,2BAA2B,EAAE,oFAAwB;AACzE;AACA,yDAAyD,yBAAyB;AAClF;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oFAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,gBAAgB,6CAAgB;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAU;AAC1B,gBAAgB,6CAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAS,mDAAmD,oDAAY;AACtG,YAAY,2EAAiB;AAC7B;AACA;AACA;AACA;AACA,sCAAsC,kFAAwB;AAC9D;AACA;AACA;AACA;AACA,mCAAmC,uEAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB,2BAA2B,0BAA0B;AACrF;AACA;AACA;AACA;AACA,kBAAkB,4EAAkB,oCAAoC,0BAA0B;AAClG;AACA;AACA;AACA,kBAAkB,4EAAkB,2BAA2B,0BAA0B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAqC;AACzD,8BAA8B,4DAAS;AACvC,mDAAmD,iBAAiB,EAAE,wCAAW,IAAI,EAAE,oCAAO,GAAG;AACjG,iEAAiE,yBAAyB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAY;AAC3C;AACA;AACA;AACA,gCAAgC,oDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA,YAAY,+EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAqB,CAAC,sCAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAU;AACxC;AACA;AACA;AACA,8BAA8B,uDAAW;AACzC,mCAAmC,mFAAsC,CAAC;AAC1E,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7nBA;AACA;AAC0D;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2EAAiB;AACtD;AACA,4BAA4B,qFAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAoB;AAC5B;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACiC;AACJ;AACI;AACqE;AACtC;AACsB;AACzB;AACC;AACJ;AACJ;AACJ;AACW;AACiB;AACb;AACa;AACT;AACrE;AACA;AACA;AACO,sCAAsC,wEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0GAA+C;AAC3D;AACA;AACA;AACA;AACA,2BAA2B,uDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C,cAAc,gBAAgB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAA+B,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA,mEAAmE,sFAAoC,EAAE;AACzG;AACA;AACA;AACA;AACA,kCAAkC,sEAAiB,CAAC,sCAAS;AAC7D;AACA;AACA;AACA;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uEAAmB;AAC1D;AACA;AACA,gDAAgD,qEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,2DAA2D,iFAA+B;AAC1F,0DAA0D,+EAA6B;AACvF;AACA;AACA;AACA;AACA,yBAAyB,6CAAgB;AACzC;AACA;AACA;AACA,oCAAoC,sDAAU,KAAK,wBAAwB,wBAAwB,KAAK,KAAK,QAAQ;AACrH;AACA;AACA,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAU,KAAK,wBAAwB,wBAAwB,KAAK,KAAK,QAAQ;AACrH;AACA,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,iDAAiD,8CAAiB;AAClE,6BAA6B,yCAAY;AACzC;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA,+DAA+D,mFAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa,KAAK,wBAAwB;AACtE;AACA;AACA;AACA;AACA,oEAAoE,wBAAwB;AAC5F;AACA;AACA;AACA;AACA,QAAQ,sFAAwC;AAChD;AACA;AACA,8DAA8D,qBAAqB;AACnF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sCAAS;AACnD,gBAAgB,2EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAS,wBAAwB,qFAAmC;AACvF,SAAS;AACT,mBAAmB,sCAAS,wBAAwB,mFAAyB;AAC7E,SAAS;AACT;AACA;AACA,eAAe,mFAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yFAA2C;AAC7E,wCAAwC,sCAAS,0CAA0C,qFAAmC;AAC9H;AACA,YAAY,2EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAW,aAAa,uCAAuC;AAC/E,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC,oBAAoB,gFAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2EAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yGAAsD;AAC5E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAA+B;AACvD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA,uEAAuE,mBAAmB,sBAAsB;AAChH,uEAAuE,mBAAmB,+BAA+B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAS,0CAA0C,qFAAmC;AAClG;AACA,uBAAuB,sCAAS,wBAAwB,qFAAmC;AAC3F,aAAa;AACb;AACA;AACA,YAAY,iFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4FAAuC;AAC1E;AACA;AACA,kBAAkB,4EAAkB;AACpC;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAkB;AACpC,sBAAsB,2HAA6D;AACnF,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzXA;AACA;AAC6B;AACqC;AACJ;AACC;AAC/D,mBAAmB,qEAAW;AAC9B,mBAAmB,mBAAO,CAAC,yBAAa,GAAG;AACpC,gCAAgC,sEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAe;AAC3B,0BAA0B,0CAAa,CAAC,yCAAY;AACpD;AACA;AACA,yBAAyB,+EAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA,kDAAkD,wEAA2B;AAC7E;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/ApprovedPackagesChecker.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/InstallManagerFactory.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseInstallManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseWorkspaceFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/installManager/WorkspaceInstallManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmWorkspaceFile.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { DependencySpecifier } from './DependencySpecifier';\nexport class ApprovedPackagesChecker {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;\n        this._filesAreOutOfDate = false;\n        if (this._approvedPackagesPolicy.enabled) {\n            this._updateApprovedPackagesPolicy();\n        }\n    }\n    /**\n     * If true, the files on disk are out of date.\n     */\n    get approvedPackagesFilesAreOutOfDate() {\n        return this._filesAreOutOfDate;\n    }\n    /**\n     * Examines the current dependencies for the projects specified in RushConfiguration,\n     * and then adds them to the 'browser-approved-packages.json' and\n     * 'nonbrowser-approved-packages.json' config files.  If these files don't exist,\n     * they will be created.\n     *\n     * If the \"approvedPackagesPolicy\" feature is not enabled, then no action is taken.\n     */\n    rewriteConfigFiles() {\n        const approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;\n        if (approvedPackagesPolicy.enabled) {\n            approvedPackagesPolicy.browserApprovedPackages.saveToFile();\n            approvedPackagesPolicy.nonbrowserApprovedPackages.saveToFile();\n        }\n    }\n    _updateApprovedPackagesPolicy() {\n        for (const rushProject of this._rushConfiguration.projects) {\n            const packageJson = rushProject.packageJson;\n            this._collectDependencies(packageJson.dependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.devDependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.peerDependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.optionalDependencies, this._approvedPackagesPolicy, rushProject);\n        }\n    }\n    _collectDependencies(dependencies, approvedPackagesPolicy, rushProject) {\n        if (dependencies) {\n            for (const packageName of Object.keys(dependencies)) {\n                let referencedPackageName = packageName;\n                // Special handling for NPM package aliases such as this:\n                //\n                // \"dependencies\": {\n                //   \"alias-name\": \"npm:target-name@^1.2.3\"\n                // }\n                const dependencySpecifier = new DependencySpecifier(packageName, dependencies[packageName]);\n                if (dependencySpecifier.aliasTarget) {\n                    // Use \"target-name\" instead of \"alias-name\"\n                    referencedPackageName = dependencySpecifier.aliasTarget.packageName;\n                }\n                const scope = this._rushConfiguration.packageNameParser.getScope(referencedPackageName);\n                // Make sure the scope isn't something like \"@types\" which should be ignored\n                if (!approvedPackagesPolicy.ignoredNpmScopes.has(scope) && rushProject.reviewCategory) {\n                    // Yes, add it to the list if it's not already there\n                    let updated = false;\n                    // By default we put everything in the browser file.  But if it already appears in the\n                    // non-browser file, then use that instead.\n                    if (approvedPackagesPolicy.nonbrowserApprovedPackages.getItemByName(referencedPackageName)) {\n                        updated = approvedPackagesPolicy.nonbrowserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);\n                    }\n                    else {\n                        updated = approvedPackagesPolicy.browserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);\n                    }\n                    this._filesAreOutOfDate = this._filesAreOutOfDate || updated;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=ApprovedPackagesChecker.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { WorkspaceInstallManager } from './installManager/WorkspaceInstallManager';\nexport class InstallManagerFactory {\n    static async getInstallManagerAsync(rushConfiguration, rushGlobalFolder, purgeManager, options) {\n        if (rushConfiguration.packageManager === 'pnpm' &&\n            rushConfiguration.pnpmOptions &&\n            rushConfiguration.pnpmOptions.useWorkspaces) {\n            return new WorkspaceInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);\n        }\n        const rushInstallManagerModule = await import(\n        /* webpackChunkName: 'RushInstallManager' */\n        './installManager/RushInstallManager');\n        return new rushInstallManagerModule.RushInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);\n    }\n}\n//# sourceMappingURL=InstallManagerFactory.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport * as semver from 'semver';\nimport { FileSystem, JsonFile, PosixModeBits, NewlineKind, AlreadyReportedError, ConsoleTerminalProvider, Terminal, Path } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { ApprovedPackagesChecker } from '../ApprovedPackagesChecker';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { Git } from '../Git';\nimport { LastInstallFlagFactory } from '../../api/LastInstallFlag';\nimport { LastLinkFlagFactory } from '../../api/LastLinkFlag';\nimport { Rush } from '../../api/Rush';\nimport { RushConstants } from '../RushConstants';\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\nimport { Utilities } from '../../utilities/Utilities';\nimport { InstallHelpers } from '../installManager/InstallHelpers';\nimport * as PolicyValidator from '../policy/PolicyValidator';\nimport { WebClient } from '../../utilities/WebClient';\nimport { SetupPackageRegistry } from '../setup/SetupPackageRegistry';\nimport { PnpmfileConfiguration } from '../pnpm/PnpmfileConfiguration';\nimport { isVariableSetInNpmrcFile } from '../../utilities/npmrcUtilities';\n/**\n * Pnpm don't support --ignore-compatibility-db, so use --config.ignoreCompatibilityDb for now.\n */\nexport const pnpmIgnoreCompatibilityDbParameter = '--config.ignoreCompatibilityDb';\nconst pnpmCacheDirParameter = '--config.cacheDir';\nconst pnpmStateDirParameter = '--config.stateDir';\nconst gitLfsHooks = new Set(['post-checkout', 'post-commit', 'post-merge', 'pre-push']);\n/**\n * This class implements common logic between \"rush install\" and \"rush update\".\n */\nexport class BaseInstallManager {\n    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {\n        this._npmSetupValidated = false;\n        this._syncNpmrcAlreadyCalled = false;\n        this.rushConfiguration = rushConfiguration;\n        this.rushGlobalFolder = rushGlobalFolder;\n        this.installRecycler = purgeManager.commonTempFolderRecycler;\n        this.options = options;\n        this._commonTempLinkFlag = LastLinkFlagFactory.getCommonTempFlag(rushConfiguration);\n        this._terminalProvider = new ConsoleTerminalProvider();\n        this._terminal = new Terminal(this._terminalProvider);\n    }\n    async doInstallAsync() {\n        const isFilteredInstall = this.options.pnpmFilterArguments.length > 0;\n        const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;\n        // Prevent filtered installs when workspaces is disabled\n        if (isFilteredInstall && !useWorkspaces) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(colors.red('Project filtering arguments can only be used when running in a workspace environment. Run the ' +\n                'command again without specifying these arguments.'));\n            throw new AlreadyReportedError();\n        }\n        // Prevent update when using a filter, as modifications to the shrinkwrap shouldn't be saved\n        if (this.options.allowShrinkwrapUpdates && isFilteredInstall) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(colors.red('Project filtering arguments cannot be used when running \"rush update\". Run the command again ' +\n                'without specifying these arguments.'));\n            throw new AlreadyReportedError();\n        }\n        const { shrinkwrapIsUpToDate, variantIsUpToDate, npmrcHash } = await this.prepareAsync();\n        if (this.options.checkOnly) {\n            return;\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + colors.bold(`Checking installation in \"${this.rushConfiguration.commonTempFolder}\"`));\n        // This marker file indicates that the last \"rush install\" completed successfully.\n        // Always perform a clean install if filter flags were provided. Additionally, if\n        // \"--purge\" was specified, or if the last install was interrupted, then we will\n        // need to perform a clean install.  Otherwise, we can do an incremental install.\n        const commonTempInstallFlag = LastInstallFlagFactory.getCommonTempFlag(this.rushConfiguration, { npmrcHash: npmrcHash || '<NO NPMRC>' });\n        const optionsToIgnore = !this.rushConfiguration.experimentsConfiguration\n            .configuration.cleanInstallAfterNpmrcChanges\n            ? ['npmrcHash'] // If the \"cleanInstallAfterNpmrcChanges\" experiment is disabled, ignore the npmrcHash\n            : undefined;\n        const cleanInstall = isFilteredInstall ||\n            !commonTempInstallFlag.checkValidAndReportStoreIssues({\n                rushVerb: this.options.allowShrinkwrapUpdates ? 'update' : 'install',\n                statePropertiesToIgnore: optionsToIgnore\n            });\n        // Allow us to defer the file read until we need it\n        const canSkipInstall = () => {\n            // Based on timestamps, can we skip this install entirely?\n            const outputStats = FileSystem.getStatistics(commonTempInstallFlag.path);\n            return this.canSkipInstall(outputStats.mtime);\n        };\n        if (cleanInstall || !shrinkwrapIsUpToDate || !variantIsUpToDate || !canSkipInstall()) {\n            // eslint-disable-next-line no-console\n            console.log();\n            await this.validateNpmSetup();\n            let publishedRelease;\n            try {\n                publishedRelease = await this._checkIfReleaseIsPublished();\n            }\n            catch (_a) {\n                // If the user is working in an environment that can't reach the registry,\n                // don't bother them with errors.\n            }\n            if (publishedRelease === false) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));\n            }\n            // Delete the successful install file to indicate the install transaction has started\n            commonTempInstallFlag.clear();\n            // Since we're going to be tampering with common/node_modules, delete the \"rush link\" flag file if it exists;\n            // this ensures that a full \"rush link\" is required next time\n            this._commonTempLinkFlag.clear();\n            // Give plugins an opportunity to act before invoking the installation process\n            if (this.options.beforeInstallAsync !== undefined) {\n                await this.options.beforeInstallAsync();\n            }\n            // Perform the actual install\n            await this.installAsync(cleanInstall);\n            if (this.options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {\n                // Copy (or delete) common\\temp\\pnpm-lock.yaml --> common\\config\\rush\\pnpm-lock.yaml\n                Utilities.syncFile(this.rushConfiguration.tempShrinkwrapFilename, this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));\n            }\n            else {\n                // TODO: Validate whether the package manager updated it in a nontrivial way\n            }\n            // Always update the state file if running \"rush update\"\n            if (this.options.allowShrinkwrapUpdates) {\n                if (this.rushConfiguration.getRepoState(this.options.variant).refreshState(this.rushConfiguration)) {\n                    // eslint-disable-next-line no-console\n                    console.log(colors.yellow(`${RushConstants.repoStateFilename} has been modified and must be committed to source control.`));\n                }\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log('Installation is already up-to-date.');\n        }\n        // Create the marker file to indicate a successful install if it's not a filtered install\n        if (!isFilteredInstall) {\n            commonTempInstallFlag.create();\n        }\n        // Perform any post-install work the install manager requires\n        await this.postInstallAsync();\n        // eslint-disable-next-line no-console\n        console.log('');\n    }\n    canSkipInstall(lastModifiedDate) {\n        // Based on timestamps, can we skip this install entirely?\n        const potentiallyChangedFiles = [];\n        // Consider the timestamp on the node_modules folder; if someone tampered with it\n        // or deleted it entirely, then we can't skip this install\n        potentiallyChangedFiles.push(path.join(this.rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName));\n        // Additionally, if they pulled an updated shrinkwrap file from Git,\n        // then we can't skip this install\n        potentiallyChangedFiles.push(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));\n        // Add common-versions.json file to the potentially changed files list.\n        potentiallyChangedFiles.push(this.rushConfiguration.getCommonVersionsFilePath(this.options.variant));\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            // If the repo is using pnpmfile.js, consider that also\n            const pnpmFileFilename = this.rushConfiguration.getPnpmfilePath(this.options.variant);\n            if (FileSystem.exists(pnpmFileFilename)) {\n                potentiallyChangedFiles.push(pnpmFileFilename);\n            }\n        }\n        return Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);\n    }\n    async prepareAsync() {\n        // Check the policies\n        await PolicyValidator.validatePolicyAsync(this.rushConfiguration, this.options);\n        this._installGitHooks();\n        const approvedPackagesChecker = new ApprovedPackagesChecker(this.rushConfiguration);\n        if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {\n            if (this.options.allowShrinkwrapUpdates) {\n                approvedPackagesChecker.rewriteConfigFiles();\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Approved package files have been updated. These updates should be committed to source control'));\n            }\n            else {\n                throw new Error(`Approved packages files are out-of date. Run \"rush update\" to update them.`);\n            }\n        }\n        // Ensure that the package manager is installed\n        await InstallHelpers.ensureLocalPackageManager(this.rushConfiguration, this.rushGlobalFolder, this.options.maxInstallAttempts);\n        let shrinkwrapFile = undefined;\n        // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)\n        if (!this.options.fullUpgrade) {\n            try {\n                shrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.packageManagerOptions, this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));\n            }\n            catch (ex) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(`Unable to load the ${this.rushConfiguration.shrinkwrapFilePhrase}: ${ex.message}`);\n                if (!this.options.allowShrinkwrapUpdates) {\n                    // eslint-disable-next-line no-console\n                    console.log();\n                    // eslint-disable-next-line no-console\n                    console.log(colors.red('You need to run \"rush update\" to fix this problem'));\n                    throw new AlreadyReportedError();\n                }\n                shrinkwrapFile = undefined;\n            }\n        }\n        // Write a file indicating which variant is being installed.\n        // This will be used by bulk scripts to determine the correct Shrinkwrap file to track.\n        const currentVariantJsonFilename = this.rushConfiguration.currentVariantJsonFilename;\n        const currentVariantJson = {\n            variant: this.options.variant || null\n        };\n        // Determine if the variant is already current by updating current-variant.json.\n        // If nothing is written, the variant has not changed.\n        const variantIsUpToDate = !JsonFile.save(currentVariantJson, currentVariantJsonFilename, {\n            onlyIfChanged: true\n        });\n        if (this.options.variant) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(colors.bold(`Using variant '${this.options.variant}' for installation.`));\n        }\n        else if (!variantIsUpToDate && !this.options.variant) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(colors.bold('Using the default variant for installation.'));\n        }\n        // Also copy down the committed .npmrc file, if there is one\n        // \"common\\config\\rush\\.npmrc\" --> \"common\\temp\\.npmrc\"\n        // Also ensure that we remove any old one that may be hanging around\n        const npmrcText = Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this.rushConfiguration.commonTempFolder);\n        this._syncNpmrcAlreadyCalled = true;\n        const npmrcHash = npmrcText\n            ? crypto.createHash('sha1').update(npmrcText).digest('hex')\n            : undefined;\n        // Copy the committed patches folder if using pnpm\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            const commonTempPnpmPatchesFolder = `${this.rushConfiguration.commonTempFolder}/${RushConstants.pnpmPatchesFolderName}`;\n            const rushPnpmPatchesFolder = `${this.rushConfiguration.commonFolder}/pnpm-${RushConstants.pnpmPatchesFolderName}`;\n            if (FileSystem.exists(rushPnpmPatchesFolder)) {\n                FileSystem.copyFiles({\n                    sourcePath: rushPnpmPatchesFolder,\n                    destinationPath: commonTempPnpmPatchesFolder\n                });\n            }\n        }\n        // Shim support for pnpmfile in. This shim will call back into the variant-specific pnpmfile.\n        // Additionally when in workspaces, the shim implements support for common versions.\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            await PnpmfileConfiguration.writeCommonTempPnpmfileShimAsync(this.rushConfiguration, this.options);\n        }\n        // Allow for package managers to do their own preparation and check that the shrinkwrap is up to date\n        // eslint-disable-next-line prefer-const\n        let { shrinkwrapIsUpToDate, shrinkwrapWarnings } = await this.prepareCommonTempAsync(shrinkwrapFile);\n        shrinkwrapIsUpToDate = shrinkwrapIsUpToDate && !this.options.recheckShrinkwrap;\n        this._syncTempShrinkwrap(shrinkwrapFile);\n        // Write out the reported warnings\n        if (shrinkwrapWarnings.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow(PrintUtilities.wrapWords(`The ${this.rushConfiguration.shrinkwrapFilePhrase} contains the following issues:`)));\n            for (const shrinkwrapWarning of shrinkwrapWarnings) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('  ' + shrinkwrapWarning));\n            }\n            // eslint-disable-next-line no-console\n            console.log();\n        }\n        // Force update if the shrinkwrap is out of date\n        if (!shrinkwrapIsUpToDate) {\n            if (!this.options.allowShrinkwrapUpdates) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(colors.red(`The ${this.rushConfiguration.shrinkwrapFilePhrase} is out of date. You need to run \"rush update\".`));\n                throw new AlreadyReportedError();\n            }\n        }\n        return { shrinkwrapIsUpToDate, variantIsUpToDate, npmrcHash };\n    }\n    /**\n     * Git hooks are only installed if the repo opts in by including files in /common/git-hooks\n     */\n    _installGitHooks() {\n        const hookSource = path.join(this.rushConfiguration.commonFolder, 'git-hooks');\n        const git = new Git(this.rushConfiguration);\n        const hookDestination = git.getHooksFolder();\n        if (FileSystem.exists(hookSource) && hookDestination) {\n            const allHookFilenames = FileSystem.readFolderItemNames(hookSource);\n            // Ignore the \".sample\" file(s) in this folder.\n            const hookFilenames = allHookFilenames.filter((x) => !/\\.sample$/.test(x));\n            if (hookFilenames.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' + colors.bold('Found files in the \"common/git-hooks\" folder.'));\n                if (!git.isHooksPathDefault()) {\n                    const color = this.options.bypassPolicy ? colors.yellow : colors.red;\n                    // eslint-disable-next-line no-console\n                    console.error(color([\n                        ' ',\n                        `Rush cannot install the \"common/git-hooks\" scripts because your Git configuration `,\n                        `specifies \"core.hooksPath=${git.getConfigHooksPath()}\". You can remove the setting by running:`,\n                        ' ',\n                        '    git config --unset core.hooksPath',\n                        ' '\n                    ].join('\\n')));\n                    if (this.options.bypassPolicy) {\n                        // If \"--bypass-policy\" is specified, skip installation of hooks because Rush doesn't\n                        // own the hooks folder\n                        return;\n                    }\n                    // eslint-disable-next-line no-console\n                    console.error(color([\n                        '(Or, to temporarily ignore this problem, invoke Rush with the ' +\n                            `\"${RushConstants.bypassPolicyFlagLongName}\" option.)`,\n                        ' '\n                    ].join('\\n')));\n                    throw new AlreadyReportedError();\n                }\n                // Clear the currently installed git hooks and install fresh copies\n                FileSystem.ensureEmptyFolder(hookDestination);\n                // Find the relative path from Git hooks directory to the directory storing the actual scripts.\n                const hookRelativePath = Path.convertToSlashes(path.relative(hookDestination, hookSource));\n                // Only copy files that look like Git hook names\n                const filteredHookFilenames = hookFilenames.filter((x) => /^[a-z\\-]+/.test(x));\n                for (const filename of filteredHookFilenames) {\n                    const hookFilePath = `${hookSource}/${filename}`;\n                    // Make sure the actual script in the hookSource directory has correct Linux compatible line endings\n                    const originalHookFileContent = FileSystem.readFile(hookFilePath);\n                    FileSystem.writeFile(hookFilePath, originalHookFileContent, {\n                        convertLineEndings: NewlineKind.Lf\n                    });\n                    // Make sure the actual script in the hookSource directory has required permission bits\n                    const originalPosixModeBits = FileSystem.getPosixModeBits(hookFilePath);\n                    FileSystem.changePosixModeBits(hookFilePath, \n                    // eslint-disable-next-line no-bitwise\n                    originalPosixModeBits | PosixModeBits.UserRead | PosixModeBits.UserExecute);\n                    const gitLfsHookHandling = gitLfsHooks.has(filename)\n                        ? `\n# Inspired by https://github.com/git-lfs/git-lfs/issues/2865#issuecomment-365742940\nif command -v git-lfs &> /dev/null; then\n  git lfs ${filename} \"$@\"\nfi\n`\n                        : '';\n                    const hookFileContent = `#!/bin/bash\nset -e\nSCRIPT_DIR=\"$( cd \"$( dirname \"\\${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\nSCRIPT_IMPLEMENTATION_PATH=\"$SCRIPT_DIR/${hookRelativePath}/${filename}\"\n\nif [[ -f \"$SCRIPT_IMPLEMENTATION_PATH\" ]]; then\n  \"$SCRIPT_IMPLEMENTATION_PATH\" $@\nelse\n  echo \"The ${filename} Git hook no longer exists in your version of the repo. Run 'rush install' or 'rush update' to refresh your installed Git hooks.\" >&2\nfi\n${gitLfsHookHandling}\n`;\n                    // Create the hook file.  Important: For Bash scripts, the EOL must not be CRLF.\n                    FileSystem.writeFile(path.join(hookDestination, filename), hookFileContent, {\n                        convertLineEndings: NewlineKind.Lf\n                    });\n                    FileSystem.changePosixModeBits(path.join(hookDestination, filename), \n                    // eslint-disable-next-line no-bitwise\n                    PosixModeBits.UserRead | PosixModeBits.UserExecute);\n                }\n                // eslint-disable-next-line no-console\n                console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + '\\n');\n            }\n        }\n    }\n    /**\n     * Used when invoking the NPM tool.  Appends the common configuration options\n     * to the command-line.\n     */\n    pushConfigurationArgs(args, options) {\n        if (this.rushConfiguration.packageManager === 'npm') {\n            if (semver.lt(this.rushConfiguration.packageManagerToolVersion, '5.0.0')) {\n                // NOTE:\n                //\n                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for\n                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.\n                //\n                // Consider the \"fsevents\" package. This is a Mac specific package\n                // which is an optional second-order dependency. Optional dependencies work by attempting to install\n                // the package, but removes the package if the install failed.\n                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.\n                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.\n                //\n                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.\n                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the\n                // optional dependency installed.\n                //\n                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0\n                //\n                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600\n                args.push('--no-optional');\n            }\n            args.push('--cache', this.rushConfiguration.npmCacheFolder);\n            args.push('--tmp', this.rushConfiguration.npmTmpFolder);\n            if (options.collectLogFile) {\n                args.push('--verbose');\n            }\n        }\n        else if (this.rushConfiguration.packageManager === 'pnpm') {\n            // Only explicitly define the store path if `pnpmStore` is using the default, or has been set to\n            // 'local'.  If `pnpmStore` = 'global', then allow PNPM to use the system's default\n            // path.  In all cases, this will be overridden by RUSH_PNPM_STORE_PATH\n            if (this.rushConfiguration.pnpmOptions.pnpmStore === 'local' ||\n                EnvironmentConfiguration.pnpmStorePathOverride) {\n                args.push('--store', this.rushConfiguration.pnpmOptions.pnpmStorePath);\n                if (semver.gte(this.rushConfiguration.packageManagerToolVersion, '6.10.0')) {\n                    args.push(`${pnpmCacheDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);\n                    args.push(`${pnpmStateDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);\n                }\n            }\n            const { pnpmVerifyStoreIntegrity } = EnvironmentConfiguration;\n            if (pnpmVerifyStoreIntegrity !== undefined) {\n                args.push(`--verify-store-integrity`, `${pnpmVerifyStoreIntegrity}`);\n            }\n            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n            if (experiments.usePnpmFrozenLockfileForRushInstall && !options.allowShrinkwrapUpdates) {\n                args.push('--frozen-lockfile');\n                if (options.pnpmFilterArguments.length > 0 &&\n                    Number.parseInt(this.rushConfiguration.packageManagerToolVersion, 10) >= 8 // PNPM Major version 8+\n                ) {\n                    // On pnpm@8, disable the \"dedupe-peer-dependents\" feature when doing a filtered CI install so that filters take effect.\n                    args.push('--config.dedupe-peer-dependents=false');\n                }\n            }\n            else if (experiments.usePnpmPreferFrozenLockfileForRushUpdate) {\n                // In workspaces, we want to avoid unnecessary lockfile churn\n                args.push('--prefer-frozen-lockfile');\n            }\n            else {\n                // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.\n                // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342\n                args.push('--no-prefer-frozen-lockfile');\n            }\n            if (options.onlyShrinkwrap) {\n                args.push(`--lockfile-only`);\n            }\n            if (options.collectLogFile) {\n                args.push('--reporter', 'ndjson');\n            }\n            if (options.networkConcurrency) {\n                args.push('--network-concurrency', options.networkConcurrency.toString());\n            }\n            if (this.rushConfiguration.pnpmOptions.strictPeerDependencies === false) {\n                args.push('--no-strict-peer-dependencies');\n            }\n            else {\n                args.push('--strict-peer-dependencies');\n            }\n            /*\n              If user set resolution-mode in pnpm-config.json only, use the value in pnpm-config.json\n              If user set resolution-mode in pnpm-config.json and .npmrc, use the value in pnpm-config.json\n              If user set resolution-mode in .npmrc only, do nothing, let pnpm handle it\n              If user does not set resolution-mode in pnpm-config.json and .npmrc, rush will default it to \"highest\"\n            */\n            const isResolutionModeInNpmrc = isVariableSetInNpmrcFile(this.rushConfiguration.commonRushConfigFolder, 'resolution-mode');\n            let resolutionMode = this.rushConfiguration.pnpmOptions.resolutionMode;\n            if (resolutionMode) {\n                if (isResolutionModeInNpmrc) {\n                    this._terminal.writeWarningLine(`Warning: PNPM's resolution-mode is specified in both .npmrc and pnpm-config.json. ` +\n                        `The value in pnpm-config.json will take precedence.`);\n                }\n            }\n            else if (!isResolutionModeInNpmrc) {\n                // if resolution-mode isn't specified in either .npmrc or pnpm-config.json,\n                // then rush will default it to \"highest\"\n                resolutionMode = 'highest';\n            }\n            if (resolutionMode) {\n                args.push(`--config.resolutionMode=${resolutionMode}`);\n            }\n            if (semver.satisfies(this.rushConfiguration.packageManagerToolVersion, '6.32.12 - 6.33.x || 7.0.1 - 7.8.x')) {\n                this._terminal.writeWarningLine('Warning: Your rush.json specifies a pnpmVersion with a known issue ' +\n                    'that may cause unintended version selections.' +\n                    \" It's recommended to upgrade to PNPM >=6.34.0 or >=7.9.0. \" +\n                    'For details see: https://rushjs.io/link/pnpm-issue-5132');\n            }\n            if (semver.gte(this.rushConfiguration.packageManagerToolVersion, '7.9.0') ||\n                semver.satisfies(this.rushConfiguration.packageManagerToolVersion, '^6.34.0')) {\n                args.push(pnpmIgnoreCompatibilityDbParameter);\n            }\n        }\n        else if (this.rushConfiguration.packageManager === 'yarn') {\n            args.push('--link-folder', 'yarn-link');\n            args.push('--cache-folder', this.rushConfiguration.yarnCacheFolder);\n            // Without this option, Yarn will sometimes stop and ask for user input on STDIN\n            // (e.g. \"Which command would you like to run?\").\n            args.push('--non-interactive');\n            if (options.networkConcurrency) {\n                args.push('--network-concurrency', options.networkConcurrency.toString());\n            }\n            if (this.rushConfiguration.yarnOptions.ignoreEngines) {\n                args.push('--ignore-engines');\n            }\n            if (options.collectLogFile) {\n                args.push('--verbose');\n            }\n        }\n    }\n    async _checkIfReleaseIsPublished() {\n        const lastCheckFile = path.join(this.rushGlobalFolder.nodeSpecificPath, 'rush-' + Rush.version, 'last-check.flag');\n        if (FileSystem.exists(lastCheckFile)) {\n            let cachedResult = undefined;\n            try {\n                // NOTE: mtimeMs is not supported yet in Node.js 6.x\n                const nowMs = new Date().getTime();\n                const ageMs = nowMs - FileSystem.getStatistics(lastCheckFile).mtime.getTime();\n                const HOUR = 60 * 60 * 1000;\n                // Is the cache too old?\n                if (ageMs < 24 * HOUR) {\n                    // No, read the cached result\n                    cachedResult = JsonFile.load(lastCheckFile);\n                }\n            }\n            catch (e) {\n                // Unable to parse file\n            }\n            if (cachedResult === 'error') {\n                throw new Error('Unable to contact server');\n            }\n            if (cachedResult === true || cachedResult === false) {\n                return cachedResult;\n            }\n        }\n        // Before we start the network operation, record a failed state.  If the process exits for some reason,\n        // this will record the error.  It will also update the timestamp to prevent other Rush instances\n        // from attempting to update the file.\n        await JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });\n        try {\n            // For this check we use the official registry, not the private registry\n            const publishedRelease = await this._queryIfReleaseIsPublishedAsync('https://registry.npmjs.org:443');\n            // Cache the result\n            await JsonFile.saveAsync(publishedRelease, lastCheckFile, { ensureFolderExists: true });\n            return publishedRelease;\n        }\n        catch (error) {\n            await JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });\n            throw error;\n        }\n    }\n    // Helper for checkIfReleaseIsPublished()\n    async _queryIfReleaseIsPublishedAsync(registryUrl) {\n        let queryUrl = registryUrl;\n        if (queryUrl[-1] !== '/') {\n            queryUrl += '/';\n        }\n        // Note that the \"@\" symbol does not normally get URL-encoded\n        queryUrl += RushConstants.rushPackageName.replace('/', '%2F');\n        const webClient = new WebClient();\n        webClient.userAgent = `pnpm/? npm/? node/${process.version} ${os.platform()} ${os.arch()}`;\n        webClient.accept = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\n        const response = await webClient.fetchAsync(queryUrl);\n        if (!response.ok) {\n            throw new Error('Failed to query');\n        }\n        const data = await response.json();\n        let url;\n        try {\n            if (!data.versions[Rush.version]) {\n                // Version was not published\n                return false;\n            }\n            url = data.versions[Rush.version].dist.tarball;\n            if (!url) {\n                throw new Error(`URL not found`);\n            }\n        }\n        catch (e) {\n            throw new Error('Error parsing response');\n        }\n        // Make sure the tarball wasn't deleted from the CDN\n        webClient.accept = '*/*';\n        const response2 = await webClient.fetchAsync(url);\n        if (!response2.ok) {\n            if (response2.status === 404) {\n                return false;\n            }\n            else {\n                throw new Error('Failed to fetch');\n            }\n        }\n        return true;\n    }\n    _syncTempShrinkwrap(shrinkwrapFile) {\n        if (shrinkwrapFile) {\n            Utilities.syncFile(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant), this.rushConfiguration.tempShrinkwrapFilename);\n            Utilities.syncFile(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant), this.rushConfiguration.tempShrinkwrapPreinstallFilename);\n        }\n        else {\n            // Otherwise delete the temporary file\n            FileSystem.deleteFile(this.rushConfiguration.tempShrinkwrapFilename);\n            if (this.rushConfiguration.packageManager === 'pnpm') {\n                // Workaround for https://github.com/pnpm/pnpm/issues/1890\n                //\n                // When \"rush update --full\" is run, Rush deletes \"common/temp/pnpm-lock.yaml\"\n                // so that a new lockfile will be generated. However \"pnpm install\" by design will try to recover\n                // \"pnpm-lock.yaml\" from \"common/temp/node_modules/.pnpm/lock.yaml\", which may prevent a full upgrade.\n                // Deleting both files ensures that a new lockfile will always be generated.\n                const pnpmPackageManager = this.rushConfiguration\n                    .packageManagerWrapper;\n                FileSystem.deleteFile(path.join(this.rushConfiguration.commonTempFolder, pnpmPackageManager.internalShrinkwrapRelativePath));\n            }\n        }\n    }\n    async validateNpmSetup() {\n        if (this._npmSetupValidated) {\n            return;\n        }\n        if (!this.options.bypassPolicy) {\n            const setupPackageRegistry = new SetupPackageRegistry({\n                rushConfiguration: this.rushConfiguration,\n                isDebug: this.options.debug,\n                syncNpmrcAlreadyCalled: this._syncNpmrcAlreadyCalled\n            });\n            const valid = await setupPackageRegistry.checkOnly();\n            if (!valid) {\n                // eslint-disable-next-line no-console\n                console.error();\n                // eslint-disable-next-line no-console\n                console.error(colors.red('ERROR: NPM credentials are missing or expired'));\n                // eslint-disable-next-line no-console\n                console.error();\n                // eslint-disable-next-line no-console\n                console.error(colors.bold('==> Please run \"rush setup\" to update your NPM token. ' +\n                    `(Or append \"${RushConstants.bypassPolicyFlagLongName}\" to proceed anyway.)`));\n                throw new AlreadyReportedError();\n            }\n        }\n        this._npmSetupValidated = true;\n    }\n}\n//# sourceMappingURL=BaseInstallManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem } from '@rushstack/node-core-library';\n/**\n * This class is a parser for pnpm's pnpm-workspace.yaml file format.\n */\nexport class BaseWorkspaceFile {\n    constructor() {\n        this._alreadyWarnedSpecs = new Set();\n    }\n    /**\n     * Serializes and saves the workspace file to specified location\n     */\n    save(filePath, options) {\n        // Do we need to read the previous file contents?\n        let oldBuffer = undefined;\n        if (options.onlyIfChanged && FileSystem.exists(filePath)) {\n            try {\n                oldBuffer = FileSystem.readFileToBuffer(filePath);\n            }\n            catch (error) {\n                // Ignore this error, and try writing a new file.  If that fails, then we should report that\n                // error instead.\n            }\n        }\n        const newYaml = this.serialize();\n        const newBuffer = Buffer.from(newYaml); // utf8 encoding happens here\n        if (options.onlyIfChanged) {\n            // Has the file changed?\n            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\n                // Nothing has changed, so don't touch the file\n                return;\n            }\n        }\n        FileSystem.writeFile(filePath, newBuffer.toString(), {\n            ensureFolderExists: options.ensureFolderExists\n        });\n    }\n}\n//# sourceMappingURL=BaseWorkspaceFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, FileConstants, AlreadyReportedError, Async } from '@rushstack/node-core-library';\nimport { BaseInstallManager } from '../base/BaseInstallManager';\nimport { DependencySpecifier, DependencySpecifierType } from '../DependencySpecifier';\nimport { DependencyType } from '../../api/PackageJsonEditor';\nimport { PnpmWorkspaceFile } from '../pnpm/PnpmWorkspaceFile';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { Utilities } from '../../utilities/Utilities';\nimport { InstallHelpers } from './InstallHelpers';\nimport { LastLinkFlagFactory } from '../../api/LastLinkFlag';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport { PNPM_CUSTOM_TIPS } from '../../api/CustomTipsConfiguration';\n/**\n * This class implements common logic between \"rush install\" and \"rush update\".\n */\nexport class WorkspaceInstallManager extends BaseInstallManager {\n    /**\n     * @override\n     */\n    async doInstallAsync() {\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        if (this.options.noLink) {\n            // eslint-disable-next-line no-console\n            console.log(colors.red('The \"--no-link\" option was provided but is not supported when using workspaces. Run the command again ' +\n                'without specifying this argument.'));\n            throw new AlreadyReportedError();\n        }\n        await super.doInstallAsync();\n    }\n    /**\n     * Regenerates the common/temp/package.json and related workspace files.\n     * If shrinkwrapFile is provided, this function also validates whether it contains\n     * everything we need to install and returns true if so; in all other cases,\n     * the return value is false.\n     *\n     * @override\n     */\n    async prepareCommonTempAsync(shrinkwrapFile) {\n        // Block use of the RUSH_TEMP_FOLDER environment variable\n        if (EnvironmentConfiguration.rushTempFolderOverride !== undefined) {\n            throw new Error('The RUSH_TEMP_FOLDER environment variable is not compatible with workspace installs. If attempting ' +\n                'to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.');\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + colors.bold('Updating workspace files in ' + this.rushConfiguration.commonTempFolder));\n        const shrinkwrapWarnings = [];\n        // We will start with the assumption that it's valid, and then set it to false if\n        // any of the checks fail\n        let shrinkwrapIsUpToDate = true;\n        if (!shrinkwrapFile) {\n            shrinkwrapIsUpToDate = false;\n        }\n        else {\n            if (!shrinkwrapFile.isWorkspaceCompatible && !this.options.fullUpgrade) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(colors.red('The shrinkwrap file has not been updated to support workspaces. Run \"rush update --full\" to update ' +\n                    'the shrinkwrap file.'));\n                throw new AlreadyReportedError();\n            }\n            // If there are orphaned projects, we need to update\n            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration);\n            if (orphanedProjects.length > 0) {\n                for (const orhpanedProject of orphanedProjects) {\n                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references \"${orhpanedProject}\" ` +\n                        'which was not found in rush.json');\n                }\n                shrinkwrapIsUpToDate = false;\n            }\n        }\n        // If preferred versions have been updated, or if the repo-state.json is invalid,\n        // we can't be certain of the state of the shrinkwrap\n        const repoState = this.rushConfiguration.getRepoState(this.options.variant);\n        if (!repoState.isValid) {\n            shrinkwrapWarnings.push(`The ${RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker in the file.`);\n            shrinkwrapIsUpToDate = false;\n        }\n        else {\n            const commonVersions = this.rushConfiguration.getCommonVersions(this.options.variant);\n            if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {\n                shrinkwrapWarnings.push(`Preferred versions from ${RushConstants.commonVersionsFilename} have been modified.`);\n                shrinkwrapIsUpToDate = false;\n            }\n        }\n        // To generate the workspace file, we will add each project to the file as we loop through and validate\n        const workspaceFile = new PnpmWorkspaceFile(path.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml'));\n        // Loop through the projects and add them to the workspace file. While we're at it, also validate that\n        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.\n        for (const rushProject of this.rushConfiguration.projects) {\n            const packageJson = rushProject.packageJsonEditor;\n            workspaceFile.addPackage(rushProject.projectFolder);\n            for (const { name, version, dependencyType } of [\n                ...packageJson.dependencyList,\n                ...packageJson.devDependencyList\n            ]) {\n                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint\n                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint\n                // and do not need to be converted to workspaces protocol.\n                if (dependencyType === DependencyType.Peer) {\n                    continue;\n                }\n                const dependencySpecifier = new DependencySpecifier(name, version);\n                // Is there a locally built Rush project that could satisfy this dependency?\n                const referencedLocalProject = this.rushConfiguration.getProjectByName(name);\n                // Validate that local projects are referenced with workspace notation. If not, and it is not a\n                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only\n                // supporting versions and version ranges for specifying a local project.\n                if ((dependencySpecifier.specifierType === DependencySpecifierType.Version ||\n                    dependencySpecifier.specifierType === DependencySpecifierType.Range) &&\n                    referencedLocalProject &&\n                    !rushProject.decoupledLocalDependencies.has(name)) {\n                    // Make sure that this version is intended to target a local package. If not, then we will fail since it\n                    // is not explicitly specified as a cyclic dependency.\n                    if (!semver.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {\n                        // eslint-disable-next-line no-console\n                        console.log();\n                        // eslint-disable-next-line no-console\n                        console.log(colors.red(`\"${rushProject.packageName}\" depends on package \"${name}\" (${version}) which exists ` +\n                            'within the workspace but cannot be fulfilled with the specified version range. Either ' +\n                            'specify a valid version range, or add the package as a cyclic dependency.'));\n                        throw new AlreadyReportedError();\n                    }\n                    if (!this.options.allowShrinkwrapUpdates) {\n                        // eslint-disable-next-line no-console\n                        console.log();\n                        // eslint-disable-next-line no-console\n                        console.log(colors.red(`\"${rushProject.packageName}\" depends on package \"${name}\" (${version}) which exists within ` +\n                            'the workspace. Run \"rush update\" to update workspace references for this package.'));\n                        throw new AlreadyReportedError();\n                    }\n                    if (this.options.fullUpgrade) {\n                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.\n                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.\n                        const workspaceRange = !!semver.validRange(dependencySpecifier.versionSpecifier) &&\n                            !semver.valid(dependencySpecifier.versionSpecifier)\n                            ? dependencySpecifier.versionSpecifier\n                            : '*';\n                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);\n                        shrinkwrapIsUpToDate = false;\n                        continue;\n                    }\n                }\n                else if (dependencySpecifier.specifierType === DependencySpecifierType.Workspace) {\n                    // Already specified as a local project. Allow the package manager to validate this\n                    continue;\n                }\n            }\n            // Save the package.json if we modified the version references and warn that the package.json was modified\n            if (packageJson.saveIfModified()) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow(`\"${rushProject.packageName}\" depends on one or more workspace packages which did not use \"workspace:\" ` +\n                    'notation. The package.json has been modified and must be committed to source control.'));\n            }\n            // Now validate that the shrinkwrap file matches what is in the package.json\n            if (await (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.isWorkspaceProjectModifiedAsync(rushProject, this.options.variant))) {\n                shrinkwrapWarnings.push(`Dependencies of project \"${rushProject.packageName}\" do not match the current shrinkwrap.`);\n                shrinkwrapIsUpToDate = false;\n            }\n        }\n        // Write the common package.json\n        InstallHelpers.generateCommonPackageJson(this.rushConfiguration);\n        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,\n        // since \"rush install\" will consider this timestamp\n        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });\n        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };\n    }\n    canSkipInstall(lastModifiedDate) {\n        if (!super.canSkipInstall(lastModifiedDate)) {\n            return false;\n        }\n        const potentiallyChangedFiles = [];\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            // Add workspace file. This file is only modified when workspace packages change.\n            const pnpmWorkspaceFilename = path.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml');\n            if (FileSystem.exists(pnpmWorkspaceFilename)) {\n                potentiallyChangedFiles.push(pnpmWorkspaceFilename);\n            }\n        }\n        // Also consider timestamps for all the project node_modules folders, as well as the package.json\n        // files\n        // Example: [ \"C:\\MyRepo\\projects\\projectA\\node_modules\", \"C:\\MyRepo\\projects\\projectA\\package.json\" ]\n        potentiallyChangedFiles.push(...this.rushConfiguration.projects.map((project) => {\n            return path.join(project.projectFolder, RushConstants.nodeModulesFolderName);\n        }), ...this.rushConfiguration.projects.map((project) => {\n            return path.join(project.projectFolder, FileConstants.PackageJson);\n        }));\n        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()\n        // returns false.\n        return Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);\n    }\n    /**\n     * Runs \"npm install\" in the common folder.\n     */\n    async installAsync(cleanInstall) {\n        // Example: \"C:\\MyRepo\\common\\temp\\npm-local\\node_modules\\.bin\\npm\"\n        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;\n        const packageManagerEnv = InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);\n        const commonNodeModulesFolder = path.join(this.rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName);\n        // Is there an existing \"node_modules\" folder to consider?\n        if (FileSystem.exists(commonNodeModulesFolder)) {\n            // Should we delete the entire \"node_modules\" folder?\n            if (cleanInstall) {\n                // YES: Delete \"node_modules\"\n                // Explain to the user why we are hosing their node_modules folder\n                // eslint-disable-next-line no-console\n                console.log('Deleting files from ' + commonNodeModulesFolder);\n                this.installRecycler.moveFolder(commonNodeModulesFolder);\n                Utilities.createFolderWithRetry(commonNodeModulesFolder);\n            }\n        }\n        const doInstallInternalAsync = async (options) => {\n            // Run \"npm install\" in the common folder\n            // To ensure that the output is always colored, set the option \"--color=always\", even when it's piped.\n            // Without this argument, certain text that should be colored (such as red) will appear white.\n            const installArgs = ['install', '--color=always'];\n            this.pushConfigurationArgs(installArgs, options);\n            // eslint-disable-next-line no-console\n            console.log('\\n' +\n                colors.bold(`Running \"${this.rushConfiguration.packageManager} install\" in` +\n                    ` ${this.rushConfiguration.commonTempFolder}`) +\n                '\\n');\n            // If any diagnostic options were specified, then show the full command-line\n            if (this.options.debug ||\n                this.options.collectLogFile ||\n                this.options.networkConcurrency ||\n                this.options.onlyShrinkwrap) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    colors.green('Invoking package manager: ') +\n                    FileSystem.getRealPath(packageManagerFilename) +\n                    ' ' +\n                    installArgs.join(' ') +\n                    '\\n');\n            }\n            // Store the tip IDs that should be printed.\n            // They will be printed all at once *after* the install\n            const tipIDsToBePrinted = new Set();\n            const pnpmTips = [];\n            for (const [customTipId, customTip] of Object.entries(PNPM_CUSTOM_TIPS)) {\n                if (this.rushConfiguration.customTipsConfiguration.providedCustomTipsByTipId.has(customTipId)) {\n                    pnpmTips.push(customTip);\n                }\n            }\n            const onPnpmStdoutChunk = pnpmTips.length > 0\n                ? (chunk) => {\n                    // Iterate over the supported custom tip metadata and try to match the chunk.\n                    for (const { isMatch, tipId } of pnpmTips) {\n                        if (isMatch === null || isMatch === void 0 ? void 0 : isMatch(chunk)) {\n                            tipIDsToBePrinted.add(tipId);\n                        }\n                    }\n                }\n                : undefined;\n            try {\n                await Utilities.executeCommandAndProcessOutputWithRetryAsync({\n                    command: packageManagerFilename,\n                    args: installArgs,\n                    workingDirectory: this.rushConfiguration.commonTempFolder,\n                    environment: packageManagerEnv,\n                    suppressOutput: false\n                }, this.options.maxInstallAttempts, onPnpmStdoutChunk, () => {\n                    if (this.rushConfiguration.packageManager === 'pnpm') {\n                        this._terminal.writeWarningLine(`Deleting the \"node_modules\" folder`);\n                        this.installRecycler.moveFolder(commonNodeModulesFolder);\n                        // Leave the pnpm-store as is for the retry. This ensures that packages that have already\n                        // been downloaded need not be downloaded again, thereby potentially increasing the chances\n                        // of a subsequent successful install.\n                        Utilities.createFolderWithRetry(commonNodeModulesFolder);\n                    }\n                });\n            }\n            finally {\n                // The try-finally is to avoid the tips NOT being printed if the install fails.\n                // NOT catching the error because we want to keep the other behaviors (i.e., the error will be caught and handle in upper layers).\n                if (tipIDsToBePrinted.size > 0) {\n                    this._terminal.writeLine();\n                    for (const tipID of tipIDsToBePrinted) {\n                        this.rushConfiguration.customTipsConfiguration._showTip(this._terminal, tipID);\n                    }\n                }\n            }\n        };\n        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n        if (this.options.allowShrinkwrapUpdates &&\n            experiments.usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate) {\n            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { onlyShrinkwrap: true }));\n            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { allowShrinkwrapUpdates: false }));\n        }\n        else {\n            await doInstallInternalAsync(this.options);\n        }\n        // If all attempts fail we just terminate. No special handling needed.\n        // Ensure that node_modules folders exist after install, since the timestamps on these folders are used\n        // to determine if the install can be skipped\n        const projectNodeModulesFolders = [\n            path.join(this.rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName),\n            ...this.rushConfiguration.projects.map((project) => {\n                return path.join(project.projectFolder, RushConstants.nodeModulesFolderName);\n            })\n        ];\n        for (const nodeModulesFolder of projectNodeModulesFolders) {\n            FileSystem.ensureFolder(nodeModulesFolder);\n        }\n        // eslint-disable-next-line no-console\n        console.log('');\n    }\n    async postInstallAsync() {\n        var _a;\n        // Grab the temp shrinkwrap, as this was the most recently completed install. It may also be\n        // more up-to-date than the checked-in shrinkwrap since filtered installs are not written back.\n        // Note that if there are no projects, or if we're in PNPM workspace mode and there are no\n        // projects with dependencies, a lockfile won't be generated.\n        const tempShrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.pnpmOptions, this.rushConfiguration.tempShrinkwrapFilename);\n        if (tempShrinkwrapFile) {\n            // Write or delete all project shrinkwraps related to the install\n            await Async.forEachAsync(this.rushConfiguration.projects, async (project) => {\n                var _a;\n                await ((_a = tempShrinkwrapFile.getProjectShrinkwrap(project)) === null || _a === void 0 ? void 0 : _a.updateProjectShrinkwrapAsync());\n            }, { concurrency: 10 });\n        }\n        else if (this.rushConfiguration.packageManager === 'pnpm' &&\n            ((_a = this.rushConfiguration.pnpmOptions) === null || _a === void 0 ? void 0 : _a.useWorkspaces)) {\n            // If we're in PNPM workspace mode and PNPM didn't create a shrinkwrap file,\n            // there are no dependencies. Generate empty shrinkwrap files for all projects.\n            await Async.forEachAsync(this.rushConfiguration.projects, async (project) => {\n                await BaseProjectShrinkwrapFile.saveEmptyProjectShrinkwrapFileAsync(project);\n            }, { concurrency: 10 });\n        }\n        else {\n            // This is an unexpected case\n            throw new Error('A shrinkwrap file does not exist after after successful installation. This probably indicates a ' +\n                'bug in the package manager.');\n        }\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration).create();\n    }\n    /**\n     * Used when invoking the NPM tool.  Appends the common configuration options\n     * to the command-line.\n     */\n    pushConfigurationArgs(args, options) {\n        super.pushConfigurationArgs(args, options);\n        // Add workspace-specific args\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            args.push('--recursive');\n            args.push('--link-workspace-packages', 'false');\n            if (process.stdout.isTTY) {\n                // If we're on a TTY console and something else didn't set a `--reporter` parameter,\n                // explicitly set the default reporter. This fixes an issue where, when the pnpm\n                // output is being monitored to match custom tips, pnpm will detect a non-TTY\n                // stdout stream and use the `append-only` reporter.\n                //\n                // See docs here: https://pnpm.io/cli/install#--reportername\n                let includesReporterArg = false;\n                for (const arg of args) {\n                    if (arg.startsWith('--reporter')) {\n                        includesReporterArg = true;\n                        break;\n                    }\n                }\n                if (!includesReporterArg) {\n                    args.push('--reporter', 'default');\n                }\n            }\n            for (const arg of this.options.pnpmFilterArguments) {\n                args.push(arg);\n            }\n        }\n    }\n}\n//# sourceMappingURL=WorkspaceInstallManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Sort, Import, Path } from '@rushstack/node-core-library';\nimport { BaseWorkspaceFile } from '../base/BaseWorkspaceFile';\nimport { PNPM_SHRINKWRAP_YAML_FORMAT } from './PnpmYamlCommon';\nconst yamlModule = Import.lazy('js-yaml', require);\nconst globEscape = require('glob-escape'); // No @types/glob-escape package exists\nexport class PnpmWorkspaceFile extends BaseWorkspaceFile {\n    /**\n     * The PNPM workspace file is used to specify the location of workspaces relative to the root\n     * of your PNPM install.\n     */\n    constructor(workspaceYamlFilename) {\n        super();\n        this.workspaceFilename = workspaceYamlFilename;\n        // Ignore any existing file since this file is generated and we need to handle deleting packages\n        // If we need to support manual customization, that should be an additional parameter for \"base file\"\n        this._workspacePackages = new Set();\n    }\n    /** @override */\n    addPackage(packagePath) {\n        // Ensure the path is relative to the pnpm-workspace.yaml file\n        if (path.isAbsolute(packagePath)) {\n            packagePath = path.relative(path.dirname(this.workspaceFilename), packagePath);\n        }\n        // Glob can't handle Windows paths\n        const globPath = Path.convertToSlashes(packagePath);\n        this._workspacePackages.add(globEscape(globPath));\n    }\n    /** @override */\n    serialize() {\n        // Ensure stable sort order when serializing\n        Sort.sortSet(this._workspacePackages);\n        const workspaceYaml = {\n            packages: Array.from(this._workspacePackages)\n        };\n        return yamlModule.safeDump(workspaceYaml, PNPM_SHRINKWRAP_YAML_FORMAT);\n    }\n}\n//# sourceMappingURL=PnpmWorkspaceFile.js.map"],"names":[],"sourceRoot":""}