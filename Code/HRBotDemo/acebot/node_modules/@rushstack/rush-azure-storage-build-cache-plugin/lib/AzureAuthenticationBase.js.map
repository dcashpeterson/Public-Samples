{"version":3,"file":"AzureAuthenticationBase.js","sourceRoot":"","sources":["../src/AzureAuthenticationBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { DeviceCodeCredential, type DeviceCodeInfo, AzureAuthorityHosts } from '@azure/identity';\nimport type { ITerminal } from '@rushstack/node-core-library';\nimport { CredentialCache } from '@rushstack/rush-sdk';\n// Use a separate import line so the .d.ts file ends up with an `import type { ... }`\n// See https://github.com/microsoft/rushstack/issues/3432\nimport type { ICredentialCacheEntry } from '@rushstack/rush-sdk';\nimport { PrintUtilities } from '@rushstack/terminal';\n\n/**\n * @public\n */\nexport type ExpiredCredentialBehavior = 'logWarning' | 'throwError' | 'ignore';\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsBase {\n  /**\n   * The behavior to take when the cached credential has expired.\n   * Defaults to 'throwError'\n   */\n  expiredCredentialBehavior?: ExpiredCredentialBehavior;\n  terminal?: ITerminal;\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsLogWarning extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'logWarning';\n  terminal: ITerminal;\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsThrow extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'throwError';\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsIgnore extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'ignore';\n}\n\nexport type ITryGetCachedCredentialOptions =\n  | ITryGetCachedCredentialOptionsLogWarning\n  | ITryGetCachedCredentialOptionsThrow\n  | ITryGetCachedCredentialOptionsIgnore;\n\n/**\n * @public\n */\nexport type AzureEnvironmentName = keyof typeof AzureAuthorityHosts;\n\n/**\n * @public\n */\nexport interface IAzureAuthenticationBaseOptions {\n  azureEnvironment?: AzureEnvironmentName;\n  credentialUpdateCommandForLogging?: string | undefined;\n}\n\n/**\n * @public\n */ export interface ICredentialResult {\n  credentialString: string;\n  expiresOn?: Date;\n  credentialMetadata?: object;\n}\n\n/**\n * @public\n */\nexport abstract class AzureAuthenticationBase {\n  protected abstract readonly _credentialNameForCache: string;\n  protected abstract readonly _credentialKindForLogging: string;\n  protected readonly _credentialUpdateCommandForLogging: string | undefined;\n\n  protected readonly _azureEnvironment: AzureEnvironmentName;\n\n  private __credentialCacheId: string | undefined;\n  private get _credentialCacheId(): string {\n    if (!this.__credentialCacheId) {\n      const cacheIdParts: string[] = [\n        this._credentialNameForCache,\n        this._azureEnvironment,\n        ...this._getCacheIdParts()\n      ];\n\n      this.__credentialCacheId = cacheIdParts.join('|');\n    }\n\n    return this.__credentialCacheId;\n  }\n\n  public constructor(options: IAzureAuthenticationBaseOptions) {\n    this._azureEnvironment = options.azureEnvironment || 'AzurePublicCloud';\n    this._credentialUpdateCommandForLogging = options.credentialUpdateCommandForLogging;\n  }\n\n  public async updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.setCacheEntry(this._credentialCacheId, {\n          credential\n        });\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  /**\n   * Launches an interactive flow to renew a cached credential.\n   *\n   * @param terminal - The terminal to log output to\n   * @param onlyIfExistingCredentialExpiresAfter - If specified, and a cached credential exists that is still valid\n   * after the date specified, no action will be taken.\n   */\n  public async updateCachedCredentialInteractiveAsync(\n    terminal: ITerminal,\n    onlyIfExistingCredentialExpiresAfter?: Date\n  ): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        if (onlyIfExistingCredentialExpiresAfter) {\n          const existingCredentialExpiration: Date | undefined = credentialsCache.tryGetCacheEntry(\n            this._credentialCacheId\n          )?.expires;\n          if (\n            existingCredentialExpiration &&\n            existingCredentialExpiration > onlyIfExistingCredentialExpiresAfter\n          ) {\n            return;\n          }\n        }\n\n        const credential: ICredentialResult = await this._getCredentialAsync(terminal);\n        credentialsCache.setCacheEntry(this._credentialCacheId, {\n          credential: credential.credentialString,\n          expires: credential.expiresOn,\n          credentialMetadata: credential.credentialMetadata\n        });\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  public async deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.deleteCacheEntry(this._credentialCacheId);\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  public async tryGetCachedCredentialAsync(\n    options?: ITryGetCachedCredentialOptionsThrow | ITryGetCachedCredentialOptionsIgnore\n  ): Promise<ICredentialCacheEntry | undefined>;\n  public async tryGetCachedCredentialAsync(\n    options: ITryGetCachedCredentialOptionsLogWarning\n  ): Promise<ICredentialCacheEntry | undefined>;\n  public async tryGetCachedCredentialAsync(\n    { expiredCredentialBehavior, terminal }: ITryGetCachedCredentialOptions = {\n      expiredCredentialBehavior: 'throwError'\n    }\n  ): Promise<ICredentialCacheEntry | undefined> {\n    let cacheEntry: ICredentialCacheEntry | undefined;\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: false\n      },\n      (credentialsCache: CredentialCache) => {\n        cacheEntry = credentialsCache.tryGetCacheEntry(this._credentialCacheId);\n      }\n    );\n\n    const expirationTime: number | undefined = cacheEntry?.expires?.getTime();\n    if (expirationTime && expirationTime < Date.now()) {\n      if (expiredCredentialBehavior === 'logWarning' || expiredCredentialBehavior === 'throwError') {\n        let errorMessage: string = `Cached Azure ${this._credentialKindForLogging} credentials have expired.`;\n        if (this._credentialUpdateCommandForLogging) {\n          errorMessage += ` Update the credentials by running \"${this._credentialUpdateCommandForLogging}\".`;\n        }\n\n        if (expiredCredentialBehavior === 'logWarning') {\n          terminal.writeWarningLine(errorMessage);\n        } else if (expiredCredentialBehavior === 'throwError') {\n          throw new Error(errorMessage);\n        }\n      }\n\n      return undefined;\n    } else {\n      return cacheEntry;\n    }\n  }\n\n  /**\n   * Get parts of the cache ID that are specific to the credential type. Note that this should\n   * not contain the Azure environment or the {@link AzureAuthenticationBase._credentialNameForCache}\n   * value, as those are added automatically.\n   */\n  protected abstract _getCacheIdParts(): string[];\n\n  protected abstract _getCredentialFromDeviceCodeAsync(\n    terminal: ITerminal,\n    deviceCodeCredential: DeviceCodeCredential\n  ): Promise<ICredentialResult>;\n\n  private async _getCredentialAsync(terminal: ITerminal): Promise<ICredentialResult> {\n    const authorityHost: string | undefined = AzureAuthorityHosts[this._azureEnvironment];\n    if (!authorityHost) {\n      throw new Error(`Unexpected Azure environment: ${this._azureEnvironment}`);\n    }\n\n    const deviceCodeCredential: DeviceCodeCredential = new DeviceCodeCredential({\n      authorityHost: authorityHost,\n      userPromptCallback: (deviceCodeInfo: DeviceCodeInfo) => {\n        PrintUtilities.printMessageInBox(deviceCodeInfo.message, terminal);\n      }\n    });\n\n    return await this._getCredentialFromDeviceCodeAsync(terminal, deviceCodeCredential);\n  }\n}\n"]}