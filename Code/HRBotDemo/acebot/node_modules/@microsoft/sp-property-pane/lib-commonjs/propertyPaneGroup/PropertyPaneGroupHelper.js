"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFixedUpDynamicProperty = exports.getFixedUpPropValue = exports.generateGroupFieldKey = void 0;
var tslib_1 = require("tslib");
var sp_component_base_1 = require("@microsoft/sp-component-base");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var lodash = tslib_1.__importStar(require("@microsoft/sp-lodash-subset"));
var IPropertyPaneField_1 = require("../propertyPaneFields/propertyPaneField/IPropertyPaneField");
/**
 * React requires a key to be set for each item in the collection.
 *
 * Key should be unique and consistent. With the way PropertyPane works today, it's very difficult to ensure the
 * consistency of the keys all the time. The only way we can achieve consistency all the time is when the web part
 * developer supplies a unique key with each field. From the framework standpoint, we did not want to keep the onus
 * of sending in the unique key with the web part developers. We are keeping it simple. Hence, solving the problem
 * for most of the cases. Uniqueness is obtained by maintaining a dictionary of keys.
 *
 * Choosing 'type' and 'targetProperty' as the key ensures that in most of the cases consistency is achieved.
 * This is because every field will have an associated target property or 'key' for CustomField.
 * For the corner cases where there is no targetProperty or same targetProperty is assigned to multiple fields,
 * we are generating a key appended by index.
 *
 * This will result in a compromised performance, but not very noticeable and hence we are okay with it.
 * If we can think of any better and simple solution to keep the consistency, we will revisit this logic.
 */
function generateGroupFieldKey(keys, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
groupField) {
    var key = '';
    if (groupField.type === IPropertyPaneField_1.PropertyPaneFieldType.Custom) {
        sp_core_library_1.Validate.isNonemptyString(groupField.properties.key, 'Custom field key');
        // CustomField uses `key` instead of `targetProperty`.
        // Adding group field type as prefix to avoid keys being messed up with keys from different control type.
        var customField = groupField;
        key = "".concat(customField.type, "-").concat(customField.properties.key);
    }
    else {
        // Non-custom fields
        key = "".concat(groupField.type, "-").concat(groupField.targetProperty || '');
    }
    // Append the smallest unused index to the key and update the index.
    // @example
    // If two CustomField controls have same properties.key such as 'sampleKey'. Their final key generated will
    // be '1-sampleKey-0' and '1-sampleKey-1'. The prefix '1' represents the control type is CustomField.
    // The suffix '0' and '1' are indexes determined by the order they appear in PropertyPaneConfiguration.
    var keyIndex = keys[key] || 0;
    keys[key] = keyIndex + 1;
    key += "-".concat(keyIndex);
    return key;
}
exports.generateGroupFieldKey = generateGroupFieldKey;
/**
 * This method does the following things to fix up the propValue:
 * If the group field is a DynamicFieldSet then,
 *    - It creates a map of targetProperty and its fixed up dynamic property.
 *    - For each entry of the set,
 *      - it will extract the propValue from the properties and
 *      - check if the propValue is of type 'DynamicProperty', if
 *        - Yes, its a NO-OP. Everything is good with propValue, no fixup required.
 *        - No, then using its static value, make the propValue a DynamicProperty
 *  else if the group field is a DynamicField then,
 *    - Will check if the propValue is of type 'DynamicProperty', if
 *      - Yes, its a NO-OP. Everything is good with propValue, no fixup required.
 *      - No, then using its static value, make the propValue a DynamicProperty
 *  else
 *    - Will check if the propValue is of type DynamicProperty, if
 *      - Yes, then extract the value out of the DynamicProperty and assign it as
 *        a static value. This case is possible, when the developers map an existing
 *        dynamic field to a non dynamic field.
 *      - No, then it's a NO-OP
 *
 * @param propertyPaneField - Group field reference.
 */
function getFixedUpPropValue(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
propertyPaneField, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
properties, dynamicConfiguration
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var fixedUpPropValue = lodash.get(properties, propertyPaneField.targetProperty);
    if (propertyPaneField.type === IPropertyPaneField_1.PropertyPaneFieldType.DynamicFieldSet) {
        // DynamicFieldSet
        var entries_1 = [];
        propertyPaneField.properties.fields.forEach(function (field) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var propValue = lodash.get(properties, field.targetProperty);
            entries_1.push({
                targetProperty: field.targetProperty,
                value: getFixedUpDynamicProperty(dynamicConfiguration, propValue),
                properties: field.properties
            });
        });
        fixedUpPropValue = entries_1;
    }
    else if (propertyPaneField.type === IPropertyPaneField_1.PropertyPaneFieldType.DynamicField) {
        // DynamicField
        var entry = {
            targetProperty: propertyPaneField.targetProperty,
            value: getFixedUpDynamicProperty(dynamicConfiguration, fixedUpPropValue),
            properties: propertyPaneField.properties
        };
        fixedUpPropValue = entry;
    }
    else {
        // Non dynamic field but the value is a DynamicProperty
        if (fixedUpPropValue instanceof sp_component_base_1.DynamicProperty) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            fixedUpPropValue = fixedUpPropValue.tryGetValue();
        }
    }
    return fixedUpPropValue;
}
exports.getFixedUpPropValue = getFixedUpPropValue;
/**
 * Checks if the propValue is of type 'DynamicProperty', if
 *  - Yes, its a NO-OP. Everything is good with propValue, no fixup required.
 *  - No, then using its static value, make the propValue a DynamicProperty
 *
 * @remarks
 * If the component provides a callback as part of the groupfield property's dynamicConfiguration
 * then we would take it else fall back to the defaultCallback of the component which is
 * provided by the framework. Example - BaseWebPart for web parts.
 *
 * @param dynamicConfiguration - dynamicConfiguration to be used.
 * @param propValue - propValue to be fixed.
 */
function getFixedUpDynamicProperty(dynamicConfiguration, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
propValue
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    var isDynamicProperty = propValue instanceof sp_component_base_1.DynamicProperty;
    if (!isDynamicProperty) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempPropValue = propValue;
        propValue = new sp_component_base_1.DynamicProperty(dynamicConfiguration.dynamicDataProvider, dynamicConfiguration.defaultCallback);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        propValue.setValue(tempPropValue);
    }
    return propValue;
}
exports.getFixedUpDynamicProperty = getFixedUpDynamicProperty;
//# sourceMappingURL=PropertyPaneGroupHelper.js.map