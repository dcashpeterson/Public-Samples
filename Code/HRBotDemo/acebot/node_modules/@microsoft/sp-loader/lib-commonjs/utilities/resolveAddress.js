"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var LocaleStore_1 = tslib_1.__importDefault(require("../stores/LocaleStore"));
var telemetryConstants = tslib_1.__importStar(require("./telemetryConstants"));
var Utilities_resx_1 = tslib_1.__importDefault(require("./Utilities.resx"));
/**
 * Given a manifest and a resource name returns the URL to the resource.
 *
 * For path or localizedPath dependencies, it returns the full URL to the resource.
 * For component dependencies, it returns the full URL to the failover path,
 * or returns an empty string if it doesn't exist.
 *
 * If the resource name is not present in the loader config, it throws an error.
 */
function resolveAddress(manifest, resourceName, useSecondaryCdn) {
    if (useSecondaryCdn === void 0) { useSecondaryCdn = false; }
    sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
    sp_core_library_1.Validate.isNonemptyString(resourceName, 'resourceName');
    if (!manifest.loaderConfig.scriptResources.hasOwnProperty(resourceName)) {
        var error = new Error(sp_core_library_1.Text.format(Utilities_resx_1.default.resourceNotFoundError, resourceName, manifest.id, manifest.alias));
        sp_diagnostics_1._TraceLogger.logError(telemetryConstants.resolveAddressLogSource, error);
        throw error;
    }
    var moduleConfiguration = manifest.loaderConfig.scriptResources[resourceName];
    var path = resolveModuleConfiguration(resourceName, moduleConfiguration);
    var address = path.path;
    // Prepend the base URL if this isn't a fully-qualified URL.
    if (!address.match(/^https?\:\/\//i)) {
        var moduleBaseUrl = manifest.loaderConfig.internalModuleBaseUrls[0];
        // Use the secondary CDN url if we have fallen back and the manifest contains the url
        if (manifest.isInternal && useSecondaryCdn) {
            var secondaryCdnUrl = manifest.loaderConfig.internalModuleBaseUrls[1];
            if (!secondaryCdnUrl) {
                sp_diagnostics_1._TraceLogger.logError(telemetryConstants.resolveAddressLogSource, new Error(telemetryConstants.noSecondaryCdnUrl), telemetryConstants.noSecondaryCdnUrl);
            }
            else {
                moduleBaseUrl = secondaryCdnUrl;
            }
        }
        // Replace this with shared URL concatenation logic. VSO#249681
        moduleBaseUrl = moduleBaseUrl.replace(/\/+$/, '');
        if (sp_core_library_1._SPFlight.isEnabled(60330 /* WEXShareLinkForTeamsMeetingApp */) &&
            moduleBaseUrl.indexOf("_api/v2.0/drives/") !== -1) {
            // We append :/content because drive urls return drive item metadata only
            // We append noext because requirejs appends js to all paths (normally we strip the js extension out).  By appending
            // the ?noext parameter it appends the .js to the query string parameter and the vroom url continues to work
            address += ":/content?noext=true";
        }
        address = "".concat(moduleBaseUrl, "/").concat(address);
    }
    return { path: address, integrity: path.integrity };
}
exports.default = resolveAddress;
/**
 * Resolves a IModuleConfiguration to a URL
 *
 * Take a look at the IModuleConfiguration documentation for more information.
 */
function resolveModuleConfiguration(moduleName, moduleConfiguration) {
    var path;
    if (moduleConfiguration) {
        switch (moduleConfiguration.type) {
            case 'component': {
                var failoverPath = moduleConfiguration.failoverPath;
                if (!failoverPath) {
                    throw new Error(Utilities_resx_1.default.noFailoverPathError);
                }
                path = failoverPath;
                break;
            }
            case 'path': {
                path = moduleConfiguration.path;
                break;
            }
            case 'localizedPath': {
                path = resolveLocalizedModuleConfiguration(moduleConfiguration);
                break;
            }
            case null:
            case undefined:
            default: {
                path = moduleName;
            }
        }
    }
    else {
        path = moduleName;
    }
    return resolveManifestPath(path);
}
/**
 * Resolves a localized module config to a path.
 */
function resolveLocalizedModuleConfiguration(moduleConfiguration) {
    // Workaround for temporary issue in SPOREL. VSO#279843
    var currentLocale = LocaleStore_1.default.getLocale();
    if (moduleConfiguration.paths) {
        // This only applies when testing production manifests without the server
        if (currentLocale) {
            for (var locale in moduleConfiguration.paths) {
                if (locale &&
                    locale.toUpperCase() === currentLocale.toUpperCase() &&
                    moduleConfiguration.paths[locale]) {
                    return moduleConfiguration.paths[locale];
                }
            }
        }
    }
    return moduleConfiguration.defaultPath;
}
function resolveManifestPath(path) {
    if (typeof path === 'string') {
        return {
            path: path
        };
    }
    else {
        return path;
    }
}
//# sourceMappingURL=resolveAddress.js.map