{"version":3,"file":"ConfigurationFile.js","sourceRoot":"","sources":["../src/ConfigurationFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as nodeJsPath from 'path';\nimport { JSONPath } from 'jsonpath-plus';\nimport {\n  JsonSchema,\n  JsonFile,\n  PackageJsonLookup,\n  Import,\n  FileSystem,\n  type ITerminal\n} from '@rushstack/node-core-library';\nimport type { IRigConfig } from '@rushstack/rig-package';\n\ninterface IConfigurationJson {\n  extends?: string;\n}\n\n/**\n * @beta\n */\nexport enum InheritanceType {\n  /**\n   * Append additional elements after elements from the parent file's property. Only applicable\n   * for arrays.\n   */\n  append = 'append',\n\n  /**\n   * Perform a shallow merge of additional elements after elements from the parent file's property.\n   * Only applicable for objects.\n   */\n  merge = 'merge',\n\n  /**\n   * Discard elements from the parent file's property\n   */\n  replace = 'replace',\n\n  /**\n   * Custom inheritance functionality\n   */\n  custom = 'custom'\n}\n\n/**\n * @beta\n */\nexport enum PathResolutionMethod {\n  /**\n   * Resolve a path relative to the configuration file\n   */\n  resolvePathRelativeToConfigurationFile = 'resolvePathRelativeToConfigurationFile',\n\n  /**\n   * Resolve a path relative to the root of the project containing the configuration file\n   */\n  resolvePathRelativeToProjectRoot = 'resolvePathRelativeToProjectRoot',\n\n  /**\n   * Treat the property as a NodeJS-style require/import reference and resolve using standard\n   * NodeJS filesystem resolution\n   *\n   * @deprecated\n   * Use {@link PathResolutionMethod.nodeResolve} instead\n   */\n  NodeResolve = 'NodeResolve',\n\n  /**\n   * Treat the property as a NodeJS-style require/import reference and resolve using standard\n   * NodeJS filesystem resolution\n   */\n  nodeResolve = 'nodeResolve',\n\n  /**\n   * Resolve the property using a custom resolver.\n   */\n  custom = 'custom'\n}\n\nconst CONFIGURATION_FILE_MERGE_BEHAVIOR_FIELD_REGEX: RegExp = /^\\$([^\\.]+)\\.inheritanceType$/;\nconst CONFIGURATION_FILE_FIELD_ANNOTATION: unique symbol = Symbol('configuration-file-field-annotation');\n\ninterface IAnnotatedField<TField> {\n  [CONFIGURATION_FILE_FIELD_ANNOTATION]: IConfigurationFileFieldAnnotation<TField>;\n}\n\ninterface IConfigurationFileFieldAnnotation<TField> {\n  configurationFilePath: string | undefined;\n  originalValues: { [propertyName in keyof TField]: unknown };\n}\n\n/**\n * Options provided to the custom resolver specified in {@link ICustomJsonPathMetadata}.\n *\n * @beta\n */\nexport interface IJsonPathMetadataResolverOptions<TConfigurationFile> {\n  /**\n   * The name of the property being resolved.\n   */\n  propertyName: string;\n  /**\n   * The value of the path property being resolved.\n   */\n  propertyValue: string;\n  /**\n   * The path to the configuration file the property was obtained from.\n   */\n  configurationFilePath: string;\n  /**\n   * The configuration file the property was obtained from.\n   */\n  configurationFile: Partial<TConfigurationFile>;\n}\n\n/**\n * Used to specify how node(s) in a JSON object should be processed after being loaded.\n *\n * @beta\n */\nexport interface ICustomJsonPathMetadata<TConfigurationFile> {\n  /**\n   * If `ICustomJsonPathMetadata.pathResolutionMethod` is set to `PathResolutionMethod.custom`,\n   * this property be used to resolve the path.\n   */\n  customResolver?: (resolverOptions: IJsonPathMetadataResolverOptions<TConfigurationFile>) => string;\n\n  /**\n   * If this property describes a filesystem path, use this property to describe\n   * how the path should be resolved.\n   */\n  pathResolutionMethod?: PathResolutionMethod.custom;\n}\n\n/**\n * Used to specify how node(s) in a JSON object should be processed after being loaded.\n *\n * @beta\n */\nexport interface INonCustomJsonPathMetadata {\n  /**\n   * If this property describes a filesystem path, use this property to describe\n   * how the path should be resolved.\n   */\n  pathResolutionMethod?:\n    | PathResolutionMethod.NodeResolve // TODO: Remove\n    | PathResolutionMethod.nodeResolve\n    | PathResolutionMethod.resolvePathRelativeToConfigurationFile\n    | PathResolutionMethod.resolvePathRelativeToProjectRoot;\n}\n\n/**\n * @beta\n */\nexport type PropertyInheritanceCustomFunction<TObject> = (\n  currentObject: TObject,\n  parentObject: TObject\n) => TObject;\n\n/**\n * @beta\n */\nexport interface IPropertyInheritance<TInheritanceType extends InheritanceType> {\n  inheritanceType: TInheritanceType;\n}\n\n/**\n * @beta\n */\nexport interface ICustomPropertyInheritance<TObject> extends IPropertyInheritance<InheritanceType.custom> {\n  /**\n   * Provides a custom inheritance function. This function takes two arguments: the first is the\n   * child file's object, and the second is the parent file's object. The function should return\n   * the resulting combined object.\n   */\n  inheritanceFunction: PropertyInheritanceCustomFunction<TObject>;\n}\n\n/**\n * @beta\n */\nexport type IPropertiesInheritance<TConfigurationFile> = {\n  [propertyName in keyof TConfigurationFile]?:\n    | IPropertyInheritance<InheritanceType.append | InheritanceType.merge | InheritanceType.replace>\n    | ICustomPropertyInheritance<TConfigurationFile[propertyName]>;\n};\n\n/**\n * @beta\n */\nexport interface IPropertyInheritanceDefaults {\n  array?: IPropertyInheritance<InheritanceType.append | InheritanceType.replace>;\n  object?: IPropertyInheritance<InheritanceType.merge | InheritanceType.replace>;\n}\n\n/**\n * @beta\n */\nexport type IJsonPathMetadata<T> = ICustomJsonPathMetadata<T> | INonCustomJsonPathMetadata;\n\n/**\n * Keys in this object are JSONPaths {@link https://jsonpath.com/}, and values are objects\n * that describe how node(s) selected by the JSONPath are processed after loading.\n *\n * @beta\n */\nexport interface IJsonPathsMetadata<TConfigurationFile> {\n  [jsonPath: string]: IJsonPathMetadata<TConfigurationFile>;\n}\n\n/**\n * @beta\n */\nexport interface IConfigurationFileOptionsBase<TConfigurationFile> {\n  /**\n   * A project root-relative path to the configuration file that should be loaded.\n   */\n  projectRelativeFilePath: string;\n\n  /**\n   * Use this property to specify how JSON nodes are postprocessed.\n   */\n  jsonPathMetadata?: IJsonPathsMetadata<TConfigurationFile>;\n\n  /**\n   * Use this property to control how root-level properties are handled between parent and child\n   * configuration files.\n   */\n  propertyInheritance?: IPropertiesInheritance<TConfigurationFile>;\n\n  /**\n   * Use this property to control how specific property types are handled between parent and child\n   * configuration files.\n   */\n  propertyInheritanceDefaults?: IPropertyInheritanceDefaults;\n}\n\n/**\n * @beta\n */\nexport interface IConfigurationFileOptionsWithJsonSchemaFilePath<TConfigurationFile>\n  extends IConfigurationFileOptionsBase<TConfigurationFile> {\n  /**\n   * The path to the schema for the configuration file.\n   */\n  jsonSchemaPath: string;\n  jsonSchemaObject?: never;\n}\n\n/**\n * @beta\n */\nexport interface IConfigurationFileOptionsWithJsonSchemaObject<TConfigurationFile>\n  extends IConfigurationFileOptionsBase<TConfigurationFile> {\n  /**\n   * The schema for the configuration file.\n   */\n  jsonSchemaObject: object;\n  jsonSchemaPath?: never;\n}\n\n/**\n * @beta\n */\nexport type IConfigurationFileOptions<TConfigurationFile> =\n  | IConfigurationFileOptionsWithJsonSchemaFilePath<TConfigurationFile>\n  | IConfigurationFileOptionsWithJsonSchemaObject<TConfigurationFile>;\n\ninterface IJsonPathCallbackObject {\n  path: string;\n  parent: object;\n  parentProperty: string;\n  value: string;\n}\n\n/**\n * @beta\n */\nexport interface IOriginalValueOptions<TParentProperty> {\n  parentObject: Partial<TParentProperty>;\n  propertyName: keyof TParentProperty;\n}\n\n/**\n * @beta\n */\nexport class ConfigurationFile<TConfigurationFile> {\n  private readonly _getSchema: () => JsonSchema;\n\n  /** {@inheritDoc IConfigurationFileOptionsBase.projectRelativeFilePath} */\n  public readonly projectRelativeFilePath: string;\n\n  private readonly _jsonPathMetadata: IJsonPathsMetadata<TConfigurationFile>;\n  private readonly _propertyInheritanceTypes: IPropertiesInheritance<TConfigurationFile>;\n  private readonly _defaultPropertyInheritance: IPropertyInheritanceDefaults;\n  private __schema: JsonSchema | undefined;\n  private get _schema(): JsonSchema {\n    if (!this.__schema) {\n      this.__schema = this._getSchema();\n    }\n\n    return this.__schema;\n  }\n\n  private readonly _configPromiseCache: Map<string, Promise<TConfigurationFile>> = new Map();\n  private readonly _packageJsonLookup: PackageJsonLookup = new PackageJsonLookup();\n\n  public constructor(options: IConfigurationFileOptions<TConfigurationFile>) {\n    this.projectRelativeFilePath = options.projectRelativeFilePath;\n\n    if (options.jsonSchemaObject) {\n      this._getSchema = () => JsonSchema.fromLoadedObject(options.jsonSchemaObject);\n    } else {\n      this._getSchema = () => JsonSchema.fromFile(options.jsonSchemaPath);\n    }\n\n    this._jsonPathMetadata = options.jsonPathMetadata || {};\n    this._propertyInheritanceTypes = options.propertyInheritance || {};\n    this._defaultPropertyInheritance = options.propertyInheritanceDefaults || {};\n  }\n\n  /**\n   * Find and return a configuration file for the specified project, automatically resolving\n   * `extends` properties and handling rigged configuration files. Will throw an error if a configuration\n   * file cannot be found in the rig or project config folder.\n   */\n  public async loadConfigurationFileForProjectAsync(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): Promise<TConfigurationFile> {\n    const projectConfigurationFilePath: string = this._getConfigurationFilePathForProject(projectPath);\n    return await this._loadConfigurationFileInnerWithCacheAsync(\n      terminal,\n      projectConfigurationFilePath,\n      new Set<string>(),\n      rigConfig\n    );\n  }\n\n  /**\n   * This function is identical to {@link ConfigurationFile.loadConfigurationFileForProjectAsync}, except\n   * that it returns `undefined` instead of throwing an error if the configuration file cannot be found.\n   */\n  public async tryLoadConfigurationFileForProjectAsync(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): Promise<TConfigurationFile | undefined> {\n    try {\n      return await this.loadConfigurationFileForProjectAsync(terminal, projectPath, rigConfig);\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  public static _formatPathForLogging: (path: string) => string = (path: string) => path;\n\n  /**\n   * Get the path to the source file that the referenced property was originally\n   * loaded from.\n   */\n  public getObjectSourceFilePath<TObject extends object>(obj: TObject): string | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const annotation: IConfigurationFileFieldAnnotation<TObject> | undefined = (obj as any)[\n      CONFIGURATION_FILE_FIELD_ANNOTATION\n    ];\n    if (annotation) {\n      return annotation.configurationFilePath;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get the value of the specified property on the specified object that was originally\n   * loaded from a configuration file.\n   */\n  public getPropertyOriginalValue<TParentProperty extends object, TValue>(\n    options: IOriginalValueOptions<TParentProperty>\n  ): TValue | undefined {\n    const annotation: IConfigurationFileFieldAnnotation<TParentProperty> | undefined =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (options.parentObject as any)[CONFIGURATION_FILE_FIELD_ANNOTATION];\n    if (annotation && annotation.originalValues.hasOwnProperty(options.propertyName)) {\n      return annotation.originalValues[options.propertyName] as TValue;\n    } else {\n      return undefined;\n    }\n  }\n\n  private async _loadConfigurationFileInnerWithCacheAsync(\n    terminal: ITerminal,\n    resolvedConfigurationFilePath: string,\n    visitedConfigurationFilePaths: Set<string>,\n    rigConfig: IRigConfig | undefined\n  ): Promise<TConfigurationFile> {\n    let cacheEntryPromise: Promise<TConfigurationFile> | undefined = this._configPromiseCache.get(\n      resolvedConfigurationFilePath\n    );\n    if (!cacheEntryPromise) {\n      cacheEntryPromise = this._loadConfigurationFileInnerAsync(\n        terminal,\n        resolvedConfigurationFilePath,\n        visitedConfigurationFilePaths,\n        rigConfig\n      );\n      this._configPromiseCache.set(resolvedConfigurationFilePath, cacheEntryPromise);\n    }\n\n    // We check for loops after caching a promise for this config file, but before attempting\n    // to resolve the promise. We can't handle loop detection in the `InnerAsync` function, because\n    // we could end up waiting for a cached promise (like A -> B -> A) that never resolves.\n    if (visitedConfigurationFilePaths.has(resolvedConfigurationFilePath)) {\n      const resolvedConfigurationFilePathForLogging: string = ConfigurationFile._formatPathForLogging(\n        resolvedConfigurationFilePath\n      );\n      throw new Error(\n        'A loop has been detected in the \"extends\" properties of configuration file at ' +\n          `\"${resolvedConfigurationFilePathForLogging}\".`\n      );\n    }\n    visitedConfigurationFilePaths.add(resolvedConfigurationFilePath);\n\n    return await cacheEntryPromise;\n  }\n\n  // NOTE: Internal calls to load a configuration file should use `_loadConfigurationFileInnerWithCacheAsync`.\n  // Don't call this function directly, as it does not provide config file loop detection,\n  // and you won't get the advantage of queueing up for a config file that is already loading.\n  private async _loadConfigurationFileInnerAsync(\n    terminal: ITerminal,\n    resolvedConfigurationFilePath: string,\n    visitedConfigurationFilePaths: Set<string>,\n    rigConfig: IRigConfig | undefined\n  ): Promise<TConfigurationFile> {\n    const resolvedConfigurationFilePathForLogging: string = ConfigurationFile._formatPathForLogging(\n      resolvedConfigurationFilePath\n    );\n\n    let fileText: string;\n    try {\n      fileText = await FileSystem.readFileAsync(resolvedConfigurationFilePath);\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        if (rigConfig) {\n          terminal.writeDebugLine(\n            `Config file \"${resolvedConfigurationFilePathForLogging}\" does not exist. Attempting to load via rig.`\n          );\n          const rigResult: TConfigurationFile | undefined = await this._tryLoadConfigurationFileInRigAsync(\n            terminal,\n            rigConfig,\n            visitedConfigurationFilePaths\n          );\n          if (rigResult) {\n            return rigResult;\n          }\n        } else {\n          terminal.writeDebugLine(\n            `Configuration file \"${resolvedConfigurationFilePathForLogging}\" not found.`\n          );\n        }\n\n        (e as Error).message = `File does not exist: ${resolvedConfigurationFilePathForLogging}`;\n      }\n\n      throw e;\n    }\n\n    let configurationJson: IConfigurationJson & TConfigurationFile;\n    try {\n      configurationJson = await JsonFile.parseString(fileText);\n    } catch (e) {\n      throw new Error(`In config file \"${resolvedConfigurationFilePathForLogging}\": ${e}`);\n    }\n\n    this._annotateProperties(resolvedConfigurationFilePath, configurationJson);\n\n    for (const [jsonPath, metadata] of Object.entries(this._jsonPathMetadata)) {\n      JSONPath({\n        path: jsonPath,\n        json: configurationJson,\n        callback: (payload: unknown, payloadType: string, fullPayload: IJsonPathCallbackObject) => {\n          const resolvedPath: string = this._resolvePathProperty(\n            {\n              propertyName: fullPayload.path,\n              propertyValue: fullPayload.value,\n              configurationFilePath: resolvedConfigurationFilePath,\n              configurationFile: configurationJson\n            },\n            metadata\n          );\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (fullPayload.parent as any)[fullPayload.parentProperty] = resolvedPath;\n        },\n        otherTypeCallback: () => {\n          throw new Error('@other() tags are not supported');\n        }\n      });\n    }\n\n    let parentConfiguration: TConfigurationFile | undefined;\n    if (configurationJson.extends) {\n      try {\n        const resolvedParentConfigPath: string = Import.resolveModule({\n          modulePath: configurationJson.extends,\n          baseFolderPath: nodeJsPath.dirname(resolvedConfigurationFilePath)\n        });\n        parentConfiguration = await this._loadConfigurationFileInnerWithCacheAsync(\n          terminal,\n          resolvedParentConfigPath,\n          visitedConfigurationFilePaths,\n          undefined\n        );\n      } catch (e) {\n        if (FileSystem.isNotExistError(e as Error)) {\n          throw new Error(\n            `In file \"${resolvedConfigurationFilePathForLogging}\", file referenced in \"extends\" property ` +\n              `(\"${configurationJson.extends}\") cannot be resolved.`\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const result: Partial<TConfigurationFile> = this._mergeConfigurationFiles(\n      parentConfiguration || {},\n      configurationJson,\n      resolvedConfigurationFilePath\n    );\n    try {\n      this._schema.validateObject(result, resolvedConfigurationFilePathForLogging);\n    } catch (e) {\n      throw new Error(`Resolved configuration object does not match schema: ${e}`);\n    }\n\n    // If the schema validates, we can assume that the configuration file is complete.\n    return result as TConfigurationFile;\n  }\n\n  private async _tryLoadConfigurationFileInRigAsync(\n    terminal: ITerminal,\n    rigConfig: IRigConfig,\n    visitedConfigurationFilePaths: Set<string>\n  ): Promise<TConfigurationFile | undefined> {\n    if (rigConfig.rigFound) {\n      const rigProfileFolder: string = await rigConfig.getResolvedProfileFolderAsync();\n      try {\n        return await this._loadConfigurationFileInnerWithCacheAsync(\n          terminal,\n          nodeJsPath.resolve(rigProfileFolder, this.projectRelativeFilePath),\n          visitedConfigurationFilePaths,\n          undefined\n        );\n      } catch (e) {\n        // Ignore cases where a configuration file doesn't exist in a rig\n        if (!FileSystem.isNotExistError(e as Error)) {\n          throw e;\n        } else {\n          terminal.writeDebugLine(\n            `Configuration file \"${\n              this.projectRelativeFilePath\n            }\" not found in rig (\"${ConfigurationFile._formatPathForLogging(rigProfileFolder)}\")`\n          );\n        }\n      }\n    } else {\n      terminal.writeDebugLine(\n        `No rig found for \"${ConfigurationFile._formatPathForLogging(rigConfig.projectFolderPath)}\"`\n      );\n    }\n\n    return undefined;\n  }\n\n  private _annotateProperties<TObject>(resolvedConfigurationFilePath: string, obj: TObject): void {\n    if (!obj) {\n      return;\n    }\n\n    if (typeof obj === 'object') {\n      this._annotateProperty(resolvedConfigurationFilePath, obj);\n\n      for (const objValue of Object.values(obj)) {\n        this._annotateProperties(resolvedConfigurationFilePath, objValue);\n      }\n    }\n  }\n\n  private _annotateProperty<TObject>(resolvedConfigurationFilePath: string, obj: TObject): void {\n    if (!obj) {\n      return;\n    }\n\n    if (typeof obj === 'object') {\n      (obj as unknown as IAnnotatedField<TObject>)[CONFIGURATION_FILE_FIELD_ANNOTATION] = {\n        configurationFilePath: resolvedConfigurationFilePath,\n        originalValues: { ...obj }\n      };\n    }\n  }\n\n  private _resolvePathProperty(\n    resolverOptions: IJsonPathMetadataResolverOptions<TConfigurationFile>,\n    metadata: IJsonPathMetadata<TConfigurationFile>\n  ): string {\n    const { propertyValue, configurationFilePath } = resolverOptions;\n    const resolutionMethod: PathResolutionMethod | undefined = metadata.pathResolutionMethod;\n    if (resolutionMethod === undefined) {\n      return propertyValue;\n    }\n\n    switch (metadata.pathResolutionMethod) {\n      case PathResolutionMethod.resolvePathRelativeToConfigurationFile: {\n        return nodeJsPath.resolve(nodeJsPath.dirname(configurationFilePath), propertyValue);\n      }\n\n      case PathResolutionMethod.resolvePathRelativeToProjectRoot: {\n        const packageRoot: string | undefined =\n          this._packageJsonLookup.tryGetPackageFolderFor(configurationFilePath);\n        if (!packageRoot) {\n          throw new Error(\n            `Could not find a package root for path \"${ConfigurationFile._formatPathForLogging(\n              configurationFilePath\n            )}\"`\n          );\n        }\n\n        return nodeJsPath.resolve(packageRoot, propertyValue);\n      }\n\n      case PathResolutionMethod.NodeResolve: // TODO: Remove\n      case PathResolutionMethod.nodeResolve: {\n        return Import.resolveModule({\n          modulePath: propertyValue,\n          baseFolderPath: nodeJsPath.dirname(configurationFilePath)\n        });\n      }\n\n      case PathResolutionMethod.custom: {\n        if (!metadata.customResolver) {\n          throw new Error(\n            `The pathResolutionMethod was set to \"${PathResolutionMethod[resolutionMethod]}\", but a custom ` +\n              'resolver was not provided.'\n          );\n        }\n\n        return metadata.customResolver(resolverOptions);\n      }\n\n      default: {\n        throw new Error(\n          `Unsupported PathResolutionMethod: ${PathResolutionMethod[resolutionMethod]} (${resolutionMethod})`\n        );\n      }\n    }\n  }\n\n  private _mergeConfigurationFiles(\n    parentConfiguration: Partial<TConfigurationFile>,\n    configurationJson: Partial<IConfigurationJson & TConfigurationFile>,\n    resolvedConfigurationFilePath: string\n  ): Partial<TConfigurationFile> {\n    const ignoreProperties: Set<string> = new Set(['extends', '$schema']);\n\n    // Need to do a dance with the casting here because while we know that JSON keys are always\n    // strings, TypeScript doesn't.\n    return this._mergeObjects(\n      parentConfiguration as { [key: string]: unknown },\n      configurationJson as { [key: string]: unknown },\n      resolvedConfigurationFilePath,\n      this._defaultPropertyInheritance,\n      this._propertyInheritanceTypes as IPropertiesInheritance<{ [key: string]: unknown }>,\n      ignoreProperties\n    ) as Partial<TConfigurationFile>;\n  }\n\n  private _mergeObjects<TField extends { [key: string]: unknown }>(\n    parentObject: Partial<TField>,\n    currentObject: Partial<TField>,\n    resolvedConfigurationFilePath: string,\n    defaultPropertyInheritance: IPropertyInheritanceDefaults,\n    configuredPropertyInheritance?: IPropertiesInheritance<TField>,\n    ignoreProperties?: Set<string>\n  ): Partial<TField> {\n    const resultAnnotation: IConfigurationFileFieldAnnotation<Partial<TField>> = {\n      configurationFilePath: resolvedConfigurationFilePath,\n      originalValues: {} as Partial<TField>\n    };\n    const result: Partial<TField> = {\n      [CONFIGURATION_FILE_FIELD_ANNOTATION]: resultAnnotation\n    } as unknown as Partial<TField>;\n\n    // An array of property names that are on the merging object. Typed as Set<string> since it may\n    // contain inheritance type annotation keys, or other built-in properties that we ignore\n    // (eg. \"extends\", \"$schema\").\n    const currentObjectPropertyNames: Set<string> = new Set(Object.keys(currentObject));\n    // An array of property names that should be included in the resulting object.\n    const filteredObjectPropertyNames: (keyof TField)[] = [];\n    // A map of property names to their inheritance type.\n    const inheritanceTypeMap: Map<keyof TField, IPropertyInheritance<InheritanceType>> = new Map();\n\n    // Do a first pass to gather and strip the inheritance type annotations from the merging object.\n    for (const propertyName of currentObjectPropertyNames) {\n      if (ignoreProperties && ignoreProperties.has(propertyName)) {\n        continue;\n      }\n\n      // Try to get the inheritance type annotation from the merging object using the regex.\n      // Note: since this regex matches a specific style of property name, we should not need to\n      // allow for any escaping of $-prefixed properties. If this ever changes (eg. to allow for\n      // `\"$propertyName\": { ... }` options), then we'll likely need to handle that error case,\n      // as well as allow escaping $-prefixed properties that developers want to be serialized,\n      // possibly by using the form `$$propertyName` to escape `$propertyName`.\n      const inheritanceTypeMatches: RegExpMatchArray | null = propertyName.match(\n        CONFIGURATION_FILE_MERGE_BEHAVIOR_FIELD_REGEX\n      );\n      if (inheritanceTypeMatches) {\n        // Should always be of length 2, since the first match is the entire string and the second\n        // match is the capture group.\n        const mergeTargetPropertyName: string = inheritanceTypeMatches[1];\n        const inheritanceTypeRaw: unknown | undefined = currentObject[propertyName];\n        if (!currentObjectPropertyNames.has(mergeTargetPropertyName)) {\n          throw new Error(\n            `Issue in processing configuration file property \"${propertyName}\". ` +\n              `An inheritance type was provided but no matching property was found in the parent.`\n          );\n        } else if (typeof inheritanceTypeRaw !== 'string') {\n          throw new Error(\n            `Issue in processing configuration file property \"${propertyName}\". ` +\n              `An unsupported inheritance type was provided: ${JSON.stringify(inheritanceTypeRaw)}`\n          );\n        } else if (typeof currentObject[mergeTargetPropertyName] !== 'object') {\n          throw new Error(\n            `Issue in processing configuration file property \"${propertyName}\". ` +\n              `An inheritance type was provided for a property that is not a keyed object or array.`\n          );\n        }\n        switch (inheritanceTypeRaw.toLowerCase()) {\n          case 'append':\n            inheritanceTypeMap.set(mergeTargetPropertyName, { inheritanceType: InheritanceType.append });\n            break;\n          case 'merge':\n            inheritanceTypeMap.set(mergeTargetPropertyName, { inheritanceType: InheritanceType.merge });\n            break;\n          case 'replace':\n            inheritanceTypeMap.set(mergeTargetPropertyName, { inheritanceType: InheritanceType.replace });\n            break;\n          default:\n            throw new Error(\n              `Issue in processing configuration file property \"${propertyName}\". ` +\n                `An unsupported inheritance type was provided: \"${inheritanceTypeRaw}\"`\n            );\n        }\n      } else {\n        filteredObjectPropertyNames.push(propertyName);\n      }\n    }\n\n    // We only filter the currentObject because the parent object should already be filtered\n    const propertyNames: Set<keyof TField> = new Set([\n      ...Object.keys(parentObject),\n      ...filteredObjectPropertyNames\n    ]);\n\n    // Cycle through properties and merge them\n    for (const propertyName of propertyNames) {\n      const propertyValue: TField[keyof TField] | undefined = currentObject[propertyName];\n      const parentPropertyValue: TField[keyof TField] | undefined = parentObject[propertyName];\n\n      let newValue: TField[keyof TField] | undefined;\n      const usePropertyValue: () => void = () => {\n        resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({\n          parentObject: currentObject,\n          propertyName: propertyName\n        });\n        newValue = propertyValue;\n      };\n      const useParentPropertyValue: () => void = () => {\n        resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({\n          parentObject: parentObject,\n          propertyName: propertyName\n        });\n        newValue = parentPropertyValue;\n      };\n\n      if (propertyValue !== undefined && parentPropertyValue === undefined) {\n        usePropertyValue();\n      } else if (parentPropertyValue !== undefined && propertyValue === undefined) {\n        useParentPropertyValue();\n      } else if (propertyValue !== undefined && parentPropertyValue !== undefined) {\n        // If the property is an inheritance type annotation, use it, otherwise fallback to the configured\n        // top-level property inheritance, if one is specified.\n        let propertyInheritance: IPropertyInheritance<InheritanceType> | undefined =\n          inheritanceTypeMap.get(propertyName) ?? configuredPropertyInheritance?.[propertyName];\n        if (!propertyInheritance) {\n          const bothAreArrays: boolean = Array.isArray(propertyValue) && Array.isArray(parentPropertyValue);\n          if (bothAreArrays) {\n            // If both are arrays, use the configured default array inheritance and fallback to appending\n            // if one is not specified\n            propertyInheritance = defaultPropertyInheritance.array ?? {\n              inheritanceType: InheritanceType.append\n            };\n          } else {\n            const bothAreObjects: boolean =\n              propertyValue &&\n              parentPropertyValue &&\n              typeof propertyValue === 'object' &&\n              typeof parentPropertyValue === 'object';\n            if (bothAreObjects) {\n              // If both are objects, use the configured default object inheritance and fallback to replacing\n              // if one is not specified\n              propertyInheritance = defaultPropertyInheritance.object ?? {\n                inheritanceType: InheritanceType.replace\n              };\n            } else {\n              // Fall back to replacing if they are of different types, since we don't know how to merge these\n              propertyInheritance = { inheritanceType: InheritanceType.replace };\n            }\n          }\n        }\n\n        switch (propertyInheritance.inheritanceType) {\n          case InheritanceType.replace: {\n            usePropertyValue();\n\n            break;\n          }\n\n          case InheritanceType.append: {\n            if (!Array.isArray(propertyValue) || !Array.isArray(parentPropertyValue)) {\n              throw new Error(\n                `Issue in processing configuration file property \"${propertyName.toString()}\". ` +\n                  `Property is not an array, but the inheritance type is set as \"${InheritanceType.append}\"`\n              );\n            }\n\n            newValue = [...parentPropertyValue, ...propertyValue] as TField[keyof TField];\n            (newValue as unknown as IAnnotatedField<unknown[]>)[CONFIGURATION_FILE_FIELD_ANNOTATION] = {\n              configurationFilePath: undefined,\n              originalValues: {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                ...(parentPropertyValue as any)[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                ...(propertyValue as any)[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues\n              }\n            };\n\n            break;\n          }\n\n          case InheritanceType.merge: {\n            if (parentPropertyValue === null || propertyValue === null) {\n              throw new Error(\n                `Issue in processing configuration file property \"${propertyName.toString()}\". ` +\n                  `Null values cannot be used when the inheritance type is set as \"${InheritanceType.merge}\"`\n              );\n            } else if (\n              (propertyValue && typeof propertyValue !== 'object') ||\n              (parentPropertyValue && typeof parentPropertyValue !== 'object')\n            ) {\n              throw new Error(\n                `Issue in processing configuration file property \"${propertyName.toString()}\". ` +\n                  `Primitive types cannot be provided when the inheritance type is set as \"${InheritanceType.merge}\"`\n              );\n            } else if (Array.isArray(propertyValue) || Array.isArray(parentPropertyValue)) {\n              throw new Error(\n                `Issue in processing configuration file property \"${propertyName.toString()}\". ` +\n                  `Property is not a keyed object, but the inheritance type is set as \"${InheritanceType.merge}\"`\n              );\n            }\n\n            // Recursively merge the parent and child objects. Don't pass the configuredPropertyInheritance or\n            // ignoreProperties because we are no longer at the top level of the configuration file. We also know\n            // that it must be a string-keyed object, since the JSON spec requires it.\n            newValue = this._mergeObjects(\n              parentPropertyValue as { [key: string]: unknown },\n              propertyValue as { [key: string]: unknown },\n              resolvedConfigurationFilePath,\n              defaultPropertyInheritance\n            ) as TField[keyof TField];\n\n            break;\n          }\n\n          case InheritanceType.custom: {\n            const customInheritance: ICustomPropertyInheritance<TField[keyof TField] | undefined> =\n              propertyInheritance as ICustomPropertyInheritance<TField[keyof TField] | undefined>;\n            if (\n              !customInheritance.inheritanceFunction ||\n              typeof customInheritance.inheritanceFunction !== 'function'\n            ) {\n              throw new Error(\n                'For property inheritance type \"InheritanceType.custom\", an inheritanceFunction must be provided.'\n              );\n            }\n\n            newValue = customInheritance.inheritanceFunction(propertyValue, parentPropertyValue);\n\n            break;\n          }\n\n          default: {\n            throw new Error(`Unknown inheritance type \"${propertyInheritance}\"`);\n          }\n        }\n      }\n\n      result[propertyName] = newValue;\n    }\n\n    return result;\n  }\n\n  private _getConfigurationFilePathForProject(projectPath: string): string {\n    return nodeJsPath.resolve(projectPath, this.projectRelativeFilePath);\n  }\n}\n"]}