"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmazonS3BuildCacheProvider = void 0;
const rush_sdk_1 = require("@rushstack/rush-sdk");
const AmazonS3Client_1 = require("./AmazonS3Client");
const WebClient_1 = require("./WebClient");
const AmazonS3Credentials_1 = require("./AmazonS3Credentials");
const DEFAULT_S3_REGION = 'us-east-1';
class AmazonS3BuildCacheProvider {
    get isCacheWriteAllowed() {
        var _a;
        return (_a = rush_sdk_1.EnvironmentConfiguration.buildCacheWriteAllowed) !== null && _a !== void 0 ? _a : this._isCacheWriteAllowedByConfiguration;
    }
    constructor(options, rushSession) {
        this._rushSession = rushSession;
        this._options = options;
        this._s3Prefix = options.s3Prefix;
        this._isCacheWriteAllowedByConfiguration = options.isCacheWriteAllowed;
    }
    get _s3Endpoint() {
        const options = this._options;
        if ('s3Bucket' in options) {
            // options: IAmazonS3BuildCacheProviderOptionsSimple
            const bucket = options.s3Bucket;
            if (options.s3Region === DEFAULT_S3_REGION) {
                return `https://${bucket}.s3.amazonaws.com`;
            }
            else {
                return `https://${bucket}.s3-${options.s3Region}.amazonaws.com`;
            }
        }
        // options: IAmazonS3BuildCacheProviderOptionsAdvanced
        return options.s3Endpoint;
    }
    get _credentialCacheId() {
        if (!this.__credentialCacheId) {
            const cacheIdParts = ['aws-s3', this._options.s3Region, this._s3Endpoint];
            if (this._isCacheWriteAllowedByConfiguration) {
                cacheIdParts.push('cacheWriteAllowed');
            }
            this.__credentialCacheId = cacheIdParts.join('|');
        }
        return this.__credentialCacheId;
    }
    async _getS3ClientAsync(terminal) {
        var _a, _b;
        if (!this.__s3Client) {
            let credentials = (_a = (0, AmazonS3Credentials_1.fromRushEnv)()) !== null && _a !== void 0 ? _a : (0, AmazonS3Credentials_1.fromAmazonEnv)();
            if (!credentials) {
                terminal.writeDebugLine('No credentials found in env. Trying cloud credentials.');
                let cacheEntry;
                await rush_sdk_1.CredentialCache.usingAsync({
                    supportEditing: false
                }, (credentialsCache) => {
                    cacheEntry = credentialsCache.tryGetCacheEntry(this._credentialCacheId);
                });
                if (cacheEntry) {
                    const expirationTime = (_b = cacheEntry.expires) === null || _b === void 0 ? void 0 : _b.getTime();
                    if (expirationTime && expirationTime < Date.now()) {
                        throw new Error('Cached Amazon S3 credentials have expired. ' +
                            `Update the credentials by running "rush ${rush_sdk_1.RushConstants.updateCloudCredentialsCommandName}".`);
                    }
                    else {
                        credentials = (0, AmazonS3Credentials_1.fromRushEnv)(cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.credential);
                    }
                }
                else if (this._isCacheWriteAllowedByConfiguration) {
                    throw new Error("An Amazon S3 credential hasn't been provided, or has expired. " +
                        `Update the credentials by running "rush ${rush_sdk_1.RushConstants.updateCloudCredentialsCommandName}", ` +
                        `or provide an <AccessKeyId>:<SecretAccessKey> pair in the ` +
                        `${rush_sdk_1.EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL} environment variable`);
                }
            }
            this.__s3Client = new AmazonS3Client_1.AmazonS3Client(credentials, Object.assign(Object.assign({}, this._options), { 
                // advanced options
                s3Endpoint: this._s3Endpoint }), new WebClient_1.WebClient(), terminal);
        }
        return this.__s3Client;
    }
    async tryGetCacheEntryBufferByIdAsync(terminal, cacheId) {
        try {
            const client = await this._getS3ClientAsync(terminal);
            return await client.getObjectAsync(this._s3Prefix ? `${this._s3Prefix}/${cacheId}` : cacheId);
        }
        catch (e) {
            terminal.writeWarningLine(`Error getting cache entry from S3: ${e}`);
            return undefined;
        }
    }
    async trySetCacheEntryBufferAsync(terminal, cacheId, objectBuffer) {
        if (!this.isCacheWriteAllowed) {
            terminal.writeErrorLine('Writing to S3 cache is not allowed in the current configuration.');
            return false;
        }
        terminal.writeDebugLine('Uploading object with cacheId: ', cacheId);
        try {
            const client = await this._getS3ClientAsync(terminal);
            await client.uploadObjectAsync(this._s3Prefix ? `${this._s3Prefix}/${cacheId}` : cacheId, objectBuffer);
            return true;
        }
        catch (e) {
            terminal.writeWarningLine(`Error uploading cache entry to S3: ${e}`);
            return false;
        }
    }
    async updateCachedCredentialAsync(terminal, credential) {
        await rush_sdk_1.CredentialCache.usingAsync({
            supportEditing: true
        }, async (credentialsCache) => {
            credentialsCache.setCacheEntry(this._credentialCacheId, { credential });
            await credentialsCache.saveIfModifiedAsync();
        });
    }
    async updateCachedCredentialInteractiveAsync(terminal) {
        throw new Error('The interactive cloud credentials flow is not supported for Amazon S3.\n' +
            'Provide your credentials to rush using the --credential flag instead. Credentials must be ' +
            'in the form of <ACCESS KEY ID>:<SECRET ACCESS KEY> or ' +
            '<ACCESS KEY ID>:<SECRET ACCESS KEY>:<SESSION TOKEN>.');
    }
    async deleteCachedCredentialsAsync(terminal) {
        await rush_sdk_1.CredentialCache.usingAsync({
            supportEditing: true
        }, async (credentialsCache) => {
            credentialsCache.deleteCacheEntry(this._credentialCacheId);
            await credentialsCache.saveIfModifiedAsync();
        });
    }
}
exports.AmazonS3BuildCacheProvider = AmazonS3BuildCacheProvider;
//# sourceMappingURL=AmazonS3BuildCacheProvider.js.map