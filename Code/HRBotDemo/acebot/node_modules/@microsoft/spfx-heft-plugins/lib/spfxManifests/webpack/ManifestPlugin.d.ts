/// <reference types="node" />
import type * as webpack from 'webpack';
import { type ITerminal } from '@rushstack/node-core-library';
import type { ILocalizedWebpackChunk } from '@rushstack/webpack4-localization-plugin';
import type { IModuleConfiguration, IClientSideComponentLoaderConfiguration, IIntegrityPath } from '@microsoft/sp-module-interfaces';
import type { _IManifestsFileMetadata as IManifestsFileMetadata } from '@ms/spfx-manifests-file';
import type { IExternalProjectMap } from '../utilities/ExternalsProcessor';
import type { IBundleEntry } from '../interfaces';
import type { CumulativeManifestProcessor, IReferencedProjectMap } from '../cumulativeManifestProcessor/CumulativeManifestProcessor';
import type { ITranslationsForLocFile } from '../../plugins/webpackConfigurationPlugin/ILocalization';
/**
 * @internal
 */
export interface IAsyncOnlyDependenciesOptions {
    asyncOnlyDependencyNames: string[];
    violationsAsErrors: boolean;
}
/**
 * @internal
 */
export interface ILegacyExternal {
    moduleConfigurations: {
        [externalName: string]: IModuleConfiguration;
    };
    assets: {
        [name: string]: string;
    };
}
/**
 * @internal
 */
export interface IManifestPluginOptions {
    terminal: ITerminal;
    bundleEntries: IBundleEntry[];
    internalModuleBaseUrls: string[];
    debugInternalModuleBaseUrls: string[];
    linkedExternals: IExternalProjectMap;
    referencedProjects: IReferencedProjectMap;
    cumulativeManifestProcessor: CumulativeManifestProcessor;
    sourceLocaleName: string;
    tryGetLocFileTranslations: (absoluteFilePath: string) => ITranslationsForLocFile | undefined;
    selectedLocales: Set<string> | undefined;
    production: boolean;
    includeIntegrity?: boolean;
    firstPassLocaleRemapping?: Map<string, string[]>;
    asyncOnlyDependencies?: IAsyncOnlyDependenciesOptions;
    componentDependenciesAuditDropPath?: string;
    tryGetLegacyExternalByNameAsync?: (name: string) => Promise<ILegacyExternal | undefined>;
    manifestsJsFileMetadata: IManifestsFileMetadata | undefined;
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFile {
    bundles: {
        [bundleName: string]: IComponentDependenciesAuditFileBundle;
    };
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileBundle {
    dependencies: IComponentDependenciesAuditFileDependency[];
    asyncChunks?: IComponentDependenciesAuditFileBundleAsyncChunks;
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileBundleAsyncChunks {
    [chunkName: string]: {
        asyncComponentDependencies: IComponentDependenciesAuditFileDependency[];
    };
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileDependency {
    componentId: string;
    componentName: string;
    componentVersion: string | undefined;
    isDirectDependency: boolean;
}
/**
 * @internal
 */
export interface IWebpackEntrypoint {
    readonly runtimeChunk: ILocalizedWebpackChunk;
}
/**
 * @internal
 */
export declare type WebpackAssets = Record<string, IExtendedAsset>;
/**
 * @internal
 */
export interface IExtendedCompilation extends webpack.compilation.Compilation {
    options: webpack.Configuration;
    assets: WebpackAssets;
}
/**
 * @internal
 */
export declare const SPFX_MANIFEST_RELEASE_VARIANT_SYMBOL: unique symbol;
/**
 * @internal
 */
export interface IExtendedAsset extends webpack.compilation.Asset {
    source: () => string;
    size: () => number;
    [SPFX_MANIFEST_RELEASE_VARIANT_SYMBOL]?: string;
}
/**
 * @internal
 */
export declare function computeIntegrity(sourceText: string): string;
/**
 * @internal
 */
export declare function computeIntegrity(sourceBuffers: Buffer[]): string;
/**
 * @internal
 */
export declare class ManifestPlugin implements webpack.Plugin {
    /**
     * @internal
     */
    _options: IManifestPluginOptions;
    private _parsedLocFileCache;
    /**
     * @internal
     */
    static _tryGetReleaseManifestVariant(asset: webpack.compilation.Asset): string | undefined;
    constructor(options: IManifestPluginOptions);
    apply(compiler: webpack.Compiler): void;
    /**
     * @virtual
     */
    protected _generateLoaderConfigurationAsync(terminal: ITerminal, bundleName: string, compilation: IExtendedCompilation, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<IClientSideComponentLoaderConfiguration>;
    protected _getRuntimeChunk(bundleName: string, entrypoint: IWebpackEntrypoint): ILocalizedWebpackChunk;
    protected _getExternalsScriptResourcesAsync(terminal: ITerminal, bundleName: string, runtimeChunk: webpack.compilation.Chunk, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<{
        [name: string]: IModuleConfiguration;
    }>;
    protected _getRuntimeChunkInfo(bundleName: string, runtimeChunk: webpack.compilation.Chunk, assets: WebpackAssets): string | IIntegrityPath;
    private _generateComponentManifest;
    /**
     * Process and localize WebPart manifest.
     * @remarks Also used for AdaptiveCardExtension manifests
     */
    private _processWebpartManifest;
    private _processApplicationManifest;
    /**
     * Does extension-specific manifest processing.
     */
    private _processExtensionsManifest;
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    private _localizeString;
    private _getEntryManifestModule;
    private _populateLinkedExternalComponentInDependencyMap;
}
//# sourceMappingURL=ManifestPlugin.d.ts.map