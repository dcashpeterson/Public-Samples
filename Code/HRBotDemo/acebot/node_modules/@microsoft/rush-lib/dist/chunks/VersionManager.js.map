{"version":3,"file":"chunks/VersionManager.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6B;AACI;AACsC;AACV;AACd;AACM;AACQ;AACP;AACN;AACY;AACH;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+FAA2C;AAC7E;AACA,kCAAkC,yDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kCAAkC,+FAA2C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAqB;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,8CAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAU;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qEAAS;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB,EAAE,4BAA4B;AACvG;AACA;AACA;AACA,6CAA6C,uFAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAmB;AACpD,aAAa,6CAAgB;AAC7B;AACA;AACA,4BAA4B,oEAAgB;AAC5C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,yEAAqB;AACjD,uCAAuC,8BAA8B,oBAAoB,qBAAqB;AAC9G,2BAA2B,qBAAqB;AAChD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAS,4BAA4B,mFAAyB;AAClG,gBAAgB,uEAAa,gCAAgC,0BAA0B;AACvF;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/VersionManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { JsonFile, FileConstants } from '@rushstack/node-core-library';\nimport { LockStepVersionPolicy } from '../api/VersionPolicy';\nimport { ChangeFile } from '../api/ChangeFile';\nimport { ChangeType } from '../api/ChangeManagement';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { PublishUtilities } from './PublishUtilities';\nimport { ChangeManager } from './ChangeManager';\nimport { DependencySpecifier } from './DependencySpecifier';\nimport { cloneDeep } from '../utilities/objectUtilities';\nexport class VersionManager {\n    constructor(rushConfiguration, userEmail, versionPolicyConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._userEmail = userEmail;\n        this._versionPolicyConfiguration = versionPolicyConfiguration\n            ? versionPolicyConfiguration\n            : this._rushConfiguration.versionPolicyConfiguration;\n        this.updatedProjects = new Map();\n        this.changeFiles = new Map();\n    }\n    /**\n     * Ensures project versions follow the provided version policy. If version policy is not\n     * provided, all projects will have their version checked according to the associated version policy.\n     * package.json files will be updated if needed.\n     * This method does not commit changes.\n     * @param versionPolicyName -- version policy name\n     * @param shouldCommit -- should update files to disk\n     * @param force -- update even when project version is higher than policy version.\n     */\n    ensure(versionPolicyName, shouldCommit, force) {\n        this._ensure(versionPolicyName, shouldCommit, force);\n    }\n    /**\n     * Bumps versions following version policies.\n     *\n     * @param lockStepVersionPolicyName - a specified lock step version policy name. Without this value,\n     * versions for all lock step policies and all individual policies will be bumped.\n     * With this value, only the specified lock step policy will be bumped along with all individual policies.\n     * @param bumpType - overrides the default bump type and only works for lock step policy\n     * @param identifier - overrides the prerelease identifier and only works for lock step policy\n     * @param shouldCommit - whether the changes will be written to disk\n     */\n    async bumpAsync(lockStepVersionPolicyName, bumpType, identifier, shouldCommit) {\n        // Bump all the lock step version policies.\n        this._versionPolicyConfiguration.bump(lockStepVersionPolicyName, bumpType, identifier, shouldCommit);\n        // Update packages and generate change files due to lock step bump.\n        this._ensure(lockStepVersionPolicyName, shouldCommit);\n        // Refresh rush configuration since we may have modified the package.json versions\n        // when calling this._ensure(...)\n        this._rushConfiguration = RushConfiguration.loadFromConfigurationFile(this._rushConfiguration.rushJsonFile);\n        // Update projects based on individual policies\n        const changeManager = new ChangeManager(this._rushConfiguration, this._getManuallyVersionedProjects());\n        await changeManager.loadAsync(this._rushConfiguration.changesFolder);\n        if (changeManager.hasChanges()) {\n            changeManager.validateChanges(this._versionPolicyConfiguration);\n            changeManager.apply(!!shouldCommit).forEach((packageJson) => {\n                this.updatedProjects.set(packageJson.name, packageJson);\n            });\n            await changeManager.updateChangelogAsync(!!shouldCommit);\n        }\n        // Refresh rush configuration again, since we've further modified the package.json files\n        // by calling changeManager.apply(...)\n        this._rushConfiguration = RushConfiguration.loadFromConfigurationFile(this._rushConfiguration.rushJsonFile);\n    }\n    _ensure(versionPolicyName, shouldCommit, force) {\n        this._updateVersionsByPolicy(versionPolicyName, force);\n        let changed = false;\n        do {\n            changed = false;\n            // Update all dependencies if needed.\n            const dependenciesUpdated = this._updateDependencies();\n            changed = changed || dependenciesUpdated;\n        } while (changed);\n        if (shouldCommit) {\n            this._updatePackageJsonFiles();\n            this.changeFiles.forEach((changeFile) => {\n                changeFile.writeSync();\n            });\n        }\n    }\n    _getManuallyVersionedProjects() {\n        const lockStepVersionPolicyNames = new Set();\n        this._versionPolicyConfiguration.versionPolicies.forEach((versionPolicy) => {\n            if (versionPolicy instanceof LockStepVersionPolicy && versionPolicy.nextBump !== undefined) {\n                lockStepVersionPolicyNames.add(versionPolicy.policyName);\n            }\n        });\n        const lockStepProjectNames = new Set();\n        this._rushConfiguration.projects.forEach((rushProject) => {\n            if (lockStepVersionPolicyNames.has(rushProject.versionPolicyName)) {\n                lockStepProjectNames.add(rushProject.packageName);\n            }\n        });\n        return lockStepProjectNames;\n    }\n    _updateVersionsByPolicy(versionPolicyName, force) {\n        let changed = false;\n        // Update versions based on version policy\n        this._rushConfiguration.projects.forEach((rushProject) => {\n            var _a;\n            const projectVersionPolicyName = rushProject.versionPolicyName;\n            if (projectVersionPolicyName &&\n                (!versionPolicyName || projectVersionPolicyName === versionPolicyName)) {\n                const versionPolicy = this._versionPolicyConfiguration.getVersionPolicy(projectVersionPolicyName);\n                const oldVersion = ((_a = this.updatedProjects.get(rushProject.packageName)) === null || _a === void 0 ? void 0 : _a.version) || rushProject.packageJson.version;\n                const updatedProject = versionPolicy.ensure(rushProject.packageJson, force);\n                changed = changed || (updatedProject === null || updatedProject === void 0 ? void 0 : updatedProject.version) !== oldVersion;\n                if (updatedProject) {\n                    this.updatedProjects.set(updatedProject.name, updatedProject);\n                    // No need to create an entry for prerelease version bump.\n                    if (!this._isPrerelease(updatedProject.version) && rushProject.isMainProject) {\n                        this._addChangeInfo(updatedProject.name, [this._createChangeInfo(updatedProject, rushProject)]);\n                    }\n                }\n            }\n        });\n        return changed;\n    }\n    _isPrerelease(version) {\n        return !!semver.prerelease(version);\n    }\n    _addChangeInfo(packageName, changeInfos) {\n        if (!changeInfos.length) {\n            return;\n        }\n        let changeFile = this.changeFiles.get(packageName);\n        if (!changeFile) {\n            changeFile = new ChangeFile({\n                changes: [],\n                packageName: packageName,\n                email: this._userEmail\n            }, this._rushConfiguration);\n            this.changeFiles.set(packageName, changeFile);\n        }\n        changeInfos.forEach((changeInfo) => {\n            changeFile.addChange(changeInfo);\n        });\n    }\n    _updateDependencies() {\n        let updated = false;\n        this._rushConfiguration.projects.forEach((rushProject) => {\n            let clonedProject = this.updatedProjects.get(rushProject.packageName);\n            let projectVersionChanged = true;\n            if (!clonedProject) {\n                clonedProject = cloneDeep(rushProject.packageJson);\n                projectVersionChanged = false;\n            }\n            const dependenciesUpdated = this._updateProjectAllDependencies(rushProject, clonedProject, projectVersionChanged);\n            updated = updated || dependenciesUpdated;\n        });\n        return updated;\n    }\n    _updateProjectAllDependencies(rushProject, clonedProject, projectVersionChanged) {\n        if (!clonedProject.dependencies && !clonedProject.devDependencies) {\n            return false;\n        }\n        const changes = [];\n        let updated = false;\n        if (this._updateProjectDependencies(clonedProject.dependencies, changes, clonedProject, rushProject, projectVersionChanged)) {\n            updated = true;\n        }\n        if (this._updateProjectDependencies(clonedProject.devDependencies, changes, clonedProject, rushProject, projectVersionChanged)) {\n            updated = true;\n        }\n        if (this._updateProjectDependencies(clonedProject.peerDependencies, changes, clonedProject, rushProject, projectVersionChanged)) {\n            updated = true;\n        }\n        if (updated) {\n            this.updatedProjects.set(clonedProject.name, clonedProject);\n            this._addChangeInfo(clonedProject.name, changes);\n        }\n        return updated;\n    }\n    _updateProjectDependencies(dependencies, changes, clonedProject, rushProject, projectVersionChanged) {\n        if (!dependencies) {\n            return false;\n        }\n        let updated = false;\n        this.updatedProjects.forEach((updatedDependentProject, updatedDependentProjectName) => {\n            if (dependencies[updatedDependentProjectName]) {\n                if (rushProject.decoupledLocalDependencies.has(updatedDependentProjectName)) {\n                    // Skip if cyclic\n                    // eslint-disable-next-line no-console\n                    console.log(`Found cyclic ${rushProject.packageName} ${updatedDependentProjectName}`);\n                    return;\n                }\n                const oldDependencyVersion = dependencies[updatedDependentProjectName];\n                const newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, updatedDependentProjectName, updatedDependentProject.version);\n                if (newDependencyVersion !== oldDependencyVersion) {\n                    updated = true;\n                    if (this._shouldTrackDependencyChange(rushProject, updatedDependentProjectName)) {\n                        this._trackDependencyChange(changes, clonedProject, projectVersionChanged, updatedDependentProject, oldDependencyVersion, newDependencyVersion);\n                    }\n                    dependencies[updatedDependentProjectName] = newDependencyVersion;\n                }\n            }\n        });\n        return updated;\n    }\n    _shouldTrackDependencyChange(rushProject, dependencyName) {\n        const dependencyRushProject = this._rushConfiguration.projectsByName.get(dependencyName);\n        return (!!dependencyRushProject &&\n            rushProject.shouldPublish &&\n            (!rushProject.versionPolicy ||\n                !rushProject.versionPolicy.isLockstepped ||\n                (rushProject.isMainProject &&\n                    dependencyRushProject.versionPolicyName !== rushProject.versionPolicyName)));\n    }\n    _trackDependencyChange(changes, clonedProject, projectVersionChanged, updatedDependentProject, oldDependencyVersion, newDependencyVersion) {\n        const oldSpecifier = new DependencySpecifier(updatedDependentProject.name, oldDependencyVersion);\n        if (!semver.satisfies(updatedDependentProject.version, oldSpecifier.versionSpecifier) &&\n            !projectVersionChanged) {\n            this._addChange(changes, {\n                changeType: ChangeType.patch,\n                packageName: clonedProject.name\n            });\n        }\n        // If current version is not a prerelease version and new dependency is also not a prerelease version,\n        // add change entry. Otherwise, too many changes will be created for frequent releases.\n        if (!this._isPrerelease(updatedDependentProject.version) && !this._isPrerelease(clonedProject.version)) {\n            this._addChange(changes, {\n                changeType: ChangeType.dependency,\n                comment: `Dependency ${updatedDependentProject.name} version bump from ${oldDependencyVersion}` +\n                    ` to ${newDependencyVersion}.`,\n                packageName: clonedProject.name\n            });\n        }\n    }\n    _addChange(changes, newChange) {\n        const exists = changes.some((changeInfo) => {\n            return (changeInfo.author === newChange.author &&\n                changeInfo.changeType === newChange.changeType &&\n                changeInfo.comment === newChange.comment &&\n                changeInfo.commit === newChange.commit &&\n                changeInfo.packageName === newChange.packageName &&\n                changeInfo.type === newChange.type);\n        });\n        if (!exists) {\n            changes.push(newChange);\n        }\n    }\n    _updatePackageJsonFiles() {\n        this.updatedProjects.forEach((newPackageJson, packageName) => {\n            const rushProject = this._rushConfiguration.getProjectByName(packageName);\n            // Update package.json\n            if (rushProject) {\n                const packagePath = path.join(rushProject.projectFolder, FileConstants.PackageJson);\n                JsonFile.save(newPackageJson, packagePath, { updateExistingFile: true });\n            }\n        });\n    }\n    _createChangeInfo(newPackageJson, rushProject) {\n        return {\n            changeType: ChangeType.none,\n            newVersion: newPackageJson.version,\n            packageName: newPackageJson.name,\n            comment: ''\n        };\n    }\n}\n//# sourceMappingURL=VersionManager.js.map"],"names":[],"sourceRoot":""}