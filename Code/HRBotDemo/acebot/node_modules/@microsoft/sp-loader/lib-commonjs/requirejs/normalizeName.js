"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeFailoverPathName = void 0;
var tslib_1 = require("tslib");
var normalizeComponentId_1 = tslib_1.__importDefault(require("../utilities/normalizeComponentId"));
/**
 * Given a manifest, or a manifest and a name, normalizes the name for usage
 * in stores and RequireJS.
 *
 * This is used in order to support versioning for components, and uniquely
 * identify non-component dependencies.
 *
 * Behavior:
 * Returns <manifestId>_<manifestVersion>.
 * If a name is provided returns the <manifestId>_<manifestVersion>/<name>.
 */
function normalizeName(manifest, name) {
    if (name) {
        return "".concat(_normalizeManifestId(manifest), "/").concat(name);
    }
    else {
        return _normalizeManifestId(manifest);
    }
}
exports.default = normalizeName;
function _normalizeManifestId(manifest) {
    return (0, normalizeComponentId_1.default)(manifest.id, manifest.version);
}
/**
 * This is only used for components that have a failover path (so far, react and react-dom).
 * As the failover path is used when there is no component, they work via its name,
 * but as opposed to the 'path' dependencies, they are unique in SPFx, like a component.
 *
 * They return the name directly, prepended by the component base URL.
 */
function normalizeFailoverPathName(name) {
    return name;
}
exports.normalizeFailoverPathName = normalizeFailoverPathName;
//# sourceMappingURL=normalizeName.js.map