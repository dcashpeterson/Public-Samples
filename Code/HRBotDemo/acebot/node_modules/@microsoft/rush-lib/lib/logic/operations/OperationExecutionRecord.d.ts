import { StdioSummarizer } from '@rushstack/terminal';
import type { CollatedWriter, StreamCollator } from '@rushstack/stream-collator';
import { OperationStatus } from './OperationStatus';
import type { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';
import type { Operation } from './Operation';
import { Stopwatch } from '../../utilities/Stopwatch';
import { OperationMetadataManager } from './OperationMetadataManager';
import type { IPhase } from '../../api/CommandLineConfiguration';
import type { RushConfigurationProject } from '../../api/RushConfigurationProject';
export interface IOperationExecutionRecordContext {
    streamCollator: StreamCollator;
    onOperationStatusChanged?: (record: OperationExecutionRecord) => void;
    debugMode: boolean;
    quietMode: boolean;
    changedProjectsOnly: boolean;
}
/**
 * Internal class representing everything about executing an operation
 *
 * @internal
 */
export declare class OperationExecutionRecord implements IOperationRunnerContext {
    /**
     * The associated operation.
     */
    readonly operation: Operation;
    /**
     * The error which occurred while executing this operation, this is stored in case we need
     * it later (for example to re-print errors at end of execution).
     */
    error: Error | undefined;
    /**
     * This number represents how far away this Operation is from the furthest "root" operation (i.e.
     * an operation with no consumers). This helps us to calculate the critical path (i.e. the
     * longest chain of projects which must be executed in order, thereby limiting execution speed
     * of the entire operation tree.
     *
     * This number is calculated via a memoized depth-first search, and when choosing the next
     * operation to execute, the operation with the highest criticalPathLength is chosen.
     *
     * Example:
     * ```
     *        (0) A
     *             \
     *          (1) B     C (0)         (applications)
     *               \   /|\
     *                \ / | \
     *             (2) D  |  X (1)      (utilities)
     *                    | / \
     *                    |/   \
     *                (2) Y     Z (2)   (other utilities)
     *
     * All roots (A & C) have a criticalPathLength of 0.
     * B has a score of 1, since A depends on it.
     * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)
     * X has a score of 1, since the only package which depends on it is A
     * Z has a score of 2, since only X depends on it, and X has a score of 1
     * Y has a score of 2, since the chain Y->X->C is longer than Y->C
     * ```
     *
     * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()
     */
    criticalPathLength: number | undefined;
    /**
     * The set of operations that must complete before this operation executes.
     */
    readonly dependencies: Set<OperationExecutionRecord>;
    /**
     * The set of operations that depend on this operation.
     */
    readonly consumers: Set<OperationExecutionRecord>;
    readonly stopwatch: Stopwatch;
    readonly stdioSummarizer: StdioSummarizer;
    readonly runner: IOperationRunner;
    readonly weight: number;
    readonly associatedPhase: IPhase | undefined;
    readonly associatedProject: RushConfigurationProject | undefined;
    readonly _operationMetadataManager: OperationMetadataManager | undefined;
    private readonly _context;
    private _collatedWriter;
    private _status;
    constructor(operation: Operation, context: IOperationExecutionRecordContext);
    get name(): string;
    get debugMode(): boolean;
    get quietMode(): boolean;
    get changedProjectsOnly(): boolean;
    get collatedWriter(): CollatedWriter;
    get nonCachedDurationMs(): number | undefined;
    get cobuildRunnerId(): string | undefined;
    /**
     * The current execution status of an operation. Operations start in the 'ready' state,
     * but can be 'blocked' if an upstream operation failed. It is 'executing' when
     * the operation is executing. Once execution is complete, it is either 'success' or
     * 'failure'.
     */
    get status(): OperationStatus;
    set status(newStatus: OperationStatus);
    executeAsync({ onStart, onResult }: {
        onStart: (record: OperationExecutionRecord) => Promise<OperationStatus | undefined>;
        onResult: (record: OperationExecutionRecord) => Promise<void>;
    }): Promise<void>;
}
//# sourceMappingURL=OperationExecutionRecord.d.ts.map