import type { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { type ITerminal } from '@rushstack/node-core-library';
import type { _IManifestsFileMetadata as IManifestsFileMetadata } from '@ms/spfx-manifests-file';
/**
 * @internal
 */
export declare enum DependencyDiscoveryMode {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    none = 0,
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    shallow = 1,
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    deep = 2,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    deepSparse = 3,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    deepSparseIgnoreFirstProject = 4
}
/**
 * @internal
 */
export interface ICumulativeManifestEnvironmentOptions {
    rootPath: string;
    tempFolderName: string;
    distFolderName: string;
    terminal: ITerminal;
}
/**
 * @internal
 */
export interface ICumulativeManifestOptions {
    /**
     * IDs of manifests to exclude from the manifest map file.
     */
    ignoreOutputManifestIds: string[];
    /**
     * The base path for debug manifests. Expected to match the result of the "debugBasePath" function passed to the
     *  WriteManifestsTask task.
     */
    baseUrl?: string;
    /**
     * Optional array of IDs to ensure aren't filtered out of the results if they are discovered.
     */
    explicitInclude: string[];
    /**
     * If set to true, include assemblies. Defaults to false. Assemblies are excluded by default.
     */
    includeAssemblies: boolean;
    /**
     * If set to true, validate manifests against the SPFx manifest schema. If the manifest is invalid, ignore it.
     */
    ignoreNonSpfxManifests: boolean;
}
/**
 * @internal
 */
export interface IReferencedProject {
    /**
     * The creation time of the newest version of this manifest we've found
     */
    manifestCreationTime: number;
    /**
     * The ID of the manifest.
     */
    id: string;
    /**
     * The version of the manifest.
     */
    version: string;
    /**
     * The project's manifest data
     */
    manifestData: IClientSideComponentManifest;
    /**
     * The path to the manifest.
     */
    manifestPath: string;
    /**
     * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only
     *  one manifest.
     */
    packageName: string;
    /**
     * If set to true, this is an assembly manifest
     */
    isAssembly: boolean;
}
/**
 * @internal
 */
export interface IVersionMap<TMember> {
    [version: string]: TMember;
}
/**
 * @internal
 */
export interface IVersionedIdMap<TMember> {
    [id: string]: IVersionMap<TMember>;
}
/**
 * @internal
 */
export declare type IReferencedProjectMap = IVersionedIdMap<IReferencedProject>;
/**
 * @internal
 */
export interface IDiscoverManifestsOptions {
    /**
     * The directory in each project's directory where we should search for manifests. Defaults to "dist"
     */
    projectTargetFolder?: string;
    /**
     * The regex to use to search for manifest files. Defaults to /^[^\.\\\/]+\.manifest\.json$/
     */
    manifestFileRegex?: RegExp;
    /**
     * If expressly set to false, realpath symlinks while crawling.
     */
    preserveSymlinks?: boolean;
}
/**
 * @internal
 */
export declare class CumulativeManifestProcessor {
    private _options;
    private _discoveryCache;
    constructor(options: Partial<ICumulativeManifestOptions> & ICumulativeManifestEnvironmentOptions);
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifestAsync(debugManifests: IClientSideComponentManifest[], manifestsJsFileMetadata: IManifestsFileMetadata | undefined): Promise<void>;
    reset(): void;
    discoverManifests(packagePath: string, forceSearchMode?: DependencyDiscoveryMode, options?: IDiscoverManifestsOptions): IReferencedProjectMap;
    private _discoverManifestsInner;
    private _insertManifestIntoMap;
    private _doTemporaryManifestFixups;
    private _getTransformedManifest;
    private _resolvePackage;
}
//# sourceMappingURL=CumulativeManifestProcessor.d.ts.map