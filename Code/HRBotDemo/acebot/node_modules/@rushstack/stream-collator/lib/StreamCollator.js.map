{"version":3,"file":"StreamCollator.js","sourceRoot":"","sources":["../src/StreamCollator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { InternalError } from '@rushstack/node-core-library';\nimport type { TerminalWritable, ITerminalChunk } from '@rushstack/terminal';\n\nimport { CollatedWriter } from './CollatedWriter';\nimport { CollatedTerminal } from './CollatedTerminal';\n\n/**\n * Constructor options for {@link StreamCollator}.\n *\n * @beta\n */\nexport interface IStreamCollatorOptions {\n  /**\n   * The target {@link @rushstack/terminal#TerminalWritable} object that the\n   * {@link StreamCollator} will write its output to.\n   */\n  destination: TerminalWritable;\n\n  /**\n   * An event handler that is called when a {@link CollatedWriter} becomes output,\n   * before any of its chunks have been written to the destination.\n   *\n   * @remarks\n   *\n   * Each `CollatedWriter` object will become active exactly once\n   * before the `StreamCollator` completes.\n   */\n  onWriterActive?: (writer: CollatedWriter) => void;\n}\n\n/**\n * A static class which manages the output of multiple threads.\n *\n * @beta\n */\nexport class StreamCollator {\n  private _taskNames: Set<string> = new Set();\n  private _writers: Set<CollatedWriter> = new Set();\n\n  // The writer whose output is being shown in realtime, or undefined if none\n  private _activeWriter: CollatedWriter | undefined = undefined;\n\n  // Writers that are not closed yet, and have never been active\n  private _openInactiveWriters: Set<CollatedWriter> = new Set();\n\n  // Writers that are now closed, but have accumulated buffered chunks, and have never been active\n  private _closedInactiveWriters: Set<CollatedWriter> = new Set();\n\n  private _onWriterActive: ((writer: CollatedWriter) => void) | undefined;\n\n  private _preventReentrantCall: boolean = false;\n\n  public readonly destination: TerminalWritable;\n  public readonly terminal: CollatedTerminal;\n\n  public constructor(options: IStreamCollatorOptions) {\n    this.destination = options.destination;\n    this.terminal = new CollatedTerminal(this.destination);\n    this._onWriterActive = options.onWriterActive;\n  }\n\n  /**\n   * Returns the currently active `CollatedWriter`, or `undefined` if no writer\n   * is active yet.\n   */\n  public get activeWriter(): CollatedWriter | undefined {\n    return this._activeWriter;\n  }\n\n  /**\n   * For diagnostic purposes, returns the {@link CollatedWriter.taskName} for the\n   * currently active writer, or an empty string if no writer is active.\n   */\n  public get activeTaskName(): string {\n    if (this._activeWriter) {\n      return this._activeWriter.taskName;\n    }\n    return '';\n  }\n\n  /**\n   * The list of writers that have been registered by calling {@link StreamCollator.registerTask},\n   * in the order that they were registered.\n   */\n  public get writers(): ReadonlySet<CollatedWriter> {\n    return this._writers;\n  }\n\n  /**\n   * Registers a new task to be collated, and constructs a {@link CollatedWriter} object\n   * to receive its input.\n   */\n  public registerTask(taskName: string): CollatedWriter {\n    if (this._taskNames.has(taskName)) {\n      throw new Error('A task with that name has already been registered');\n    }\n\n    const writer: CollatedWriter = new CollatedWriter(taskName, this);\n\n    this._writers.add(writer);\n    this._taskNames.add(writer.taskName);\n\n    // When a task is initially registered, it is open and has not accumulated any buffered chunks\n    this._openInactiveWriters.add(writer);\n\n    if (this._activeWriter === undefined) {\n      // If there is no active writer, then the first one to be registered becomes active.\n      this._assignActiveWriter(writer);\n    }\n\n    return writer;\n  }\n\n  /** @internal */\n  public _writerWriteChunk(\n    writer: CollatedWriter,\n    chunk: ITerminalChunk,\n    bufferedChunks: ITerminalChunk[]\n  ): void {\n    this._checkForReentrantCall();\n\n    if (this._activeWriter === undefined) {\n      // If no writer is currently active, then the first one to write something becomes active\n      this._assignActiveWriter(writer);\n    }\n\n    if (writer.isActive) {\n      this.destination.writeChunk(chunk);\n    } else {\n      bufferedChunks.push(chunk);\n    }\n  }\n\n  /** @internal */\n  public _writerClose(writer: CollatedWriter, bufferedChunks: ITerminalChunk[]): void {\n    this._checkForReentrantCall();\n\n    if (writer.isActive) {\n      writer._flushBufferedChunks();\n\n      this._activeWriter = undefined;\n\n      // If any buffered writers are already closed, activate them each immediately\n      // We copy the set, since _assignActiveWriter() will be deleting from it.\n      for (const closedInactiveWriter of [...this._closedInactiveWriters]) {\n        try {\n          this._assignActiveWriter(closedInactiveWriter);\n        } finally {\n          this._activeWriter = undefined;\n        }\n      }\n\n      let writerToActivate: CollatedWriter | undefined = undefined;\n\n      // Try to activate a writer that already accumulated some data\n      for (const openInactiveWriter of this._openInactiveWriters) {\n        if (openInactiveWriter.bufferedChunks.length > 0) {\n          writerToActivate = openInactiveWriter;\n          break;\n        }\n      }\n      if (!writerToActivate) {\n        // Otherwise just take the first one\n        for (const openInactiveWriter of this._openInactiveWriters) {\n          writerToActivate = openInactiveWriter;\n          break;\n        }\n      }\n\n      if (writerToActivate) {\n        this._assignActiveWriter(writerToActivate);\n      }\n    } else {\n      this._openInactiveWriters.delete(writer);\n      this._closedInactiveWriters.add(writer);\n    }\n  }\n\n  private _assignActiveWriter(writer: CollatedWriter): void {\n    this._activeWriter = writer;\n\n    this._closedInactiveWriters.delete(writer);\n    this._openInactiveWriters.delete(writer);\n\n    if (this._onWriterActive) {\n      this._preventReentrantCall = true;\n      try {\n        this._onWriterActive(writer);\n      } finally {\n        this._preventReentrantCall = false;\n      }\n    }\n\n    writer._flushBufferedChunks();\n  }\n\n  private _checkForReentrantCall(): void {\n    if (this._preventReentrantCall) {\n      throw new InternalError('Reentrant call to StreamCollator');\n    }\n  }\n}\n"]}