{"version":3,"file":"circular-deps.js","sourceRoot":"","sources":["../src/circular-deps.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAM3D,8EAAoE;AAEpE,uDAAoD;AACpD,6DAA0E;AAC1E,iCAA8B;AAK9B,MAAM,YAAY,GAA6C;IAC7D,IAAI,EAAE;QACJ,IAAI,EAAE,SAAS;QACf,QAAQ,EAAE,EAAE,iBAAiB,EAAE,0DAA0D,EAAE;QAC3F,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,QAAQ;gBACd,oBAAoB,EAAE,KAAK;aAC5B;SACF;QACD,IAAI,EAAE;YACJ,WAAW,EAAE,kDAAkD;YAC/D,4DAA4D;YAC5D,QAAQ,EAAE,gBAAgB;YAC1B,WAAW,EAAE,MAAM;YACnB,GAAG,EAAE,iEAAiE;SAC1C;KAC/B;IAED,MAAM,EAAE,CAAC,OAAkD,EAAE,EAAE;QAC7D,gEAAgE;QAChE,MAAM,aAAa,GAAW,OAAO,CAAC,WAAW,EAAE,CAAC;QAEpD,6CAA6C;QAC7C,MAAM,OAAO,GAAe,gCAAW,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC;QAC3E,MAAM,gBAAgB,GAAuB,OAAO,CAAC,kBAAkB,EAAE,CAAC,gBAAgB,CAAW,CAAC;QAEtG,MAAM,eAAe,GAAoB,iCAAe,CAAC,gBAAgB,CACvE,aAAa,EACb,gBAAgB,CACjB,CAAC;QACF,IAAI,eAAe,CAAC,WAAW,EAAE;YAC/B,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,mGAAmG;YACnG,yGAAyG;YACzG,gDAAgD;YAChD,OAAO,EAAE,CAAC,IAAmB,EAAQ,EAAE;gBACrC,IAAI,eAAe,CAAC,YAAY,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;oBAC1D,MAAM,cAAc,GAClB,uCAAkB,CAAC,gCAAgC,CACjD,eAAe,CAAC,oBAAqB,EACrC,eAAe,EACf,OAAO,CACR,CAAC;oBAEJ,IAAI,cAAc,EAAE;wBAClB,MAAM,kBAAkB,GAAW,WAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;wBAElE,MAAM,oBAAoB,GAAa,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;wBAEhF,wGAAwG;wBACxG,4EAA4E;wBAC5E,oBAAoB,CAAC,IAAI,EAAE,CAAC;wBAC5B,IAAI,oBAAoB,CAAC,CAAC,CAAC,KAAK,eAAe,CAAC,oBAAoB,EAAE;4BACpE,IAAI,MAAM,GAAW,EAAE,CAAC;4BACxB,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;gCAC1C,MAAM,QAAQ,GAAW,WAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE,aAAa,CAAC,YAAY,CAAC,CAAC;gCACvF,MAAM,IAAI,IAAI,aAAa,CAAC,WAAW,sBAAsB,QAAQ,IAAI,CAAC;6BAC3E;4BAED,OAAO,CAAC,MAAM,CAAC;gCACb,IAAI,EAAE,IAAI;gCACV,SAAS,EAAE,iBAAiB;gCAC5B,IAAI,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE;6BACzB,CAAC,CAAC;yBACJ;qBACF;iBACF;YACH,CAAC;SACF,CAAC;IACJ,CAAC;CACF,CAAC;AAEO,oCAAY","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\nimport * as path from 'path';\n\nimport type { ParserServices, TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\nimport { ESLintUtils } from '@typescript-eslint/experimental-utils';\n\nimport { PackletAnalyzer } from './PackletAnalyzer';\nimport { DependencyAnalyzer, IPackletImport } from './DependencyAnalyzer';\nimport { Path } from './Path';\n\nexport type MessageIds = 'circular-import';\ntype Options = [];\n\nconst circularDeps: TSESLint.RuleModule<MessageIds, Options> = {\n  meta: {\n    type: 'problem',\n    messages: { 'circular-import': 'Packlet imports create a circular reference:\\n{{report}}' },\n    schema: [\n      {\n        type: 'object',\n        additionalProperties: false\n      }\n    ],\n    docs: {\n      description: 'Check for circular dependencies between packlets',\n      // Deprecated in ESLint v8; Keep for backwards compatibility\n      category: 'Best Practices',\n      recommended: 'warn',\n      url: 'https://www.npmjs.com/package/@rushstack/eslint-plugin-packlets'\n    } as TSESLint.RuleMetaDataDocs\n  },\n\n  create: (context: TSESLint.RuleContext<MessageIds, Options>) => {\n    // Example: /path/to/my-project/src/packlets/my-packlet/index.ts\n    const inputFilePath: string = context.getFilename();\n\n    // Example: /path/to/my-project/tsconfig.json\n    const program: ts.Program = ESLintUtils.getParserServices(context).program;\n    const tsconfigFilePath: string | undefined = program.getCompilerOptions()['configFilePath'] as string;\n\n    const packletAnalyzer: PackletAnalyzer = PackletAnalyzer.analyzeInputFile(\n      inputFilePath,\n      tsconfigFilePath\n    );\n    if (packletAnalyzer.nothingToDo) {\n      return {};\n    }\n\n    return {\n      // Match the first node in the source file.  Ideally we should be matching \"Program > :first-child\"\n      // so a warning doesn't highlight the whole file.  But that's blocked behind a bug in the query selector:\n      // https://github.com/estools/esquery/issues/114\n      Program: (node: TSESTree.Node): void => {\n        if (packletAnalyzer.isEntryPoint && !packletAnalyzer.error) {\n          const packletImports: IPackletImport[] | undefined =\n            DependencyAnalyzer.checkEntryPointForCircularImport(\n              packletAnalyzer.inputFilePackletName!,\n              packletAnalyzer,\n              program\n            );\n\n          if (packletImports) {\n            const tsconfigFileFolder: string = Path.dirname(tsconfigFilePath);\n\n            const affectedPackletNames: string[] = packletImports.map((x) => x.packletName);\n\n            // If 3 different packlets form a circular dependency, we don't need to report the same warning 3 times.\n            // Instead, only report the warning for the alphabetically smallest packlet.\n            affectedPackletNames.sort();\n            if (affectedPackletNames[0] === packletAnalyzer.inputFilePackletName) {\n              let report: string = '';\n              for (const packletImport of packletImports) {\n                const filePath: string = Path.relative(tsconfigFileFolder, packletImport.fromFilePath);\n                report += `\"${packletImport.packletName}\" is referenced by ${filePath}\\n`;\n              }\n\n              context.report({\n                node: node,\n                messageId: 'circular-import',\n                data: { report: report }\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n};\n\nexport { circularDeps };\n"]}