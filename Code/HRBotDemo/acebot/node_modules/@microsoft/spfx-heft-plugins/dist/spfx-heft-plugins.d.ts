/// <reference types="node" />

import { AsyncParallelHook } from 'tapable';
import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import { BlobHTTPHeaders } from '@azure/storage-blob';
import crypto from 'crypto';
import type { EntityMarker } from '@rushstack/webpack4-localization-plugin/lib/utilities/EntityMarker';
import type { GenerateCssClassNameFunction } from '@microsoft/sp-css-loader';
import type { HeftConfiguration } from '@rushstack/heft';
import type { IClientSideComponentLoaderConfiguration } from '@microsoft/sp-module-interfaces';
import type { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import type { IHeftTaskPlugin } from '@rushstack/heft';
import type { IHeftTaskSession } from '@rushstack/heft';
import type { IIntegrityPath } from '@microsoft/sp-module-interfaces';
import type { ILocalizedPathModuleConfiguration } from '@microsoft/sp-module-interfaces';
import type { ILocalizedString } from '@microsoft/sp-module-interfaces';
import type { ILocalizedStrings } from '@rushstack/webpack4-localization-plugin';
import type { ILocalizedWebpackChunk } from '@rushstack/webpack4-localization-plugin';
import type { _IManifestsFileMetadata } from '@ms/spfx-manifests-file';
import type { IModuleConfiguration } from '@microsoft/sp-module-interfaces';
import { IPackageJson } from '@rushstack/node-core-library';
import type { IRigConfig } from '@rushstack/rig-package';
import { ITerminal } from '@rushstack/node-core-library';
import type { IWebpackConfigurationWithDevServer } from '@rushstack/heft-webpack4-plugin/lib/index';
import type { LocalizationPlugin } from '@rushstack/webpack4-localization-plugin';
import { SyncHook } from 'tapable';
import { SyncWaterfallHook } from 'tapable';
import { URLSearchParams as URLSearchParams_2 } from 'url';
import type * as webpack from 'webpack';

/**
 * @internal
 */
export declare class _AzureUploader {
    static readonly DEFAULT_AZURE_MAX_PARALLELISM: number;
    static readonly DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS: number;
    static readonly DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES: number;
    private readonly _containerClient;
    constructor(options: _IAzureUploaderOptionsForSas | _IAzureUploaderOptionsForKey);
    /**
     * Upload file to Azure
     */
    uploadFileToAzureAsync(terminal: ITerminal | undefined, localFilename: string, serverFilename: string, blobHeaders?: BlobHTTPHeaders): Promise<void>;
    uploadToAzureAsync(terminal: ITerminal, contents: string | Buffer, serverFilename: string, blobMetadata?: {
        [name: string]: string;
    }): Promise<void>;
    /**
     * Upload files to Azure
     */
    uploadFilesToAzureAsync(terminal: ITerminal, files: _IUploadableFile[], maxParallelism?: number, maxRetries?: number, retryDelayMs?: number, onFileUploaded?: (serverPath: string) => void): Promise<void>;
    ensureContainerExistsAsync(terminal: ITerminal): Promise<void>;
    private _getBlockBlobClient;
}

/**
 * @internal
 */
export declare function _buildManifestsJsAsync(manifestsArray: IClientSideComponentManifest[], outputFilePath: string, azurePathOverride: string | undefined, manifestsJsFileMetadata: _IManifestsFileMetadata | undefined): Promise<void>;

/**
 * @internal
 */
export declare class _ComponentNamePlugin implements webpack.Plugin {
    private _options;
    constructor(options: _IComponentNamePluginOptions);
    apply(compiler: webpack.Compiler): void;
}

/**
 * @internal
 */
export declare function _computeIntegrity(sourceText: string): string;

/**
 * @internal
 */
export declare function _computeIntegrity(sourceBuffers: Buffer[]): string;

/**
 * @public
 */
export declare const CONFIG_JSON_SYMBOL: unique symbol;

/**
 * @internal
 */
export declare class _CumulativeManifestProcessor {
    private _options;
    private _discoveryCache;
    constructor(options: Partial<_ICumulativeManifestOptions> & _ICumulativeManifestEnvironmentOptions);
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  8. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifestAsync(debugManifests: IClientSideComponentManifest[], manifestsJsFileMetadata: _IManifestsFileMetadata | undefined): Promise<void>;
    reset(): void;
    discoverManifests(packagePath: string, forceSearchMode?: _DependencyDiscoveryMode, options?: _IDiscoverManifestsOptions): _IReferencedProjectMap;
    private _discoverManifestsInner;
    private _insertManifestIntoMap;
    private _doTemporaryManifestFixups;
    private _getTransformedManifest;
    private _resolvePackage;
}

/**
 * @public
 */
declare const CustomizeWebpackConfigPlugin: 'customize-spfx-webpack-configuration-plugin';

/**
 * @internal
 */
export declare class _CustomizeWebpackConfigurationPlugin implements IHeftTaskPlugin<_ICustomizeWebpackConfigurationPluginOptions> {
    apply(taskSession: IHeftTaskSession, heftConfiguration: HeftConfiguration, options: _ICustomizeWebpackConfigurationPluginOptions): void;
    private _updateWebpackConfigurationAsync;
}

/**
 * @alpha
 */
export declare const DEFAULT_PORT: 4321;

/**
 * @internal
 */
export declare enum _DependencyDiscoveryMode {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    none = 0,
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    shallow = 1,
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    deep = 2,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    deepSparse = 3,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    deepSparseIgnoreFirstProject = 4
}

/**
 * @public
 */
declare const DeployAzureStoragePlugin: 'deploy-azure-storage-plugin';

/**
 * @internal
 */
export declare class _DeployAzureStoragePlugin implements IHeftTaskPlugin {
    static deployToAzureAsync({ terminal, buildFolder, emitError, rigConfig, tryCreateContainer }: _IDeployToAzureOptions): Promise<void>;
    apply(taskSession: IHeftTaskSession, heftConfiguration: HeftConfiguration): void;
}

/**
 * Helper functions for dev-deploy.
 * @public
 */
export declare class DevDeployHelper {
    static deployFilesAsync(terminal: ITerminal, deployConfig: IDevDeployConfig, deployData: IDevDeployData, deployPathsFunction?: (pathsToUpload: IDeployFile[]) => Promise<void>): Promise<void>;
}

/**
 * @public
 */
export declare class DevDeployHooks {
    /**
     * Initialize
     */
    readonly init: AsyncParallelHook<IDevDeployOptions>;
    /**
     * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
     */
    readonly preProcess: SyncHook<void>;
    /**
     * Gets the files to be deployed to the CDN
     */
    readonly getFiles: AsyncSeriesWaterfallHook<IDevDeployData>;
    /**
     * Gets the name of the folder in the container into which files should be uploaded
     */
    readonly getContainerFolderName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the Azure storage account
     */
    readonly getStorageAccountName: SyncWaterfallHook<string>;
    /**
     * Gets the name of the container
     */
    readonly getContainerName: SyncWaterfallHook<string>;
    /**
     * Gets a SAS for the storage container
     */
    readonly getStorageSas: AsyncSeriesWaterfallHook<string>;
    /**
     * Returns true if the deployment is in a prod environment
     */
    readonly isProd: SyncWaterfallHook<boolean>;
    /**
     * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
     */
    readonly postProcess: AsyncSeriesHook<void>;
}

/**
 * @public
 */
declare const DevDeployPlugin: 'spfx-dev-deploy-plugin';

/**
 * @public
 */
export declare const FILE_LOADER_EXTENSIONS: string[];

/**
 * @internal
 */
export declare function _getFullHash(data: crypto.BinaryLike): string;

/**
 * @internal
 */
export declare function _getVersionFromPackageJson(packageName: string): (projectRootPath: string) => string | undefined;

/**
 * @public
 */
export declare interface IApplicationDefinition {
}

/**
 * @internal
 */
export declare interface _IAsyncOnlyDependenciesOptions {
    asyncOnlyDependencyNames: string[];
    violationsAsErrors: boolean;
}

/**
 * @internal
 */
export declare interface _IAzureUploaderOptions {
    storageAccountName: string;
    containerName: string;
}

/**
 * @internal
 */
export declare interface _IAzureUploaderOptionsForKey extends _IAzureUploaderOptions {
    storageKey: string;
}

/**
 * @internal
 */
export declare interface _IAzureUploaderOptionsForSas extends _IAzureUploaderOptions {
    sas: string;
}

/**
 * @internal
 */
export declare interface _IBaseConfigJsonResult {
    /**
     * True if the file is missing.
     */
    missingFile: boolean;
    /**
     * Parse error data.
     */
    readError?: {};
    /**
     * The version of the original config file.
     */
    version?: string;
    /**
     * True if the config file is the latest version.
     */
    isLatestVersion?: boolean;
}

/**
 * @internal
 */
export declare interface _IBundleComponent extends IConfigComponent {
    manifestData: IClientSideComponentManifest;
    manifestPath: string;
    exportName: string | undefined;
}

/**
 * @internal
 */
export declare interface _IBundleEntry {
    bundleName: string;
    components: {
        [id: string]: _IBundleComponent;
    };
}

/**
 * @public
 */
export declare interface IComponent {
    name: string;
    description: string;
    id: string;
    manifest: IClientSideComponentManifest;
    requiresCustomScript: boolean;
    componentDefinition: IWebPartDefinition | IApplicationDefinition | IExtensionDefinition | undefined;
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFile {
    bundles: {
        [bundleName: string]: _IComponentDependenciesAuditFileBundle;
    };
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFileBundle {
    dependencies: _IComponentDependenciesAuditFileDependency[];
    asyncChunks?: _IComponentDependenciesAuditFileBundleAsyncChunks;
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFileBundleAsyncChunks {
    [chunkName: string]: {
        asyncComponentDependencies: _IComponentDependenciesAuditFileDependency[];
    };
}

/**
 * @internal
 */
export declare interface _IComponentDependenciesAuditFileDependency {
    componentId: string;
    componentName: string;
    componentVersion: string | undefined;
    isDirectDependency: boolean;
}

/**
 * @internal
 */
export declare interface _IComponentNamePluginOptions {
    getLibraryNameForChunk: (chunk: webpack.compilation.Chunk, existingId: string) => string | undefined;
}

/**
 * @public
 */
export declare interface IConfigBundle {
    /**
     * An array of components to be included in this bundle.
     */
    components: IConfigComponent[];
}

/**
 * @public
 */
export declare interface IConfigComponent {
    /**
     * The path to the code entrypoint for this component, relative to the project root.
     */
    entrypoint: string;
    /**
     * The path to the manifest for this component, relative to the project root.
     */
    manifest: string;
}

/**
 * @public
 */
export declare interface IConfigJson {
    $schema: string;
    /**
     * The config version
     */
    version: '2.0';
    /**
     * A list of bundle definitions. Bundle names may be between 10 and 30 lowercase alphanumeric or dash characters.
     */
    bundles: {
        [name: string]: IConfigBundle;
    };
    /**
     * The localized resources specified in config.json
     */
    localizedResources?: {
        [key: string]: string;
    };
    /**
     * The externals specified in config.json
     */
    externals?: {
        [name: string]: string | INonAMDExternalModuleConfig;
    };
    /**
     * A list of components that should generate a warning if made synchronous dependencies of any component in
     *  this project.
     */
    asyncComponents?: string[];
}

/**
 * @internal
 */
export declare interface _IConfigJsonResult extends _IBaseConfigJsonResult {
    /**
     * The data in the config file.
     */
    configData?: IConfigJson;
}

/**
 * @internal
 */
export declare interface _ICumulativeManifestEnvironmentOptions {
    rootPath: string;
    tempFolderName: string;
    distFolderName: string;
    terminal: ITerminal;
}

/**
 * @internal
 */
export declare interface _ICumulativeManifestOptions {
    /**
     * IDs of manifests to exclude from the manifest map file.
     */
    ignoreOutputManifestIds: string[];
    /**
     * The base path for debug manifests. Expected to match the result of the "debugBasePath" function passed to the
     *  WriteManifestsTask task.
     */
    baseUrl?: string;
    /**
     * Optional array of IDs to ensure aren't filtered out of the results if they are discovered.
     */
    explicitInclude: string[];
    /**
     * If set to true, include assemblies. Defaults to false. Assemblies are excluded by default.
     */
    includeAssemblies: boolean;
    /**
     * If set to true, validate manifests against the SPFx manifest schema. If the manifest is invalid, ignore it.
     */
    ignoreNonSpfxManifests: boolean;
}

/**
 * @internal
 */
export declare interface _ICustomActionConfiguration {
    /**
     * The type of custom action, use "ClientSideExtension.ApplicationCustomizer" for the Application Customizer
     *  extension.
     */
    location: 'ClientSideExtension.ApplicationCustomizer' | 'ClientSideExtension.ListViewCommandSet.ContextMenu' | 'ClientSideExtension.ListViewCommandSet.CommandBar' | 'ClientSideExtension.ListViewCommandSet' | 'ClientSideExtension.SearchQueryModifier';
    properties?: unknown;
}

/**
 * @internal
 */
export declare interface _ICustomizeWebpackConfigurationPluginOptions {
    customizationFilename: string;
}

/**
 * @public
 */
export declare interface IDeployFile {
    localPath: string;
    deployPath: string;
}

/**
 * @internal
 */
export declare interface _IDeployToAzureOptions {
    terminal: ITerminal;
    emitError: (error: Error) => void;
    buildFolder: string;
    tryCreateContainer: boolean;
    rigConfig?: IRigConfig;
}

/**
 * @public
 */
export declare interface IDevDeployConfig {
    accountName: string;
    sas: string;
    containerName: string;
    /**
     * The directory in the Azure container to use. Recommended to be set to something that includes your user name
     *  to ensure you don't clobber others' work.
     */
    folderNameInContainer?: string;
    /**
     * If false, the current project directory and its dependencies are deployed. If true, we attempt to find a
     *  rush.json file and deploy everything in the repo. Defaults to false.
     */
    useRush: boolean;
    /**
     * The number of upload retries
     */
    maxRetries?: number;
    /**
     * Include these folders alongside the "dist" directory. This is useful for deploying integration tests.
     *
     * @internal
     */
    _additionalFoldersToInclude?: string[];
    /**
     * True if the deployment is in a prod environment.
     */
    isProd?: boolean;
}

/**
 * @public
 */
export declare interface IDevDeployData {
    filesToUpload: IDeployFile[];
    loaderPath?: string;
}

/**
 * @public
 */
export declare interface IDevDeployOptions {
    /**
     * If true, projects will be uploaded into individual directories. This is useful if projects have files that may
     *  have conflicting names. If this is false and a collision is detected, a warning will be printed. Defaults to true.
     */
    isolateProjects?: boolean;
    /**
     * The project root path
     */
    rootPath: string;
    terminal: ITerminal;
    ignoreCollisions?: boolean;
    devDeployConfig: IDevDeployConfig;
}

/**
 * @public
 */
export declare interface IDevDeployParameters {
    rush: boolean;
    maxRetries: number | undefined;
}

/**
 * @public
 */
export declare interface IDevDeployPluginAccessor {
    hooks: DevDeployHooks;
    properties: IDevDeployPluginAccessorProperties;
}

/**
 * @public
 */
export declare interface IDevDeployPluginAccessorProperties {
    /**
     * @internal
     */
    _manifestsJsFileMetadata?: _IManifestsFileMetadata;
}

/**
 * Defines the necessary information to generate a feature xml
 */
/**
 * @public
 */
export declare interface IDevProperties {
    name: string;
    websiteUrl: string;
    privacyUrl: string;
    termsOfUseUrl: string;
    mpnId?: string;
}

/**
 * @internal
 */
export declare interface _IDiscoverManifestsOptions {
    /**
     * The directory in each project's directory where we should search for manifests. Defaults to "dist"
     */
    projectTargetFolder?: string;
    /**
     * The regex to use to search for manifest files. Defaults to /^[^\.\\\/]+\.manifest\.json$/
     */
    manifestFileRegex?: RegExp;
    /**
     * If expressly set to false, realpath symlinks while crawling.
     */
    preserveSymlinks?: boolean;
}

/**
 * @internal
 */
export declare interface _IDynamicExternalProject extends _IExternalProject {
    /**
     * A function to get the failover path given the package's root.
     */
    getFailoverPath?: (projectRootPath: string) => string;
    /**
     * A function to get the version of the package. Return undefined if the package is not a dependency.
     */
    getVersion: (projectRootPath: string, referencedProjects: _IReferencedProjectMap) => string | undefined;
}

/**
 * @internal
 */
export declare interface _IExtendedAsset extends webpack.compilation.Asset {
    source: () => string;
    size: () => number;
    [_SPFX_MANIFEST_RELEASE_VARIANT_SYMBOL]?: string;
}

/**
 * @internal
 */
export declare interface _IExtendedCompilation extends webpack.compilation.Compilation {
    options: webpack.Configuration;
    assets: _WebpackAssets;
}

/**
 * @public
 */
export declare interface IExtensionDefinition {
}

/**
 * @internal
 */
export declare interface _IExternalProject {
    /**
     * The ID of the project from the manifest.
     */
    id: string;
    /**
     * The name of the project.
     */
    name: string;
    /**
     * The version of the project from the manifest.
     */
    version: string | undefined;
    /**
     * The failover path, if one exists.
     */
    failoverPath?: string;
}

/**
 * @internal
 */
export declare interface _IExternalProjectMap {
    [name: string]: _IExternalProject;
}

/**
 * @public
 */
export declare interface IFeature {
    title: string;
    description: string;
    id: string;
    version?: string;
    componentIds?: string[];
    components?: IComponent[];
    assets?: ISharepointAssets<string>;
}

/**
 * @internal
 */
export declare interface _IFieldCustomizerConfiguration {
    /**
     * The ID of the field customizer component.
     */
    id: string;
    properties?: unknown;
}

/**
 * @internal
 *
 * @remarks this interface is used to construct query string for List Form page.
 * The service (server-side) expects parameters in PascalCase.
 * That's why we are using PascalCase here instead of camelCase.
 */
export declare interface _IFormCustomizerConfiguration {
    componentId: string;
    /**
     * Form Display Mode.
     * See {@link @microsoft/sp-core-library#FormDisplayMode} for more information.
     */
    PageType: 4 | 6 | 8;
    /**
     * Server relative URL to the current folder of the list.
     */
    RootFolder: string;
    /**
     * The ID of the content type for New form.
     */
    ContentTypeID?: string;
    /**
     * The ID of the item for Edit/Display forms.
     */
    ID?: number;
    /**
     * Component properties
     */
    properties?: unknown;
}

/**
 * @internal
 */
export declare interface _IGenerateLocalizedManifestModuleExistingIntegrityOptions extends _IGenerateLocalizedManifestModuleOptionsBase {
    generateIntegrity?: never;
    assets?: never;
}

/**
 * @internal
 */
export declare interface _IGenerateLocalizedManifestModuleGenerateIntegrityOptions extends _IGenerateLocalizedManifestModuleOptionsBase {
    generateIntegrity?: boolean;
    assets: _WebpackAssets;
}

/**
 * @internal
 */
export declare type _IGenerateLocalizedManifestModuleOptions = _IGenerateLocalizedManifestModuleGenerateIntegrityOptions | _IGenerateLocalizedManifestModuleExistingIntegrityOptions;

/**
 * @internal
 */
export declare interface _IGenerateLocalizedManifestModuleOptionsBase {
    bundleName: string;
    localizedPaths: {
        [locale: string]: string | IIntegrityPath;
    };
    firstPassLocaleRemapping: Map<string, string[]> | undefined;
    production: boolean;
    selectedLocales: ReadonlySet<string> | undefined;
}

declare interface IInfoPluginOptions {
    terminal: ITerminal;
    port?: number;
    tempFolderName?: string;
}

/**
 * @internal
 */
export declare interface _ILegacyExternal {
    moduleConfigurations: {
        [externalName: string]: IModuleConfiguration;
    };
    assets: {
        [name: string]: string;
    };
}

/**
 * @internal
 */
export declare interface _ILegacyLocalizationOptions {
    configJson: IConfigJson;
    terminal: ITerminal;
    selectedLocales: ReadonlyArray<string> | undefined;
    buildFolder: string;
    serveMode: boolean;
    production: boolean;
}

/**
 * @alpha
 */
export declare interface ILocalization {
    getProjectLocalizedStringsAsync(): Promise<ILocalizedStrings>;
    getLocFileTranslations(absoluteFilePath: string): ITranslationsForLocFile;
    getLocalizationConfigurationAsync(selectedLocales: Iterable<string>): Promise<ILocalizationConfiguration>;
}

/**
 * @alpha
 */
export declare interface ILocalizationConfiguration {
    localizationPlugin: LocalizationPlugin;
    stringsLoaders: webpack.RuleSetRule[];
    entityMarker: EntityMarker;
}

/**
 * @internal
 */
export declare interface _IManifestPluginOptions {
    terminal: ITerminal;
    bundleEntries: _IBundleEntry[];
    internalModuleBaseUrls: string[];
    debugInternalModuleBaseUrls: string[];
    linkedExternals: _IExternalProjectMap;
    referencedProjects: _IReferencedProjectMap;
    cumulativeManifestProcessor: _CumulativeManifestProcessor;
    sourceLocaleName: string;
    tryGetLocFileTranslations: (absoluteFilePath: string) => ITranslationsForLocFile | undefined;
    selectedLocales: Set<string> | undefined;
    production: boolean;
    includeIntegrity?: boolean;
    firstPassLocaleRemapping?: Map<string, string[]>;
    asyncOnlyDependencies?: _IAsyncOnlyDependenciesOptions;
    componentDependenciesAuditDropPath?: string;
    tryGetLegacyExternalByNameAsync?: (name: string) => Promise<_ILegacyExternal | undefined>;
    manifestsJsFileMetadata: _IManifestsFileMetadata | undefined;
}

/**
 * @internal
 */
export declare function _includeNonStandardExternal(name: string, external: _IDynamicExternalProject): void;

/**
 * Configuration for a non-AMD external module
 *
 * @public
 */
export declare interface INonAMDExternalModuleConfig {
    /**
     * The path or URL to the bundled external non-AMD file
     */
    path: string;
    /**
     * The name of the global variable where an non-AMD dependency drops its exports
     */
    globalName: string;
    /**
     * The names of the non-AMD dependencies for this project
     */
    globalDependencies?: string[];
}

/**
 * @public
 */
export declare interface IPackageSolution extends IPackageSolutionConfig {
    $schema: string;
}

/**
 * @public
 */
export declare interface IPackageSolutionConfig {
    paths: IPackageSolutionConfigPaths;
    /** A mapping of extensions to content types for resources included in the package */
    contentTypes: Record<string, string>;
    /**
     * The definition of this solution's package, features, and components
     */
    solution: ISolution;
}

/**
 * @public
 */
export declare interface IPackageSolutionConfigPaths {
    /**
     * The packaging root folder. Defaults to './sharepoint'. All other paths are relative to this folder.
     */
    packageDir: string;
    /**
     * The folder to write the raw package to disk for debugging. Defaults to 'solution/debug'
     */
    debugDir: string;
    /**
     * The name of the sppkg to create (including extension) Defaults to 'ClientSolution.sppkg'
     */
    zippedPackage: string;
    /**
     * The folder containing the custom feature xml to import into the package. Defaults to 'feature_xml'.
     * Note that all files in this folder will be included in the SPPKG, however, you must create a .rels
     * file for your custom feature for it to be included in the package manifest.
     */
    featureXmlDir: string;
    /**
     * The directory containing Sharepoint assets (such as feature elements, element manifests, and upgrade actions),
     * which will be automatically included in the sharepoint package. Defaults to 'assets'.
     */
    sharepointAssetDir: string;
    /**
     * The directory containing teams assets (such as icons)
     */
    teamsDir: string;
}

/**
 * @internal
 */
export declare interface _IReferencedProject {
    /**
     * The creation time of the newest version of this manifest we've found
     */
    manifestCreationTime: number;
    /**
     * The ID of the manifest.
     */
    id: string;
    /**
     * The version of the manifest.
     */
    version: string;
    /**
     * The project's manifest data
     */
    manifestData: IClientSideComponentManifest;
    /**
     * The path to the manifest.
     */
    manifestPath: string;
    /**
     * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only
     *  one manifest.
     */
    packageName: string;
    /**
     * If set to true, this is an assembly manifest
     */
    isAssembly: boolean;
}

/**
 * @internal
 */
export declare type _IReferencedProjectMap = _IVersionedIdMap<_IReferencedProject>;

/**
 * @public
 */
export declare const IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL: unique symbol;

/**
 * @internal
 *
 * @remarks
 * If this schema is updated, dependant schemas MUST also be updated, including the spfx-serve.schema.json.
 * The spfx-serve.schema.json is the serve.schema.json file with the spfx-specific properties included. The
 * merge is simple, but must be done manually whenever the serve.schema.json file is changed.
 */
export declare interface _IServeTaskConfig {
    /**
     * API server configuration
     */
    api?: {
        /**
         * The port on which to run the API server
         */
        port: number;
        /**
         * The path to the script to run as the API server
         */
        entryPath: string;
    };
    /**
     * The path to the page which should open automatically after this task completes. If you prefer no page to be
     * launched, run the build with the "--nobrowser" flag
     */
    initialPage?: string;
    /**
     * The port on which to host the file server.
     */
    port?: number;
    /**
     * The name of the host on which serve is running. Defaults to 'localhost'
     */
    hostname?: string;
    /**
     * IP address of the host on which serve is running.
     * @remarks
     * This parameter is helpful when using Docker containers. For example, to set the serve host as '0.0.0.0'.
     */
    ipAddress?: string;
    /**
     * If true, the server should run on HTTPS
     */
    https?: boolean;
    /**
     * The project relative path or array of paths to serve static content from.
     */
    contentBase?: string | string[];
    /**
     * The URL path to serve static content requests from.
     */
    contentBasePublicPath?: string;
    /**
     * Path to the HTTPS key
     */
    keyPath?: string;
    /**
     * Path to the HTTPS cert
     */
    certPath?: string;
    /**
     * Path to the HTTPS PFX cert
     */
    pfxPath?: string;
    /**
     * If true, when serve is initialized and a dev certificate doesn't already exist and hasn't been
     *  specified, attempt to generate one and trust it automatically.
     *
     * defaults to false
     */
    tryCreateDevCertificate?: boolean;
}

/**
 * A list of asset files which will be automatically included.
 * These are expected to be exist in the sharepointAssetDir.
 *
 * @public
 */
export declare interface ISharepointAssets<T> {
    /**
     * A list of element filenames.
     * Any supported files that accompany the element manifest will be an element file.
     * For example, the list instance schema is an element manifest that is associated with a
     * list instance that is defined in an element manifest.
     */
    elementManifests?: T[];
    /**
     * A list of element manifest filenames.
     */
    elementFiles?: T[];
    /**
     * A list of upgrade action filenames
     */
    upgradeActions?: T[];
}

/**
 * @public
 */
export declare interface ISolution {
    name: string;
    id: string;
    title?: string;
    supportedLocales?: string[];
    version?: string;
    features?: IFeature[];
    iconPath?: string;
    skipFeatureDeployment?: boolean;
    includeClientSideAssets?: boolean;
    clientSideAssets?: Array<ISolutionAsset>;
    webApiPermissionRequests?: Array<IWebApiPermissionRequest>;
    isDomainIsolated?: boolean;
    developer?: IDevProperties;
    metadata?: ISolutionMetadata;
}

/**
 * @public
 */
export declare interface ISolutionAsset {
    originalFilename: string;
    packageFilename: string;
}

/**
 * @public
 */
export declare interface ISolutionMetadata {
    shortDescription?: ILocalizedString;
    longDescription?: ILocalizedString;
    screenshotPaths?: string[];
    videoUrl?: string;
    categories?: SolutionCategories[];
}

/**
 * @internal
 */
export declare interface _ISolutionPackagerOptions {
    buildFolder: string;
    terminal: ITerminal;
    emitError: (error: Error) => void;
    emitWarning: (warning: Error) => void;
}

/**
 * Options for sp-client dev-deploy
 * @public
 */
export declare interface ISpDevDeployOptions extends IDevDeployOptions {
    /**
     * @internal
     */
    _projectDiscoveryMode?: _DependencyDiscoveryMode;
    /**
     * @internal
     */
    _manifestsJsFileMetadata?: _IManifestsFileMetadata;
}

/**
 * Describes the interface for serve.json config files in SPFx projects.
 *
 * @internal
 */
export declare interface _ISpfxServe extends _ISpfxServeTaskConfig {
    $schema: string;
}

/**
 * @internal
 */
export declare interface _ISpfxServeSessionConfiguration {
    /**
     * The fully-qualified URL of the page to launch
     */
    pageUrl: string;
    /**
     * An optional list of custom actions to provide as query parameters to the page. The key of this
     *  object must be the ID of the custom action component.
     */
    customActions?: {
        [id: string]: _ICustomActionConfiguration;
    };
    /**
     * An optional list of field customizers to provide as query parameters to the page. The key of this
     *  object must be the field ID the customizer applies to.
     */
    fieldCustomizers?: {
        [fieldName: string]: _IFieldCustomizerConfiguration;
    };
    /**
     * An optional list of form customizers to provide as query parameters to the page. The key of this
     * object must be the ID  of the form component.
     */
    formCustomizer?: _IFormCustomizerConfiguration;
}

/**
 * @remarks
 * If the GCB-serve schema is updated, this schema MUST also be updated. The spfx-serve.schema.json is
 * the serve.schema.json file with the spfx-specific properties included. The merge is simple, but
 * must be done manually whenever the serve.schema.json file in GCB is changed.
 *
 * @internal
 */
export declare interface _ISpfxServeTaskConfig extends _IServeTaskConfig {
    serveConfigurations?: {
        default: _ISpfxServeSessionConfiguration;
        [id: string]: _ISpfxServeSessionConfiguration;
    };
}

/**
 * @public
 */
export declare interface ISpfxWebpackConfiguration extends IWebpackConfigurationWithDevServer {
    [IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL]: true;
    [CONFIG_JSON_SYMBOL]: IConfigJson;
}

/**
 * @public
 */
export declare interface ISpfxWebpackFolderPaths {
    buildFolder: string;
    tempFolder: string;
    outputFolder: string;
    releaseFolder: string;
}

/**
 * @alpha
 */
export declare interface ITranslationsForLocFile {
    [locale: string]: Record<string, string>;
}

/**
 * Represents a file's local path and container-root-relative path in Azure Storage destination
 * @internal
 */
export declare interface _IUploadableFile {
    /**
     * A container-root-relative path to the file's Azure Storage destination
     *
     * For example, if the account name is "example" the container's name is "files",
     * and this property is "foo/bar/baz.json", the fully-qualified URL of the uploaded
     * file will be:
     * https://example.blob.core.windows.net/files/foo/bar/baz.json
     */
    azurePath: string;
    /**
     * A fully-qualified filesystem path to a file.
     */
    localPath: string;
    blobHeaders?: BlobHTTPHeaders;
}

/**
 * @internal
 */
export declare interface _IVersionedIdMap<TMember> {
    [id: string]: _IVersionMap<TMember>;
}

/**
 * @internal
 */
export declare interface _IVersionMap<TMember> {
    [version: string]: TMember;
}

/**
 * Defines the necessary information to generate the WebApiPermissionRequests xml nodes.
 */
/**
 * @public
 */
export declare interface IWebApiPermissionRequest {
    resource: string;
    scope: string;
    appId?: string;
    replyUrl?: string;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationGeneratorOptions {
    configJson: IConfigJson;
    folders: ISpfxWebpackFolderPaths;
    terminal: ITerminal;
    emitStats?: boolean;
    production: boolean;
    serveMode: boolean;
    projectPackageJson: IPackageJson;
    /**
     * @alpha
     */
    getLocalization?: () => ILocalization;
    selectedLocales?: ReadonlyArray<string>;
    linkedExternalsToBundle?: string[];
    libraryName?: string;
    libraryTarget?: WebpackLibraryTarget;
    disableAsyncComponentLoading?: boolean;
    assetsAreVersioned?: boolean;
    generateCssClassName?: GenerateCssClassNameFunction;
    loadThemedStylesImportPath?: string;
    releaseManifestFolderName?: string;
    crossOriginLoading?: boolean;
    /**
     * @internal
     */
    _manifestsJsFileMetadata?: _IManifestsFileMetadata;
    /**
     * @internal
     */
    _includeIntegrityInManifestPaths?: boolean;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationPluginAccessor {
    properties: IWebpackConfigurationPluginAccessorProperties;
}

/**
 * @public
 */
export declare interface IWebpackConfigurationPluginAccessorProperties {
    linkedExternalsToBundle?: string[];
    libraryName?: string;
    libraryTarget?: WebpackLibraryTarget;
    disableAsyncComponentLoading?: boolean;
    assetsAreVersioned?: boolean;
    generateCssClassName?: GenerateCssClassNameFunction;
    loadThemedStylesImportPath?: string;
    configJson?: IConfigJson;
    /**
     * @alpha
     */
    getLocalization?: () => ILocalization;
    releaseManifestFolderName?: string;
    /**
     * @internal
     */
    _manifestsJsFileMetadata?: _IManifestsFileMetadata;
    /**
     * @internal
     */
    _allowMissingConfigJson?: boolean;
    /**
     * @internal
     */
    _includeIntegrityInManifestPaths?: boolean;
}

/**
 * @internal
 */
export declare interface _IWebpackEntrypoint {
    readonly runtimeChunk: ILocalizedWebpackChunk;
}

/**
 * @public
 */
export declare interface IWebpackServeConfigurationPluginAccessor {
    properties: {
        getAdditionalServePathsAsync?: () => Promise<Map<string, string>>;
    };
}

/**
 * @internal
 */
export declare interface _IWebpackStatsPluginOptions {
    dropPath: string;
}

/**
 * @public
 */
export declare interface IWebPartDefinition {
    entries: IWebPartEntryDefinition[];
}

/**
 * Entry Definition of a WebPart component.
 *
 * id:          Id of the entry, to be used for file names, as opposed to the id.
 *              It's in the form of <webPartId>_<entryNumber> (i.e. x...x-xxxx-xxxx-xxxx-x...x_0)
 *
 * webPartData: Serialized webPartData. It comes from the pre-configured entry and is used for
 *              the initial webPartData of the client-side web part the first time it renders.
 * @public
 */
export declare interface IWebPartEntryDefinition {
    id: string;
    name: string;
    description: string;
    webPartData: string;
}

/**
 * @internal
 */
export declare class _LegacyExternals {
    private readonly _configJson;
    private readonly _terminal;
    private readonly _buildFolder;
    private readonly _serveMode;
    private readonly _production;
    private readonly _selectedLocales;
    private _discoveredLocalizedResources;
    private _legacyExternalsByName;
    constructor(options: _ILegacyLocalizationOptions);
    updateWebpackConfiguration(webpackConfiguration: webpack.Configuration): void;
    private _ensureLocalizedResourcesAsync;
    private _collectResourcesForKeyAsync;
    private _tryGetLegacyExternalsByNameAsync;
}

/**
 * @internal
 */
export declare function _loadServeSchemaJson(): object;

/**
 * @internal
 */
export declare class _LocalizedManifestModuleProcessor {
    static readonly LOCALE_MAPPING: Map<string, string[]>;
    static LOCALE_FALLBACK: Map<string, string>;
    static generateLocalizedManifestModule({ bundleName, localizedPaths, firstPassLocaleRemapping, production, selectedLocales, assets, generateIntegrity }: _IGenerateLocalizedManifestModuleOptions): ILocalizedPathModuleConfiguration;
    static findDefaultString(localizedPaths: Record<string, string | undefined>): string | undefined;
    static findDefaultString(localizedPaths: _LocalizedPaths): string | IIntegrityPath | undefined;
    static applyLocaleRemapping(manifestLocalizedPaths: _LocalizedPaths, localeRemapping: Map<string, string[]>): void;
}

/**
 * @internal
 */
export declare type _LocalizedPaths = Record<string, string | IIntegrityPath | undefined>;

/**
 * @internal
 */
export declare class _ManifestPlugin implements webpack.Plugin {
    /**
     * @internal
     */
    _options: _IManifestPluginOptions;
    private _parsedLocFileCache;
    /**
     * @internal
     */
    static _tryGetReleaseManifestVariant(asset: webpack.compilation.Asset): string | undefined;
    constructor(options: _IManifestPluginOptions);
    apply(compiler: webpack.Compiler): void;
    /**
     * @virtual
     */
    protected _generateLoaderConfigurationAsync(terminal: ITerminal, bundleName: string, compilation: _IExtendedCompilation, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, _IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<IClientSideComponentLoaderConfiguration>;
    protected _getRuntimeChunk(bundleName: string, entrypoint: _IWebpackEntrypoint): ILocalizedWebpackChunk;
    protected _getExternalsScriptResourcesAsync(terminal: ITerminal, bundleName: string, runtimeChunk: webpack.compilation.Chunk, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, _IComponentDependenciesAuditFileDependency>, emitAsset: (assetName: string, assetContents: string) => void): Promise<{
        [name: string]: IModuleConfiguration;
    }>;
    protected _getRuntimeChunkInfo(bundleName: string, runtimeChunk: webpack.compilation.Chunk, assets: _WebpackAssets): string | IIntegrityPath;
    private _generateComponentManifest;
    /**
     * Process and localize WebPart manifest.
     * @remarks Also used for AdaptiveCardExtension manifests
     */
    private _processWebpartManifest;
    private _processApplicationManifest;
    /**
     * Does extension-specific manifest processing.
     */
    private _processExtensionsManifest;
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    private _localizeString;
    private _getEntryManifestModule;
    private _populateLinkedExternalComponentInDependencyMap;
}

/**
 * @internal
 */
export declare function _migrateToLatestVersion(logWarning: (message: string) => void, configJson: IConfigJson): void;

/**
 * Normalizes a locale name. So "en-us" becomes "en-US" and "sr-cyrl-rs" becomes "sr-Cyrl-RS". There are two special
 *  cases. For pseudo-locales like "qps-ploc", everything stays lowecase. For language-script locales like "uz-Cyrl",
 *  only the script name's first character should be uppercased.
 *
 * @internal
 */
export declare function _normalizeLocaleName(localeName: string): string;

/**
 * @public
 */
declare const PackageSolutionPlugin: 'package-solution-plugin';

declare namespace PluginNames {
    export {
        DevDeployPlugin,
        SpfxHeftPlugin,
        SpfxHeftExtensionsPlugin,
        SpfxWebpackConfigurationPlugin,
        SpfxWebpackServePlugin,
        CustomizeWebpackConfigPlugin,
        PackageSolutionPlugin,
        ThirdPartyExternalsPlugin,
        DeployAzureStoragePlugin
    }
}
export { PluginNames }

/**
 * @internal
 */
export declare function _readConfigFile(logVerbose: (message: string) => void, filename: string): _IConfigJsonResult;

/**
 * @internal
 */
export declare function _readServeConfigFile(configPath: string): _ISpfxServe;

/**
 * @internal
 */
export declare class _ServeInfoPlugin implements webpack.Plugin {
    baseUrlSearchParams: URLSearchParams_2 | undefined;
    readonly port: number;
    private readonly _terminal;
    private readonly _tempFolderName;
    constructor(options: IInfoPluginOptions);
    /**
     * Print information to the developer's console.
     */
    apply(compiler: webpack.Compiler): void;
}

/**
 * For the list of categories see response for https://partner.microsoft.com/en-us/dashboard/office/products/00000000-0000-0000-0000-000000000000/properties
 * where 00000000-0000-0000-0000-000000000000 should be replaced with a valid application guid from the partner center
 * @public
 */
export declare type SolutionCategories = 'Accounting + Finance' | 'Collaboration' | 'Content management' | 'CRM' | 'Data + analytics' | 'File managers' | 'IT/admin' | 'Legal + HR' | 'News + weather' | 'Productivity' | 'Project management' | 'Reference' | 'Sales + marketing' | 'Site Design' | 'Social' | 'Workflow & Process Management';

/**
 * @internal
 */
export declare class _SolutionPackager {
    private static readonly _configFile;
    private readonly _buildFolder;
    private readonly _webpackOutputFolderPaths;
    private readonly _terminal;
    private readonly _emitError;
    private readonly _emitWarning;
    private _alreadyTriedToLoadConfig;
    private _config;
    constructor(options: _ISolutionPackagerOptions);
    packageSolutionAsync(production: boolean, prettyPrintXml?: boolean, noSpppkg?: boolean): Promise<void>;
    getCleanPathsAsync(): Promise<string[]>;
    private _ensureConfigFileAsync;
    private _updateContentTypes;
    private _getFilesExtensions;
}

/**
 * @public
 */
export declare class SpDevDeploy {
    private static readonly _debugManifestPath;
    private static __spDevDeployConfigFile;
    private static get _spDevDeployConfigFile();
    private _rushConfig;
    private _options;
    private _devDeployManifestFileUrl;
    private _devDeployModuleLoaderUrl;
    private _devDeployMetadata;
    private readonly _collisionDetectionMap;
    private _configFileData;
    static getDevDeployContainerDirectoryName(): string;
    static initializeAsync(options: ISpDevDeployOptions): Promise<SpDevDeploy>;
    preProcess(): void;
    getFilesAsync(): Promise<IDevDeployData>;
    getFilesInFolderAsync(localDirPath: string, deployDirName: string): Promise<IDeployFile[]>;
    postProcess(): void;
    private constructor();
    private _getFilesInFolderInnerAsync;
    private _printCollisionWarnings;
    private _saveDevDeployMetadata;
    private _printDevDeployLink;
    private _getDeployBaseUrl;
    private _getContainerUrl;
    private _getAzureStorageUrl;
    private _processAllPathsInManifest;
    /**
     * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
     * not collide with another directory's name. It also ensures that if the specified filesystem path has already
     * been mapped to a destination directory, the same name is used in the destination.
     */
    private _getDestinationDirName;
    private _getManifests;
    private _mergeReferencedProjectLists;
    private _doComponentTypeSpecificFixup;
    private _fixupIconPath;
    private _getRushConfig;
    private _getMetadataDropPath;
    private _doesFilenameAppearToContainHash;
}

/**
 * @internal
 */
export declare const _SPFX_MANIFEST_RELEASE_VARIANT_SYMBOL: unique symbol;

/**
 * @public
 */
declare const SpfxHeftExtensionsPlugin: 'spfx-heft-extensions-plugin';

/**
 * @public
 */
declare const SpfxHeftPlugin: 'spfx-heft-plugin';

/**
 * @public
 */
declare const SpfxWebpackConfigurationPlugin: 'spfx-webpack-configuration-plugin';

/**
 * @public
 */
declare const SpfxWebpackServePlugin: 'spfx-webpack-serve-plugin';

/**
 * @public
 */
declare const ThirdPartyExternalsPlugin: 'third-party-externals-plugin';

/**
 * @internal
 */
export declare type _WebpackAssets = Record<string, _IExtendedAsset>;

/**
 * @public
 */
export declare class WebpackConfigurationGenerator {
    static generateWebpackConfigurationAsync(options: IWebpackConfigurationGeneratorOptions): Promise<ISpfxWebpackConfiguration | undefined>;
    static getComponentsBundleId(manifests: IClientSideComponentManifest[]): string;
    private static _getBundleId;
    /**
     * Writes the entrypoint file to the temp directory and returns the path to the file.
     */
    private static _generateBundleEntrypointFile;
    private static _requireResolveWithCorrectCase;
    private static _validateEntries;
}

/**
 * @public
 */
export declare type WebpackLibraryTarget = 'amd' | 'var' | 'this' | 'commonjs' | 'commonjs2' | 'umd' | 'window' | 'assign' | 'jsonp';

/**
 * This plugin drops the webpack stats object to the specified filesystem path
 *
 * @internal
 */
export declare class _WebpackStatsPlugin implements webpack.Plugin {
    private _options;
    constructor(options: _IWebpackStatsPluginOptions);
    apply(compiler: webpack.Compiler): void;
}

export { }
