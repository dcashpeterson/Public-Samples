{"version":3,"file":"adaptivecards-templating.min.js","mappings":"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","sources":["webpack://ACData/webpack/universalModuleDefinition","webpack://ACData/./src/adaptivecards-templating.ts","webpack://ACData/./src/json-schema-card.ts","webpack://ACData/./src/template-engine.ts","webpack://ACData/external umd {\"commonjs2\":\"adaptive-expressions\",\"commonjs\":\"adaptive-expressions\",\"root\":\"AEL\"}","webpack://ACData/webpack/bootstrap","webpack://ACData/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"adaptive-expressions\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ACData\"] = factory(require(\"adaptive-expressions\"));\n\telse\n\t\troot[\"ACData\"] = factory(root[\"AEL\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__949__) {\nreturn ","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nexport * from \"./template-engine\";\r\nexport * from \"./json-schema-card\";","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IAdaptiveCard, ICardElement, IChoiceSetInput, IContainer, INumberInput, ITextInput, ITimeInput, IToggleInput } from 'adaptivecards/src/schema';\r\nimport { JSONSchema7, JSONSchema7Definition, JSONSchema7Type } from 'json-schema';\r\n\r\n\r\n// JSON Schema Card\r\n// generates an Adaptive Card given a JSON schema\r\nexport function JSONSchemaCard(schema: JSONSchema7): IAdaptiveCard | undefined {\r\n\ttry {\r\n\t\treturn {\r\n\t\t\ttype: \"AdaptiveCard\",\r\n\t\t\tbody: [\r\n\t\t\t\tJSONSchemaCardObject(schema, '', 0),\r\n\t\t\t],\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t\treturn undefined;\r\n\t}\r\n}\r\n\r\n\r\n// JSON Schema Elements\r\n\r\nfunction JSONSchemaCardElement(schema: JSONSchema7Definition, path: string, depth: number): ICardElement {\r\n    if (typeof (schema) === \"boolean\") return null;\r\n    switch (schema.type) {\r\n        case \"array\":\r\n            if (Array.isArray(schema.items)) {\r\n                return JSONSchemaCardTuple(schema, path, depth);\r\n            } else {\r\n                return JSONSchemaCardList(schema, path, depth);\r\n            }\r\n        case \"object\":\r\n            return JSONSchemaCardObject(schema, path, depth);\r\n        case \"boolean\":\r\n            return JSONSchemaCardBoolean(schema, path)\r\n        case \"integer\":\r\n        case \"number\":\r\n            return JSONSchemaCardNumber(schema, path)\r\n        case \"string\":\r\n            if (schema.enum) {\r\n                return JSONSchemaCardChoiceSet(schema, path)\r\n            } else {\r\n                return JSONSchemaCardText(schema, path)\r\n            }\r\n        case \"date-time\":\r\n        case \"time\":\r\n        case \"date\":\r\n            return JSONSchemaCardTime(schema, path)\r\n        default:\r\n            return null;\r\n    }\r\n}\r\n\r\nfunction encodeProperty(property: string) {\r\n    return encodeURIComponent(property).replace('.', '%2e')\r\n}\r\n\r\nfunction textSizeAtDepth(depth: number) {\r\n    switch (depth) {\r\n        case 0:\r\n            \"large\"\r\n        case 1:\r\n            \"medium\"\r\n        default:\r\n            \"small\"\r\n    }\r\n}\r\n\r\nfunction JSONSchemaFieldTitle(schema: JSONSchema7, path: string, depth: number): ICardElement[] {\r\n    return [\r\n        schema.title ? {\r\n            type: \"TextBlock\",\r\n            size: textSizeAtDepth(depth),\r\n            text: schema.title,\r\n        } : null,\r\n        schema.description ? {\r\n            type: \"TextBlock\",\r\n            size: textSizeAtDepth(depth + 1),\r\n            isSubtle: true,\r\n            wrap: true,\r\n            text: schema.description,\r\n        } : null,\r\n    ]\r\n}\r\n\r\nfunction JSONSchemaCardTuple(schema: JSONSchema7, path: string, depth: number): IContainer {\r\n    if (!Array.isArray(schema.items)) return null;\r\n    return {\r\n        type: \"Container\",\r\n        items: [\r\n            ...JSONSchemaFieldTitle(schema, path, depth),\r\n            ...schema.items?.map((item: JSONSchema7Definition, idx: number) => {\r\n                return JSONSchemaCardElement(item, `${path}[${idx}]`, depth + 1)\r\n            }) ?? [],\r\n        ],\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardList(schema: JSONSchema7, path: string, depth: number): IContainer {\r\n    return {\r\n        type: \"Container\",\r\n        items: [\r\n            ...JSONSchemaFieldTitle(schema, path, depth),\r\n            // TODO not implemented\r\n        ],\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardObject(schema: JSONSchema7, path: string, depth: number): IContainer {\r\n    return {\r\n        type: \"Container\",\r\n        items: [\r\n            ...JSONSchemaFieldTitle(schema, path, depth),\r\n            ...schema.required?.map((property: string) => {\r\n                return JSONSchemaCardElement(schema.properties[property], `${path}.${encodeProperty(property)}`, depth + 1)\r\n            }) ?? [],\r\n        ],\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardBoolean(schema: JSONSchema7, path: string): IToggleInput {\r\n    return {\r\n        type: \"Input.Toggle\",\r\n        id: path,\r\n        title: schema.title,\r\n        label: schema.description,\r\n        value: schema.default as string,\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardNumber(schema: JSONSchema7, path: string): INumberInput {\r\n    return {\r\n        type: \"Input.Number\",\r\n        id: path,\r\n        title: schema.title,\r\n        placeholder: schema.description,\r\n        value: schema.default as string,\r\n        min: schema.exclusiveMinimum ?? schema.minimum,\r\n        max: schema.exclusiveMaximum ?? schema.maximum,\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardChoiceSet(schema: JSONSchema7, path: string): IChoiceSetInput {\r\n    return {\r\n        type: \"Input.ChoiceSet\",\r\n        id: path,\r\n        title: schema.title,\r\n        choices: schema.enum.map((item: JSONSchema7Type) => {\r\n            return {\r\n                title: item as string,\r\n                value: item as string,\r\n            }\r\n        }),\r\n        placeholder: schema.description,\r\n        value: schema.default as string,\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardText(schema: JSONSchema7, path: string): ITextInput {\r\n    return {\r\n        type: \"Input.Text\",\r\n        id: path,\r\n        title: schema.title,\r\n        placeholder: schema.description,\r\n        value: schema.default as string,\r\n        maxLength: schema.maxLength,\r\n        regex: schema.pattern,\r\n    }\r\n}\r\n\r\nfunction JSONSchemaCardTime(schema: JSONSchema7, path: string): ITimeInput {\r\n    return {\r\n        type: \"Input.Time\",\r\n        id: path,\r\n        title: schema.title,\r\n        placeholder: schema.description,\r\n        value: schema.default as string,\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport * as AEL from \"adaptive-expressions\";\r\nconst pkg = require('./../package.json');\r\n\r\nclass EvaluationContext {\r\n    private static readonly _reservedFields = [\"$data\", \"$when\", \"$root\", \"$index\", \"$host\", \"$_acTemplateVersion\"];\r\n\r\n    private _stateStack: Array<{ $data: any, $index: any }> = [];\r\n    private _$data: any;\r\n\r\n    $root: any;\r\n    $host: any;\r\n    $index: number;\r\n    $_acTemplateVersion: any;\r\n\r\n    constructor(context?: IEvaluationContext) {\r\n        if (context !== undefined) {\r\n            this.$_acTemplateVersion = this.generateVersionJson();\r\n\r\n            this.$root = context.$root;\r\n            this.$host = context.$host;\r\n        }\r\n    }\r\n\r\n    isReservedField(name: string): boolean {\r\n        return EvaluationContext._reservedFields.indexOf(name) >= 0;\r\n    }\r\n\r\n    saveState() {\r\n        this._stateStack.push(\r\n            {\r\n                $data: this.$data,\r\n                $index: this.$index\r\n            });\r\n    }\r\n\r\n    restoreLastState() {\r\n        if (this._stateStack.length === 0) {\r\n            throw new Error(\"There is no evaluation context state to restore.\");\r\n        }\r\n\r\n        let savedContext = this._stateStack.pop();\r\n\r\n        this.$data = savedContext.$data;\r\n        this.$index = savedContext.$index;\r\n    }\r\n\r\n    get $data(): any {\r\n        return this._$data !== undefined ? this._$data : this.$root;\r\n    }\r\n\r\n    set $data(value: any) {\r\n        this._$data = value;\r\n    }\r\n\r\n    generateVersionJson() {\r\n        // Example version: 2.3.0-alpha\r\n        const version = pkg.version;\r\n        const versionSplit = version.split('.');\r\n\r\n        let patchSplit = [];\r\n        const patchIndex = 2;\r\n        if (versionSplit[patchIndex]) {\r\n            patchSplit = versionSplit[patchIndex].split('-');\r\n        }\r\n\r\n        return {\r\n            \"major\": parseInt(versionSplit[0]),\r\n            \"minor\": parseInt(versionSplit[1]),\r\n            \"patch\": parseInt(patchSplit[0]),\r\n            \"suffix\": patchSplit[1] || \"\",\r\n        }\r\n    }\r\n}\r\n\r\nclass TemplateObjectMemory implements AEL.MemoryInterface {\r\n    private _memory: AEL.MemoryInterface;\r\n\r\n    $root: any;\r\n    $data: any;\r\n    $index: any;\r\n    $host: any;\r\n    $_acTemplateVersion: any;\r\n\r\n    constructor() {\r\n        this._memory = new AEL.SimpleObjectMemory(this);\r\n    }\r\n\r\n    getValue(path: string): any {\r\n        let actualPath = (path.length > 0 && path[0] !== \"$\") ? \"$data.\" + path : path;\r\n\r\n        return this._memory.getValue(actualPath);\r\n    }\r\n\r\n    setValue(path: string, input: any) {\r\n        this._memory.setValue(path, input);\r\n    }\r\n\r\n    version(): string {\r\n        return this._memory.version();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds global settings that can be used to customize the way templates are expanded.\r\n */\r\nexport class GlobalSettings {\r\n    /**\r\n     * Callback invoked when expression evaluation needs the value of a field in the source data object\r\n     * and that field is undefined or null. By default, expression evaluation will substitute an undefined\r\n     * field with its binding expression (e.g. `${field}`). This callback makes it possible to customize that\r\n     * behavior.\r\n     *\r\n     * **Example**\r\n     * Given this data object:\r\n     *\r\n     * ```json\r\n     * {\r\n     *     firstName: \"David\"\r\n     * }\r\n     * ```\r\n     *\r\n     * The expression `${firstName} ${lastName}` will evaluate to \"David ${lastName}\" because the `lastName`\r\n     * field is undefined.\r\n     *\r\n     * Now let's set the callback:\r\n     * ```typescript\r\n     * GlobalSettings.getUndefinedFieldValueSubstitutionString = (path: string) => { return \"<undefined value>\"; }\r\n     * ```\r\n     *\r\n     * With that, the above expression will evaluate to \"David &lt;undefined value&gt;\"\r\n     */\r\n    static getUndefinedFieldValueSubstitutionString?: (path: string) => string | undefined = undefined;\r\n}\r\n\r\n/**\r\n * Holds the context used to expand a template.\r\n */\r\nexport interface IEvaluationContext {\r\n    /**\r\n     * The root data object the template will bind to. Expressions that refer to $root in the template payload\r\n     * map to this field. Initially, $data also maps to $root.\r\n     */\r\n    $root?: any;\r\n    /**\r\n     * The host data object the template will bind to. Expressions that refer to $host in the template payload\r\n     * map to this field. This allows a host process to supply additional context to the template.\r\n     */\r\n    $host?: any;\r\n}\r\n\r\n/**\r\n * Represents a template that can be bound to data.\r\n */\r\nexport class Template {\r\n\r\n    private templateExpansionWarnings;\r\n\r\n    private static prepare(node: any): any {\r\n        if (typeof node === \"string\") {\r\n            return Template.parseInterpolatedString(node);\r\n        }\r\n        else if (typeof node === \"object\" && node !== null) {\r\n            if (Array.isArray(node)) {\r\n                let result: any[] = [];\r\n\r\n                for (let item of node) {\r\n                    result.push(Template.prepare(item));\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                let keys = Object.keys(node);\r\n                let result = {};\r\n\r\n                for (let key of keys) {\r\n                    result[key] = Template.prepare(node[key]);\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    }\r\n\r\n    private static internalTryEvaluateExpression(expression: AEL.Expression, context: EvaluationContext, allowSubstitutions: boolean): { value: any; error: string } {\r\n        let memory = new TemplateObjectMemory();\r\n        memory.$root = context.$root;\r\n        memory.$data = context.$data;\r\n        memory.$index = context.$index;\r\n        memory.$host = context.$host;\r\n        memory.$_acTemplateVersion = context.$_acTemplateVersion;\r\n\r\n        let options: AEL.Options | undefined = undefined;\r\n\r\n        if (allowSubstitutions) {\r\n            options = new AEL.Options();\r\n            options.nullSubstitution = (path: string) => {\r\n                let substitutionValue: string | undefined = undefined;\r\n\r\n                if (GlobalSettings.getUndefinedFieldValueSubstitutionString) {\r\n                    substitutionValue = GlobalSettings.getUndefinedFieldValueSubstitutionString(path);\r\n                }\r\n\r\n                return substitutionValue ? substitutionValue : \"${\" + path + \"}\";\r\n            }\r\n        }\r\n\r\n        // The root of an expression coming from an interpolated string is of type Concat.\r\n        // In that case, and if the caller allows it, we're doing our own concatenation\r\n        // in order to catch each individual expression evaluation error and substitute in\r\n        // the final string\r\n        if (expression.type === AEL.ExpressionType.Concat && allowSubstitutions) {\r\n            let result = \"\";\r\n\r\n            for (let childExpression of expression.children) {\r\n                let evaluationResult: { value: any; error: string };\r\n\r\n                try {\r\n                    evaluationResult = childExpression.tryEvaluate(memory, options);\r\n                }\r\n                catch (ex) {\r\n                    // We'll swallow all exceptions here\r\n                    evaluationResult = {\r\n                        value: undefined,\r\n                        error: ex\r\n                    };\r\n                }\r\n\r\n                if (evaluationResult.error) {\r\n                    evaluationResult.value = \"${\" + childExpression.toString() + \"}\";\r\n                }\r\n\r\n                result += evaluationResult.value.toString();\r\n            }\r\n\r\n            return { value: result, error: undefined };\r\n        }\r\n\r\n        return expression.tryEvaluate(memory, options);\r\n    }\r\n\r\n    /**\r\n     * Parses an interpolated string into an Expression object ready to evaluate.\r\n     *\r\n     * @param interpolatedString The interpolated string to parse. Example: \"Hello ${name}\"\r\n     * @returns An Expression object if the provided interpolated string contained at least one expression (e.g. \"${expression}\"); the original string otherwise.\r\n     */\r\n    public static parseInterpolatedString(interpolatedString: string): AEL.Expression | string {\r\n        let lookup: AEL.EvaluatorLookup = (type: string) => {\r\n            let standardFunction = AEL.ExpressionFunctions.standardFunctions.get(type);\r\n\r\n            if (standardFunction) {\r\n                return standardFunction;\r\n            }\r\n            else {\r\n                return new AEL.ExpressionEvaluator(\r\n                    type,\r\n                    (expression: AEL.Expression, state: AEL.MemoryInterface, options: AEL.Options) => { throw new Error(\"Unknown function \" + type); },\r\n                    AEL.ReturnType.String);\r\n            }\r\n        }\r\n\r\n        // If there is at least one expression start marker, let's attempt to convert into an expression\r\n        if (interpolatedString.indexOf(\"${\") >= 0) {\r\n            let parsedExpression = AEL.Expression.parse(\"`\" + interpolatedString + \"`\", lookup);\r\n\r\n            if (parsedExpression.type === \"concat\") {\r\n                if (parsedExpression.children.length === 1 && !(parsedExpression.children[0] instanceof AEL.Constant)) {\r\n                    // The concat contains a single child that isn't a constant, thus the original\r\n                    // string was a single expression. When evaluated, we want it to produce the type\r\n                    // of that single expression\r\n                    return parsedExpression.children[0];\r\n                }\r\n                else if (parsedExpression.children.length === 2) {\r\n                    let firstChild = parsedExpression.children[0];\r\n\r\n                    if (firstChild instanceof AEL.Constant && firstChild.value === \"\" && !(parsedExpression.children[1] instanceof AEL.Constant)) {\r\n                        // The concat contains 2 children, and the first one is an empty string constant and the second isn't a constant.\r\n                        // From version 4.10.3, AEL always inserts an empty string constant in all concat expression. Thus the original\r\n                        // string was a single expression in this case as well. When evaluated, we want it to produce the type\r\n                        // of that single expression.\r\n                        return parsedExpression.children[1];\r\n                    }\r\n                }\r\n\r\n                // Otherwise, we want the expression to produce a string\r\n                return parsedExpression;\r\n            }\r\n        }\r\n\r\n        // If the original string didn't contain any expression, return i as is\r\n        return interpolatedString;\r\n    }\r\n\r\n    /**\r\n     * Tries to evaluate the provided expression using the provided context.\r\n     *\r\n     * @param expression The expression to evaluate.\r\n     * @param context The context (data) used to evaluate the expression.\r\n     * @param allowSubstitutions Indicates if the expression evaluator should substitute undefined value with a default\r\n     *   string or the value returned by the GlobalSettings.getUndefinedFieldValueSubstitutionString callback.\r\n     * @returns An object representing the result of the evaluation. If the evaluation succeeded, the value property\r\n     *   contains the actual evaluation result, and the error property is undefined. If the evaluation fails, the error\r\n     *   property contains a message detailing the error that occurred.\r\n     */\r\n    public static tryEvaluateExpression(expression: AEL.Expression, context: IEvaluationContext, allowSubstitutions: boolean): { value: any; error: string } {\r\n        return Template.internalTryEvaluateExpression(expression, new EvaluationContext(context), allowSubstitutions);\r\n    }\r\n\r\n    private _context: EvaluationContext;\r\n    private _preparedPayload: any;\r\n\r\n    private expandSingleObject(node: object): any {\r\n        let result = {};\r\n        let keys = Object.keys(node);\r\n\r\n        for (let key of keys) {\r\n            if (!this._context.isReservedField(key)) {\r\n                let value = this.internalExpand(node[key]);\r\n\r\n                if (value !== undefined) {\r\n                    result[key] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private internalExpand(node: any): any {\r\n        let result: any;\r\n\r\n        this._context.saveState();\r\n\r\n        if (Array.isArray(node)) {\r\n            let itemArray: any[] = [];\r\n\r\n            for (let item of node) {\r\n                let expandedItem = this.internalExpand(item);\r\n\r\n                if (expandedItem !== null) {\r\n                    if (Array.isArray(expandedItem)) {\r\n                        itemArray = itemArray.concat(expandedItem);\r\n                    }\r\n                    else {\r\n                        itemArray.push(expandedItem);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result = itemArray;\r\n        }\r\n        else if (node instanceof AEL.Expression) {\r\n            let evaluationResult = Template.internalTryEvaluateExpression(node, this._context, true);\r\n\r\n            if (!evaluationResult.error) {\r\n                result = evaluationResult.value;\r\n            }\r\n            else {\r\n                throw new Error(evaluationResult.error);\r\n            }\r\n        }\r\n        else if (typeof node === \"object\" && node !== null) {\r\n            let when = node[\"$when\"];\r\n            let dataContext = node[\"$data\"];\r\n            let dataContextIsArray: boolean = false;\r\n            let dataContexts: any[];\r\n\r\n            if (dataContext === undefined) {\r\n                dataContexts = [ undefined ];\r\n            }\r\n            else {\r\n                if (dataContext instanceof AEL.Expression) {\r\n                    let evaluationResult = Template.internalTryEvaluateExpression(dataContext, this._context, true);\r\n\r\n                    if (!evaluationResult.error) {\r\n                        dataContext = evaluationResult.value;\r\n                    }\r\n                    else {\r\n                        throw new Error(evaluationResult.error);\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(dataContext)) {\r\n                    dataContexts = dataContext;\r\n                    dataContextIsArray = true;\r\n                }\r\n                else {\r\n                    dataContexts = [ dataContext ];\r\n                }\r\n            }\r\n\r\n            result = [];\r\n\r\n            for (let i = 0; i < dataContexts.length; i++) {\r\n                if (dataContextIsArray) {\r\n                    this._context.$index = i;\r\n                }\r\n\r\n                if (dataContexts[i] !== undefined) {\r\n                    this._context.$data = dataContexts[i];\r\n                }\r\n\r\n                let dropObject = false;\r\n\r\n                if (when instanceof AEL.Expression) {\r\n                    let evaluationResult = Template.internalTryEvaluateExpression(when, this._context, false);\r\n                    let whenValue: boolean = false;\r\n\r\n                    // If $when fails to evaluate or evaluates to anything but a boolean, consider it is false\r\n                    if (!evaluationResult.error) {\r\n                        whenValue = typeof evaluationResult.value === \"boolean\" && evaluationResult.value;\r\n                    }\r\n                    \r\n                    if (!evaluationResult.value) {\r\n                        // Value was not found, and we should warn the client that the Expression was invalid\r\n                        this.templateExpansionWarnings.push(`WARN: Unable to parse the Adaptive Expression ${when}. The $when condition has been set to false by default.`);\r\n                    }\r\n\r\n                    dropObject = !whenValue;\r\n                } else if (when) {\r\n                    // If $when was provided, but it is not an AEL.Expression, drop the object\r\n                    this.templateExpansionWarnings.push(`WARN: ${when} is not an Adaptive Expression. The $when condition has been set to false by default.`);\r\n                    dropObject = true;\r\n                }\r\n\r\n                if (!dropObject) {\r\n                    let expandedObject = this.expandSingleObject(node);\r\n\r\n                    if (expandedObject !== null) {\r\n                        result.push(expandedObject);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (result.length === 0) {\r\n                result = null;\r\n            }\r\n            else if (result.length === 1) {\r\n                result = result[0];\r\n            }\r\n        }\r\n        else {\r\n            result = node;\r\n        }\r\n\r\n        this._context.restoreLastState();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Initializes a new Template instance based on the provided payload.\r\n     * Once created, the instance can be bound to different data objects\r\n     * in a loop.\r\n     *\r\n     * @param payload The template payload.\r\n     */\r\n    constructor(payload: any) {\r\n        this._preparedPayload = Template.prepare(payload);\r\n    }\r\n\r\n    /**\r\n     * Expands the template using the provided context. Template expansion involves\r\n     * evaluating the expressions used in the original template payload, as well as\r\n     * repeating (expanding) parts of that payload that are bound to arrays.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```typescript\r\n     * let context = {\r\n     *     $root: {\r\n     *         firstName: \"John\",\r\n     *         lastName: \"Doe\",\r\n     *         children: [\r\n     *             { fullName: \"Jane Doe\", age: 9 },\r\n     *             { fullName: \"Alex Doe\", age: 12 }\r\n     *         ]\r\n     *     }\r\n     * }\r\n     *\r\n     * let templatePayload = {\r\n     *     type: \"AdaptiveCard\",\r\n     *     version: \"1.2\",\r\n     *     body: [\r\n     *         {\r\n     *             type: \"TextBlock\",\r\n     *             text: \"${firstName} ${lastName}\"\r\n     *         },\r\n     *         {\r\n     *             type: \"TextBlock\",\r\n     *             $data: \"${children}\",\r\n     *             text: \"${fullName} (${age})\"\r\n     *         }\r\n     *     ]\r\n     * }\r\n     *\r\n     * let template = new Template(templatePayload);\r\n     *\r\n     * let expandedTemplate = template.expand(context);\r\n     * ```\r\n     *\r\n     * With the above code, the value of `expandedTemplate` will be\r\n     *\r\n     * ```json\r\n     * {\r\n     *     type: \"AdaptiveCard\",\r\n     *     version: \"1.2\",\r\n     *     body: [\r\n     *         {\r\n     *             type: \"TextBlock\",\r\n     *             text: \"John Doe\"\r\n     *         },\r\n     *         {\r\n     *             type: \"TextBlock\",\r\n     *             text: \"Jane Doe (9)\"\r\n     *         },\r\n     *         {\r\n     *             type: \"TextBlock\",\r\n     *             text: \"Alex Doe (12)\"\r\n     *         }\r\n     *     ]\r\n     * }\r\n     * ```\r\n     *\r\n     * @param context The context to bind the template to.\r\n     * @returns A value representing the expanded template. The type of that value\r\n     *   is dependent on the type of the original template payload passed to the constructor.\r\n     */\r\n    expand(context: IEvaluationContext): any {\r\n        this.templateExpansionWarnings = [];\r\n        this._context = new EvaluationContext(context);\r\n        return this.internalExpand(this._preparedPayload);\r\n    }\r\n\r\n    /**\r\n     * Getter method for the array of warning strings\r\n     * @returns An array storing any warnings that occurred while expanding the template\r\n     */\r\n    public getLastTemplateExpansionWarnings(): string[] {\r\n        return this.templateExpansionWarnings;\r\n    }\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__949__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(716);\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__949__","JSONSchemaCardElement","schema","path","depth","type","Array","isArray","items","JSONSchemaFieldTitle","map","item","idx","JSONSchemaCardTuple","JSONSchemaCardList","JSONSchemaCardObject","id","title","label","description","value","default","JSONSchemaCardBoolean","placeholder","min","exclusiveMinimum","minimum","max","exclusiveMaximum","maximum","JSONSchemaCardNumber","enum","choices","JSONSchemaCardChoiceSet","maxLength","regex","pattern","JSONSchemaCardText","JSONSchemaCardTime","size","textSizeAtDepth","text","isSubtle","wrap","required","property","properties","encodeURIComponent","replace","encodeProperty","body","e","console","error","pkg","context","_stateStack","undefined","$_acTemplateVersion","generateVersionJson","$root","$host","isReservedField","name","EvaluationContext","_reservedFields","indexOf","saveState","push","$data","$index","restoreLastState","length","Error","savedContext","pop","_$data","versionSplit","version","split","patchSplit","parseInt","_memory","AEL","SimpleObjectMemory","getValue","actualPath","setValue","input","getUndefinedFieldValueSubstitutionString","GlobalSettings","payload","_preparedPayload","Template","prepare","node","parseInterpolatedString","result","Object","keys","key","internalTryEvaluateExpression","expression","allowSubstitutions","memory","TemplateObjectMemory","options","Options","nullSubstitution","substitutionValue","ExpressionType","Concat","children","childExpression","evaluationResult","tryEvaluate","ex","toString","interpolatedString","parsedExpression","Expression","parse","ExpressionFunctions","standardFunctions","get","ExpressionEvaluator","state","ReturnType","String","Constant","firstChild","tryEvaluateExpression","expandSingleObject","_context","internalExpand","itemArray","expandedItem","concat","when","dataContext","dataContextIsArray","dataContexts","i","dropObject","whenValue","templateExpansionWarnings","expandedObject","expand","getLastTemplateExpansionWarnings","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}