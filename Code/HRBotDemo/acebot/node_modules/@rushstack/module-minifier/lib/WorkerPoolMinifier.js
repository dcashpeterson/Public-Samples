"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerPoolMinifier = void 0;
const crypto_1 = require("crypto");
const os_1 = require("os");
const serialize_javascript_1 = __importDefault(require("serialize-javascript"));
const worker_pool_1 = require("@rushstack/worker-pool");
/**
 * Minifier implementation that uses a thread pool for minification.
 * @public
 */
class WorkerPoolMinifier {
    constructor(options) {
        const { maxThreads = (0, os_1.cpus)().length, terserOptions = {}, verbose = false } = options || {};
        const activeRequests = new Map();
        const resultCache = new Map();
        const terserPool = new worker_pool_1.WorkerPool({
            id: 'Minifier',
            maxWorkers: maxThreads,
            workerData: terserOptions,
            workerScriptPath: require.resolve('./MinifierWorker')
        });
        const { version: terserVersion } = require('terser/package.json');
        this._configHash = (0, crypto_1.createHash)('sha256')
            .update(WorkerPoolMinifier.name, 'utf8')
            .update(`terser@${terserVersion}`)
            .update((0, serialize_javascript_1.default)(terserOptions))
            .digest('base64');
        this._activeRequests = activeRequests;
        this._refCount = 0;
        this._resultCache = resultCache;
        this._pool = terserPool;
        this._verbose = verbose;
        this._deduped = 0;
        this._minified = 0;
    }
    get maxThreads() {
        return this._pool.maxWorkers;
    }
    set maxThreads(threads) {
        this._pool.maxWorkers = threads;
    }
    /**
     * Transform code by farming it out to a worker pool.
     * @param request - The request to process
     * @param callback - The callback to invoke
     */
    minify(request, callback) {
        const { hash } = request;
        const cached = this._resultCache.get(hash);
        if (cached) {
            ++this._deduped;
            return callback(cached);
        }
        const { _activeRequests: activeRequests } = this;
        const callbacks = activeRequests.get(hash);
        if (callbacks) {
            ++this._deduped;
            callbacks.push(callback);
            return;
        }
        activeRequests.set(hash, [callback]);
        ++this._minified;
        this._pool
            .checkoutWorkerAsync(true)
            .then((worker) => {
            const cb = (message) => {
                worker.off('message', cb);
                const workerCallbacks = activeRequests.get(message.hash);
                activeRequests.delete(message.hash);
                this._resultCache.set(message.hash, message);
                for (const workerCallback of workerCallbacks) {
                    workerCallback(message);
                }
                // This should always be the last thing done with the worker
                this._pool.checkinWorker(worker);
            };
            worker.on('message', cb);
            worker.postMessage(request);
        })
            .catch((error) => {
            const errorCallbacks = activeRequests.get(hash);
            for (const errorCallback of errorCallbacks) {
                errorCallback({
                    hash,
                    error,
                    code: undefined,
                    map: undefined
                });
            }
        });
    }
    async connect() {
        if (++this._refCount === 1) {
            this._pool.reset();
        }
        return {
            configHash: this._configHash,
            disconnect: async () => {
                if (--this._refCount === 0) {
                    if (this._verbose) {
                        // eslint-disable-next-line no-console
                        console.log(`Shutting down minifier worker pool`);
                    }
                    await this._pool.finishAsync();
                    this._resultCache.clear();
                    this._activeRequests.clear();
                    if (this._verbose) {
                        // eslint-disable-next-line no-console
                        console.log(`Module minification: ${this._deduped} Deduped, ${this._minified} Processed`);
                    }
                }
                this._deduped = 0;
                this._minified = 0;
            }
        };
    }
}
exports.WorkerPoolMinifier = WorkerPoolMinifier;
//# sourceMappingURL=WorkerPoolMinifier.js.map