"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentStore = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var normalize_1 = require("../common/normalize");
var Stores_resx_1 = tslib_1.__importDefault(require("../../stores/Stores.resx"));
/**
 * Manages loaded components and component load promises.
 */
var ComponentStore = /** @class */ (function () {
    function ComponentStore() {
        this._componentPromises = new Map();
        this._components = new Map();
        this._componentVersions = new Map();
    }
    /**
     * Try and get a component load promise.
     *
     * @param id - Component id
     * @param version - Component version
     *
     * @returns If the component load promise exists, return it
     */
    ComponentStore.prototype.tryGetComponent = function (id, version) {
        return this._componentPromises.get((0, normalize_1.normalizeComponentId)(id, version));
    };
    /**
     * Try and get a loaded component.
     *
     * @param id - Component id
     * @param version - Component version
     *
     * @returns If the component has been loaded, return it
     */
    ComponentStore.prototype.tryGetComponentReference = function (id, version) {
        return this._components.get((0, normalize_1.normalizeComponentId)(id, version));
    };
    /**
     * Get all loaded components.
     *
     * @remarks
     * This is not meant to be used as the regular behavior of ComponentStore as it's exposing its internals.
     * This exists only to ensure the SystemJS side-loader knows about all components loaded by RequireJS.
     *
     * @returns Map of all the loaded components
     */
    ComponentStore.prototype.getAllComponentReferences = function () {
        return this._components;
    };
    /**
     * Try and get a component load promise by id.
     *
     * @param id - Component id
     *
     * @returns If, and only if, one component with the id exists, return a promise
     *   which will resolve to the component.
     */
    ComponentStore.prototype.tryGetComponentById = function (id) {
        try {
            return this.getComponentById(id);
        }
        catch (e) {
            return undefined;
        }
    };
    /**
     * Get a component load promise by id.
     *
     * @remarks If there is no component or there are multiple components an exception will be thrown.
     *
     * @param id - Component id
     *
     * @returns If, and only if, one component with the id exists, return a promise
     *   which will resolve to the component.
     */
    ComponentStore.prototype.getComponentById = function (id) {
        var versions = this._componentVersions.get(id) || [];
        if (versions.length !== 1) {
            var msg = versions.length === 0 ? Stores_resx_1.default.noComponentFoundError : Stores_resx_1.default.tooManyComponentsError;
            throw new Error(sp_core_library_1.Text.format(msg, id));
        }
        // If a version exists then the component must exist in either map
        var normalizedId = (0, normalize_1.normalizeComponentId)(id, versions[0]);
        var retVal;
        var component = this._components.get(normalizedId);
        if (component) {
            retVal = Promise.resolve(component);
        }
        else {
            retVal = this._componentPromises.get(normalizedId);
        }
        return retVal;
    };
    /**
     * Store a component load promise.
     *
     * @param id - Component id
     * @param version - Component version
     * @param componentPromise - Component load promise
     *
     * @returns A boolean indicating if the component load promise was stored
     */
    ComponentStore.prototype.storeComponent = function (id, version, componentPromise) {
        var _this = this;
        var normalizedId = (0, normalize_1.normalizeComponentId)(id, version);
        var shouldStore = !this._componentPromises.get(normalizedId);
        if (shouldStore) {
            this._storeVersion(id, version);
            this._componentPromises.set(normalizedId, componentPromise);
            componentPromise
                .then(function (component) {
                // Ensure the component hasn't been deleted before storing the component
                if (_this._componentPromises.has(normalizedId)) {
                    _this._components.set(normalizedId, component);
                }
                return component;
            })
                .catch(function () {
                /* no-op */
            });
        }
        return shouldStore;
    };
    /**
     * Store a loaded component.
     *
     * @param id - Component id
     * @param version - Component version
     * @param component - Loaded component
     *
     * @returns A boolean indicating if the component was stored
     */
    ComponentStore.prototype.storeLoadedComponent = function (id, version, component) {
        var normalizedId = (0, normalize_1.normalizeComponentId)(id, version);
        var shouldStore = !this._components.get(normalizedId);
        if (shouldStore) {
            this._storeVersion(id, version);
            this._components.set(normalizedId, component);
            this._componentPromises.set(normalizedId, Promise.resolve(component));
        }
        return shouldStore;
    };
    /**
     * Delete a component.
     *
     * @param id - Component id
     * @param version - Component version
     *
     * @returns A boolean indicating if the component was deleted
     */
    ComponentStore.prototype.deleteComponent = function (id, version) {
        var normalizedId = (0, normalize_1.normalizeComponentId)(id, version);
        // A component should always, if it exists, be in the promise map
        var isDeleted = this._componentPromises.delete(normalizedId);
        if (isDeleted) {
            this._components.delete(normalizedId);
            var versions = this._componentVersions.get(id);
            var i = versions.indexOf(version);
            if (i > -1) {
                versions.splice(i, 1);
                if (versions.length === 0) {
                    this._componentVersions.delete(id);
                }
            }
        }
        return isDeleted;
    };
    /**
     * This is only used to satisfy the old ComponentStore interface.
     * todo: Delete when graduating tiny loader flight
     */
    ComponentStore.prototype._getComponentById = function (id) {
        return this.getComponentById(id);
    };
    /**
     * Track stored versions for a component.
     *
     * @param id - Component id
     * @param version - Component version
     */
    ComponentStore.prototype._storeVersion = function (id, version) {
        if (!this._componentVersions.has(id)) {
            this._componentVersions.set(id, []);
        }
        this._componentVersions.get(id).push(version);
    };
    return ComponentStore;
}());
exports.ComponentStore = ComponentStore;
//# sourceMappingURL=ComponentStore.js.map