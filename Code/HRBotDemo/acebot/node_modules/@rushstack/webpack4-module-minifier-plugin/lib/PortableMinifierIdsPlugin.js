"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortableMinifierModuleIdsPlugin = void 0;
const crypto_1 = require("crypto");
const RequestShortener_1 = __importDefault(require("webpack/lib/RequestShortener"));
const Constants_1 = require("./Constants");
const PLUGIN_NAME = 'PortableMinifierModuleIdsPlugin';
const TAP_BEFORE = {
    name: PLUGIN_NAME,
    stage: Constants_1.STAGE_BEFORE
};
const TAP_AFTER = {
    name: PLUGIN_NAME,
    stage: Constants_1.STAGE_AFTER
};
const STABLE_MODULE_ID_PREFIX = '__MODULEID_SHA_';
// The negative lookback here is to ensure that this regex does not match an async import placeholder
const STABLE_MODULE_ID_REGEX = /(?<!C)['"]?(__MODULEID_SHA_[0-9a-f]+)['"]?/g;
/**
 * Plugin responsible for converting the Webpack module ids (of whatever variety) to stable ids before code is handed to the minifier, then back again.
 * Uses the node module identity of the target module. Will emit an error if it encounters multiple versions of the same package in the same compilation.
 * @public
 */
class PortableMinifierModuleIdsPlugin {
    constructor(minifierHooks) {
        this._minifierHooks = minifierHooks;
    }
    apply(compiler) {
        // Ensure that "EXTERNAL MODULE: " comments are portable and module version invariant
        const baseShorten = RequestShortener_1.default.prototype.shorten;
        RequestShortener_1.default.prototype.shorten = function (request) {
            const baseResult = baseShorten.call(this, request);
            const nodeModules = '/node_modules/';
            if (!baseResult) {
                return baseResult;
            }
            const nodeModulesIndex = baseResult.lastIndexOf(nodeModules);
            if (nodeModulesIndex < 0) {
                return baseResult;
            }
            const nodeModulePath = baseResult.slice(nodeModulesIndex + nodeModules.length);
            this.cache.set(request, nodeModulePath);
            return nodeModulePath;
        };
        const stableIdToFinalId = new Map();
        this._minifierHooks.finalModuleId.tap(PLUGIN_NAME, (id) => {
            return id === undefined ? id : stableIdToFinalId.get(id);
        });
        this._minifierHooks.postProcessCodeFragment.tap(PLUGIN_NAME, (source, context) => {
            const code = source.original().source();
            STABLE_MODULE_ID_REGEX.lastIndex = -1;
            // RegExp.exec uses null or an array as the return type, explicitly
            let match = null;
            while ((match = STABLE_MODULE_ID_REGEX.exec(code))) {
                const id = match[1];
                const mapped = this._minifierHooks.finalModuleId.call(id, context.compilation);
                if (mapped === undefined) {
                    context.compilation.errors.push(new Error(`Missing module id for ${id} in ${context.loggingName}!`));
                }
                source.replace(match.index, STABLE_MODULE_ID_REGEX.lastIndex - 1, JSON.stringify(mapped));
            }
            return source;
        });
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, compilationData) => {
            const { normalModuleFactory } = compilationData;
            normalModuleFactory.hooks.module.tap(PLUGIN_NAME, (mod, data) => {
                const { resourceResolveData: resolveData } = data;
                if (resolveData) {
                    mod.factoryMeta.resolveData = resolveData;
                    return;
                }
                // eslint-disable-next-line no-console
                console.error(`Missing resolution data for ${mod.resource}`);
            });
            compilation.hooks.succeedModule.tap(PLUGIN_NAME, (mod) => {
                const { resolveData } = mod.factoryMeta;
                if (!resolveData) {
                    return;
                }
                const { descriptionFileData: packageJson, relativePath } = resolveData;
                if (packageJson && relativePath) {
                    const nodeId = `${packageJson.name}${relativePath.slice(1).replace(/\.js(on)?$/, '')}`;
                    mod.factoryMeta.nodeResource = nodeId;
                }
            });
            stableIdToFinalId.clear();
            // Make module ids a pure function of the file path immediately before rendering.
            // Unfortunately, other means of altering these ids don't work in Webpack 4 without a lot more code and work.
            // Namely, a number of functions reference "module.id" directly during code generation
            compilation.hooks.beforeChunkAssets.tap(TAP_AFTER, () => {
                // For tracking collisions
                const resourceById = new Map();
                for (const mod of compilation.modules) {
                    const originalId = mod.id;
                    // Need different cache keys for different sets of loaders, so can't use 'resource'
                    const identity = mod.identifier();
                    const hashId = (0, crypto_1.createHash)('sha256').update(identity).digest('hex');
                    // This is designed to be an easily regex-findable string
                    const stableId = `${STABLE_MODULE_ID_PREFIX}${hashId}`;
                    const existingResource = resourceById.get(stableId);
                    if (existingResource) {
                        compilation.errors.push(new Error(`Module id collision for ${identity} with ${existingResource}.\n This means you are bundling multiple versions of the same module.`));
                    }
                    stableIdToFinalId.set(stableId, originalId);
                    // Record to detect collisions
                    resourceById.set(stableId, identity);
                    mod.id = stableId;
                }
            });
            // This is the hook immediately following chunk asset rendering. Fix the module ids.
            compilation.hooks.additionalChunkAssets.tap(TAP_BEFORE, () => {
                // Restore module ids in case any later hooks need them
                for (const mod of compilation.modules) {
                    const stableId = mod.id;
                    const finalId = stableIdToFinalId.get(stableId);
                    if (finalId !== undefined) {
                        mod.id = finalId;
                    }
                }
            });
        });
    }
}
exports.PortableMinifierModuleIdsPlugin = PortableMinifierModuleIdsPlugin;
//# sourceMappingURL=PortableMinifierIdsPlugin.js.map