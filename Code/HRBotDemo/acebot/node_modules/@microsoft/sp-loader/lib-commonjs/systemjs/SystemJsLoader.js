"use strict";
// Copyright (c) Microsoft. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/// <reference path="./es-module-loader.d.ts" />
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var ManifestStore_1 = tslib_1.__importDefault(require("../stores/ManifestStore"));
var AddressStore_1 = tslib_1.__importDefault(require("../stores/AddressStore"));
var resolveAddress_1 = tslib_1.__importDefault(require("../utilities/resolveAddress"));
var isCorsEnabled_1 = tslib_1.__importDefault(require("../utilities/isCorsEnabled"));
var normalizeName_1 = tslib_1.__importStar(require("./normalizeName"));
var telemetryConstants = tslib_1.__importStar(require("../utilities/telemetryConstants"));
var ErrorBuilder_1 = tslib_1.__importDefault(require("../error/ErrorBuilder"));
var loadScriptWithoutEval_1 = require("../requirejs/loadScriptWithoutEval");
var SystemsJs_resx_1 = tslib_1.__importDefault(require("./SystemsJs.resx"));
/**
 * Loader for SystemJS.
 * Provides the instance of SystemJS and allows methods for configuration.
 */
var SystemJsLoader = /** @class */ (function () {
    function SystemJsLoader(serviceScope) {
        this._configuredFailoverPaths = [];
        this._checkEntryPointDependenciesError = this._checkEntryPointDependenciesError.bind(this);
        this._initialize();
    }
    Object.defineProperty(SystemJsLoader.prototype, "loadEntryPointErrorProcessors", {
        get: function () {
            return [this._checkEntryPointDependenciesError];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SystemJsLoader.prototype, "loadComponentDependencyErrorProcessors", {
        get: function () {
            return [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SystemJsLoader.prototype, "loadPathDependencyErrorProcessors", {
        get: function () {
            return [];
        },
        enumerable: false,
        configurable: true
    });
    SystemJsLoader.prototype.ensure = function (manifest, module) {
        var name = (0, normalizeName_1.default)(manifest);
        return this._ensure(name, module);
    };
    /**
     * If a module hasn't been loaded with the specified name,
     * it created a new module and sets it in SystemJS
     */
    SystemJsLoader.prototype._ensure = function (name, module) {
        var system = this._system;
        if (!system.has(name)) {
            system.set(name, system.newModule(module));
        }
    };
    SystemJsLoader.prototype.delete = function (manifest) {
        return this._delete((0, normalizeName_1.default)(manifest));
    };
    /**
     * If a module has been loaded with the specified name,
     * it delete it from SystemJS
     */
    SystemJsLoader.prototype._delete = function (name) {
        var system = this._system;
        if (system.has(name)) {
            system.delete(name);
        }
    };
    /**
     * Calls actual System.config()
     */
    SystemJsLoader.prototype.systemConfig = function (config) {
        this._originalSystemConfig.call(this._system, config);
    };
    SystemJsLoader.prototype.load = function (manifest, name, globalName) {
        var _this = this;
        return this.systemImport((0, normalizeName_1.default)(manifest, name)).then(function (module) {
            var retValue = module;
            // Save "exportedModuleName" in SystemJS
            if (!name && manifest.loaderConfig.exportName) {
                retValue = module[manifest.loaderConfig.exportName];
                _this._ensure((0, normalizeName_1.default)(manifest, manifest.loaderConfig.exportName), retValue);
            }
            return retValue;
        });
    };
    SystemJsLoader.prototype.loadFromFailoverPath = function (name) {
        return this.systemImport((0, normalizeName_1.normalizeFailoverPathName)(name));
    };
    /**
     * Calls System.import()
     * Catches exceptions and returns a rejected promise with the error from SystemJS
     */
    SystemJsLoader.prototype.systemImport = function (name) {
        try {
            return this._system.import(name);
        }
        catch (error) {
            sp_diagnostics_1._TraceLogger.logError(telemetryConstants.loadComponentLogSource, error, SystemJsLoader._systemImportEventName);
            return Promise.reject(error);
        }
    };
    /** Calls System.delete() with the name matching the input manifest */
    SystemJsLoader.prototype.systemDelete = function (manifest) {
        this._system.delete((0, normalizeName_1.default)(manifest));
    };
    /**
     * Sets the config for SystemJS. Handles global exports, renames the dependencies.
     * Also sets AddressStore with the right mapping between script and URL.
     */
    SystemJsLoader.prototype.configure = function (manifest) {
        var resources = manifest.loaderConfig.scriptResources;
        var depsMap = {};
        // Used only for failover paths. So far, this impacts react and react-dom on debug manifests.
        var globalDepsMap = {};
        for (var name_1 in resources) {
            if (resources[name_1].type === 'component') {
                var moduleConfiguration = resources[name_1];
                var resourceManifest = ManifestStore_1.default.instance.tryGetManifest(moduleConfiguration.id, moduleConfiguration.version);
                if (resourceManifest) {
                    depsMap[name_1] = (0, normalizeName_1.default)(resourceManifest);
                }
                if (moduleConfiguration.failoverPath) {
                    if (this._configuredFailoverPaths.indexOf(name_1) === -1) {
                        var normalizedName = (0, normalizeName_1.normalizeFailoverPathName)(name_1);
                        var address = (0, resolveAddress_1.default)(manifest, name_1);
                        // Start downloading the script without evaluating it.
                        void (0, loadScriptWithoutEval_1.loadScriptWithoutEval)(address, false /* Do not append .js to url */);
                        AddressStore_1.default.set(normalizedName, address);
                        globalDepsMap[name_1] = normalizedName;
                        this._configuredFailoverPaths.push(name_1);
                    }
                }
            }
            else {
                // path or localizedPath
                var normalizedName = void 0;
                if (name_1 === manifest.loaderConfig.entryModuleId) {
                    // the entry point of the module
                    normalizedName = (0, normalizeName_1.default)(manifest);
                }
                else {
                    normalizedName = (0, normalizeName_1.default)(manifest, name_1);
                    depsMap[name_1] = normalizedName;
                }
                var address = (0, resolveAddress_1.default)(manifest, name_1);
                // Start downloading the script without evaluating it.
                void (0, loadScriptWithoutEval_1.loadScriptWithoutEval)(address, false /* Do not append .js to url */);
                AddressStore_1.default.set(normalizedName, address);
                var resource = resources[name_1];
                this._configureMetadata(normalizedName, address, resource);
            }
        }
        var packages = {};
        packages[(0, normalizeName_1.default)(manifest)] = {
            map: depsMap,
            defaultExtension: false
        };
        var config = {
            packages: packages
        };
        this.systemConfig(config);
        if (Object.keys(globalDepsMap).length) {
            this.systemConfig({
                map: globalDepsMap
            });
        }
    };
    /**
     * Returns the dependencies of a component, as detected by SystemJS when importing the module.
     * This method ignores the manifest dependencies and looks only at the JS file instead.
     * Used as a helper to find mismatching dependencies.
     *
     * @returns Array with the dependencies in a component. Empty array if dependencies could not be found.
     */
    SystemJsLoader.prototype.getDependencies = function (manifest) {
        sp_core_library_1.Validate.isNotNullOrUndefined(manifest, 'manifest');
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var defined = this._system.defined;
        // Empirically, this is saved in 'https://relative-path.invalid/<id>_<version>'
        var definedName = this._getDefinedId(manifest);
        var componentDefinition = defined[definedName];
        if (!componentDefinition) {
            return [];
        }
        return componentDefinition.deps;
    };
    /**
     * Executes the base configuration for SystemJS. It should be private but it's public
     * so STS pages can modify scriptLoad to be false.
     */
    SystemJsLoader.prototype._baseSystemConfig = function (pluginName, scriptLoad) {
        var systemConfig = {
            meta: {
                '*': {
                    loader: pluginName,
                    scriptLoad: scriptLoad
                }
            }
        };
        this.systemConfig(systemConfig);
    };
    SystemJsLoader.prototype._initialize = function () {
        this._system = this._loadSystemJs();
        this._setCustomLoader(SystemJsLoader.pluginName, this._system);
        // Create a default SystemJS config that passes everything to our loader.
        var systemConfig = {
            baseURL: SystemJsLoader._invalidBaseUrl,
            defaultJsExtensions: false
        };
        this.systemConfig(systemConfig);
        this._baseSystemConfig(SystemJsLoader.pluginName, true);
    };
    SystemJsLoader.prototype._loadSystemJs = function () {
        // Load SystemJS
        var system = DEPRECATED_UNIT_TEST
            ? // eslint-disable-next-line @typescript-eslint/no-require-imports
                require('./test/SystemJsMock')
            : // eslint-disable-next-line @typescript-eslint/no-require-imports
                require('@rushstack/loader-raw-script!../../blobs/systemjs/0.19.25/dist/system.spfx');
        // Hide System.config()
        this._originalSystemConfig = system.config;
        system.config = function (config) {
            throw new Error(SystemsJs_resx_1.default.systemConfigDisabledError);
        };
        return system;
    };
    SystemJsLoader.prototype._setCustomLoader = function (pluginName, system) {
        var loader = {
            /**
             * locate returns an address for a module name.
             * In the case of components it takes the normalized name, which is an absolute URL.
             * SystemJS gets the name as 'https://component-id.invalid/<id>', which has an entry
             * in the AddressStore.
             * If the AddressStore doesn't have an entry for the name, locate leaves the name unmodified.
             * This supports the scenario where people call System.import() with an absolute URL.
             * System.import() with a relative URL is not supported and will fail to fetch the module,
             * as the base URL is 'https://relative-path.invalid/'
             */
            locate: function (module) {
                var address = AddressStore_1.default.tryGetAddress(module.name);
                if (address) {
                    // TODO (1213908): Handle the subresource integrity
                    return address.path;
                }
                else {
                    sp_diagnostics_1._TraceLogger.logVerbose(telemetryConstants.loadComponentLogSource, "Address not found for module name: ".concat(module.name, ". Using it as absolute URL."));
                    // If we don't have the address mapped, assume the name IS the URL to grab it
                    return module.name;
                }
            }
        };
        // Load the loader as a system module and then set the system config. We need to do this is this order, otherwise
        // SystemJS will try to load our loader with itself, and will throw.
        system.set(pluginName, system.newModule(loader));
    };
    /**
     * Returns the id used by SystemJS in System.defined.
     * This allows to browse through SystemJS internals for additional data, like the JS dependencies.
     */
    SystemJsLoader.prototype._getDefinedId = function (manifest) {
        return SystemJsLoader._invalidBaseUrl + manifest.id + '_' + manifest.version;
    };
    /**
     * Configures the SystemJS metadata with the crossOrigin parameter,
     * and if the resource has a globalName; sets the global name configuration.
     * The crossOrigin parameter is needed for the SPFx service worker to transparently
     * read cross-domain resources.
     */
    SystemJsLoader.prototype._configureMetadata = function (normalizedName, address, resource) {
        var meta = {};
        // Support global names
        if (resource.globalName) {
            meta[normalizedName] = {
                format: 'global',
                exports: resource.globalName
            };
        }
        if ((0, isCorsEnabled_1.default)(address.path)) {
            (meta[normalizedName] || (meta[normalizedName] = {})).crossOrigin = 'anonymous';
        }
        var globalConfig = {
            meta: meta
        };
        this.systemConfig(globalConfig);
    };
    /**
     * Checks if the loaded JS dependencies match with dependencies declared in the manifest.
     * This can happen when a component is re-built but the manifest hasn't been modified.
     * If missing dependencies are found, it throws with an error stating the first mismatch.
     *
     * @param manifest - Manifest to check
     * @param name - Name of the entry point. Unused in this function.
     */
    SystemJsLoader.prototype._checkEntryPointDependenciesError = function (manifest, name) {
        var dependencies = this.getDependencies(manifest);
        var resources = manifest.loaderConfig.scriptResources;
        dependencies.forEach(function (depName) {
            if (!resources[depName]) {
                throw ErrorBuilder_1.default.buildModuleHasUndeclaredDependencyError(manifest, depName);
            }
        });
        return Promise.resolve();
    };
    SystemJsLoader.serviceKey = sp_core_library_1.ServiceKey.create('sp-loader:SystemJsLoader', SystemJsLoader);
    SystemJsLoader.pluginName = 'sp-loader-resolver';
    SystemJsLoader._systemImportEventName = 'System.import';
    /**
     * This is the configured base URL for SystemJS.
     * When a user tries to call SystemJS with a relative path, an error will show this as the base URL.
     *
     * Example:
     * `System.import("myModule") => Error: https://relative-path.invalid/myModule not found`
     */
    SystemJsLoader._invalidBaseUrl = 'https://relative-path.invalid/';
    return SystemJsLoader;
}());
exports.default = SystemJsLoader;
//# sourceMappingURL=SystemJsLoader.js.map