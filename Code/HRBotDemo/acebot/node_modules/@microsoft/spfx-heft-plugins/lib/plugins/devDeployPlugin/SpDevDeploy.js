"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpDevDeploy = void 0;
const Url = __importStar(require("url"));
const path = __importStar(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const rush_lib_1 = require("@microsoft/rush-lib");
const node_core_library_1 = require("@rushstack/node-core-library");
const heft_config_file_1 = require("@rushstack/heft-config-file");
const DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
const UrlUtilities_1 = require("../../utilities/UrlUtilities");
const ManifestsFileBuilder_1 = require("../../spfxManifests/manifestFileBuilder/ManifestsFileBuilder");
const CumulativeManifestProcessor_1 = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const constants_1 = require("../../utilities/constants");
const IconHandler_1 = require("../../spfxManifests/utilities/IconHandler");
const devDeployUtilities_1 = require("../../utilities/devDeployUtilities");
const MANIFESTS_JS_FILENAME = 'manifests.js';
/**
 * @public
 */
class SpDevDeploy {
    constructor(options, configFileData) {
        this._collisionDetectionMap = new Map();
        this._configFileData = configFileData;
        this._options = {
            isolateProjects: true,
            ignoreCollisions: false,
            _projectDiscoveryMode: CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparse,
            ...options
        };
        if (!this._options.rootPath) {
            throw new Error('rootPath must be provided.');
        }
        if (!this._options.terminal) {
            throw new Error('Terminal must be provided.');
        }
    }
    static get _spDevDeployConfigFile() {
        if (!SpDevDeploy.__spDevDeployConfigFile) {
            SpDevDeploy.__spDevDeployConfigFile = new heft_config_file_1.ConfigurationFile({
                projectRelativeFilePath: 'config/sp-dev-deploy.json',
                jsonSchemaPath: `${__dirname}/sp-dev-deploy.schema.json`
            });
        }
        return SpDevDeploy.__spDevDeployConfigFile;
    }
    static getDevDeployContainerDirectoryName() {
        return (0, devDeployUtilities_1.getDevDeployContainerDirectoryName)();
    }
    static async initializeAsync(options) {
        const configFileData = await SpDevDeploy._spDevDeployConfigFile.tryLoadConfigurationFileForProjectAsync(options.terminal, options.rootPath);
        return new SpDevDeploy(options, configFileData);
    }
    preProcess() {
        const metadataFilePath = this._getMetadataDropPath();
        // Proactively delete the metadata file so we aren't left with invalid metadata from a previous deploy if
        // this deploy fails
        node_core_library_1.FileSystem.deleteFile(metadataFilePath);
    }
    async getFilesAsync() {
        const cumulativeManifestProcessor = new CumulativeManifestProcessor_1.CumulativeManifestProcessor({
            explicitInclude: [constants_1.SP_LOADER_ASSEMBLY_ID],
            rootPath: this._options.rootPath,
            tempFolderName: 'temp',
            distFolderName: 'dist',
            includeAssemblies: true,
            ignoreNonSpfxManifests: true,
            terminal: this._options.terminal
        });
        const manifests = this._getManifests(cumulativeManifestProcessor);
        const manifestsArray = [];
        this._options.terminal.writeVerboseLine(`Discovered ${Object.keys(manifests).length} projects.`);
        const foldersToUpload = new Map();
        const projectContainerNames = new Map(); // Ensure we don't reuse a name
        let spLoaderFolderPath;
        let debugSPLoader;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (const id in manifests) {
            if (manifests.hasOwnProperty(id)) {
                for (const version in manifests[id]) {
                    if (manifests[id].hasOwnProperty(version)) {
                        const referencedProject = manifests[id][version];
                        const manifest = referencedProject.manifestData;
                        const loaderConfig = manifest.loaderConfig;
                        this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias}) in "${referencedProject.manifestPath}"...`);
                        manifestsArray.push(manifest);
                        const projectContainerName = this._options.isolateProjects
                            ? this._getDestinationDirName(projectContainerNames, referencedProject.manifestPath)
                            : '.';
                        // A relative base URL applies when the paths are based on the tenant URL.
                        // This applies, for example, in the JSOM library, that takes the JS files from a known place
                        // available on every tenant.
                        const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0 &&
                            !Url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                        // If the Base URL is a relative path, keep the relative path
                        if (!isBaseUrlRelative) {
                            loaderConfig.internalModuleBaseUrls = [];
                        }
                        const manifestFolderPath = path.dirname(referencedProject.manifestPath);
                        const processPath = (resourcePath) => {
                            if (typeof resourcePath === 'object') {
                                resourcePath = resourcePath.path;
                            }
                            // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                            if (UrlUtilities_1.UrlUtilities.isUrl(resourcePath) || isBaseUrlRelative) {
                                return resourcePath; // Do not deal with fully-qualified URL.
                            }
                            else {
                                this._options.terminal.writeVerboseLine(`    Processing resource path ${resourcePath}`);
                                const filesystemPath = path.join(manifestFolderPath, resourcePath);
                                const filename = path.basename(resourcePath);
                                // Path resources are in the 'dist' folder by default and usually have some secondary
                                // references, so let's just upload the whole folder.
                                const filesystemFolder = path.dirname(filesystemPath);
                                this._options.terminal.writeVerboseLine(`    Added ${filesystemFolder} to folders to upload`);
                                foldersToUpload.set(filesystemFolder, projectContainerName);
                                if (!spLoaderFolderPath && id === constants_1.SP_LOADER_ASSEMBLY_ID) {
                                    spLoaderFolderPath = projectContainerName;
                                    debugSPLoader = filename;
                                }
                                return UrlUtilities_1.UrlUtilities.joinUrlSegments(projectContainerName, filename);
                            }
                        };
                        this._doComponentTypeSpecificFixup(manifest, processPath);
                        this._processAllPathsInManifest(manifest, processPath);
                        this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias})...DONE`);
                    }
                }
            }
        }
        // Expand directories to individual files
        const filesToUpload = [];
        await node_core_library_1.Async.forEachAsync(foldersToUpload, async ([localDirPath, deployDirName]) => {
            const filesIterable = this._getFilesInFolderInnerAsync(localDirPath, deployDirName);
            for await (const file of filesIterable) {
                filesToUpload.push(file);
            }
        }, { concurrency: 10 });
        const manifestsFileFullPath = path.join(this._options.rootPath, 'temp', 'dev-deploy', MANIFESTS_JS_FILENAME);
        await (0, ManifestsFileBuilder_1.buildManifestsJsAsync)(manifestsArray, manifestsFileFullPath, undefined, this._options._manifestsJsFileMetadata);
        filesToUpload.push({
            localPath: manifestsFileFullPath,
            deployPath: MANIFESTS_JS_FILENAME
        });
        const deployBaseUrl = this._getDeployBaseUrl();
        this._devDeployManifestFileUrl = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployBaseUrl, SpDevDeploy._debugManifestPath);
        if (spLoaderFolderPath && debugSPLoader) {
            this._devDeployModuleLoaderUrl = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployBaseUrl, spLoaderFolderPath, debugSPLoader);
        }
        return {
            filesToUpload,
            loaderPath: this._devDeployModuleLoaderUrl
        };
    }
    async getFilesInFolderAsync(localDirPath, deployDirName) {
        const files = [];
        const filesIterable = this._getFilesInFolderInnerAsync(localDirPath, deployDirName);
        for await (const file of filesIterable) {
            files.push(file);
        }
        return files;
    }
    postProcess() {
        if (!this._options.ignoreCollisions) {
            this._printCollisionWarnings();
        }
        this._options.terminal.writeLine();
        this._printDevDeployLink();
        this._options.terminal.writeLine();
        this._saveDevDeployMetadata();
    }
    async *_getFilesInFolderInnerAsync(localDirPath, deployDirName) {
        const localDirEntries = await node_core_library_1.FileSystem.readFolderItemsAsync(localDirPath);
        for (const localDirEntry of localDirEntries) {
            const localDirEntryName = localDirEntry.name;
            const deployPath = UrlUtilities_1.UrlUtilities.joinUrlSegments(deployDirName, localDirEntryName);
            const localPath = `${localDirPath}/${localDirEntryName}`;
            if (localDirEntry.isFile()) {
                yield {
                    localPath,
                    deployPath
                };
                if (!this._options.isolateProjects) {
                    let collisionsForPath = this._collisionDetectionMap.get(deployPath);
                    if (!collisionsForPath) {
                        collisionsForPath = [];
                        this._collisionDetectionMap.set(deployPath, collisionsForPath);
                    }
                    collisionsForPath.push(localPath);
                }
            }
            else {
                yield* this._getFilesInFolderInnerAsync(localPath, deployPath);
            }
        }
    }
    _printCollisionWarnings() {
        // Warn about collisions
        this._collisionDetectionMap.forEach((localPaths, url) => {
            if (localPaths.length > 1 && !this._doesFilenameAppearToContainHash(localPaths[0])) {
                this._options.terminal.writeWarningLine(`COLLISION DETECTED AS ${url} IN THESE:\n${localPaths.join('\n')}\n` +
                    `It is very probable that the dev-deploy will not work as expected. This may indicate a ` +
                    `serious issue for production environments as well.`);
            }
        });
    }
    _saveDevDeployMetadata() {
        const dropPath = this._getMetadataDropPath();
        node_core_library_1.JsonFile.save(this._devDeployMetadata, dropPath, { ensureFolderExists: true });
    }
    _printDevDeployLink() {
        var _a;
        const deployBaseUrl = this._getDeployBaseUrl();
        if (!this._devDeployManifestFileUrl) {
            throw new Error('"_devDeployManifestFileUrl" must be defined');
        }
        this._devDeployMetadata = {
            deployUrl: deployBaseUrl,
            debugManifestUrl: this._devDeployManifestFileUrl
        };
        if (this._devDeployModuleLoaderUrl) {
            this._devDeployMetadata.loaderUrl = this._devDeployModuleLoaderUrl;
        }
        (0, DevDeployLinkPrinter_1.printDevDeployLink)({
            terminal: this._options.terminal,
            metadata: this._devDeployMetadata,
            testingPageUrl: (_a = this._configFileData) === null || _a === void 0 ? void 0 : _a.testingPageUrl
        });
    }
    _getDeployBaseUrl() {
        if (this._options.devDeployConfig.folderNameInContainer) {
            return UrlUtilities_1.UrlUtilities.joinUrlSegments(this._getContainerUrl(), this._options.devDeployConfig.folderNameInContainer);
        }
        else {
            return this._getContainerUrl();
        }
    }
    _getContainerUrl() {
        return this._getAzureStorageUrl(this._options.devDeployConfig.accountName, this._options.devDeployConfig.containerName);
    }
    _getAzureStorageUrl(accountName, containerName) {
        return UrlUtilities_1.UrlUtilities.joinUrlSegments(`https://${accountName}.blob.core.windows.net`, containerName || '');
    }
    _processAllPathsInManifest({ loaderConfig }, pathProcessFunction) {
        for (const scriptResourceId in loaderConfig.scriptResources) {
            if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                switch (scriptResource.type) {
                    case 'path': {
                        // Path script resource, we need to fix up its path and upload it
                        const pathResource = scriptResource;
                        pathResource.path = pathProcessFunction(pathResource.path);
                        break;
                    }
                    case 'component': {
                        // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                        // miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear
                        // it out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                        // framework
                        const componentResource = scriptResource;
                        componentResource.failoverPath = undefined;
                        break;
                    }
                    case 'localizedPath': {
                        // Localized path script resource, we need to fix up the paths for each locale and upload each file
                        const localizedPathResource = scriptResource;
                        // Select en-us if it exists, otherwise pass through the default path.
                        const pathToProcess = (localizedPathResource.paths
                            ? localizedPathResource.paths[constants_1.DEFAULT_LOCALE]
                            : localizedPathResource.defaultPath) || localizedPathResource.defaultPath;
                        if (!pathToProcess) {
                            // eslint-disable-next-line no-console
                            console.warn('module ' + loaderConfig.entryModuleId + ' has a localized resorce with no default path');
                        }
                        else {
                            localizedPathResource.defaultPath = pathProcessFunction(pathToProcess);
                        }
                        if (localizedPathResource.paths) {
                            for (const locale in localizedPathResource.paths) {
                                if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                    localizedPathResource.paths[locale] = pathProcessFunction(localizedPathResource.paths[locale]);
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
    /**
     * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
     * not collide with another directory's name. It also ensures that if the specified filesystem path has already
     * been mapped to a destination directory, the same name is used in the destination.
     */
    _getDestinationDirName(directoryMap, filesystemPath) {
        const projectFolder = node_core_library_1.PackageJsonLookup.instance.tryGetPackageFolderFor(filesystemPath);
        if (!projectFolder) {
            throw new Error(`Unable to find a project folder for "${filesystemPath}"`);
        }
        let destinationDirName = path.basename(projectFolder).toLowerCase();
        if (directoryMap.has(destinationDirName)) {
            const existingPaths = directoryMap.get(destinationDirName);
            if (!existingPaths) {
                throw new Error("Couldn't get paths");
            }
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                destinationDirName = `${destinationDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                destinationDirName = `${destinationDirName}_${currentPathId}`;
            }
        }
        else {
            directoryMap.set(destinationDirName, [filesystemPath]);
        }
        return destinationDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this._options.devDeployConfig.useRush) {
            const rushConfig = this._getRushConfig();
            if (!rushConfig) {
                throw new Error('Unable to find the rush configuration file.');
            }
            let manifests;
            const directories = rushConfig.projects.map((proj) => proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], this._options._projectDiscoveryMode);
            for (let i = 1; i < directories.length; i++) {
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], this._options._projectDiscoveryMode);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this._options.rootPath, this._options._projectDiscoveryMode);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1)
            .concat(Object.keys(list2))
            .forEach((id) => ids.add(id));
        const result = {};
        ids.forEach((id) => {
            const list1Versions = list1[id];
            const list2Versions = list2[id];
            if (!list1Versions || !list2Versions) {
                // Element is only present in one list
                result[id] = list1Versions || list2Versions;
            }
            else {
                // Arrays are present in both lists, merge them together
                const versionMapping = {};
                function addVersionsToMapping(referencedVersions) {
                    for (const version in referencedVersions) {
                        if (!versionMapping[version] ||
                            referencedVersions[version].manifestCreationTime > versionMapping[version].manifestCreationTime) {
                            versionMapping[version] = referencedVersions[version];
                        }
                    }
                }
                addVersionsToMapping(list1Versions);
                addVersionsToMapping(list2Versions);
                result[id] = versionMapping;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch (manifest.componentType) {
            case 'WebPart':
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries) {
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch (extensionManifest.extensionType) {
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for (const itemId in commandSetManifest.items) {
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing to do for the other extension types
                        break;
                }
                break;
            default:
                // Nothing to do for the other component types
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (IconHandler_1.IconHandler.getIconPathType(iconPath) === IconHandler_1.IconPathType.RelativeUrl) {
            const relativeIconPath = lodash_1.default.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        }
        else {
            return iconPath;
        }
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
    _getMetadataDropPath() {
        const METADATA_FILENAME = 'dev-deploy-metadata.json';
        const rushConfig = this._getRushConfig();
        if (!rushConfig) {
            throw new Error('Unable to find the rush configuration file.');
        }
        const commonTempDirectory = rushConfig.commonTempFolder;
        return path.join(commonTempDirectory, METADATA_FILENAME);
    }
    _doesFilenameAppearToContainHash(filePath) {
        const filename = path.basename(filePath, path.extname(filePath));
        // Look for a hexadecimal string at the end of the filename that is at least 5 characters long and
        // starts with an underscore (_) or a hyphen (-).
        return !!filename.match(/[_-][a-f0-9]{5,}$/i);
    }
}
exports.SpDevDeploy = SpDevDeploy;
SpDevDeploy._debugManifestPath = MANIFESTS_JS_FILENAME;
//# sourceMappingURL=SpDevDeploy.js.map