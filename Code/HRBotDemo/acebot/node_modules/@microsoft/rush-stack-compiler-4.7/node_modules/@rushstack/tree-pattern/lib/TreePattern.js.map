{"version":3,"file":"TreePattern.js","sourceRoot":"","sources":["../src/TreePattern.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Indicates the tree-like data structure that {@link TreePattern} will traverse.\n *\n * @remarks\n * Since `TreePattern` makes relatively few assumptions object the object structure, this is\n * just an alias for `any`.  At least as far as the portions to be matched, the tree nodes\n * are expected to be JSON-like structures made from JavaScript arrays, JavaScript objects,\n * and primitive values that can be compared using `===`.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type TreeNode = any;\n\nclass TreePatternArg {\n  public readonly keyName: string;\n  public readonly subtree: TreeNode | undefined;\n  public constructor(keyName: string, subtree?: TreeNode) {\n    this.keyName = keyName;\n    this.subtree = subtree;\n  }\n}\n\nclass TreePatternAlternatives {\n  public readonly possibleSubtrees: TreeNode[];\n  public constructor(possibleSubtrees: TreeNode[]) {\n    this.possibleSubtrees = possibleSubtrees;\n  }\n}\n\n/**\n * Provides additional detail about the success or failure of {@link TreePattern.match}.\n *\n * @remarks\n * On success, the object will contain keys for any successfully matched tags, as\n * defined using {@link TreePattern.tag}.\n *\n * On failure, the `failPath` member will indicate the JSON path of the node that\n * failed to match.\n *\n * @public\n */\nexport type ITreePatternCaptureSet =\n  | {\n      [tagName: string]: TreeNode;\n    }\n  | { failPath: string };\n\n/**\n * A fast, lightweight pattern matcher for tree structures such as an Abstract Syntax Tree (AST).\n * @public\n */\nexport class TreePattern {\n  private readonly _pattern: TreeNode;\n\n  public constructor(pattern: TreeNode) {\n    this._pattern = pattern;\n  }\n\n  /**\n   * Labels a subtree within the search pattern, so that the matching object can be retrieved.\n   *\n   * @remarks\n   * Used to build the `pattern` tree for {@link TreePattern.match}.  For the given `subtree` of the pattern,\n   * if it is matched, that node will be assigned to the `captures` object using `tagName` as the key.\n   *\n   * Example:\n   *\n   * ```ts\n   * const myCaptures: { personName?: string } = {};\n   * const myPattern = {\n   *   name: TreePattern.tag('personName')\n   * };\n   * if (myPattern.match({ name: 'Bob' }, myCaptures)) {\n   *   console.log(myCaptures.personName);\n   * }\n   * ```\n   */\n  public static tag(tagName: string, subtree?: TreeNode): TreeNode {\n    return new TreePatternArg(tagName, subtree);\n  }\n\n  /**\n   * Used to specify alternative possible subtrees in the search pattern.\n   *\n   * @remarks\n   * Used to build the `pattern` tree for {@link TreePattern.match}.  Allows several alternative patterns\n   * to be matched for a given subtree.\n   *\n   * Example:\n   *\n   * ```ts\n   * const myPattern: TreePattern = new TreePattern({\n   *   animal: TreePattern.oneOf([\n   *     { kind: 'dog', bark: 'loud' },\n   *     { kind: 'cat', meow: 'quiet' }\n   *   ])\n   * });\n   * if (myPattern.match({ animal: { kind: 'dog', bark: 'loud' } })) {\n   *   console.log('I can match dog.');\n   * }\n   * if (myPattern.match({ animal: { kind: 'cat', meow: 'quiet' } })) {\n   *   console.log('I can match cat, too.');\n   * }\n   * ```\n   */\n  public static oneOf(possibleSubtrees: TreeNode[]): TreeNode {\n    return new TreePatternAlternatives(possibleSubtrees);\n  }\n\n  /**\n   * Match an input tree.\n   *\n   * @remarks\n   * Return true if the `root` node matches the pattern.  (If the `root` node does not match, the child nodes are\n   * not recursively tested, since for an Abstract Syntax Tree the caller is typically an efficient visitor\n   * callback that already handles that job.)\n   *\n   * If the input matches the pattern, any tagged subtrees will be assigned to the `captures` target object\n   * if provided.  If the input does not match, the path of the mismatched node will be assigned to\n   * `captures.failPath`.\n   *\n   * @param root - the input tree to be matched\n   * @param captures - an optional object to receive any subtrees that were matched using {@link TreePattern.tag}\n   * @returns `true` if `root` matches the pattern, or `false` otherwise\n   */\n  public match(root: TreeNode, captures: ITreePatternCaptureSet = {}): boolean {\n    return TreePattern._matchTreeRecursive(root, this._pattern, captures, 'root');\n  }\n\n  private static _matchTreeRecursive(\n    root: TreeNode,\n    pattern: TreeNode,\n    captures: ITreePatternCaptureSet,\n    path: string\n  ): boolean {\n    if (pattern === undefined) {\n      throw new Error('pattern has an undefined value at ' + path);\n    }\n\n    // Avoid \"Element implicitly has an 'any' type\" (TS7053)\n    const castedCaptures: Record<string, TreeNode> = captures;\n\n    if (pattern instanceof TreePatternArg) {\n      if (pattern.subtree !== undefined) {\n        if (!TreePattern._matchTreeRecursive(root, pattern.subtree, captures, path)) {\n          return false;\n        }\n      }\n\n      castedCaptures[pattern.keyName] = root;\n      return true;\n    }\n\n    if (pattern instanceof TreePatternAlternatives) {\n      // Try each possible alternative until we find one that matches\n      for (const possibleSubtree of pattern.possibleSubtrees) {\n        // We shouldn't update \"captures\" unless the match is fully successful.\n        // So make a temporary copy of it.\n        const tempCaptures: Record<string, TreeNode> = { ...captures };\n        if (TreePattern._matchTreeRecursive(root, possibleSubtree, tempCaptures, path)) {\n          // The match was successful, so assign the tempCaptures results back into the\n          // original \"captures\" object.\n          for (const key of Object.getOwnPropertyNames(tempCaptures)) {\n            castedCaptures[key] = tempCaptures[key];\n          }\n          return true;\n        }\n      }\n\n      // None of the alternatives matched\n      return false;\n    }\n\n    if (Array.isArray(pattern)) {\n      if (!Array.isArray(root)) {\n        captures.failPath = path;\n        return false;\n      }\n\n      if (root.length !== pattern.length) {\n        captures.failPath = path;\n        return false;\n      }\n\n      for (let i: number = 0; i < pattern.length; ++i) {\n        const subPath: string = path + '[' + i + ']';\n\n        const rootElement: TreeNode = root[i];\n        const patternElement: TreeNode = pattern[i];\n        if (!TreePattern._matchTreeRecursive(rootElement, patternElement, captures, subPath)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    // In JavaScript, typeof null === 'object'\n    if (typeof pattern === 'object' && pattern !== null) {\n      if (typeof root !== 'object' || root === null) {\n        captures.failPath = path;\n        return false;\n      }\n\n      for (const keyName of Object.getOwnPropertyNames(pattern)) {\n        let subPath: string;\n        if (/^[a-z_][a-z0-9_]*$/i.test(keyName)) {\n          subPath = path + '.' + keyName;\n        } else {\n          subPath = path + '[' + JSON.stringify(keyName) + ']';\n        }\n\n        if (!Object.hasOwnProperty.call(root, keyName)) {\n          captures.failPath = subPath;\n          return false;\n        }\n        if (!TreePattern._matchTreeRecursive(root[keyName], pattern[keyName], captures, subPath)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (root !== pattern) {\n      captures.failPath = path;\n      return false;\n    }\n\n    return true;\n  }\n}\n"]}