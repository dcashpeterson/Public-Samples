"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevDeployHooks = void 0;
const tapable_1 = require("tapable");
const node_core_library_1 = require("@rushstack/node-core-library");
const SpDevDeploy_1 = require("./SpDevDeploy");
const DevDeployHelper_1 = require("./DevDeployHelper");
const PluginNames_1 = require("../PluginNames");
const AzureUploader_1 = require("../../utilities/AzureUploader");
/**
 * @public
 */
class DevDeployHooks {
    constructor() {
        /**
         * Initialize
         */
        this.init = new tapable_1.AsyncParallelHook(['deployOptions']);
        /**
         * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
         */
        this.preProcess = new tapable_1.SyncHook();
        /**
         * Gets the files to be deployed to the CDN
         */
        this.getFiles = new tapable_1.AsyncSeriesWaterfallHook([
            'files'
        ]);
        /**
         * Gets the name of the folder in the container into which files should be uploaded
         */
        this.getContainerFolderName = new tapable_1.SyncWaterfallHook([
            'containerFolderName'
        ]);
        /**
         * Gets the name of the Azure storage account
         */
        this.getStorageAccountName = new tapable_1.SyncWaterfallHook([
            'storageAccountName'
        ]);
        /**
         * Gets the name of the container
         */
        this.getContainerName = new tapable_1.SyncWaterfallHook(['containerName']);
        /**
         * Gets a SAS for the storage container
         */
        this.getStorageSas = new tapable_1.AsyncSeriesWaterfallHook([
            'storageSas'
        ]);
        /**
         * Returns true if the deployment is in a prod environment
         */
        this.isProd = new tapable_1.SyncWaterfallHook(['isProd']);
        /**
         * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
         */
        this.postProcess = new tapable_1.AsyncSeriesHook();
    }
}
exports.DevDeployHooks = DevDeployHooks;
/**
 * @internal
 */
class DevDeployPlugin {
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                hooks: new DevDeployHooks(),
                properties: {}
            };
        }
        return this._accessor;
    }
    apply(taskSession, heftConfiguration) {
        const logger = taskSession.logger;
        const rushParameter = taskSession.parameters.getFlagParameter('--rush');
        const maxRetriesParameter = taskSession.parameters.getIntegerParameter('--max-retries');
        this._installDefaultHooks();
        taskSession.hooks.run.tapPromise(PluginNames_1.DevDeployPlugin, async () => {
            logger.terminal.writeLine('Starting DevDeploy...');
            try {
                await this._deployAsync({
                    useRush: rushParameter.value,
                    maxRetries: maxRetriesParameter.value,
                    terminal: logger.terminal,
                    rootPath: heftConfiguration.buildFolderPath
                });
                logger.terminal.writeLine(node_core_library_1.Colors.green('DevDeploy completed successfully.'));
            }
            catch (e) {
                logger.emitError(e);
            }
        });
    }
    _installDefaultHooks() {
        const hooks = this.accessor.hooks;
        let devDeployProcessor;
        hooks.init.tapPromise(PluginNames_1.DevDeployPlugin, async (options) => {
            devDeployProcessor = await SpDevDeploy_1.SpDevDeploy.initializeAsync({
                _manifestsJsFileMetadata: this.accessor.properties._manifestsJsFileMetadata,
                ...options
            });
        });
        hooks.preProcess.tap(PluginNames_1.DevDeployPlugin, () => {
            devDeployProcessor.preProcess();
        });
        hooks.getContainerFolderName.tap(PluginNames_1.DevDeployPlugin, () => {
            return SpDevDeploy_1.SpDevDeploy.getDevDeployContainerDirectoryName();
        });
        hooks.isProd.tap(PluginNames_1.DevDeployPlugin, () => {
            return false;
        });
        hooks.getFiles.tapPromise(PluginNames_1.DevDeployPlugin, async () => {
            return await devDeployProcessor.getFilesAsync();
        });
        hooks.postProcess.tapPromise(PluginNames_1.DevDeployPlugin, async () => {
            devDeployProcessor.postProcess();
        });
    }
    async _deployAsync(options) {
        const hooks = this.accessor.hooks;
        const accountName = hooks.getStorageAccountName.call();
        const sas = await hooks.getStorageSas.promise();
        const isProd = hooks.isProd.call(false);
        const containerName = hooks.getContainerName.call();
        const folderNameInContainer = hooks.getContainerFolderName.call();
        if (!accountName) {
            throw new Error('Azure storage account not set.');
        }
        if (!sas) {
            throw new Error('Azure storage account SAS not set.');
        }
        if (!containerName) {
            throw new Error('Azure container name not set.');
        }
        const deployConfig = {
            accountName,
            sas,
            isProd,
            containerName,
            folderNameInContainer,
            useRush: options.useRush,
            maxRetries: options.maxRetries || AzureUploader_1.AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES
        };
        await hooks.init.promise({
            isolateProjects: false,
            rootPath: options.rootPath,
            terminal: options.terminal,
            devDeployConfig: deployConfig
        });
        hooks.preProcess.call();
        const deployData = await hooks.getFiles.promise();
        await DevDeployHelper_1.DevDeployHelper.deployFilesAsync(options.terminal, deployConfig, deployData);
        await hooks.postProcess.promise();
    }
}
exports.default = DevDeployPlugin;
//# sourceMappingURL=DevDeployPlugin.js.map