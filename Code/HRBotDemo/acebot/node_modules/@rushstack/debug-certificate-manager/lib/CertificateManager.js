"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CertificateManager = void 0;
const path = __importStar(require("path"));
const os_1 = require("os");
const node_core_library_1 = require("@rushstack/node-core-library");
const runCommand_1 = require("./runCommand");
const CertificateStore_1 = require("./CertificateStore");
const forge = node_core_library_1.Import.lazy('node-forge', require);
const SERIAL_NUMBER = '731c321744e34650a202e3ef91c3c1b0';
const FRIENDLY_NAME = 'debug-certificate-manager Development Certificate';
const MAC_KEYCHAIN = '/Library/Keychains/System.keychain';
const CERTUTIL_EXE_NAME = 'certutil';
/**
 * A utility class to handle generating, trusting, and untrustring a debug certificate.
 * Contains two public methods to `ensureCertificate` and `untrustCertificate`.
 * @public
 */
class CertificateManager {
    constructor() {
        this._certificateStore = new CertificateStore_1.CertificateStore();
    }
    /**
     * Get a development certificate from the store, or optionally, generate a new one
     * and trust it if one doesn't exist in the store.
     *
     * @public
     */
    async ensureCertificateAsync(canGenerateNewCertificate, terminal) {
        if (this._certificateStore.certificateData && this._certificateStore.keyData) {
            let invalidCertificate = false;
            const messages = [];
            if (!this._certificateHasSubjectAltName()) {
                invalidCertificate = true;
                messages.push('The existing development certificate is missing the subjectAltName ' +
                    'property and will not work with the latest versions of some browsers.');
            }
            if (!(await this._detectIfCertificateIsTrustedAsync(terminal))) {
                invalidCertificate = true;
                messages.push('The existing development certificate is not currently trusted by your system.');
            }
            if (invalidCertificate) {
                if (canGenerateNewCertificate) {
                    messages.push('Attempting to untrust the certificate and generate a new one.');
                    terminal.writeWarningLine(messages.join(' '));
                    await this.untrustCertificateAsync(terminal);
                    await this._ensureCertificateInternalAsync(terminal);
                }
                else {
                    messages.push('Untrust the certificate and generate a new one, or set the ' +
                        '`canGenerateNewCertificate` parameter to `true` when calling `ensureCertificateAsync`.');
                    throw new Error(messages.join(' '));
                }
            }
        }
        else if (canGenerateNewCertificate) {
            await this._ensureCertificateInternalAsync(terminal);
        }
        else {
            throw new Error('No development certificate found. Generate a new certificate manually, or set the ' +
                '`canGenerateNewCertificate` parameter to `true` when calling `ensureCertificateAsync`.');
        }
        return {
            pemCertificate: this._certificateStore.certificateData,
            pemKey: this._certificateStore.keyData
        };
    }
    /**
     * Attempt to locate a previously generated debug certificate and untrust it.
     *
     * @public
     */
    async untrustCertificateAsync(terminal) {
        this._certificateStore.certificateData = undefined;
        this._certificateStore.keyData = undefined;
        switch (process.platform) {
            case 'win32':
                const winUntrustResult = await (0, runCommand_1.runAsync)(CERTUTIL_EXE_NAME, [
                    '-user',
                    '-delstore',
                    'root',
                    SERIAL_NUMBER
                ]);
                if (winUntrustResult.code !== 0) {
                    terminal.writeErrorLine(`Error: ${winUntrustResult.stderr.join(' ')}`);
                    return false;
                }
                else {
                    terminal.writeVerboseLine('Successfully untrusted development certificate.');
                    return true;
                }
            case 'darwin':
                terminal.writeVerboseLine('Trying to find the signature of the development certificate.');
                const macFindCertificateResult = await (0, runCommand_1.runAsync)('security', [
                    'find-certificate',
                    '-c',
                    'localhost',
                    '-a',
                    '-Z',
                    MAC_KEYCHAIN
                ]);
                if (macFindCertificateResult.code !== 0) {
                    terminal.writeErrorLine(`Error finding the development certificate: ${macFindCertificateResult.stderr.join(' ')}`);
                    return false;
                }
                const shaHash = this._parseMacOsMatchingCertificateHash(macFindCertificateResult.stdout.join(os_1.EOL));
                if (!shaHash) {
                    terminal.writeErrorLine('Unable to find the development certificate.');
                    return false;
                }
                else {
                    terminal.writeVerboseLine(`Found the development certificate. SHA is ${shaHash}`);
                }
                const macUntrustResult = await (0, runCommand_1.runSudoAsync)('security', [
                    'delete-certificate',
                    '-Z',
                    shaHash,
                    MAC_KEYCHAIN
                ]);
                if (macUntrustResult.code === 0) {
                    terminal.writeVerboseLine('Successfully untrusted development certificate.');
                    return true;
                }
                else {
                    terminal.writeErrorLine(macUntrustResult.stderr.join(' '));
                    return false;
                }
            default:
                // Linux + others: Have the user manually untrust the cert
                terminal.writeLine('Automatic certificate untrust is only implemented for debug-certificate-manager on Windows ' +
                    'and macOS. To untrust the development certificate, remove this certificate from your trusted ' +
                    `root certification authorities: "${this._certificateStore.certificatePath}". The ` +
                    `certificate has serial number "${SERIAL_NUMBER}".`);
                return false;
        }
    }
    _createDevelopmentCertificate() {
        const keys = forge.pki.rsa.generateKeyPair(2048);
        const certificate = forge.pki.createCertificate();
        certificate.publicKey = keys.publicKey;
        certificate.serialNumber = SERIAL_NUMBER;
        const now = new Date();
        certificate.validity.notBefore = now;
        // Valid for 3 years
        certificate.validity.notAfter.setFullYear(certificate.validity.notBefore.getFullYear() + 3);
        const attrs = [
            {
                name: 'commonName',
                value: 'localhost'
            }
        ];
        certificate.setSubject(attrs);
        certificate.setIssuer(attrs);
        certificate.setExtensions([
            {
                name: 'subjectAltName',
                altNames: [
                    {
                        type: 2,
                        value: 'localhost'
                    }
                ]
            },
            {
                name: 'keyUsage',
                digitalSignature: true,
                keyEncipherment: true,
                dataEncipherment: true
            },
            {
                name: 'extKeyUsage',
                serverAuth: true
            },
            {
                name: 'friendlyName',
                value: FRIENDLY_NAME
            }
        ]);
        // self-sign certificate
        certificate.sign(keys.privateKey, forge.md.sha256.create());
        // convert a Forge certificate to PEM
        const pem = forge.pki.certificateToPem(certificate);
        const pemKey = forge.pki.privateKeyToPem(keys.privateKey);
        return {
            pemCertificate: pem,
            pemKey: pemKey
        };
    }
    async _tryTrustCertificateAsync(certificatePath, terminal) {
        switch (process.platform) {
            case 'win32':
                terminal.writeLine('Attempting to trust a development certificate. This self-signed certificate only points to localhost ' +
                    'and will be stored in your local user profile to be used by other instances of ' +
                    'debug-certificate-manager. If you do not consent to trust this certificate, click "NO" in the dialog.');
                const winTrustResult = await (0, runCommand_1.runAsync)(CERTUTIL_EXE_NAME, [
                    '-user',
                    '-addstore',
                    'root',
                    certificatePath
                ]);
                if (winTrustResult.code !== 0) {
                    terminal.writeErrorLine(`Error: ${winTrustResult.stdout.toString()}`);
                    const errorLines = winTrustResult.stdout
                        .toString()
                        .split(os_1.EOL)
                        .map((line) => line.trim());
                    // Not sure if this is always the status code for "cancelled" - should confirm.
                    if (winTrustResult.code === 2147943623 ||
                        errorLines[errorLines.length - 1].indexOf('The operation was canceled by the user.') > 0) {
                        terminal.writeLine('Certificate trust cancelled.');
                    }
                    else {
                        terminal.writeErrorLine('Certificate trust failed with an unknown error.');
                    }
                    return false;
                }
                else {
                    terminal.writeVerboseLine('Successfully trusted development certificate.');
                    return true;
                }
            case 'darwin':
                terminal.writeLine('Attempting to trust a development certificate. This self-signed certificate only points to localhost ' +
                    'and will be stored in your local user profile to be used by other instances of ' +
                    'debug-certificate-manager. If you do not consent to trust this certificate, do not enter your ' +
                    'root password in the prompt.');
                const result = await (0, runCommand_1.runSudoAsync)('security', [
                    'add-trusted-cert',
                    '-d',
                    '-r',
                    'trustRoot',
                    '-k',
                    MAC_KEYCHAIN,
                    certificatePath
                ]);
                if (result.code === 0) {
                    terminal.writeVerboseLine('Successfully trusted development certificate.');
                    return true;
                }
                else {
                    if (result.stderr.some((value) => !!value.match(/The authorization was cancelled by the user\./))) {
                        terminal.writeLine('Certificate trust cancelled.');
                        return false;
                    }
                    else {
                        terminal.writeErrorLine(`Certificate trust failed with an unknown error. Exit code: ${result.code}. ` +
                            `Error: ${result.stderr.join(' ')}`);
                        return false;
                    }
                }
            default:
                // Linux + others: Have the user manually trust the cert if they want to
                terminal.writeLine('Automatic certificate trust is only implemented for debug-certificate-manager on Windows ' +
                    'and macOS. To trust the development certificate, add this certificate to your trusted root ' +
                    `certification authorities: "${certificatePath}".`);
                return true;
        }
    }
    async _detectIfCertificateIsTrustedAsync(terminal) {
        switch (process.platform) {
            case 'win32':
                const winVerifyStoreResult = await (0, runCommand_1.runAsync)(CERTUTIL_EXE_NAME, [
                    '-user',
                    '-verifystore',
                    'root',
                    SERIAL_NUMBER
                ]);
                if (winVerifyStoreResult.code !== 0) {
                    terminal.writeVerboseLine('The development certificate was not found in the store. CertUtil error: ', winVerifyStoreResult.stderr.join(' '));
                    return false;
                }
                else {
                    terminal.writeVerboseLine('The development certificate was found in the store. CertUtil output: ', winVerifyStoreResult.stdout.join(' '));
                    return true;
                }
            case 'darwin':
                terminal.writeVerboseLine('Trying to find the signature of the development certificate.');
                const macFindCertificateResult = await (0, runCommand_1.runAsync)('security', [
                    'find-certificate',
                    '-c',
                    'localhost',
                    '-a',
                    '-Z',
                    MAC_KEYCHAIN
                ]);
                if (macFindCertificateResult.code !== 0) {
                    terminal.writeVerboseLine('The development certificate was not found in keychain. Find certificate error: ', macFindCertificateResult.stderr.join(' '));
                    return false;
                }
                const shaHash = this._parseMacOsMatchingCertificateHash(macFindCertificateResult.stdout.join(os_1.EOL));
                if (!shaHash) {
                    terminal.writeVerboseLine('The development certificate was not found in keychain. Find certificate output:\n', macFindCertificateResult.stdout.join(' '));
                    return false;
                }
                terminal.writeVerboseLine(`The development certificate was found in keychain.`);
                return true;
            default:
                // Linux + others: Have the user manually verify the cert is trusted
                terminal.writeVerboseLine('Automatic certificate trust validation is only implemented for debug-certificate-manager on Windows ' +
                    'and macOS. Manually verify this development certificate is present in your trusted ' +
                    `root certification authorities: "${this._certificateStore.certificatePath}". ` +
                    `The certificate has serial number "${SERIAL_NUMBER}".`);
                // Always return true on Linux to prevent breaking flow.
                return true;
        }
    }
    async _trySetFriendlyNameAsync(certificatePath, terminal) {
        if (process.platform === 'win32') {
            const basePath = path.dirname(certificatePath);
            const fileName = path.basename(certificatePath, path.extname(certificatePath));
            const friendlyNamePath = path.join(basePath, `${fileName}.inf`);
            const friendlyNameFile = [
                '[Version]',
                'Signature = "$Windows NT$"',
                '[Properties]',
                `11 = "{text}${FRIENDLY_NAME}"`,
                ''
            ].join(os_1.EOL);
            await node_core_library_1.FileSystem.writeFileAsync(friendlyNamePath, friendlyNameFile);
            const repairStoreResult = await (0, runCommand_1.runAsync)(CERTUTIL_EXE_NAME, [
                '-repairstore',
                '-user',
                'root',
                SERIAL_NUMBER,
                friendlyNamePath
            ]);
            if (repairStoreResult.code !== 0) {
                terminal.writeErrorLine(`CertUtil Error: ${repairStoreResult.stderr.join('')}`);
                return false;
            }
            else {
                terminal.writeVerboseLine('Successfully set certificate name.');
                return true;
            }
        }
        else {
            // No equivalent concept outside of Windows
            return true;
        }
    }
    async _ensureCertificateInternalAsync(terminal) {
        const certificateStore = this._certificateStore;
        const generatedCertificate = this._createDevelopmentCertificate();
        const now = new Date();
        const certificateName = now.getTime().toString();
        const tempDirName = path.join(__dirname, '..', 'temp');
        const tempCertificatePath = path.join(tempDirName, `${certificateName}.pem`);
        const pemFileContents = generatedCertificate.pemCertificate;
        if (pemFileContents) {
            await node_core_library_1.FileSystem.writeFileAsync(tempCertificatePath, pemFileContents, {
                ensureFolderExists: true
            });
        }
        const trustCertificateResult = await this._tryTrustCertificateAsync(tempCertificatePath, terminal);
        if (trustCertificateResult) {
            certificateStore.certificateData = generatedCertificate.pemCertificate;
            certificateStore.keyData = generatedCertificate.pemKey;
            // Try to set the friendly name, and warn if we can't
            if (!this._trySetFriendlyNameAsync(tempCertificatePath, terminal)) {
                terminal.writeWarningLine("Unable to set the certificate's friendly name.");
            }
        }
        else {
            // Clear out the existing store data, if any exists
            certificateStore.certificateData = undefined;
            certificateStore.keyData = undefined;
        }
        await node_core_library_1.FileSystem.deleteFileAsync(tempCertificatePath);
    }
    _certificateHasSubjectAltName() {
        const certificateData = this._certificateStore.certificateData;
        if (!certificateData) {
            return false;
        }
        const certificate = forge.pki.certificateFromPem(certificateData);
        return !!certificate.getExtension('subjectAltName');
    }
    _parseMacOsMatchingCertificateHash(findCertificateOuput) {
        let shaHash = undefined;
        for (const line of findCertificateOuput.split(os_1.EOL)) {
            // Sets `shaHash` to the current certificate SHA-1 as we progress through the lines of certificate text.
            const shaHashMatch = line.match(/^SHA-1 hash: (.+)$/);
            if (shaHashMatch) {
                shaHash = shaHashMatch[1];
            }
            const snbrMatch = line.match(/^\s*"snbr"<blob>=0x([^\s]+).+$/);
            if (snbrMatch && (snbrMatch[1] || '').toLowerCase() === SERIAL_NUMBER) {
                return shaHash;
            }
        }
    }
}
exports.CertificateManager = CertificateManager;
//# sourceMappingURL=CertificateManager.js.map