"use strict";
exports.id = "ProjectWatcher";
exports.ids = ["ProjectWatcher"];
exports.modules = {

/***/ 725223:
/*!********************************************!*\
  !*** ./lib-esnext/logic/ProjectWatcher.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectWatcher": () => (/* binding */ ProjectWatcher)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 657147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! readline */ 514521);
/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(readline__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ 582361);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/package-deps-hash */ 717642);
/* harmony import */ var _rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Git */ 668229);
/* harmony import */ var _ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ProjectChangeAnalyzer */ 311605);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.








/**
 * This class is for incrementally watching a set of projects in the repository for changes.
 *
 * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean
 * signal indicating that "at least 1 file in a watched project changed". We then defer to ProjectChangeAnalyzer (which
 * is responsible for change detection in all incremental builds) to determine what actually chanaged.
 *
 * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or
 * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.
 */
class ProjectWatcher {
    constructor(options) {
        this.isPaused = false;
        const { debounceMs = 1000, rushConfiguration, projectsToWatch, terminal, initialState } = options;
        this._debounceMs = debounceMs;
        this._rushConfiguration = rushConfiguration;
        this._projectsToWatch = projectsToWatch;
        this._terminal = terminal;
        const gitPath = new _Git__WEBPACK_IMPORTED_MODULE_6__.Git(rushConfiguration).getGitPathOrThrow();
        this._repoRoot = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes((0,_rushstack_package_deps_hash__WEBPACK_IMPORTED_MODULE_4__.getRepoRoot)(rushConfiguration.rushJsonFolder, gitPath));
        this._initialState = initialState;
        this._previousState = initialState;
        this._hasRenderedStatus = false;
    }
    pause() {
        this.isPaused = true;
    }
    resume() {
        this.isPaused = false;
        if (this._resolveIfChanged) {
            this._resolveIfChanged().catch(() => {
                // Suppress unhandled promise rejection error
            });
        }
    }
    /**
     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.
     * Will return immediately the first time it is invoked, since no state has been recorded.
     * If no change is currently present, watches the source tree of all selected projects for file changes.
     * `waitForChange` is not allowed to be called multiple times concurrently.
     */
    async waitForChange(onWatchingFiles) {
        const initialChangeResult = await this._computeChanged();
        // Ensure that the new state is recorded so that we don't loop infinitely
        this._commitChanges(initialChangeResult.state);
        if (initialChangeResult.changedProjects.size) {
            return initialChangeResult;
        }
        const previousState = initialChangeResult.state;
        const repoRoot = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);
        // Map of path to whether config for the path
        const pathsToWatch = new Map();
        // Node 12 supports the "recursive" parameter to fs.watch only on win32 and OSX
        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats
        const useNativeRecursiveWatch = os__WEBPACK_IMPORTED_MODULE_1__.platform() === 'win32' || os__WEBPACK_IMPORTED_MODULE_1__.platform() === 'darwin';
        if (useNativeRecursiveWatch) {
            // Watch the root non-recursively
            pathsToWatch.set(repoRoot, { recurse: false });
            // Watch the rush config folder non-recursively
            pathsToWatch.set(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes(this._rushConfiguration.commonRushConfigFolder), {
                recurse: false
            });
            for (const project of this._projectsToWatch) {
                // Use recursive watch in individual project folders
                pathsToWatch.set(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes(project.projectFolder), { recurse: true });
            }
        }
        else {
            for (const project of this._projectsToWatch) {
                const projectState = (await previousState._tryGetProjectDependenciesAsync(project, this._terminal));
                const prefixLength = project.projectFolder.length - repoRoot.length - 1;
                // Watch files in the root of the project, or
                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {
                    pathsToWatch.set(`${this._repoRoot}/${pathToWatch}`, { recurse: true });
                }
            }
        }
        const watchers = new Map();
        const watchedResult = await new Promise((resolve, reject) => {
            let timeout;
            let terminated = false;
            const terminal = this._terminal;
            const debounceMs = this._debounceMs;
            this._hasRenderedStatus = false;
            const resolveIfChanged = (this._resolveIfChanged = async () => {
                timeout = undefined;
                if (terminated) {
                    return;
                }
                try {
                    if (this.isPaused) {
                        this._setStatus(`Project watcher paused.`);
                        return;
                    }
                    this._setStatus(`Evaluating changes to tracked files...`);
                    const result = await this._computeChanged();
                    this._setStatus(`Finished analyzing.`);
                    // Need an async tick to allow for more file system events to be handled
                    process.nextTick(() => {
                        if (timeout) {
                            // If another file has changed, wait for another pass.
                            this._setStatus(`More file changes detected, aborting.`);
                            return;
                        }
                        this._commitChanges(result.state);
                        if (result.changedProjects.size) {
                            terminated = true;
                            terminal.writeLine();
                            resolve(result);
                        }
                        else {
                            this._setStatus(`No changes detected to tracked files.`);
                        }
                    });
                }
                catch (err) {
                    // eslint-disable-next-line require-atomic-updates
                    terminated = true;
                    terminal.writeLine();
                    reject(err);
                }
            });
            for (const [pathToWatch, { recurse }] of pathsToWatch) {
                addWatcher(pathToWatch, recurse);
            }
            if (onWatchingFiles) {
                onWatchingFiles();
            }
            function onError(err) {
                if (terminated) {
                    return;
                }
                terminated = true;
                terminal.writeLine();
                reject(err);
            }
            function addWatcher(watchedPath, recursive) {
                if (watchers.has(watchedPath)) {
                    return;
                }
                const listener = changeListener(watchedPath, recursive);
                const watcher = fs__WEBPACK_IMPORTED_MODULE_0__.watch(watchedPath, {
                    encoding: 'utf-8',
                    recursive: recursive && useNativeRecursiveWatch
                }, listener);
                watchers.set(watchedPath, watcher);
                watcher.on('error', (err) => {
                    watchers.delete(watchedPath);
                    onError(err);
                });
            }
            function innerListener(root, recursive, event, fileName) {
                try {
                    if (terminated) {
                        return;
                    }
                    if (fileName === '.git' || fileName === 'node_modules') {
                        return;
                    }
                    // Handling for added directories
                    if (recursive && !useNativeRecursiveWatch) {
                        const decodedName = fileName ? fileName.toString() : '';
                        const normalizedName = decodedName && _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes(decodedName);
                        const fullName = normalizedName && `${root}/${normalizedName}`;
                        if (fullName && !watchers.has(fullName)) {
                            try {
                                const stat = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.getStatistics(fullName);
                                if (stat.isDirectory()) {
                                    addWatcher(fullName, true);
                                }
                            }
                            catch (err) {
                                const code = err.code;
                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {
                                    throw err;
                                }
                            }
                        }
                    }
                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(resolveIfChanged, debounceMs);
                }
                catch (err) {
                    terminated = true;
                    terminal.writeLine();
                    reject(err);
                }
            }
            function changeListener(root, recursive) {
                return innerListener.bind(0, root, recursive);
            }
        }).finally(() => {
            this._resolveIfChanged = undefined;
        });
        const closePromises = [];
        for (const [watchedPath, watcher] of watchers) {
            closePromises.push((0,events__WEBPACK_IMPORTED_MODULE_3__.once)(watcher, 'close').then(() => {
                watchers.delete(watchedPath);
            }));
            watcher.close();
        }
        await Promise.all(closePromises);
        return watchedResult;
    }
    _setStatus(status) {
        if (this._hasRenderedStatus) {
            readline__WEBPACK_IMPORTED_MODULE_2__.clearLine(process.stdout, 0);
            readline__WEBPACK_IMPORTED_MODULE_2__.cursorTo(process.stdout, 0);
        }
        else {
            this._hasRenderedStatus = true;
        }
        this._terminal.write(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Colors.bold(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Colors.cyan(`[${this.isPaused ? 'PAUSED' : 'WATCHING'}] Watch Status: ${status} ${this.isPaused ? 'Press <w> to resume. Press <b> to build once.' : 'Press <w> to pause.'}`)));
    }
    /**
     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore
     */
    async _computeChanged() {
        const state = new _ProjectChangeAnalyzer__WEBPACK_IMPORTED_MODULE_7__.ProjectChangeAnalyzer(this._rushConfiguration);
        const previousState = this._previousState;
        if (!previousState) {
            return {
                changedProjects: this._projectsToWatch,
                state
            };
        }
        const changedProjects = new Set();
        for (const project of this._projectsToWatch) {
            const [previous, current] = await Promise.all([
                previousState._tryGetProjectDependenciesAsync(project, this._terminal),
                state._tryGetProjectDependenciesAsync(project, this._terminal)
            ]);
            if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {
                // May need to detect if the nature of the change will break the process, e.g. changes to package.json
                changedProjects.add(project);
            }
        }
        return {
            changedProjects,
            state
        };
    }
    _commitChanges(state) {
        this._previousState = state;
        if (!this._initialState) {
            this._initialState = state;
        }
    }
    /**
     * Tests for inequality of the passed Maps. Order invariant.
     *
     * @returns `true` if the maps are different, `false` otherwise
     */
    static _haveProjectDepsChanged(prev, next) {
        if (!prev && !next) {
            return false;
        }
        if (!prev || !next) {
            return true;
        }
        if (prev.size !== next.size) {
            return true;
        }
        for (const [key, value] of prev) {
            if (next.get(key) !== value) {
                return true;
            }
        }
        return false;
    }
    static *_enumeratePathsToWatch(paths, prefixLength) {
        for (const path of paths) {
            const rootSlashIndex = path.indexOf('/', prefixLength);
            if (rootSlashIndex < 0) {
                yield path;
                return;
            }
            yield path.slice(0, rootSlashIndex);
            let slashIndex = path.indexOf('/', rootSlashIndex + 1);
            while (slashIndex >= 0) {
                yield path.slice(0, slashIndex);
                slashIndex = path.indexOf('/', slashIndex + 1);
            }
        }
    }
}
//# sourceMappingURL=ProjectWatcher.js.map

/***/ })

};
;
//# sourceMappingURL=ProjectWatcher.js.map