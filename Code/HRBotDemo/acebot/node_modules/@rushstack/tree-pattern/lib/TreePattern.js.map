{"version":3,"file":"TreePattern.js","sourceRoot":"","sources":["../src/TreePattern.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Indicates the tree-like data structure that {@link TreePattern} will traverse.\r\n *\r\n * @remarks\r\n * Since `TreePattern` makes relatively few assumptions object the object structure, this is\r\n * just an alias for `any`.  At least as far as the portions to be matched, the tree nodes\r\n * are expected to be JSON-like structures made from JavaScript arrays, JavaScript objects,\r\n * and primitive values that can be compared using `===`.\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type TreeNode = any;\r\n\r\nclass TreePatternArg {\r\n  public readonly keyName: string;\r\n  public readonly subtree: TreeNode | undefined;\r\n  public constructor(keyName: string, subtree?: TreeNode) {\r\n    this.keyName = keyName;\r\n    this.subtree = subtree;\r\n  }\r\n}\r\n\r\nclass TreePatternAlternatives {\r\n  public readonly possibleSubtrees: TreeNode[];\r\n  public constructor(possibleSubtrees: TreeNode[]) {\r\n    this.possibleSubtrees = possibleSubtrees;\r\n  }\r\n}\r\n\r\n/**\r\n * Provides additional detail about the success or failure of {@link TreePattern.match}.\r\n *\r\n * @remarks\r\n * On success, the object will contain keys for any successfully matched tags, as\r\n * defined using {@link TreePattern.tag}.\r\n *\r\n * On failure, the `failPath` member will indicate the JSON path of the node that\r\n * failed to match.\r\n *\r\n * @public\r\n */\r\nexport type ITreePatternCaptureSet =\r\n  | {\r\n      [tagName: string]: TreeNode;\r\n    }\r\n  | { failPath: string };\r\n\r\n/**\r\n * A fast, lightweight pattern matcher for tree structures such as an Abstract Syntax Tree (AST).\r\n * @public\r\n */\r\nexport class TreePattern {\r\n  private readonly _pattern: TreeNode;\r\n\r\n  public constructor(pattern: TreeNode) {\r\n    this._pattern = pattern;\r\n  }\r\n\r\n  /**\r\n   * Labels a subtree within the search pattern, so that the matching object can be retrieved.\r\n   *\r\n   * @remarks\r\n   * Used to build the `pattern` tree for {@link TreePattern.match}.  For the given `subtree` of the pattern,\r\n   * if it is matched, that node will be assigned to the `captures` object using `tagName` as the key.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```ts\r\n   * const myCaptures: { personName?: string } = {};\r\n   * const myPattern = {\r\n   *   name: TreePattern.tag('personName')\r\n   * };\r\n   * if (myPattern.match({ name: 'Bob' }, myCaptures)) {\r\n   *   console.log(myCaptures.personName);\r\n   * }\r\n   * ```\r\n   */\r\n  public static tag(tagName: string, subtree?: TreeNode): TreeNode {\r\n    return new TreePatternArg(tagName, subtree);\r\n  }\r\n\r\n  /**\r\n   * Used to specify alternative possible subtrees in the search pattern.\r\n   *\r\n   * @remarks\r\n   * Used to build the `pattern` tree for {@link TreePattern.match}.  Allows several alternative patterns\r\n   * to be matched for a given subtree.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```ts\r\n   * const myPattern: TreePattern = new TreePattern({\r\n   *   animal: TreePattern.oneOf([\r\n   *     { kind: 'dog', bark: 'loud' },\r\n   *     { kind: 'cat', meow: 'quiet' }\r\n   *   ])\r\n   * });\r\n   * if (myPattern.match({ animal: { kind: 'dog', bark: 'loud' } })) {\r\n   *   console.log('I can match dog.');\r\n   * }\r\n   * if (myPattern.match({ animal: { kind: 'cat', meow: 'quiet' } })) {\r\n   *   console.log('I can match cat, too.');\r\n   * }\r\n   * ```\r\n   */\r\n  public static oneOf(possibleSubtrees: TreeNode[]): TreeNode {\r\n    return new TreePatternAlternatives(possibleSubtrees);\r\n  }\r\n\r\n  /**\r\n   * Match an input tree.\r\n   *\r\n   * @remarks\r\n   * Return true if the `root` node matches the pattern.  (If the `root` node does not match, the child nodes are\r\n   * not recursively tested, since for an Abstract Syntax Tree the caller is typically an efficient visitor\r\n   * callback that already handles that job.)\r\n   *\r\n   * If the input matches the pattern, any tagged subtrees will be assigned to the `captures` target object\r\n   * if provided.  If the input does not match, the path of the mismatched node will be assigned to\r\n   * `captures.failPath`.\r\n   *\r\n   * @param root - the input tree to be matched\r\n   * @param captures - an optional object to receive any subtrees that were matched using {@link TreePattern.tag}\r\n   * @returns `true` if `root` matches the pattern, or `false` otherwise\r\n   */\r\n  public match(root: TreeNode, captures: ITreePatternCaptureSet = {}): boolean {\r\n    return TreePattern._matchTreeRecursive(root, this._pattern, captures, 'root');\r\n  }\r\n\r\n  private static _matchTreeRecursive(\r\n    root: TreeNode,\r\n    pattern: TreeNode,\r\n    captures: ITreePatternCaptureSet,\r\n    path: string\r\n  ): boolean {\r\n    if (pattern === undefined) {\r\n      throw new Error('pattern has an undefined value at ' + path);\r\n    }\r\n\r\n    // Avoid \"Element implicitly has an 'any' type\" (TS7053)\r\n    const castedCaptures: Record<string, TreeNode> = captures;\r\n\r\n    if (pattern instanceof TreePatternArg) {\r\n      if (pattern.subtree !== undefined) {\r\n        if (!TreePattern._matchTreeRecursive(root, pattern.subtree, captures, path)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      castedCaptures[pattern.keyName] = root;\r\n      return true;\r\n    }\r\n\r\n    if (pattern instanceof TreePatternAlternatives) {\r\n      // Try each possible alternative until we find one that matches\r\n      for (const possibleSubtree of pattern.possibleSubtrees) {\r\n        // We shouldn't update \"captures\" unless the match is fully successful.\r\n        // So make a temporary copy of it.\r\n        const tempCaptures: Record<string, TreeNode> = { ...captures };\r\n        if (TreePattern._matchTreeRecursive(root, possibleSubtree, tempCaptures, path)) {\r\n          // The match was successful, so assign the tempCaptures results back into the\r\n          // original \"captures\" object.\r\n          for (const key of Object.getOwnPropertyNames(tempCaptures)) {\r\n            castedCaptures[key] = tempCaptures[key];\r\n          }\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // None of the alternatives matched\r\n      return false;\r\n    }\r\n\r\n    if (Array.isArray(pattern)) {\r\n      if (!Array.isArray(root)) {\r\n        captures.failPath = path;\r\n        return false;\r\n      }\r\n\r\n      if (root.length !== pattern.length) {\r\n        captures.failPath = path;\r\n        return false;\r\n      }\r\n\r\n      for (let i: number = 0; i < pattern.length; ++i) {\r\n        const subPath: string = path + '[' + i + ']';\r\n\r\n        const rootElement: TreeNode = root[i];\r\n        const patternElement: TreeNode = pattern[i];\r\n        if (!TreePattern._matchTreeRecursive(rootElement, patternElement, captures, subPath)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    // In JavaScript, typeof null === 'object'\r\n    if (typeof pattern === 'object' && pattern !== null) {\r\n      if (typeof root !== 'object' || root === null) {\r\n        captures.failPath = path;\r\n        return false;\r\n      }\r\n\r\n      for (const keyName of Object.getOwnPropertyNames(pattern)) {\r\n        let subPath: string;\r\n        if (/^[a-z_][a-z0-9_]*$/i.test(keyName)) {\r\n          subPath = path + '.' + keyName;\r\n        } else {\r\n          subPath = path + '[' + JSON.stringify(keyName) + ']';\r\n        }\r\n\r\n        if (!Object.hasOwnProperty.call(root, keyName)) {\r\n          captures.failPath = subPath;\r\n          return false;\r\n        }\r\n        if (!TreePattern._matchTreeRecursive(root[keyName], pattern[keyName], captures, subPath)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    if (root !== pattern) {\r\n      captures.failPath = path;\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n"]}