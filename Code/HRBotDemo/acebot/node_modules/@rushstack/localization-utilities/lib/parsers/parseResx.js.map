{"version":3,"file":"parseResx.js","sourceRoot":"","sources":["../../src/parsers/parseResx.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { type ITerminal, Text, type NewlineKind } from '@rushstack/node-core-library';\nimport { XmlDocument, type XmlElement } from 'xmldoc';\n\nimport type { ILocalizedString, ILocalizationFile, IParseFileOptions } from '../interfaces';\n\n/**\n * @public\n */\nexport interface IParseResxOptions extends IParseFileOptions, IParseResxOptionsBase {}\n\n/**\n * @public\n */\nexport interface IParseResxOptionsBase {\n  terminal: ITerminal;\n  resxNewlineNormalization: NewlineKind | undefined;\n  ignoreMissingResxComments: boolean | undefined;\n}\n\ninterface ILoggingFunctions {\n  logError: (message: string) => void;\n  logWarning: (message: string) => void;\n  logFileError: (message: string, filePath: string, line?: number, position?: number) => void;\n  logFileWarning: (message: string, filePath: string, line?: number, position?: number) => void;\n}\n\ninterface IResxReaderOptionsInternal extends Omit<IParseResxOptions, 'terminal'> {\n  loggingFunctions: ILoggingFunctions;\n}\n\n/**\n * @public\n */\nexport function parseResx(options: IParseResxOptions): ILocalizationFile {\n  const writeError: (message: string) => void = options.terminal.writeErrorLine.bind(options.terminal);\n  const writeWarning: (message: string) => void = options.terminal.writeWarningLine.bind(options.terminal);\n  const loggingFunctions: ILoggingFunctions = {\n    logError: (message: string) => writeError(message),\n    logWarning: (message: string) => writeWarning(message),\n    logFileError: (message: string, filePath: string, line?: number, position?: number) => {\n      _logWithLocation(writeError, message, filePath, line, position);\n    },\n    logFileWarning: (message: string, filePath: string, line?: number, position?: number) => {\n      _logWithLocation(writeWarning, message, filePath, line, position);\n    }\n  };\n\n  return _readResxAsLocFileInternal({\n    ...options,\n    loggingFunctions\n  });\n}\n\nfunction _readResxAsLocFileInternal(options: IResxReaderOptionsInternal): ILocalizationFile {\n  const { ignoreString } = options;\n  const xmlDocument: XmlDocument = new XmlDocument(options.content);\n\n  if (xmlDocument.name !== 'root') {\n    _logErrorWithLocation(\n      options,\n      `Expected RESX to have a \"root\" element, found \"${xmlDocument.name}\"`,\n      xmlDocument\n    );\n  }\n\n  const locFile: ILocalizationFile = {};\n\n  for (const childNode of xmlDocument.children) {\n    switch (childNode.type) {\n      case 'element': {\n        switch (childNode.name) {\n          case 'data': {\n            const stringName: string = childNode.attr.name;\n            if (!stringName) {\n              _logErrorWithLocation(options, 'Unexpected missing or empty string name', childNode);\n            } else {\n              if (locFile.hasOwnProperty(stringName)) {\n                _logErrorWithLocation(options, `Duplicate string value \"${stringName}\"`, childNode);\n              }\n\n              const locString: ILocalizedString | undefined = _readDataElement(options, childNode);\n\n              if (locString && !ignoreString?.(options.filePath, stringName)) {\n                locFile[stringName] = locString;\n              }\n            }\n\n            break;\n          }\n\n          // Other allowed elements\n          case 'xsd:schema':\n          case 'resheader':\n            break;\n\n          default:\n            _logErrorWithLocation(options, `Unexpected RESX element ${childNode.name}`, childNode);\n        }\n\n        break;\n      }\n\n      case 'text': {\n        if (childNode.text.trim() !== '') {\n          _logErrorWithLocation(options, 'Found unexpected non-empty text node in RESX');\n        }\n\n        break;\n      }\n\n      case 'comment':\n        break;\n\n      default:\n        _logErrorWithLocation(options, `Unexpected ${childNode.type} child in RESX`);\n        break;\n    }\n  }\n\n  return locFile;\n}\n\nfunction _readDataElement(\n  options: IResxReaderOptionsInternal,\n  dataElement: XmlElement\n): ILocalizedString | undefined {\n  let foundCommentElement: boolean = false;\n  let foundValueElement: boolean = false;\n  let comment: string | undefined = undefined;\n  let value: string | undefined = undefined;\n\n  for (const childNode of dataElement.children) {\n    switch (childNode.type) {\n      case 'element': {\n        switch (childNode.name) {\n          case 'value': {\n            if (foundValueElement) {\n              _logErrorWithLocation(options, 'Duplicate <value> element found', childNode);\n            } else {\n              foundValueElement = true;\n              value = _readTextElement(options, childNode);\n              if (value && options.resxNewlineNormalization) {\n                value = Text.convertTo(value, options.resxNewlineNormalization);\n              }\n            }\n\n            break;\n          }\n\n          case 'comment': {\n            if (foundCommentElement) {\n              _logErrorWithLocation(options, 'Duplicate <comment> element found', childNode);\n            } else {\n              foundCommentElement = true;\n              comment = _readTextElement(options, childNode);\n            }\n\n            break;\n          }\n\n          default:\n            _logErrorWithLocation(options, `Unexpected RESX element ${childNode.name}`, childNode);\n            break;\n        }\n\n        break;\n      }\n\n      case 'text': {\n        if (childNode.text.trim() !== '') {\n          _logErrorWithLocation(\n            options,\n            'Found unexpected non-empty text node in RESX <data> element',\n            dataElement\n          );\n        }\n\n        break;\n      }\n\n      case 'comment':\n        break;\n\n      default:\n        _logErrorWithLocation(\n          options,\n          `Unexpected ${childNode.type} child in RESX <data> element`,\n          dataElement\n        );\n    }\n  }\n\n  if (!foundValueElement) {\n    _logErrorWithLocation(options, 'Missing string value in <data> element', dataElement);\n  } else {\n    if (comment === undefined && options.ignoreMissingResxComments === false) {\n      _logWarningWithLocation(options, 'Missing string comment in <data> element', dataElement);\n    }\n\n    return {\n      value: value || '',\n      comment\n    };\n  }\n}\n\nfunction _readTextElement(options: IResxReaderOptionsInternal, element: XmlElement): string | undefined {\n  let foundText: string | undefined = undefined;\n\n  for (const childNode of element.children) {\n    switch (childNode.type) {\n      case 'cdata':\n      case 'text': {\n        if (foundText !== undefined) {\n          _logErrorWithLocation(options, 'More than one child node found containing text content', element);\n          break;\n        }\n\n        foundText = childNode.type === 'text' ? childNode.text : childNode.cdata;\n        break;\n      }\n\n      case 'comment':\n        break;\n\n      case 'element':\n        _logErrorWithLocation(options, `Unexpected element`, childNode);\n        break;\n\n      default:\n        _logErrorWithLocation(options, `Unexpected ${element.type} child`, element);\n        break;\n    }\n  }\n\n  return foundText;\n}\n\nfunction _logErrorWithLocation(\n  options: IResxReaderOptionsInternal,\n  message: string,\n  element?: XmlElement | XmlDocument\n): void {\n  if (element) {\n    options.loggingFunctions.logFileError(message, options.filePath, element.line + 1, element.column + 1);\n  } else {\n    options.loggingFunctions.logFileError(message, options.filePath);\n  }\n}\n\nfunction _logWarningWithLocation(\n  options: IResxReaderOptionsInternal,\n  message: string,\n  element?: XmlElement | XmlDocument\n): void {\n  if (element) {\n    options.loggingFunctions.logFileWarning(message, options.filePath, element.line + 1, element.column + 1);\n  } else {\n    options.loggingFunctions.logFileWarning(message, options.filePath);\n  }\n}\n\nfunction _logWithLocation(\n  loggingFn: (message: string) => void,\n  message: string,\n  filePath: string,\n  line?: number,\n  position?: number\n): void {\n  let location: string;\n  if (position !== undefined) {\n    location = `${filePath}(${line},${position})`;\n  } else if (line !== undefined) {\n    location = `${filePath}(${line})`;\n  } else {\n    location = filePath;\n  }\n\n  loggingFn(`${location}: ${message}`);\n}\n"]}