"use strict";
exports.id = "LinkManagerFactory";
exports.ids = ["LinkManagerFactory"];
exports.modules = {

/***/ 662116:
/*!************************************************!*\
  !*** ./lib-esnext/logic/LinkManagerFactory.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkManagerFactory": () => (/* binding */ LinkManagerFactory)
/* harmony export */ });
/* harmony import */ var _npm_NpmLinkManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./npm/NpmLinkManager */ 671285);
/* harmony import */ var _pnpm_PnpmLinkManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pnpm/PnpmLinkManager */ 699058);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class LinkManagerFactory {
    static getLinkManager(rushConfiguration) {
        switch (rushConfiguration.packageManager) {
            case 'npm':
                return new _npm_NpmLinkManager__WEBPACK_IMPORTED_MODULE_0__.NpmLinkManager(rushConfiguration);
            case 'pnpm':
                return new _pnpm_PnpmLinkManager__WEBPACK_IMPORTED_MODULE_1__.PnpmLinkManager(rushConfiguration);
            case 'yarn':
                // Yarn uses the same node_modules structure as NPM
                return new _npm_NpmLinkManager__WEBPACK_IMPORTED_MODULE_0__.NpmLinkManager(rushConfiguration);
            default:
                throw new Error(`Unsupported package manager: ${rushConfiguration.packageManager}`);
        }
    }
}
//# sourceMappingURL=LinkManagerFactory.js.map

/***/ }),

/***/ 748432:
/*!*******************************************!*\
  !*** ./lib-esnext/logic/PackageLookup.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackageLookup": () => (/* binding */ PackageLookup)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
class PackageLookup {
    constructor() {
        this._packageMap = new Map();
    }
    loadTree(root) {
        const queue = [root];
        // We want the lookup to return the shallowest match, so this is a breadth first
        // traversal
        for (;;) {
            const current = queue.shift();
            if (!current) {
                break;
            }
            for (const child of current.children) {
                queue.push(child);
            }
            const key = current.nameAndVersion;
            if (!this._packageMap.has(key)) {
                this._packageMap.set(key, current);
            }
        }
    }
    getPackage(nameAndVersion) {
        return this._packageMap.get(nameAndVersion);
    }
}
//# sourceMappingURL=PackageLookup.js.map

/***/ }),

/***/ 826636:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/base/BaseLinkManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseLinkManager": () => (/* binding */ BaseLinkManager),
/* harmony export */   "SymlinkKind": () => (/* binding */ SymlinkKind)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 314318);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.







var SymlinkKind;
(function (SymlinkKind) {
    SymlinkKind[SymlinkKind["File"] = 0] = "File";
    SymlinkKind[SymlinkKind["Directory"] = 1] = "Directory";
})(SymlinkKind || (SymlinkKind = {}));
class BaseLinkManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    static _createSymlink(options) {
        const newLinkFolder = path__WEBPACK_IMPORTED_MODULE_1__.dirname(options.newLinkPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.ensureFolder(newLinkFolder);
        let targetPath;
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfiguration.absoluteSymlinks) {
            targetPath = options.linkTargetPath;
        }
        else {
            // Link to the relative path, to avoid going outside containers such as a Docker image
            targetPath = path__WEBPACK_IMPORTED_MODULE_1__.relative(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);
        }
        if (process.platform === 'win32') {
            if (options.symlinkKind === SymlinkKind.Directory) {
                // For directories, we use a Windows "junction".  On Unix, this produces a regular symlink.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.createSymbolicLinkJunction({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                // For files, we use a Windows "hard link", because creating a symbolic link requires
                // administrator permission.
                // NOTE: We cannot use the relative path for hard links
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.createHardLink({
                    linkTargetPath: options.linkTargetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
        else {
            // However hard links seem to cause build failures on Mac, so for all other operating systems
            // we use symbolic links for this case.
            if (options.symlinkKind === SymlinkKind.Directory) {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.createSymbolicLinkFolder({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.createSymbolicLinkFile({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
    }
    /**
     * For a Package object that represents a top-level Rush project folder
     * (i.e. with source code that we will be building), this clears out its
     * node_modules folder and then recursively creates all the symlinked folders.
     */
    static _createSymlinksForTopLevelProject(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(localPackage.folderPath, 'node_modules');
        // Sanity check
        if (localPackage.parent) {
            throw new Error('The provided package is not a top-level project');
        }
        // The root-level folder is the project itself, so we simply delete its node_modules
        // to start clean
        // eslint-disable-next-line no-console
        console.log('Purging ' + localModuleFolder);
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.dangerouslyDeletePath(localModuleFolder);
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * This is a helper function used by createSymlinksForTopLevelProject().
     * It will recursively creates symlinked folders corresponding to each of the
     * Package objects in the provided tree.
     */
    static _createSymlinksForDependencies(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(localPackage.folderPath, 'node_modules');
        if (!localPackage.symlinkTargetFolderPath) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.InternalError('localPackage.symlinkTargetFolderPath was not assigned');
        }
        // This is special case for when localPackage.name has the form '@scope/name',
        // in which case we need to create the '@scope' folder first.
        const parentFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.dirname(localPackage.folderPath);
        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.exists(parentFolderPath)) {
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(parentFolderPath);
            }
        }
        if (localPackage.children.length === 0) {
            // If there are no children, then we can symlink the entire folder
            BaseLinkManager._createSymlink({
                linkTargetPath: localPackage.symlinkTargetFolderPath,
                newLinkPath: localPackage.folderPath,
                symlinkKind: SymlinkKind.Directory
            });
        }
        else {
            // If there are children, then we need to symlink each item in the folder individually
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localPackage.folderPath);
            for (const filename of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {
                if (filename.toLowerCase() !== 'node_modules') {
                    // Create the symlink
                    let symlinkKind = SymlinkKind.File;
                    const linkSource = path__WEBPACK_IMPORTED_MODULE_1__.join(localPackage.folderPath, filename);
                    let linkTarget = path__WEBPACK_IMPORTED_MODULE_1__.join(localPackage.symlinkTargetFolderPath, filename);
                    const linkStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getLinkStatistics(linkTarget);
                    if (linkStats.isSymbolicLink()) {
                        const targetStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getStatistics(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getRealPath(linkTarget));
                        if (targetStats.isDirectory()) {
                            // Neither a junction nor a directory-symlink can have a directory-symlink
                            // as its target; instead, we must obtain the real physical path.
                            // A junction can link to another junction.  Unfortunately, the node 'fs' API
                            // lacks the ability to distinguish between a junction and a directory-symlink
                            // (even though it has the ability to create them both), so the safest policy
                            // is to always make a junction and always to the real physical path.
                            linkTarget = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getRealPath(linkTarget);
                            symlinkKind = SymlinkKind.Directory;
                        }
                    }
                    else if (linkStats.isDirectory()) {
                        symlinkKind = SymlinkKind.Directory;
                    }
                    BaseLinkManager._createSymlink({
                        linkTargetPath: linkTarget,
                        newLinkPath: linkSource,
                        symlinkKind
                    });
                }
            }
        }
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.
     * @param force - Normally the operation will be skipped if the links are already up to date;
     *   if true, this option forces the links to be recreated.
     */
    async createSymlinksForProjects(force) {
        // eslint-disable-next-line no-console
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Linking local projects'));
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__.Stopwatch.start();
        await this._linkProjects();
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_6__.LastLinkFlagFactory.getCommonTempFlag(this._rushConfiguration).create();
        stopwatch.stop();
        // eslint-disable-next-line no-console
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green(`Linking finished successfully. (${stopwatch.toString()})`));
        // eslint-disable-next-line no-console
        console.log('\nNext you should probably run "rush build" or "rush rebuild"');
    }
}
//# sourceMappingURL=BaseLinkManager.js.map

/***/ }),

/***/ 22978:
/*!**********************************************!*\
  !*** ./lib-esnext/logic/base/BasePackage.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasePackage": () => (/* binding */ BasePackage),
/* harmony export */   "PackageDependencyKind": () => (/* binding */ PackageDependencyKind)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * The type of dependency; used by IPackageDependency.
 */
var PackageDependencyKind;
(function (PackageDependencyKind) {
    PackageDependencyKind[PackageDependencyKind["Normal"] = 0] = "Normal";
    /**
     * The dependency was listed in the optionalDependencies section of package.json.
     */
    PackageDependencyKind[PackageDependencyKind["Optional"] = 1] = "Optional";
    /**
     * The dependency should be a symlink to a project that is locally built by Rush..
     */
    PackageDependencyKind[PackageDependencyKind["LocalLink"] = 2] = "LocalLink";
})(PackageDependencyKind || (PackageDependencyKind = {}));
/**
 * Represents an NPM package being processed by the linking algorithm.
 */
class BasePackage {
    constructor(name, version, folderPath, packageJson) {
        /**
         * If this is a local path that we are planning to symlink to a target folder,
         * then symlinkTargetFolderPath keeps track of the intended target.
         */
        this.symlinkTargetFolderPath = undefined;
        this.name = name;
        this.packageJson = packageJson;
        this.version = version;
        this.folderPath = folderPath;
        // Extract `@alias-scope/alias-name` from  `C:\node_modules\@alias-scope\alias-name`
        const pathParts = folderPath.split(/[\\\/]/);
        this.installedName = pathParts[pathParts.length - 1];
        if (pathParts.length >= 2) {
            // Is there an NPM scope?
            const parentFolder = pathParts[pathParts.length - 2];
            if (parentFolder[0] === '@') {
                this.installedName = parentFolder + '/' + this.installedName;
            }
        }
        this.children = [];
        this._childrenByName = new Map();
    }
    /**
     * Used by link managers, creates a virtual Package object that represents symbolic links
     * which will be created later
     */
    static createLinkedPackage(name, version, folderPath, packageJson) {
        return new BasePackage(name, version, folderPath, packageJson);
    }
    /**
     * Used by "npm link" to simulate a temp project that is missing from the common/node_modules
     * folder (e.g. because it was added after the shrinkwrap file was regenerated).
     * @param packageJsonFilename - Filename of the source package.json
     *        Example: `C:\MyRepo\common\temp\projects\project1\package.json`
     * @param targetFolderName - Filename where it should have been installed
     *        Example: `C:\MyRepo\common\temp\node_modules\@rush-temp\project1`
     */
    static createVirtualTempPackage(packageJsonFilename, installFolderName) {
        const packageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.JsonFile.load(packageJsonFilename);
        return BasePackage.createLinkedPackage(packageJson.name, packageJson.version, installFolderName, packageJson);
    }
    get nameAndVersion() {
        let result = '';
        if (this.name) {
            result += this.name;
        }
        else {
            result += '(missing name)';
        }
        result += '@';
        if (this.version) {
            result += this.version;
        }
        else {
            result += '(missing version)';
        }
        return result;
    }
    addChild(child) {
        if (child.parent) {
            throw new Error('Child already has a parent');
        }
        if (this._childrenByName.has(child.installedName)) {
            throw new Error(`Child already exists: ${child.installedName}`);
        }
        child.parent = this;
        this.children.push(child);
        this._childrenByName.set(child.installedName, child);
    }
    getChildByName(childPackageName) {
        return this._childrenByName.get(childPackageName);
    }
    printTree(indent) {
        if (!indent) {
            indent = '';
        }
        // eslint-disable-next-line no-console
        console.log(indent + this.nameAndVersion);
        for (const child of this.children) {
            child.printTree(indent + '  ');
        }
    }
}
//# sourceMappingURL=BasePackage.js.map

/***/ }),

/***/ 671285:
/*!************************************************!*\
  !*** ./lib-esnext/logic/npm/NpmLinkManager.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmLinkManager": () => (/* binding */ NpmLinkManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tar */ 827193);
/* harmony import */ var tar__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(tar__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var read_package_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! read-package-tree */ 5745);
/* harmony import */ var read_package_tree__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(read_package_tree__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _NpmPackage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./NpmPackage */ 976860);
/* harmony import */ var _PackageLookup__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../PackageLookup */ 748432);
/* harmony import */ var _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/BaseLinkManager */ 826636);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.











class NpmLinkManager extends _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_6__.BaseLinkManager {
    async _linkProjects() {
        const npmPackage = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.LegacyAdapters.convertCallbackToPromise((read_package_tree__WEBPACK_IMPORTED_MODULE_4___default()), this._rushConfiguration.commonTempFolder);
        const commonRootPackage = _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.NpmPackage.createFromNpm(npmPackage);
        const commonPackageLookup = new _PackageLookup__WEBPACK_IMPORTED_MODULE_8__.PackageLookup();
        commonPackageLookup.loadTree(commonRootPackage);
        for (const rushProject of this._rushConfiguration.projects) {
            // eslint-disable-next-line no-console
            console.log(`\nLINKING: ${rushProject.packageName}`);
            this._linkProject(rushProject, commonRootPackage, commonPackageLookup);
        }
    }
    /**
     * This is called once for each local project from Rush.json.
     * @param project             The local project that we will create symlinks for
     * @param commonRootPackage   The common/temp/package.json package
     * @param commonPackageLookup A dictionary for finding packages under common/temp/node_modules
     */
    _linkProject(project, commonRootPackage, commonPackageLookup) {
        let commonProjectPackage = commonRootPackage.getChildByName(project.tempProjectName);
        if (!commonProjectPackage) {
            // Normally we would expect the temp project to have been installed into the common\node_modules
            // folder.  However, if it was recently added, "rush install" doesn't technically require
            // this, as long as its dependencies can be found at the root of the NPM shrinkwrap file.
            // This avoids the need to run "rush generate" unnecessarily.
            // Example: "project1"
            const unscopedTempProjectName = this._rushConfiguration.packageNameParser.getUnscopedName(project.tempProjectName);
            // Example: "C:\MyRepo\common\temp\projects\project1
            const extractedFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);
            // Example: "C:\MyRepo\common\temp\projects\project1.tgz"
            const tarballFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.rushTempProjectsFolderName, unscopedTempProjectName + '.tgz');
            // Example: "C:\MyRepo\common\temp\projects\project1\package.json"
            const packageJsonFilename = path__WEBPACK_IMPORTED_MODULE_1__.join(extractedFolder, 'package', _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileConstants.PackageJson);
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_10__.Utilities.createFolderWithRetry(extractedFolder);
            tar__WEBPACK_IMPORTED_MODULE_3__.extract({
                cwd: extractedFolder,
                file: tarballFile,
                sync: true
            });
            // Example: "C:\MyRepo\common\temp\node_modules\@rush-temp\project1"
            const installFolderName = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.rushTempNpmScope, unscopedTempProjectName);
            commonProjectPackage = _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.NpmPackage.createVirtualTempPackage(packageJsonFilename, installFolderName);
            // remove the extracted tarball contents
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.deleteFile(packageJsonFilename);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.deleteFile(extractedFolder);
            commonRootPackage.addChild(commonProjectPackage);
        }
        // TODO: Validate that the project's package.json still matches the common folder
        const localProjectPackage = _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.NpmPackage.createLinkedNpmPackage(project.packageJsonEditor.name, commonProjectPackage.version, commonProjectPackage.dependencies, project.projectFolder);
        const queue = [];
        queue.push({
            commonPackage: commonProjectPackage,
            localPackage: localProjectPackage,
            cyclicSubtreeRoot: undefined
        });
        for (;;) {
            const queueItem = queue.shift();
            if (!queueItem) {
                break;
            }
            // A project from somewhere under "common/temp/node_modules"
            const commonPackage = queueItem.commonPackage;
            // A symlinked virtual package somewhere under "this-project/node_modules",
            // where "this-project" corresponds to the "project" parameter for linkProject().
            const localPackage = queueItem.localPackage;
            // If we encounter a dependency listed in decoupledLocalDependencies, this will be set to the root
            // of the localPackage subtree where we will stop creating local links.
            const cyclicSubtreeRoot = queueItem.cyclicSubtreeRoot;
            // NOTE: It's important that this traversal follows the dependencies in the Common folder,
            // because for Rush projects this will be the union of
            // devDependencies / dependencies / optionalDependencies.
            for (const dependency of commonPackage.dependencies) {
                let startingCyclicSubtree = false;
                // Should this be a "local link" to a top-level Rush project (i.e. versus a regular link
                // into the Common folder)?
                const matchedRushPackage = this._rushConfiguration.getProjectByName(dependency.name);
                if (matchedRushPackage) {
                    const matchedVersion = matchedRushPackage.packageJsonEditor.version;
                    // The dependency name matches an Rush project, but are there any other reasons not
                    // to create a local link?
                    if (cyclicSubtreeRoot) {
                        // DO NOT create a local link, because this is part of an existing
                        // decoupledLocalDependencies subtree
                    }
                    else if (project.decoupledLocalDependencies.has(dependency.name)) {
                        // DO NOT create a local link, because we are starting a new
                        // decoupledLocalDependencies subtree
                        startingCyclicSubtree = true;
                    }
                    else if (dependency.kind !== _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.PackageDependencyKind.LocalLink &&
                        !semver__WEBPACK_IMPORTED_MODULE_2__.satisfies(matchedVersion, dependency.versionRange)) {
                        // DO NOT create a local link, because the local project's version isn't SemVer compatible.
                        // (Note that in order to make version bumping work as expected, we ignore SemVer for
                        // immediate dependencies of top-level projects, indicated by PackageDependencyKind.LocalLink.
                        // Is this wise?)
                        // eslint-disable-next-line no-console
                        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Rush will not locally link ${dependency.name} for ${localPackage.name}` +
                            ` because the requested version "${dependency.versionRange}" is incompatible` +
                            ` with the local version ${matchedVersion}`));
                    }
                    else {
                        // Yes, it is compatible, so create a symlink to the Rush project.
                        // Is the dependency already resolved?
                        const resolution = localPackage.resolveOrCreate(dependency.name);
                        if (!resolution.found || resolution.found.version !== matchedVersion) {
                            // We did not find a suitable match, so place a new local package that
                            // symlinks to the Rush project
                            const newLocalFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.join(resolution.parentForCreate.folderPath, 'node_modules', dependency.name);
                            const newLocalPackage = _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.NpmPackage.createLinkedNpmPackage(dependency.name, matchedVersion, 
                            // Since matchingRushProject does not have a parent, its dependencies are
                            // guaranteed to be already fully resolved inside its node_modules folder.
                            [], newLocalFolderPath);
                            newLocalPackage.symlinkTargetFolderPath = matchedRushPackage.projectFolder;
                            resolution.parentForCreate.addChild(newLocalPackage);
                            // (There are no dependencies, so we do not need to push it onto the queue.)
                        }
                        continue;
                    }
                }
                // We can't symlink to an Rush project, so instead we will symlink to a folder
                // under the "Common" folder
                const commonDependencyPackage = commonPackage.resolve(dependency.name);
                if (commonDependencyPackage) {
                    // This is the version that was chosen when "npm install" ran in the common folder
                    const effectiveDependencyVersion = commonDependencyPackage.version;
                    // Is the dependency already resolved?
                    let resolution;
                    if (!cyclicSubtreeRoot || !matchedRushPackage) {
                        // Perform normal module resolution.
                        resolution = localPackage.resolveOrCreate(dependency.name);
                    }
                    else {
                        // We are inside a decoupledLocalDependencies subtree (i.e. cyclicSubtreeRoot != undefined),
                        // and the dependency is a local project (i.e. matchedRushPackage != undefined), so
                        // we use a special module resolution strategy that places everything under the
                        // cyclicSubtreeRoot.
                        resolution = localPackage.resolveOrCreate(dependency.name, cyclicSubtreeRoot);
                    }
                    if (!resolution.found || resolution.found.version !== effectiveDependencyVersion) {
                        // We did not find a suitable match, so place a new local package
                        const newLocalFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.join(resolution.parentForCreate.folderPath, 'node_modules', commonDependencyPackage.name);
                        const newLocalPackage = _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.NpmPackage.createLinkedNpmPackage(commonDependencyPackage.name, commonDependencyPackage.version, commonDependencyPackage.dependencies, newLocalFolderPath);
                        const commonPackageFromLookup = commonPackageLookup.getPackage(newLocalPackage.nameAndVersion);
                        if (!commonPackageFromLookup) {
                            throw new Error(`The ${localPackage.name}@${localPackage.version} package was not found` +
                                ` in the common folder`);
                        }
                        newLocalPackage.symlinkTargetFolderPath = commonPackageFromLookup.folderPath;
                        let newCyclicSubtreeRoot = cyclicSubtreeRoot;
                        if (startingCyclicSubtree) {
                            // If we are starting a new subtree, then newLocalPackage will be its root
                            // NOTE: cyclicSubtreeRoot is guaranteed to be undefined here, since we never start
                            // a new tree inside an existing tree
                            newCyclicSubtreeRoot = newLocalPackage;
                        }
                        resolution.parentForCreate.addChild(newLocalPackage);
                        queue.push({
                            commonPackage: commonDependencyPackage,
                            localPackage: newLocalPackage,
                            cyclicSubtreeRoot: newCyclicSubtreeRoot
                        });
                    }
                }
                else {
                    if (dependency.kind !== _NpmPackage__WEBPACK_IMPORTED_MODULE_7__.PackageDependencyKind.Optional) {
                        throw new Error(`The dependency "${dependency.name}" needed by "${localPackage.name}"` +
                            ` was not found in the common folder -- do you need to run "rush install"?`);
                    }
                    else {
                        // eslint-disable-next-line no-console
                        console.log('Skipping optional dependency: ' + dependency.name);
                    }
                }
            }
        }
        // When debugging, you can uncomment this line to dump the data structure
        // to the console:
        // localProjectPackage.printTree();
        NpmLinkManager._createSymlinksForTopLevelProject(localProjectPackage);
        // Also symlink the ".bin" folder
        if (localProjectPackage.children.length > 0) {
            const commonBinFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, 'node_modules', '.bin');
            const projectBinFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(localProjectPackage.folderPath, 'node_modules', '.bin');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.exists(commonBinFolder)) {
                NpmLinkManager._createSymlink({
                    linkTargetPath: commonBinFolder,
                    newLinkPath: projectBinFolder,
                    symlinkKind: _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_6__.SymlinkKind.Directory
                });
            }
        }
    }
}
//# sourceMappingURL=NpmLinkManager.js.map

/***/ }),

/***/ 976860:
/*!********************************************!*\
  !*** ./lib-esnext/logic/npm/NpmPackage.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmPackage": () => (/* binding */ NpmPackage),
/* harmony export */   "PackageDependencyKind": () => (/* binding */ PackageDependencyKind)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _base_BasePackage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/BasePackage */ 22978);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * The type of dependency; used by IPackageDependency.
 */
var PackageDependencyKind;
(function (PackageDependencyKind) {
    PackageDependencyKind[PackageDependencyKind["Normal"] = 0] = "Normal";
    /**
     * The dependency was listed in the optionalDependencies section of package.json.
     */
    PackageDependencyKind[PackageDependencyKind["Optional"] = 1] = "Optional";
    /**
     * The dependency should be a symlink to a project that is locally built by Rush..
     */
    PackageDependencyKind[PackageDependencyKind["LocalLink"] = 2] = "LocalLink";
})(PackageDependencyKind || (PackageDependencyKind = {}));
class NpmPackage extends _base_BasePackage__WEBPACK_IMPORTED_MODULE_2__.BasePackage {
    constructor(name, version, dependencies, folderPath) {
        super(name, version, folderPath, undefined);
        this.dependencies = dependencies.slice(0); // clone the array
        this.parent = undefined;
    }
    /**
     * Used by "npm link" when creating a Package object that represents symbolic links to be created.
     */
    static createLinkedNpmPackage(name, version, dependencies, folderPath) {
        return new NpmPackage(name, version, dependencies, folderPath);
    }
    /**
     * Used by "npm link" to simulate a temp project that is missing from the common/node_modules
     * folder (e.g. because it was added after the shrinkwrap file was regenerated).
     * @param packageJsonFilename - Filename of the source package.json
     *        Example: `C:\MyRepo\common\temp\projects\project1\package.json`
     * @param targetFolderName - Filename where it should have been installed
     *        Example: `C:\MyRepo\common\temp\node_modules\@rush-temp\project1`
     */
    static createVirtualTempPackage(packageJsonFilename, installFolderName) {
        const packageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.JsonFile.load(packageJsonFilename);
        const npmPackage = {
            children: [],
            error: null,
            id: 0,
            isLink: false,
            package: packageJson,
            parent: null,
            path: installFolderName,
            realpath: installFolderName
        };
        return NpmPackage.createFromNpm(npmPackage);
    }
    /**
     * Recursive constructs a tree of NpmPackage objects using information returned
     * by the "read-package-tree" library.
     */
    static createFromNpm(npmPackage) {
        if (npmPackage.error) {
            throw new Error(`Failed to parse package.json for ${path__WEBPACK_IMPORTED_MODULE_0__.basename(npmPackage.path)}: ${npmPackage.error.message}`);
        }
        let dependencies = [];
        const dependencyNames = new Set();
        const packageJson = npmPackage.package;
        if (packageJson.optionalDependencies) {
            for (const dependencyName of Object.keys(packageJson.optionalDependencies)) {
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.optionalDependencies[dependencyName],
                        kind: PackageDependencyKind.Optional
                    });
                }
            }
        }
        if (packageJson.dependencies) {
            for (const dependencyName of Object.keys(packageJson.dependencies)) {
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.dependencies[dependencyName],
                        kind: PackageDependencyKind.Normal
                    });
                }
            }
        }
        if (packageJson.rushDependencies) {
            for (const dependencyName of Object.keys(packageJson.rushDependencies)) {
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.dependencies[dependencyName],
                        kind: PackageDependencyKind.LocalLink
                    });
                }
            }
        }
        dependencies = dependencies.sort((a, b) => a.name.localeCompare(b.name));
        const newPackage = new NpmPackage(npmPackage.package.name, npmPackage.package.version, dependencies, 
        // NOTE: We don't use packageNode.realpath here, because if "npm unlink" was
        // performed without redoing "rush link", then a broken symlink is better than
        // a symlink to the wrong thing.
        npmPackage.path);
        for (const child of npmPackage.children) {
            newPackage.addChild(NpmPackage.createFromNpm(child));
        }
        return newPackage;
    }
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  Note that the nearest match may have an incompatible version.
     * If a match is found, then the "found" result will not be undefined.
     * In either case, the parentForCreate result indicates where the missing
     * dependency can be added, i.e. if the requested dependency was not found
     * or was found with an incompatible version.
     *
     * "cyclicSubtreeRoot" is a special optional parameter that specifies a different
     * root for the tree; the decoupledLocalDependencies feature uses this to isolate
     * certain devDependencies in their own subtree.
     */
    resolveOrCreate(dependencyName, cyclicSubtreeRoot) {
        let currentParent = this;
        let parentForCreate = undefined;
        for (;;) {
            // Does any child match?
            for (const child of currentParent.children) {
                // The package.json name can differ from the installation folder name, in the case of an NPM package alias
                // such as this:
                //
                // "dependencies": {
                //   "@alias-scope/alias-name": "npm:target-name@^1.2.3"
                // }
                //
                // Thus we need to compare child.installedName instead of child.name:
                if (child.installedName === dependencyName) {
                    // One of the children matched.  Note that parentForCreate may be
                    // undefined, e.g. if an immediate child is found but has the wrong version,
                    // then we have no place in the tree to create another version.
                    return { found: child, parentForCreate };
                }
            }
            // If no child matched, then make this node the "parentForCreate" where we
            // could add a missing dependency.
            parentForCreate = currentParent;
            if (!currentParent.parent || (cyclicSubtreeRoot && currentParent === cyclicSubtreeRoot)) {
                // We reached the root without finding a match
                // parentForCreate will be the root.
                return { found: undefined, parentForCreate };
            }
            // Continue walking upwards.
            currentParent = currentParent.parent;
        }
    }
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  If no match is found, then undefined is returned.
     */
    resolve(dependencyName) {
        return this.resolveOrCreate(dependencyName).found;
    }
}
//# sourceMappingURL=NpmPackage.js.map

/***/ }),

/***/ 699058:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmLinkManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmLinkManager": () => (/* binding */ PnpmLinkManager)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strict_uri_encode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strict-uri-encode */ 120531);
/* harmony import */ var strict_uri_encode__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strict_uri_encode__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pnpm/link-bins */ 567726);
/* harmony import */ var _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_pnpm_link_bins__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/BaseLinkManager */ 826636);
/* harmony import */ var _base_BasePackage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../base/BasePackage */ 22978);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PnpmShrinkwrapFile */ 930997);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.











// special flag for debugging, will print extra diagnostic information,
// but comes with performance cost
const DEBUG = false;
class PnpmLinkManager extends _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_7__.BaseLinkManager {
    constructor() {
        super(...arguments);
        this._pnpmVersion = new semver__WEBPACK_IMPORTED_MODULE_4__.SemVer(this._rushConfiguration.packageManagerToolVersion);
    }
    /**
     * @override
     */
    async createSymlinksForProjects(force) {
        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;
        if (useWorkspaces) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_5___default().red('Linking is not supported when using workspaces. Run "rush install" or "rush update" ' +
                'to restore project node_modules folders.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.AlreadyReportedError();
        }
        await super.createSymlinksForProjects(force);
    }
    async _linkProjects() {
        if (this._rushConfiguration.projects.length > 0) {
            // Use shrinkwrap from temp as the committed shrinkwrap may not always be up to date
            // See https://github.com/microsoft/rushstack/issues/1273#issuecomment-492779995
            const pnpmShrinkwrapFile = _PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__.PnpmShrinkwrapFile.loadFromFile(this._rushConfiguration.tempShrinkwrapFilename);
            if (!pnpmShrinkwrapFile) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot load shrinkwrap at "${this._rushConfiguration.tempShrinkwrapFilename}"`);
            }
            for (const rushProject of this._rushConfiguration.projects) {
                await this._linkProject(rushProject, pnpmShrinkwrapFile);
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_5___default().yellow('\nWarning: Nothing to do. Please edit rush.json and add at least one project' +
                ' to the "projects" section.\n'));
        }
    }
    /**
     * This is called once for each local project from Rush.json.
     * @param project             The local project that we will create symlinks for
     * @param rushLinkJson        The common/temp/rush-link.json output file
     */
    async _linkProject(project, pnpmShrinkwrapFile) {
        // eslint-disable-next-line no-console
        console.log(`\nLINKING: ${project.packageName}`);
        // first, read the temp package.json information
        // Example: "project1"
        const unscopedTempProjectName = this._rushConfiguration.packageNameParser.getUnscopedName(project.tempProjectName);
        // Example: "C:\MyRepo\common\temp\projects\project1
        const extractedFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);
        // Example: "C:\MyRepo\common\temp\projects\project1\package.json"
        const packageJsonFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(extractedFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.FileConstants.PackageJson);
        // Example: "C:\MyRepo\common\temp\node_modules\@rush-temp\project1"
        const installFolderName = path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.rushTempNpmScope, unscopedTempProjectName);
        const commonPackage = _base_BasePackage__WEBPACK_IMPORTED_MODULE_10__.BasePackage.createVirtualTempPackage(packageJsonFilename, installFolderName);
        const localPackage = _base_BasePackage__WEBPACK_IMPORTED_MODULE_10__.BasePackage.createLinkedPackage(project.packageName, commonPackage.version, project.projectFolder);
        // now that we have the temp package.json, we can go ahead and link up all the direct dependencies
        // first, start with the rush dependencies, we just need to link to the project folder
        for (const dependencyName of Object.keys(commonPackage.packageJson.rushDependencies || {})) {
            const matchedRushPackage = this._rushConfiguration.getProjectByName(dependencyName);
            if (matchedRushPackage) {
                // We found a suitable match, so place a new local package that
                // symlinks to the Rush project
                const matchedVersion = matchedRushPackage.packageJsonEditor.version;
                // e.g. "C:\my-repo\project-a\node_modules\project-b" if project-b is a rush dependency of project-a
                const newLocalFolderPath = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules', dependencyName);
                const newLocalPackage = _base_BasePackage__WEBPACK_IMPORTED_MODULE_10__.BasePackage.createLinkedPackage(dependencyName, matchedVersion, newLocalFolderPath);
                newLocalPackage.symlinkTargetFolderPath = matchedRushPackage.projectFolder;
                localPackage.children.push(newLocalPackage);
            }
            else {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot find dependency "${dependencyName}" for "${project.packageName}" in the Rush configuration`);
            }
        }
        // Iterate through all the regular dependencies
        // With npm, it's possible for two different projects to have dependencies on
        // the same version of the same library, but end up with different implementations
        // of that library, if the library is installed twice and with different secondary
        // dependencies.The NpmLinkManager recursively links dependency folders to try to
        // honor this. Since PNPM always uses the same physical folder to represent a given
        // version of a library, we only need to link directly to the folder that PNPM has chosen,
        // and it will have a consistent set of secondary dependencies.
        // each of these dependencies should be linked in a special folder that pnpm
        // creates for the installed version of each .TGZ package, all we need to do
        // is re-use that symlink in order to get linked to whatever PNPM thought was
        // appropriate. This folder is usually something like:
        // C:\{uri-encoded-path-to-tgz}\node_modules\{package-name}
        // e.g.:
        //   file:projects/bentleyjs-core.tgz
        //   file:projects/build-tools.tgz_dc21d88642e18a947127a751e00b020a
        //   file:projects/imodel-from-geojson.tgz_request@2.88.0
        const tempProjectDependencyKey = pnpmShrinkwrapFile.getTempProjectDependencyKey(project.tempProjectName);
        if (!tempProjectDependencyKey) {
            throw new Error(`Cannot get dependency key for temp project: ${project.tempProjectName}`);
        }
        // e.g.: file:projects/project-name.tgz
        const tarballEntry = pnpmShrinkwrapFile.getTarballPath(tempProjectDependencyKey);
        if (!tarballEntry) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot find tarball path for "${project.tempProjectName}" in shrinkwrap.`);
        }
        // e.g.: projects\api-documenter.tgz
        const relativePathToTgzFile = tarballEntry.slice(`file:`.length);
        // e.g.: C:\wbt\common\temp\projects\api-documenter.tgz
        const absolutePathToTgzFile = path__WEBPACK_IMPORTED_MODULE_0__.resolve(this._rushConfiguration.commonTempFolder, relativePathToTgzFile);
        // The folder name in `.local` is constructed as:
        //   UriEncode(absolutePathToTgzFile) + _suffix
        //
        // Note that _suffix is not encoded. The tarball attribute of the package 'file:projects/project-name.tgz_suffix'
        // holds the tarball path 'file:projects/project-name.tgz', which can be used for the constructing the folder name.
        //
        // '_suffix' is extracted by stripping the tarball path from top level dependency value.
        // tarball path = 'file:projects/project-name.tgz'
        // top level dependency = 'file:projects/project-name.tgz_suffix'
        // e.g.:
        //   '' [empty string]
        //   _@types+node@14.18.36
        //   _jsdom@11.12.0
        //   _2a665c89609864b4e75bc5365d7f8f56
        //   (@types/node@14.18.36)
        const folderNameSuffix = tarballEntry && tarballEntry.length < tempProjectDependencyKey.length
            ? tempProjectDependencyKey.slice(tarballEntry.length)
            : '';
        // e.g.: C:\wbt\common\temp\node_modules\.local\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\node_modules
        const pathToLocalInstallation = await this._getPathToLocalInstallationAsync(tarballEntry, absolutePathToTgzFile, folderNameSuffix);
        const parentShrinkwrapEntry = pnpmShrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);
        if (!parentShrinkwrapEntry) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot find shrinkwrap entry using dependency key for temp project: ${project.tempProjectName}`);
        }
        for (const dependencyName of Object.keys(commonPackage.packageJson.dependencies || {})) {
            const newLocalPackage = this._createLocalPackageForDependency(project, parentShrinkwrapEntry, localPackage, pathToLocalInstallation, dependencyName);
            localPackage.addChild(newLocalPackage);
        }
        // TODO: Rush does not currently handle optional dependencies of projects. This should be uncommented when
        // support is added
        // for (const dependencyName of Object.keys(commonPackage.packageJson!.optionalDependencies || {})) {
        //   const newLocalPackage: BasePackage | undefined = this._createLocalPackageForDependency(
        //     project,
        //     parentShrinkwrapEntry,
        //     localPackage,
        //     pathToLocalInstallation,
        //     dependencyName,
        //     true); // isOptional
        //   if (newLocalPackage) {
        //     localPackage.addChild(newLocalPackage);
        //   }
        // }
        if (DEBUG) {
            localPackage.printTree();
        }
        await pnpmShrinkwrapFile.getProjectShrinkwrap(project).updateProjectShrinkwrapAsync();
        PnpmLinkManager._createSymlinksForTopLevelProject(localPackage);
        // Also symlink the ".bin" folder
        const projectFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules');
        const projectBinFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules', '.bin');
        await _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_3___default()(projectFolder, projectBinFolder, {
            warn: (msg) => {
                // eslint-disable-next-line no-console
                console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_5___default().yellow(msg));
            }
        });
    }
    async _getPathToLocalInstallationAsync(tarballEntry, absolutePathToTgzFile, folderSuffix) {
        if (this._pnpmVersion.major === 6) {
            // PNPM 6 changed formatting to replace all ':' and '/' chars with '+'. Additionally, folder names > 120
            // are trimmed and hashed. NOTE: PNPM internally uses fs.realpath.native, which will cause additional
            // issues in environments that do not support long paths.
            // See https://github.com/pnpm/pnpm/releases/tag/v6.0.0
            // e.g.:
            //   C++dev+imodeljs+imodeljs+common+temp+projects+presentation-integration-tests.tgz_jsdom@11.12.0
            //   C++dev+imodeljs+imodeljs+common+temp+projects+presentation-integrat_089eb799caf0f998ab34e4e1e9254956
            const specialCharRegex = /\/|:/g;
            const escapedLocalPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.Path.convertToSlashes(absolutePathToTgzFile).replace(specialCharRegex, '+');
            let folderName = `local+${escapedLocalPath}${folderSuffix}`;
            if (folderName.length > 120) {
                folderName = `${folderName.substring(0, 50)}_${crypto__WEBPACK_IMPORTED_MODULE_1__.createHash('md5')
                    .update(folderName)
                    .digest('hex')}`;
            }
            return path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, '.pnpm', folderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName);
        }
        else if (this._pnpmVersion.major >= 8) {
            const { depPathToFilename } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @pnpm/dependency-path */ 595945, 23));
            // PNPM 8 changed the local path format again and the hashing algorithm, and
            // is now using the scoped '@pnpm/dependency-path' package
            // See https://github.com/pnpm/pnpm/releases/tag/v8.0.0
            // e.g.:
            //   file+projects+presentation-integration-tests.tgz_jsdom@11.12.0
            const folderName = depPathToFilename(`${tarballEntry}${folderSuffix}`);
            return path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, '.pnpm', folderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName);
        }
        else if (this._pnpmVersion.major >= 7) {
            const { depPathToFilename } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! dependency-path */ 824957, 23));
            // PNPM 7 changed the local path format again and the hashing algorithm
            // See https://github.com/pnpm/pnpm/releases/tag/v7.0.0
            // e.g.:
            //   file+projects+presentation-integration-tests.tgz_jsdom@11.12.0
            const escapedLocalPath = depPathToFilename(tarballEntry);
            const folderName = `${escapedLocalPath}${folderSuffix}`;
            return path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, '.pnpm', folderName, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName);
        }
        else {
            // e.g.:
            //   C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz
            //   C%3A%2Fdev%2Fimodeljs%2Fimodeljs%2Fcommon%2Ftemp%2Fprojects%2Fpresentation-integration-tests.tgz_jsdom@11.12.0
            //   C%3A%2Fdev%2Fimodeljs%2Fimodeljs%2Fcommon%2Ftemp%2Fprojects%2Fbuild-tools.tgz_2a665c89609864b4e75bc5365d7f8f56
            const folderNameInLocalInstallationRoot = strict_uri_encode__WEBPACK_IMPORTED_MODULE_2___default()(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.Path.convertToSlashes(absolutePathToTgzFile)) + folderSuffix;
            // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0
            return path__WEBPACK_IMPORTED_MODULE_0__.join(this._rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName, '.pnpm', 'local', folderNameInLocalInstallationRoot, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_9__.RushConstants.nodeModulesFolderName);
        }
    }
    _createLocalPackageForDependency(project, parentShrinkwrapEntry, localPackage, pathToLocalInstallation, dependencyName, isOptional = false) {
        // the dependency we are looking for should have already created a symlink here
        // FYI dependencyName might contain an NPM scope, here it gets converted into a filesystem folder name
        // e.g. if the dependency is supi:
        // "C:\wbt\common\temp\node_modules\.local\C%3A%2Fwbt%2Fcommon%2Ftemp%2Fprojects%2Fapi-documenter.tgz\node_modules\supi"
        const dependencyLocalInstallationSymlink = path__WEBPACK_IMPORTED_MODULE_0__.join(pathToLocalInstallation, dependencyName);
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.FileSystem.exists(dependencyLocalInstallationSymlink)) {
            // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot find installed dependency "${dependencyName}" in "${pathToLocalInstallation}"`);
        }
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.FileSystem.getLinkStatistics(dependencyLocalInstallationSymlink).isSymbolicLink()) {
            // if this occurs, it is a bug in Rush algorithm or unexpected PNPM behavior
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Dependency "${dependencyName}" is not a symlink in "${pathToLocalInstallation}`);
        }
        // read the version number from the shrinkwrap entry and return if no version is specified
        // and the dependency is optional
        const versionSpecifier = isOptional
            ? (parentShrinkwrapEntry.optionalDependencies || {})[dependencyName]
            : (parentShrinkwrapEntry.dependencies || {})[dependencyName];
        if (!versionSpecifier) {
            if (!isOptional) {
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.InternalError(`Cannot find shrinkwrap entry dependency "${dependencyName}" for temp project: ` +
                    `${project.tempProjectName}`);
            }
            return;
        }
        const newLocalFolderPath = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules', dependencyName);
        const version = (0,_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_8__.normalizePnpmVersionSpecifier)(versionSpecifier);
        const newLocalPackage = _base_BasePackage__WEBPACK_IMPORTED_MODULE_10__.BasePackage.createLinkedPackage(dependencyName, version, newLocalFolderPath);
        // The dependencyLocalInstallationSymlink is just a symlink to another folder. To reduce the number of filesystem
        // reads that are needed, we will link to where that symlink pointed, rather than linking to a link.
        newLocalPackage.symlinkTargetFolderPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_6__.FileSystem.getRealPath(dependencyLocalInstallationSymlink);
        return newLocalPackage;
    }
}
//# sourceMappingURL=PnpmLinkManager.js.map

/***/ })

};
;
//# sourceMappingURL=LinkManagerFactory.js.map