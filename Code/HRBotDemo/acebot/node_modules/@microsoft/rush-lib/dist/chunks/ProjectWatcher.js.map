{"version":3,"file":"chunks/ProjectWatcher.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACyB;AACA;AACY;AACP;AAC6B;AACa;AAC5C;AACoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,gFAAgF;AAChG;AACA;AACA;AACA;AACA,4BAA4B,qCAAG;AAC/B,yBAAyB,+EAAqB,CAAC,yEAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+EAAqB;AAC9C;AACA;AACA;AACA;AACA,wCAAwC,wCAAW,kBAAkB,wCAAW;AAChF;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA,6BAA6B,+EAAqB;AAClD;AACA,aAAa;AACb;AACA;AACA,iCAAiC,+EAAqB,2BAA2B,eAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe,GAAG,YAAY,KAAK,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAQ;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,+EAAqB;AACnF,8DAA8D,KAAK,GAAG,eAAe;AACrF;AACA;AACA,6CAA6C,kFAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,+BAA+B,4CAAI;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAkB;AAC9B,YAAY,8CAAiB;AAC7B;AACA;AACA;AACA;AACA,6BAA6B,qEAAW,CAAC,qEAAW,KAAK,sCAAsC,kBAAkB,QAAQ,EAAE,wFAAwF;AACnN;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectWatcher.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as readline from 'readline';\nimport { once } from 'events';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { Colors, Path, FileSystem } from '@rushstack/node-core-library';\nimport { Git } from './Git';\nimport { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';\n/**\n * This class is for incrementally watching a set of projects in the repository for changes.\n *\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to ProjectChangeAnalyzer (which\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\n *\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\n */\nexport class ProjectWatcher {\n    constructor(options) {\n        this.isPaused = false;\n        const { debounceMs = 1000, rushConfiguration, projectsToWatch, terminal, initialState } = options;\n        this._debounceMs = debounceMs;\n        this._rushConfiguration = rushConfiguration;\n        this._projectsToWatch = projectsToWatch;\n        this._terminal = terminal;\n        const gitPath = new Git(rushConfiguration).getGitPathOrThrow();\n        this._repoRoot = Path.convertToSlashes(getRepoRoot(rushConfiguration.rushJsonFolder, gitPath));\n        this._initialState = initialState;\n        this._previousState = initialState;\n        this._hasRenderedStatus = false;\n    }\n    pause() {\n        this.isPaused = true;\n    }\n    resume() {\n        this.isPaused = false;\n        if (this._resolveIfChanged) {\n            this._resolveIfChanged().catch(() => {\n                // Suppress unhandled promise rejection error\n            });\n        }\n    }\n    /**\n     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\n     * Will return immediately the first time it is invoked, since no state has been recorded.\n     * If no change is currently present, watches the source tree of all selected projects for file changes.\n     * `waitForChange` is not allowed to be called multiple times concurrently.\n     */\n    async waitForChange(onWatchingFiles) {\n        const initialChangeResult = await this._computeChanged();\n        // Ensure that the new state is recorded so that we don't loop infinitely\n        this._commitChanges(initialChangeResult.state);\n        if (initialChangeResult.changedProjects.size) {\n            return initialChangeResult;\n        }\n        const previousState = initialChangeResult.state;\n        const repoRoot = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\n        // Map of path to whether config for the path\n        const pathsToWatch = new Map();\n        // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\n        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\n        const useNativeRecursiveWatch = os.platform() === 'win32' || os.platform() === 'darwin';\n        if (useNativeRecursiveWatch) {\n            // Watch the root non-recursively\n            pathsToWatch.set(repoRoot, { recurse: false });\n            // Watch the rush config folder non-recursively\n            pathsToWatch.set(Path.convertToSlashes(this._rushConfiguration.commonRushConfigFolder), {\n                recurse: false\n            });\n            for (const project of this._projectsToWatch) {\n                // Use recursive watch in individual project folders\n                pathsToWatch.set(Path.convertToSlashes(project.projectFolder), { recurse: true });\n            }\n        }\n        else {\n            for (const project of this._projectsToWatch) {\n                const projectState = (await previousState._tryGetProjectDependenciesAsync(project, this._terminal));\n                const prefixLength = project.projectFolder.length - repoRoot.length - 1;\n                // Watch files in the root of the project, or\n                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {\n                    pathsToWatch.set(`${this._repoRoot}/${pathToWatch}`, { recurse: true });\n                }\n            }\n        }\n        const watchers = new Map();\n        const watchedResult = await new Promise((resolve, reject) => {\n            let timeout;\n            let terminated = false;\n            const terminal = this._terminal;\n            const debounceMs = this._debounceMs;\n            this._hasRenderedStatus = false;\n            const resolveIfChanged = (this._resolveIfChanged = async () => {\n                timeout = undefined;\n                if (terminated) {\n                    return;\n                }\n                try {\n                    if (this.isPaused) {\n                        this._setStatus(`Project watcher paused.`);\n                        return;\n                    }\n                    this._setStatus(`Evaluating changes to tracked files...`);\n                    const result = await this._computeChanged();\n                    this._setStatus(`Finished analyzing.`);\n                    // Need an async tick to allow for more file system events to be handled\n                    process.nextTick(() => {\n                        if (timeout) {\n                            // If another file has changed, wait for another pass.\n                            this._setStatus(`More file changes detected, aborting.`);\n                            return;\n                        }\n                        this._commitChanges(result.state);\n                        if (result.changedProjects.size) {\n                            terminated = true;\n                            terminal.writeLine();\n                            resolve(result);\n                        }\n                        else {\n                            this._setStatus(`No changes detected to tracked files.`);\n                        }\n                    });\n                }\n                catch (err) {\n                    // eslint-disable-next-line require-atomic-updates\n                    terminated = true;\n                    terminal.writeLine();\n                    reject(err);\n                }\n            });\n            for (const [pathToWatch, { recurse }] of pathsToWatch) {\n                addWatcher(pathToWatch, recurse);\n            }\n            if (onWatchingFiles) {\n                onWatchingFiles();\n            }\n            function onError(err) {\n                if (terminated) {\n                    return;\n                }\n                terminated = true;\n                terminal.writeLine();\n                reject(err);\n            }\n            function addWatcher(watchedPath, recursive) {\n                if (watchers.has(watchedPath)) {\n                    return;\n                }\n                const listener = changeListener(watchedPath, recursive);\n                const watcher = fs.watch(watchedPath, {\n                    encoding: 'utf-8',\n                    recursive: recursive && useNativeRecursiveWatch\n                }, listener);\n                watchers.set(watchedPath, watcher);\n                watcher.on('error', (err) => {\n                    watchers.delete(watchedPath);\n                    onError(err);\n                });\n            }\n            function innerListener(root, recursive, event, fileName) {\n                try {\n                    if (terminated) {\n                        return;\n                    }\n                    if (fileName === '.git' || fileName === 'node_modules') {\n                        return;\n                    }\n                    // Handling for added directories\n                    if (recursive && !useNativeRecursiveWatch) {\n                        const decodedName = fileName ? fileName.toString() : '';\n                        const normalizedName = decodedName && Path.convertToSlashes(decodedName);\n                        const fullName = normalizedName && `${root}/${normalizedName}`;\n                        if (fullName && !watchers.has(fullName)) {\n                            try {\n                                const stat = FileSystem.getStatistics(fullName);\n                                if (stat.isDirectory()) {\n                                    addWatcher(fullName, true);\n                                }\n                            }\n                            catch (err) {\n                                const code = err.code;\n                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n                                    throw err;\n                                }\n                            }\n                        }\n                    }\n                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\n                    if (timeout) {\n                        clearTimeout(timeout);\n                    }\n                    timeout = setTimeout(resolveIfChanged, debounceMs);\n                }\n                catch (err) {\n                    terminated = true;\n                    terminal.writeLine();\n                    reject(err);\n                }\n            }\n            function changeListener(root, recursive) {\n                return innerListener.bind(0, root, recursive);\n            }\n        }).finally(() => {\n            this._resolveIfChanged = undefined;\n        });\n        const closePromises = [];\n        for (const [watchedPath, watcher] of watchers) {\n            closePromises.push(once(watcher, 'close').then(() => {\n                watchers.delete(watchedPath);\n            }));\n            watcher.close();\n        }\n        await Promise.all(closePromises);\n        return watchedResult;\n    }\n    _setStatus(status) {\n        if (this._hasRenderedStatus) {\n            readline.clearLine(process.stdout, 0);\n            readline.cursorTo(process.stdout, 0);\n        }\n        else {\n            this._hasRenderedStatus = true;\n        }\n        this._terminal.write(Colors.bold(Colors.cyan(`[${this.isPaused ? 'PAUSED' : 'WATCHING'}] Watch Status: ${status} ${this.isPaused ? 'Press <w> to resume. Press <b> to build once.' : 'Press <w> to pause.'}`)));\n    }\n    /**\n     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\n     */\n    async _computeChanged() {\n        const state = new ProjectChangeAnalyzer(this._rushConfiguration);\n        const previousState = this._previousState;\n        if (!previousState) {\n            return {\n                changedProjects: this._projectsToWatch,\n                state\n            };\n        }\n        const changedProjects = new Set();\n        for (const project of this._projectsToWatch) {\n            const [previous, current] = await Promise.all([\n                previousState._tryGetProjectDependenciesAsync(project, this._terminal),\n                state._tryGetProjectDependenciesAsync(project, this._terminal)\n            ]);\n            if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {\n                // May need to detect if the nature of the change will break the process, e.g. changes to package.json\n                changedProjects.add(project);\n            }\n        }\n        return {\n            changedProjects,\n            state\n        };\n    }\n    _commitChanges(state) {\n        this._previousState = state;\n        if (!this._initialState) {\n            this._initialState = state;\n        }\n    }\n    /**\n     * Tests for inequality of the passed Maps. Order invariant.\n     *\n     * @returns `true` if the maps are different, `false` otherwise\n     */\n    static _haveProjectDepsChanged(prev, next) {\n        if (!prev && !next) {\n            return false;\n        }\n        if (!prev || !next) {\n            return true;\n        }\n        if (prev.size !== next.size) {\n            return true;\n        }\n        for (const [key, value] of prev) {\n            if (next.get(key) !== value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static *_enumeratePathsToWatch(paths, prefixLength) {\n        for (const path of paths) {\n            const rootSlashIndex = path.indexOf('/', prefixLength);\n            if (rootSlashIndex < 0) {\n                yield path;\n                return;\n            }\n            yield path.slice(0, rootSlashIndex);\n            let slashIndex = path.indexOf('/', rootSlashIndex + 1);\n            while (slashIndex >= 0) {\n                yield path.slice(0, slashIndex);\n                slashIndex = path.indexOf('/', slashIndex + 1);\n            }\n        }\n    }\n}\n//# sourceMappingURL=ProjectWatcher.js.map"],"names":[],"sourceRoot":""}