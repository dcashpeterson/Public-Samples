{
  "name": "@rushstack/eslint-plugin",
  "version": "0.9.1",
  "description": "An ESLint plugin providing supplementary rules for use with the @rushstack/eslint-config package",
  "license": "MIT",
  "repository": {
    "url": "https://github.com/microsoft/rushstack.git",
    "type": "git",
    "directory": "eslint/eslint-plugin"
  },
  "homepage": "https://rushstack.io",
  "keywords": [
    "eslint",
    "eslint-config",
    "monorepo",
    "rush",
    "scalable",
    "scale",
    "typescript"
  ],
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "dependencies": {
    "@rushstack/tree-pattern": "0.2.4",
    "@typescript-eslint/experimental-utils": "~5.20.0"
  },
  "peerDependencies": {
    "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
  },
  "devDependencies": {
    "@rushstack/heft": "0.45.6",
    "@rushstack/heft-node-rig": "1.9.7",
    "@types/eslint": "8.2.0",
    "@types/estree": "0.0.50",
    "@types/heft-jest": "1.0.1",
    "@types/node": "12.20.24",
    "@typescript-eslint/parser": "~5.20.0",
    "@typescript-eslint/typescript-estree": "~5.20.0",
    "eslint": "~8.7.0",
    "typescript": "~4.6.3"
  },
  "scripts": {
    "build": "heft build --clean",
    "_phase:build": "heft build --clean",
    "_phase:test": "heft test --no-build"
  },
  "readme": "# @rushstack/eslint-plugin\n\nThis plugin implements supplementary rules for use with the `@rushstack/eslint-config` package,\nwhich provides a TypeScript ESLint ruleset tailored for large teams and projects.\nPlease see [that project's documentation](https://www.npmjs.com/package/@rushstack/eslint-config)\nfor details.  To learn about Rush Stack, please visit: [https://rushstack.io/](https://rushstack.io/)\n\n## `@rushstack/hoist-jest-mock`\n\nRequire Jest module mocking APIs to be called before any other statements in their code block.\n\n#### Rule Details\n\nJest module mocking APIs such as \"jest.mock()\" must be called before the associated module is imported, otherwise\nthey will have no effect. Transpilers such as `ts-jest` and `babel-jest` automatically \"hoist\" these calls, however\nthis can produce counterintuitive behavior. Instead, the `hoist-jest-mocks` lint rule simply requires developers\nto write the statements in the correct order.\n\nThe following APIs are affected: 'jest.mock()', 'jest.unmock()', 'jest.enableAutomock()', 'jest.disableAutomock()',\n'jest.deepUnmock()'.\n\nFor technical background, please read the Jest documentation here: https://jestjs.io/docs/en/es6-class-mocks\n\n#### Examples\n\nThe following patterns are considered problems when `@rushstack/hoist-jest-mock` is enabled:\n\n```ts\nimport * as file from './file'; // import statement\njest.mock('./file'); // error\n\ntest(\"example\", () => {\n  jest.mock('./file2'); // error\n});\n```\n\n```ts\nrequire('./file'); // import statement\njest.mock('./file'); // error\n```\n\nThe following patterns are NOT considered problems:\n\n```ts\njest.mock('./file'); // okay, because mock() precedes the import below\nimport * as file from './file'; // import statement\n```\n\n```ts\n// These statements are not real \"imports\" because they import compile-time types\n// without any runtime effects\nimport type { X } from './file';\nlet y: typeof import('./file');\n\njest.mock('./file'); // okay\n```\n\n## `@rushstack/no-new-null`\n\nPrevent usage of the JavaScript `null` value, while allowing code to access existing APIs that\nmay require `null`.\n\n#### Rule Details\n\nMost programming languages have a \"null\" or \"nil\" value that serves several purposes:\n\n1. the initial value for an uninitialized variable\n2. the value of `x.y` or `x[\"y\"]` when `x` has no such key, and\n3. a special token that developers can assign to indicate an unknown or empty state.\n\nIn JavaScript, the `undefined` value fulfills all three roles.  JavaScript's `null` value is a redundant secondary\ntoken that only fulfills (3), even though its name confusingly implies otherwise.  The `null` value was arguably\na mistake in the original JavaScript language design, but it cannot be banned entirely because it is returned\nby some entrenched system APIs such as `JSON.parse()`, and also some popular NPM packages.  Thus, this rule aims\nto tolerate preexisting `null` values while preventing new ones from being introduced.\n\nThe `@rushstack/no-new-null` rule flags type definitions with `null` that can be exported or used by others.\nThe rule ignores declarations that are local variables, private members, or types that are not exported.\n\nIf you are designing a new JSON file format, it's a good idea to avoid `null` entirely.  In most cases\nthere are better representations that convey more information about an item that is unknown, omitted,\nor disabled.  If you do need to declare types for JSON structures containing `null`, rather than\nsuppressing the lint rule, you can use a specialized\n[JsonNull](https://rushstack.io/pages/api/node-core-library.jsonnull/)\ntype as provided by [@rushstack/node-core-library](https://www.npmjs.com/package/@rushstack/node-core-library).\n\n\n#### Examples\n\nThe following patterns are considered problems when `@rushstack/no-new-null` is enabled:\n\n```ts\n// interface declaration with null field\ninterface IHello { hello: null; } // error\n\n// type declaration with null field\ntype Hello = { hello: null; } // error\n\n// type function alias\ntype T = (args: string | null) => void; // error\n\n// type alias\ntype N = null; // error\n\n// type constructor\ntype C = {new (args: string | null)} // error\n\n// function declaration with null args\nfunction hello(world: string | null): void {}; // error\nfunction legacy(callback: (err: Error| null) => void): void { }; // error\n\n// function with null return type\nfunction hello(): (err: Error | null) => void {}; // error\n\n// const with null type\nconst nullType: 'hello' | null = 'hello'; // error\n\n// classes with publicly visible properties and methods\nclass PublicNulls {\n  property: string | null; // error\n  propertyFunc: (val: string | null) => void; // error\n  legacyImplicitPublic(hello: string | null): void {} // error\n  public legacyExplicitPublic(hello: string | null): void {} // error\n}\n```\n\nThe following patterns are NOT considered problems:\n\n```ts\n// wrapping an null-API\nexport function ok(hello: string): void {\n  const innerCallback: (err: Error | null) => void = (e) => {}; // passes\n  return innerCallback(null);\n}\n\n// classes where null APIs are used, but are private-only\nclass PrivateNulls {\n  private pField: string | null; // passes\n  private pFunc: (val: string | null) => void; // passes\n  private legacyPrivate(hello: string | null): void { // passes\n    this.pField = hello;\n    this.pFunc(this.pField)\n    this.pFunc('hello')\n  }\n}\n```\n\n## `@rushstack/no-null`\n\n(Deprecated) Prevent usage of JavaScript's `null` keyword.\n\n#### Rule Details\n\nThis rule has been superseded by `@rushstack/no-new-null`, and is maintained to support code that has not\nmigrated to the new rule yet. The `@rushstack/no-null` rule prohibits `null` as a literal value, but allows\nit in type annotations.  Comparisons with `null` are also allowed.\n\n#### Examples\n\nThe following patterns are considered problems when `@rushstack/no-null` is enabled:\n\n```ts\nlet x = null;  // error\n\nf(null); // error\n\nfunction g() {\n    return null; // error\n}\n```\n\nThe following patterns are NOT considered problems:\n\n```ts\nlet x: number | null = f(); // declaring types as possibly \"null\" is okay\n\nif (x === null) {  // comparisons are okay\n    x = 0;\n}\n```\n\n## `@rushstack/no-untyped-underscore` (Opt-in)\n\nPrevent TypeScript code from accessing legacy JavaScript members whose name has an underscore prefix.\n\n#### Rule Details\n\nJavaScript does not provide a straightforward way to restrict access to object members, so API names commonly\nindicate a private member by using an underscore prefix (e.g. `exampleObject._privateMember`).  For inexperienced\ndevelopers who may be unfamiliar with this convention, in TypeScript we can mark the APIs as `private` or omit them\nfrom the typings.  However, when migrating a large code base to TypeScript, it may be difficult to declare types\nfor every legacy API.  In this situation, the `@rushstack/no-untyped-underscore` rule can help.\n\nThis rule detects expressions that access a member with an underscore prefix, EXCEPT in cases where:\n\n- The object is typed: specifically, `exampleObject` has a TypeScript type that declares `_privateMember`; OR\n- The object expression uses: the `this` or `super` keywords; OR\n- The object expression is a variable named `that`.  (In older ES5 code, `that` was commonly used as an alias\n for `this` in unbound contexts.)\n\n#### Examples\n\nThe following patterns are considered problems when `@rushstack/no-untyped-underscore` is enabled:\n\n```ts\nlet x: any;\nx._privateMember = 123;  // error, because x is untyped\n\nlet x: { [key: string]: number };\nx._privateMember = 123;  // error, because _privateMember is not a declared member of x's type\n```\n\nThe following patterns are NOT considered problems:\n\n```ts\nlet x: { _privateMember: any };\nx._privateMember = 123;  // okay, because _privateMember is declared by x's type\n\nlet x = { _privateMember: 0 };\nx._privateMember = 123;  // okay, because _privateMember is part of the inferred type\n\nenum E {\n    _PrivateMember\n}\nlet e: E._PrivateMember = E._PrivateMember; // okay, because _PrivateMember is declared by E\n```\n\n\n## Links\n\n- [CHANGELOG.md](\n  https://github.com/microsoft/rushstack/blob/main/stack/eslint-plugin/CHANGELOG.md) - Find\n  out what's new in the latest version\n\n`@rushstack/eslint-plugin` is part of the [Rush Stack](https://rushstack.io/) family of projects.\n"
}