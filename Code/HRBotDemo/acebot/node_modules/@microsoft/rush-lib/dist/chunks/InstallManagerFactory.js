"use strict";
exports.id = "InstallManagerFactory";
exports.ids = ["InstallManagerFactory"];
exports.modules = {

/***/ 171208:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/ApprovedPackagesChecker.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApprovedPackagesChecker": () => (/* binding */ ApprovedPackagesChecker)
/* harmony export */ });
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DependencySpecifier */ 68654);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class ApprovedPackagesChecker {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        this._filesAreOutOfDate = false;
        if (this._approvedPackagesPolicy.enabled) {
            this._updateApprovedPackagesPolicy();
        }
    }
    /**
     * If true, the files on disk are out of date.
     */
    get approvedPackagesFilesAreOutOfDate() {
        return this._filesAreOutOfDate;
    }
    /**
     * Examines the current dependencies for the projects specified in RushConfiguration,
     * and then adds them to the 'browser-approved-packages.json' and
     * 'nonbrowser-approved-packages.json' config files.  If these files don't exist,
     * they will be created.
     *
     * If the "approvedPackagesPolicy" feature is not enabled, then no action is taken.
     */
    rewriteConfigFiles() {
        const approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        if (approvedPackagesPolicy.enabled) {
            approvedPackagesPolicy.browserApprovedPackages.saveToFile();
            approvedPackagesPolicy.nonbrowserApprovedPackages.saveToFile();
        }
    }
    _updateApprovedPackagesPolicy() {
        for (const rushProject of this._rushConfiguration.projects) {
            const packageJson = rushProject.packageJson;
            this._collectDependencies(packageJson.dependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.devDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.peerDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.optionalDependencies, this._approvedPackagesPolicy, rushProject);
        }
    }
    _collectDependencies(dependencies, approvedPackagesPolicy, rushProject) {
        if (dependencies) {
            for (const packageName of Object.keys(dependencies)) {
                let referencedPackageName = packageName;
                // Special handling for NPM package aliases such as this:
                //
                // "dependencies": {
                //   "alias-name": "npm:target-name@^1.2.3"
                // }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__.DependencySpecifier(packageName, dependencies[packageName]);
                if (dependencySpecifier.aliasTarget) {
                    // Use "target-name" instead of "alias-name"
                    referencedPackageName = dependencySpecifier.aliasTarget.packageName;
                }
                const scope = this._rushConfiguration.packageNameParser.getScope(referencedPackageName);
                // Make sure the scope isn't something like "@types" which should be ignored
                if (!approvedPackagesPolicy.ignoredNpmScopes.has(scope) && rushProject.reviewCategory) {
                    // Yes, add it to the list if it's not already there
                    let updated = false;
                    // By default we put everything in the browser file.  But if it already appears in the
                    // non-browser file, then use that instead.
                    if (approvedPackagesPolicy.nonbrowserApprovedPackages.getItemByName(referencedPackageName)) {
                        updated = approvedPackagesPolicy.nonbrowserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    else {
                        updated = approvedPackagesPolicy.browserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    this._filesAreOutOfDate = this._filesAreOutOfDate || updated;
                }
            }
        }
    }
}
//# sourceMappingURL=ApprovedPackagesChecker.js.map

/***/ }),

/***/ 611779:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/InstallManagerFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstallManagerFactory": () => (/* binding */ InstallManagerFactory)
/* harmony export */ });
/* harmony import */ var _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./installManager/WorkspaceInstallManager */ 8735);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class InstallManagerFactory {
    static async getInstallManagerAsync(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        if (rushConfiguration.packageManager === 'pnpm' &&
            rushConfiguration.pnpmOptions &&
            rushConfiguration.pnpmOptions.useWorkspaces) {
            return new _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__.WorkspaceInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
        }
        const rushInstallManagerModule = await Promise.all(/*! import() | RushInstallManager */[__webpack_require__.e("LinkManagerFactory"), __webpack_require__.e("RushInstallManager")]).then(__webpack_require__.bind(__webpack_require__, /*! ./installManager/RushInstallManager */ 108860));
        return new rushInstallManagerModule.RushInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
    }
}
//# sourceMappingURL=InstallManagerFactory.js.map

/***/ }),

/***/ 876149:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseInstallManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseInstallManager": () => (/* binding */ BaseInstallManager),
/* harmony export */   "pnpmIgnoreCompatibilityDbParameter": () => (/* binding */ pnpmIgnoreCompatibilityDbParameter)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ 822037);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ 706113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @rushstack/terminal */ 569956);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ApprovedPackagesChecker */ 171208);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Git */ 668229);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../api/LastInstallFlag */ 919846);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../api/Rush */ 465002);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../RushConstants */ 951904);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 819779);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../installManager/InstallHelpers */ 741340);
/* harmony import */ var _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../policy/PolicyValidator */ 999291);
/* harmony import */ var _utilities_WebClient__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/WebClient */ 618105);
/* harmony import */ var _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../setup/SetupPackageRegistry */ 555992);
/* harmony import */ var _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../pnpm/PnpmfileConfiguration */ 238032);
/* harmony import */ var _utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/npmrcUtilities */ 679877);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






















/**
 * Pnpm don't support --ignore-compatibility-db, so use --config.ignoreCompatibilityDb for now.
 */
const pnpmIgnoreCompatibilityDbParameter = '--config.ignoreCompatibilityDb';
const pnpmCacheDirParameter = '--config.cacheDir';
const pnpmStateDirParameter = '--config.stateDir';
const gitLfsHooks = new Set(['post-checkout', 'post-commit', 'post-merge', 'pre-push']);
/**
 * This class implements common logic between "rush install" and "rush update".
 */
class BaseInstallManager {
    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        this._npmSetupValidated = false;
        this._syncNpmrcAlreadyCalled = false;
        this.rushConfiguration = rushConfiguration;
        this.rushGlobalFolder = rushGlobalFolder;
        this.installRecycler = purgeManager.commonTempFolderRecycler;
        this.options = options;
        this._commonTempLinkFlag = _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_7__.LastLinkFlagFactory.getCommonTempFlag(rushConfiguration);
        this._terminalProvider = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.ConsoleTerminalProvider();
        this._terminal = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Terminal(this._terminalProvider);
    }
    async doInstallAsync() {
        const isFilteredInstall = this.options.pnpmFilterArguments.length > 0;
        const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
        // Prevent filtered installs when workspaces is disabled
        if (isFilteredInstall && !useWorkspaces) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('Project filtering arguments can only be used when running in a workspace environment. Run the ' +
                'command again without specifying these arguments.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
        }
        // Prevent update when using a filter, as modifications to the shrinkwrap shouldn't be saved
        if (this.options.allowShrinkwrapUpdates && isFilteredInstall) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('Project filtering arguments cannot be used when running "rush update". Run the command again ' +
                'without specifying these arguments.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
        }
        const { shrinkwrapIsUpToDate, variantIsUpToDate, npmrcHash } = await this.prepareAsync();
        if (this.options.checkOnly) {
            return;
        }
        // eslint-disable-next-line no-console
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Checking installation in "${this.rushConfiguration.commonTempFolder}"`));
        // This marker file indicates that the last "rush install" completed successfully.
        // Always perform a clean install if filter flags were provided. Additionally, if
        // "--purge" was specified, or if the last install was interrupted, then we will
        // need to perform a clean install.  Otherwise, we can do an incremental install.
        const commonTempInstallFlag = _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_8__.LastInstallFlagFactory.getCommonTempFlag(this.rushConfiguration, { npmrcHash: npmrcHash || '<NO NPMRC>' });
        const optionsToIgnore = !this.rushConfiguration.experimentsConfiguration
            .configuration.cleanInstallAfterNpmrcChanges
            ? ['npmrcHash'] // If the "cleanInstallAfterNpmrcChanges" experiment is disabled, ignore the npmrcHash
            : undefined;
        const cleanInstall = isFilteredInstall ||
            !commonTempInstallFlag.checkValidAndReportStoreIssues({
                rushVerb: this.options.allowShrinkwrapUpdates ? 'update' : 'install',
                statePropertiesToIgnore: optionsToIgnore
            });
        // Allow us to defer the file read until we need it
        const canSkipInstall = () => {
            // Based on timestamps, can we skip this install entirely?
            const outputStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.getStatistics(commonTempInstallFlag.path);
            return this.canSkipInstall(outputStats.mtime);
        };
        if (cleanInstall || !shrinkwrapIsUpToDate || !variantIsUpToDate || !canSkipInstall()) {
            // eslint-disable-next-line no-console
            console.log();
            await this.validateNpmSetup();
            let publishedRelease;
            try {
                publishedRelease = await this._checkIfReleaseIsPublished();
            }
            catch (_a) {
                // If the user is working in an environment that can't reach the registry,
                // don't bother them with errors.
            }
            if (publishedRelease === false) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));
            }
            // Delete the successful install file to indicate the install transaction has started
            commonTempInstallFlag.clear();
            // Since we're going to be tampering with common/node_modules, delete the "rush link" flag file if it exists;
            // this ensures that a full "rush link" is required next time
            this._commonTempLinkFlag.clear();
            // Give plugins an opportunity to act before invoking the installation process
            if (this.options.beforeInstallAsync !== undefined) {
                await this.options.beforeInstallAsync();
            }
            // Perform the actual install
            await this.installAsync(cleanInstall);
            if (this.options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {
                // Copy (or delete) common\temp\pnpm-lock.yaml --> common\config\rush\pnpm-lock.yaml
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(this.rushConfiguration.tempShrinkwrapFilename, this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));
            }
            else {
                // TODO: Validate whether the package manager updated it in a nontrivial way
            }
            // Always update the state file if running "rush update"
            if (this.options.allowShrinkwrapUpdates) {
                if (this.rushConfiguration.getRepoState(this.options.variant).refreshState(this.rushConfiguration)) {
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.repoStateFilename} has been modified and must be committed to source control.`));
                }
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log('Installation is already up-to-date.');
        }
        // Create the marker file to indicate a successful install if it's not a filtered install
        if (!isFilteredInstall) {
            commonTempInstallFlag.create();
        }
        // Perform any post-install work the install manager requires
        await this.postInstallAsync();
        // eslint-disable-next-line no-console
        console.log('');
    }
    canSkipInstall(lastModifiedDate) {
        // Based on timestamps, can we skip this install entirely?
        const potentiallyChangedFiles = [];
        // Consider the timestamp on the node_modules folder; if someone tampered with it
        // or deleted it entirely, then we can't skip this install
        potentiallyChangedFiles.push(path__WEBPACK_IMPORTED_MODULE_2__.join(this.rushConfiguration.commonTempFolder, _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.nodeModulesFolderName));
        // Additionally, if they pulled an updated shrinkwrap file from Git,
        // then we can't skip this install
        potentiallyChangedFiles.push(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));
        // Add common-versions.json file to the potentially changed files list.
        potentiallyChangedFiles.push(this.rushConfiguration.getCommonVersionsFilePath(this.options.variant));
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // If the repo is using pnpmfile.js, consider that also
            const pnpmFileFilename = this.rushConfiguration.getPnpmfilePath(this.options.variant);
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.exists(pnpmFileFilename)) {
                potentiallyChangedFiles.push(pnpmFileFilename);
            }
        }
        return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);
    }
    async prepareAsync() {
        // Check the policies
        await _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_11__.validatePolicyAsync(this.rushConfiguration, this.options);
        this._installGitHooks();
        const approvedPackagesChecker = new _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_12__.ApprovedPackagesChecker(this.rushConfiguration);
        if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {
            if (this.options.allowShrinkwrapUpdates) {
                approvedPackagesChecker.rewriteConfigFiles();
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('Approved package files have been updated. These updates should be committed to source control'));
            }
            else {
                throw new Error(`Approved packages files are out-of date. Run "rush update" to update them.`);
            }
        }
        // Ensure that the package manager is installed
        await _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_13__.InstallHelpers.ensureLocalPackageManager(this.rushConfiguration, this.rushGlobalFolder, this.options.maxInstallAttempts);
        let shrinkwrapFile = undefined;
        // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)
        if (!this.options.fullUpgrade) {
            try {
                shrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_14__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.packageManagerOptions, this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant));
            }
            catch (ex) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(`Unable to load the ${this.rushConfiguration.shrinkwrapFilePhrase}: ${ex.message}`);
                if (!this.options.allowShrinkwrapUpdates) {
                    // eslint-disable-next-line no-console
                    console.log();
                    // eslint-disable-next-line no-console
                    console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('You need to run "rush update" to fix this problem'));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
                }
                shrinkwrapFile = undefined;
            }
        }
        // Write a file indicating which variant is being installed.
        // This will be used by bulk scripts to determine the correct Shrinkwrap file to track.
        const currentVariantJsonFilename = this.rushConfiguration.currentVariantJsonFilename;
        const currentVariantJson = {
            variant: this.options.variant || null
        };
        // Determine if the variant is already current by updating current-variant.json.
        // If nothing is written, the variant has not changed.
        const variantIsUpToDate = !_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.JsonFile.save(currentVariantJson, currentVariantJsonFilename, {
            onlyIfChanged: true
        });
        if (this.options.variant) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Using variant '${this.options.variant}' for installation.`));
        }
        else if (!variantIsUpToDate && !this.options.variant) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Using the default variant for installation.'));
        }
        // Also copy down the committed .npmrc file, if there is one
        // "common\config\rush\.npmrc" --> "common\temp\.npmrc"
        // Also ensure that we remove any old one that may be hanging around
        const npmrcText = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this.rushConfiguration.commonTempFolder);
        this._syncNpmrcAlreadyCalled = true;
        const npmrcHash = npmrcText
            ? crypto__WEBPACK_IMPORTED_MODULE_3__.createHash('sha1').update(npmrcText).digest('hex')
            : undefined;
        // Copy the committed patches folder if using pnpm
        if (this.rushConfiguration.packageManager === 'pnpm') {
            const commonTempPnpmPatchesFolder = `${this.rushConfiguration.commonTempFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmPatchesFolderName}`;
            const rushPnpmPatchesFolder = `${this.rushConfiguration.commonFolder}/pnpm-${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmPatchesFolderName}`;
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.exists(rushPnpmPatchesFolder)) {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.copyFiles({
                    sourcePath: rushPnpmPatchesFolder,
                    destinationPath: commonTempPnpmPatchesFolder
                });
            }
        }
        // Shim support for pnpmfile in. This shim will call back into the variant-specific pnpmfile.
        // Additionally when in workspaces, the shim implements support for common versions.
        if (this.rushConfiguration.packageManager === 'pnpm') {
            await _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_15__.PnpmfileConfiguration.writeCommonTempPnpmfileShimAsync(this.rushConfiguration, this.options);
        }
        // Allow for package managers to do their own preparation and check that the shrinkwrap is up to date
        // eslint-disable-next-line prefer-const
        let { shrinkwrapIsUpToDate, shrinkwrapWarnings } = await this.prepareCommonTempAsync(shrinkwrapFile);
        shrinkwrapIsUpToDate = shrinkwrapIsUpToDate && !this.options.recheckShrinkwrap;
        this._syncTempShrinkwrap(shrinkwrapFile);
        // Write out the reported warnings
        if (shrinkwrapWarnings.length > 0) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_6__.PrintUtilities.wrapWords(`The ${this.rushConfiguration.shrinkwrapFilePhrase} contains the following issues:`)));
            for (const shrinkwrapWarning of shrinkwrapWarnings) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow('  ' + shrinkwrapWarning));
            }
            // eslint-disable-next-line no-console
            console.log();
        }
        // Force update if the shrinkwrap is out of date
        if (!shrinkwrapIsUpToDate) {
            if (!this.options.allowShrinkwrapUpdates) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`The ${this.rushConfiguration.shrinkwrapFilePhrase} is out of date. You need to run "rush update".`));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
            }
        }
        return { shrinkwrapIsUpToDate, variantIsUpToDate, npmrcHash };
    }
    /**
     * Git hooks are only installed if the repo opts in by including files in /common/git-hooks
     */
    _installGitHooks() {
        const hookSource = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rushConfiguration.commonFolder, 'git-hooks');
        const git = new _Git__WEBPACK_IMPORTED_MODULE_16__.Git(this.rushConfiguration);
        const hookDestination = git.getHooksFolder();
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.exists(hookSource) && hookDestination) {
            const allHookFilenames = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.readFolderItemNames(hookSource);
            // Ignore the ".sample" file(s) in this folder.
            const hookFilenames = allHookFilenames.filter((x) => !/\.sample$/.test(x));
            if (hookFilenames.length > 0) {
                // eslint-disable-next-line no-console
                console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Found files in the "common/git-hooks" folder.'));
                if (!git.isHooksPathDefault()) {
                    const color = this.options.bypassPolicy ? (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow) : (colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red);
                    // eslint-disable-next-line no-console
                    console.error(color([
                        ' ',
                        `Rush cannot install the "common/git-hooks" scripts because your Git configuration `,
                        `specifies "core.hooksPath=${git.getConfigHooksPath()}". You can remove the setting by running:`,
                        ' ',
                        '    git config --unset core.hooksPath',
                        ' '
                    ].join('\n')));
                    if (this.options.bypassPolicy) {
                        // If "--bypass-policy" is specified, skip installation of hooks because Rush doesn't
                        // own the hooks folder
                        return;
                    }
                    // eslint-disable-next-line no-console
                    console.error(color([
                        '(Or, to temporarily ignore this problem, invoke Rush with the ' +
                            `"${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" option.)`,
                        ' '
                    ].join('\n')));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
                }
                // Clear the currently installed git hooks and install fresh copies
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.ensureEmptyFolder(hookDestination);
                // Find the relative path from Git hooks directory to the directory storing the actual scripts.
                const hookRelativePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_2__.relative(hookDestination, hookSource));
                // Only copy files that look like Git hook names
                const filteredHookFilenames = hookFilenames.filter((x) => /^[a-z\-]+/.test(x));
                for (const filename of filteredHookFilenames) {
                    const hookFilePath = `${hookSource}/${filename}`;
                    // Make sure the actual script in the hookSource directory has correct Linux compatible line endings
                    const originalHookFileContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.readFile(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.writeFile(hookFilePath, originalHookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.NewlineKind.Lf
                    });
                    // Make sure the actual script in the hookSource directory has required permission bits
                    const originalPosixModeBits = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.getPosixModeBits(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.changePosixModeBits(hookFilePath, 
                    // eslint-disable-next-line no-bitwise
                    originalPosixModeBits | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.PosixModeBits.UserExecute);
                    const gitLfsHookHandling = gitLfsHooks.has(filename)
                        ? `
# Inspired by https://github.com/git-lfs/git-lfs/issues/2865#issuecomment-365742940
if command -v git-lfs &> /dev/null; then
  git lfs ${filename} "$@"
fi
`
                        : '';
                    const hookFileContent = `#!/bin/bash
set -e
SCRIPT_DIR="$( cd "$( dirname "\${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
SCRIPT_IMPLEMENTATION_PATH="$SCRIPT_DIR/${hookRelativePath}/${filename}"

if [[ -f "$SCRIPT_IMPLEMENTATION_PATH" ]]; then
  "$SCRIPT_IMPLEMENTATION_PATH" $@
else
  echo "The ${filename} Git hook no longer exists in your version of the repo. Run 'rush install' or 'rush update' to refresh your installed Git hooks." >&2
fi
${gitLfsHookHandling}
`;
                    // Create the hook file.  Important: For Bash scripts, the EOL must not be CRLF.
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_2__.join(hookDestination, filename), hookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.NewlineKind.Lf
                    });
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.changePosixModeBits(path__WEBPACK_IMPORTED_MODULE_2__.join(hookDestination, filename), 
                    // eslint-disable-next-line no-bitwise
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.PosixModeBits.UserExecute);
                }
                // eslint-disable-next-line no-console
                console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + '\n');
            }
        }
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options) {
        if (this.rushConfiguration.packageManager === 'npm') {
            if (semver__WEBPACK_IMPORTED_MODULE_4__.lt(this.rushConfiguration.packageManagerToolVersion, '5.0.0')) {
                // NOTE:
                //
                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for
                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.
                //
                // Consider the "fsevents" package. This is a Mac specific package
                // which is an optional second-order dependency. Optional dependencies work by attempting to install
                // the package, but removes the package if the install failed.
                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.
                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.
                //
                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.
                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the
                // optional dependency installed.
                //
                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0
                //
                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600
                args.push('--no-optional');
            }
            args.push('--cache', this.rushConfiguration.npmCacheFolder);
            args.push('--tmp', this.rushConfiguration.npmTmpFolder);
            if (options.collectLogFile) {
                args.push('--verbose');
            }
        }
        else if (this.rushConfiguration.packageManager === 'pnpm') {
            // Only explicitly define the store path if `pnpmStore` is using the default, or has been set to
            // 'local'.  If `pnpmStore` = 'global', then allow PNPM to use the system's default
            // path.  In all cases, this will be overridden by RUSH_PNPM_STORE_PATH
            if (this.rushConfiguration.pnpmOptions.pnpmStore === 'local' ||
                _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_17__.EnvironmentConfiguration.pnpmStorePathOverride) {
                args.push('--store', this.rushConfiguration.pnpmOptions.pnpmStorePath);
                if (semver__WEBPACK_IMPORTED_MODULE_4__.gte(this.rushConfiguration.packageManagerToolVersion, '6.10.0')) {
                    args.push(`${pnpmCacheDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                    args.push(`${pnpmStateDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                }
            }
            const { pnpmVerifyStoreIntegrity } = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_17__.EnvironmentConfiguration;
            if (pnpmVerifyStoreIntegrity !== undefined) {
                args.push(`--verify-store-integrity`, `${pnpmVerifyStoreIntegrity}`);
            }
            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
            if (experiments.usePnpmFrozenLockfileForRushInstall && !options.allowShrinkwrapUpdates) {
                args.push('--frozen-lockfile');
                if (options.pnpmFilterArguments.length > 0 &&
                    Number.parseInt(this.rushConfiguration.packageManagerToolVersion, 10) >= 8 // PNPM Major version 8+
                ) {
                    // On pnpm@8, disable the "dedupe-peer-dependents" feature when doing a filtered CI install so that filters take effect.
                    args.push('--config.dedupe-peer-dependents=false');
                }
            }
            else if (experiments.usePnpmPreferFrozenLockfileForRushUpdate) {
                // In workspaces, we want to avoid unnecessary lockfile churn
                args.push('--prefer-frozen-lockfile');
            }
            else {
                // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.
                // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342
                args.push('--no-prefer-frozen-lockfile');
            }
            if (options.onlyShrinkwrap) {
                args.push(`--lockfile-only`);
            }
            if (options.collectLogFile) {
                args.push('--reporter', 'ndjson');
            }
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (this.rushConfiguration.pnpmOptions.strictPeerDependencies === false) {
                args.push('--no-strict-peer-dependencies');
            }
            else {
                args.push('--strict-peer-dependencies');
            }
            /*
              If user set resolution-mode in pnpm-config.json only, use the value in pnpm-config.json
              If user set resolution-mode in pnpm-config.json and .npmrc, use the value in pnpm-config.json
              If user set resolution-mode in .npmrc only, do nothing, let pnpm handle it
              If user does not set resolution-mode in pnpm-config.json and .npmrc, rush will default it to "highest"
            */
            const isResolutionModeInNpmrc = (0,_utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_18__.isVariableSetInNpmrcFile)(this.rushConfiguration.commonRushConfigFolder, 'resolution-mode');
            let resolutionMode = this.rushConfiguration.pnpmOptions.resolutionMode;
            if (resolutionMode) {
                if (isResolutionModeInNpmrc) {
                    this._terminal.writeWarningLine(`Warning: PNPM's resolution-mode is specified in both .npmrc and pnpm-config.json. ` +
                        `The value in pnpm-config.json will take precedence.`);
                }
            }
            else if (!isResolutionModeInNpmrc) {
                // if resolution-mode isn't specified in either .npmrc or pnpm-config.json,
                // then rush will default it to "highest"
                resolutionMode = 'highest';
            }
            if (resolutionMode) {
                args.push(`--config.resolutionMode=${resolutionMode}`);
            }
            if (semver__WEBPACK_IMPORTED_MODULE_4__.satisfies(this.rushConfiguration.packageManagerToolVersion, '6.32.12 - 6.33.x || 7.0.1 - 7.8.x')) {
                this._terminal.writeWarningLine('Warning: Your rush.json specifies a pnpmVersion with a known issue ' +
                    'that may cause unintended version selections.' +
                    " It's recommended to upgrade to PNPM >=6.34.0 or >=7.9.0. " +
                    'For details see: https://rushjs.io/link/pnpm-issue-5132');
            }
            if (semver__WEBPACK_IMPORTED_MODULE_4__.gte(this.rushConfiguration.packageManagerToolVersion, '7.9.0') ||
                semver__WEBPACK_IMPORTED_MODULE_4__.satisfies(this.rushConfiguration.packageManagerToolVersion, '^6.34.0')) {
                args.push(pnpmIgnoreCompatibilityDbParameter);
            }
        }
        else if (this.rushConfiguration.packageManager === 'yarn') {
            args.push('--link-folder', 'yarn-link');
            args.push('--cache-folder', this.rushConfiguration.yarnCacheFolder);
            // Without this option, Yarn will sometimes stop and ask for user input on STDIN
            // (e.g. "Which command would you like to run?").
            args.push('--non-interactive');
            if (options.networkConcurrency) {
                args.push('--network-concurrency', options.networkConcurrency.toString());
            }
            if (this.rushConfiguration.yarnOptions.ignoreEngines) {
                args.push('--ignore-engines');
            }
            if (options.collectLogFile) {
                args.push('--verbose');
            }
        }
    }
    async _checkIfReleaseIsPublished() {
        const lastCheckFile = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rushGlobalFolder.nodeSpecificPath, 'rush-' + _api_Rush__WEBPACK_IMPORTED_MODULE_19__.Rush.version, 'last-check.flag');
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.exists(lastCheckFile)) {
            let cachedResult = undefined;
            try {
                // NOTE: mtimeMs is not supported yet in Node.js 6.x
                const nowMs = new Date().getTime();
                const ageMs = nowMs - _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.getStatistics(lastCheckFile).mtime.getTime();
                const HOUR = 60 * 60 * 1000;
                // Is the cache too old?
                if (ageMs < 24 * HOUR) {
                    // No, read the cached result
                    cachedResult = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.JsonFile.load(lastCheckFile);
                }
            }
            catch (e) {
                // Unable to parse file
            }
            if (cachedResult === 'error') {
                throw new Error('Unable to contact server');
            }
            if (cachedResult === true || cachedResult === false) {
                return cachedResult;
            }
        }
        // Before we start the network operation, record a failed state.  If the process exits for some reason,
        // this will record the error.  It will also update the timestamp to prevent other Rush instances
        // from attempting to update the file.
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
        try {
            // For this check we use the official registry, not the private registry
            const publishedRelease = await this._queryIfReleaseIsPublishedAsync('https://registry.npmjs.org:443');
            // Cache the result
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.JsonFile.saveAsync(publishedRelease, lastCheckFile, { ensureFolderExists: true });
            return publishedRelease;
        }
        catch (error) {
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
            throw error;
        }
    }
    // Helper for checkIfReleaseIsPublished()
    async _queryIfReleaseIsPublishedAsync(registryUrl) {
        let queryUrl = registryUrl;
        if (queryUrl[-1] !== '/') {
            queryUrl += '/';
        }
        // Note that the "@" symbol does not normally get URL-encoded
        queryUrl += _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.rushPackageName.replace('/', '%2F');
        const webClient = new _utilities_WebClient__WEBPACK_IMPORTED_MODULE_20__.WebClient();
        webClient.userAgent = `pnpm/? npm/? node/${process.version} ${os__WEBPACK_IMPORTED_MODULE_1__.platform()} ${os__WEBPACK_IMPORTED_MODULE_1__.arch()}`;
        webClient.accept = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';
        const response = await webClient.fetchAsync(queryUrl);
        if (!response.ok) {
            throw new Error('Failed to query');
        }
        const data = await response.json();
        let url;
        try {
            if (!data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_19__.Rush.version]) {
                // Version was not published
                return false;
            }
            url = data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_19__.Rush.version].dist.tarball;
            if (!url) {
                throw new Error(`URL not found`);
            }
        }
        catch (e) {
            throw new Error('Error parsing response');
        }
        // Make sure the tarball wasn't deleted from the CDN
        webClient.accept = '*/*';
        const response2 = await webClient.fetchAsync(url);
        if (!response2.ok) {
            if (response2.status === 404) {
                return false;
            }
            else {
                throw new Error('Failed to fetch');
            }
        }
        return true;
    }
    _syncTempShrinkwrap(shrinkwrapFile) {
        if (shrinkwrapFile) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant), this.rushConfiguration.tempShrinkwrapFilename);
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_9__.Utilities.syncFile(this.rushConfiguration.getCommittedShrinkwrapFilename(this.options.variant), this.rushConfiguration.tempShrinkwrapPreinstallFilename);
        }
        else {
            // Otherwise delete the temporary file
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.deleteFile(this.rushConfiguration.tempShrinkwrapFilename);
            if (this.rushConfiguration.packageManager === 'pnpm') {
                // Workaround for https://github.com/pnpm/pnpm/issues/1890
                //
                // When "rush update --full" is run, Rush deletes "common/temp/pnpm-lock.yaml"
                // so that a new lockfile will be generated. However "pnpm install" by design will try to recover
                // "pnpm-lock.yaml" from "common/temp/node_modules/.pnpm/lock.yaml", which may prevent a full upgrade.
                // Deleting both files ensures that a new lockfile will always be generated.
                const pnpmPackageManager = this.rushConfiguration
                    .packageManagerWrapper;
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.FileSystem.deleteFile(path__WEBPACK_IMPORTED_MODULE_2__.join(this.rushConfiguration.commonTempFolder, pnpmPackageManager.internalShrinkwrapRelativePath));
            }
        }
    }
    async validateNpmSetup() {
        if (this._npmSetupValidated) {
            return;
        }
        if (!this.options.bypassPolicy) {
            const setupPackageRegistry = new _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_21__.SetupPackageRegistry({
                rushConfiguration: this.rushConfiguration,
                isDebug: this.options.debug,
                syncNpmrcAlreadyCalled: this._syncNpmrcAlreadyCalled
            });
            const valid = await setupPackageRegistry.checkOnly();
            if (!valid) {
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('ERROR: NPM credentials are missing or expired'));
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('==> Please run "rush setup" to update your NPM token. ' +
                    `(Or append "${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" to proceed anyway.)`));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_5__.AlreadyReportedError();
            }
        }
        this._npmSetupValidated = true;
    }
}
//# sourceMappingURL=BaseInstallManager.js.map

/***/ }),

/***/ 896704:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseWorkspaceFile": () => (/* binding */ BaseWorkspaceFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * This class is a parser for pnpm's pnpm-workspace.yaml file format.
 */
class BaseWorkspaceFile {
    constructor() {
        this._alreadyWarnedSpecs = new Set();
    }
    /**
     * Serializes and saves the workspace file to specified location
     */
    save(filePath, options) {
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.onlyIfChanged && _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(filePath)) {
            try {
                oldBuffer = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileToBuffer(filePath);
            }
            catch (error) {
                // Ignore this error, and try writing a new file.  If that fails, then we should report that
                // error instead.
            }
        }
        const newYaml = this.serialize();
        const newBuffer = Buffer.from(newYaml); // utf8 encoding happens here
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return;
            }
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFile(filePath, newBuffer.toString(), {
            ensureFolderExists: options.ensureFolderExists
        });
    }
}
//# sourceMappingURL=BaseWorkspaceFile.js.map

/***/ }),

/***/ 8735:
/*!********************************************************************!*\
  !*** ./lib-esnext/logic/installManager/WorkspaceInstallManager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceInstallManager": () => (/* binding */ WorkspaceInstallManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ 710912);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/BaseInstallManager */ 876149);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../DependencySpecifier */ 68654);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 73666);
/* harmony import */ var _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pnpm/PnpmWorkspaceFile */ 688477);
/* harmony import */ var _logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logic/RushConstants */ 951904);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/Utilities */ 827501);
/* harmony import */ var _InstallHelpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./InstallHelpers */ 741340);
/* harmony import */ var _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../api/LastLinkFlag */ 986208);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 382806);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 819779);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../base/BaseProjectShrinkwrapFile */ 894306);
/* harmony import */ var _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../api/CustomTipsConfiguration */ 268756);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
















/**
 * This class implements common logic between "rush install" and "rush update".
 */
class WorkspaceInstallManager extends _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_4__.BaseInstallManager {
    /**
     * @override
     */
    async doInstallAsync() {
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        if (this.options.noLink) {
            // eslint-disable-next-line no-console
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('The "--no-link" option was provided but is not supported when using workspaces. Run the command again ' +
                'without specifying this argument.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
        }
        await super.doInstallAsync();
    }
    /**
     * Regenerates the common/temp/package.json and related workspace files.
     * If shrinkwrapFile is provided, this function also validates whether it contains
     * everything we need to install and returns true if so; in all other cases,
     * the return value is false.
     *
     * @override
     */
    async prepareCommonTempAsync(shrinkwrapFile) {
        // Block use of the RUSH_TEMP_FOLDER environment variable
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_5__.EnvironmentConfiguration.rushTempFolderOverride !== undefined) {
            throw new Error('The RUSH_TEMP_FOLDER environment variable is not compatible with workspace installs. If attempting ' +
                'to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.');
        }
        // eslint-disable-next-line no-console
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold('Updating workspace files in ' + this.rushConfiguration.commonTempFolder));
        const shrinkwrapWarnings = [];
        // We will start with the assumption that it's valid, and then set it to false if
        // any of the checks fail
        let shrinkwrapIsUpToDate = true;
        if (!shrinkwrapFile) {
            shrinkwrapIsUpToDate = false;
        }
        else {
            if (!shrinkwrapFile.isWorkspaceCompatible && !this.options.fullUpgrade) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red('The shrinkwrap file has not been updated to support workspaces. Run "rush update --full" to update ' +
                    'the shrinkwrap file.'));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
            }
            // If there are orphaned projects, we need to update
            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration);
            if (orphanedProjects.length > 0) {
                for (const orhpanedProject of orphanedProjects) {
                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references "${orhpanedProject}" ` +
                        'which was not found in rush.json');
                }
                shrinkwrapIsUpToDate = false;
            }
        }
        // If preferred versions have been updated, or if the repo-state.json is invalid,
        // we can't be certain of the state of the shrinkwrap
        const repoState = this.rushConfiguration.getRepoState(this.options.variant);
        if (!repoState.isValid) {
            shrinkwrapWarnings.push(`The ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker in the file.`);
            shrinkwrapIsUpToDate = false;
        }
        else {
            const commonVersions = this.rushConfiguration.getCommonVersions(this.options.variant);
            if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {
                shrinkwrapWarnings.push(`Preferred versions from ${_logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.commonVersionsFilename} have been modified.`);
                shrinkwrapIsUpToDate = false;
            }
        }
        // To generate the workspace file, we will add each project to the file as we loop through and validate
        const workspaceFile = new _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_7__.PnpmWorkspaceFile(path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml'));
        // Loop through the projects and add them to the workspace file. While we're at it, also validate that
        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.
        for (const rushProject of this.rushConfiguration.projects) {
            const packageJson = rushProject.packageJsonEditor;
            workspaceFile.addPackage(rushProject.projectFolder);
            for (const { name, version, dependencyType } of [
                ...packageJson.dependencyList,
                ...packageJson.devDependencyList
            ]) {
                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint
                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint
                // and do not need to be converted to workspaces protocol.
                if (dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_8__.DependencyType.Peer) {
                    continue;
                }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_9__.DependencySpecifier(name, version);
                // Is there a locally built Rush project that could satisfy this dependency?
                const referencedLocalProject = this.rushConfiguration.getProjectByName(name);
                // Validate that local projects are referenced with workspace notation. If not, and it is not a
                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only
                // supporting versions and version ranges for specifying a local project.
                if ((dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_9__.DependencySpecifierType.Version ||
                    dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_9__.DependencySpecifierType.Range) &&
                    referencedLocalProject &&
                    !rushProject.decoupledLocalDependencies.has(name)) {
                    // Make sure that this version is intended to target a local package. If not, then we will fail since it
                    // is not explicitly specified as a cyclic dependency.
                    if (!semver__WEBPACK_IMPORTED_MODULE_2__.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists ` +
                            'within the workspace but cannot be fulfilled with the specified version range. Either ' +
                            'specify a valid version range, or add the package as a cyclic dependency.'));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
                    }
                    if (!this.options.allowShrinkwrapUpdates) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists within ` +
                            'the workspace. Run "rush update" to update workspace references for this package.'));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
                    }
                    if (this.options.fullUpgrade) {
                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.
                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.
                        const workspaceRange = !!semver__WEBPACK_IMPORTED_MODULE_2__.validRange(dependencySpecifier.versionSpecifier) &&
                            !semver__WEBPACK_IMPORTED_MODULE_2__.valid(dependencySpecifier.versionSpecifier)
                            ? dependencySpecifier.versionSpecifier
                            : '*';
                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);
                        shrinkwrapIsUpToDate = false;
                        continue;
                    }
                }
                else if (dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_9__.DependencySpecifierType.Workspace) {
                    // Already specified as a local project. Allow the package manager to validate this
                    continue;
                }
            }
            // Save the package.json if we modified the version references and warn that the package.json was modified
            if (packageJson.saveIfModified()) {
                // eslint-disable-next-line no-console
                console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(`"${rushProject.packageName}" depends on one or more workspace packages which did not use "workspace:" ` +
                    'notation. The package.json has been modified and must be committed to source control.'));
            }
            // Now validate that the shrinkwrap file matches what is in the package.json
            if (await (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.isWorkspaceProjectModifiedAsync(rushProject, this.options.variant))) {
                shrinkwrapWarnings.push(`Dependencies of project "${rushProject.packageName}" do not match the current shrinkwrap.`);
                shrinkwrapIsUpToDate = false;
            }
        }
        // Write the common package.json
        _InstallHelpers__WEBPACK_IMPORTED_MODULE_10__.InstallHelpers.generateCommonPackageJson(this.rushConfiguration);
        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,
        // since "rush install" will consider this timestamp
        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });
        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };
    }
    canSkipInstall(lastModifiedDate) {
        if (!super.canSkipInstall(lastModifiedDate)) {
            return false;
        }
        const potentiallyChangedFiles = [];
        if (this.rushConfiguration.packageManager === 'pnpm') {
            // Add workspace file. This file is only modified when workspace packages change.
            const pnpmWorkspaceFilename = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(pnpmWorkspaceFilename)) {
                potentiallyChangedFiles.push(pnpmWorkspaceFilename);
            }
        }
        // Also consider timestamps for all the project node_modules folders, as well as the package.json
        // files
        // Example: [ "C:\MyRepo\projects\projectA\node_modules", "C:\MyRepo\projects\projectA\package.json" ]
        potentiallyChangedFiles.push(...this.rushConfiguration.projects.map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_1__.join(project.projectFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.nodeModulesFolderName);
        }), ...this.rushConfiguration.projects.map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_1__.join(project.projectFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileConstants.PackageJson);
        }));
        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()
        // returns false.
        return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_11__.Utilities.isFileTimestampCurrent(lastModifiedDate, potentiallyChangedFiles);
    }
    /**
     * Runs "npm install" in the common folder.
     */
    async installAsync(cleanInstall) {
        // Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;
        const packageManagerEnv = _InstallHelpers__WEBPACK_IMPORTED_MODULE_10__.InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);
        const commonNodeModulesFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.nodeModulesFolderName);
        // Is there an existing "node_modules" folder to consider?
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(commonNodeModulesFolder)) {
            // Should we delete the entire "node_modules" folder?
            if (cleanInstall) {
                // YES: Delete "node_modules"
                // Explain to the user why we are hosing their node_modules folder
                // eslint-disable-next-line no-console
                console.log('Deleting files from ' + commonNodeModulesFolder);
                this.installRecycler.moveFolder(commonNodeModulesFolder);
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_11__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
            }
        }
        const doInstallInternalAsync = async (options) => {
            // Run "npm install" in the common folder
            // To ensure that the output is always colored, set the option "--color=always", even when it's piped.
            // Without this argument, certain text that should be colored (such as red) will appear white.
            const installArgs = ['install', '--color=always'];
            this.pushConfigurationArgs(installArgs, options);
            // eslint-disable-next-line no-console
            console.log('\n' +
                colors_safe__WEBPACK_IMPORTED_MODULE_0___default().bold(`Running "${this.rushConfiguration.packageManager} install" in` +
                    ` ${this.rushConfiguration.commonTempFolder}`) +
                '\n');
            // If any diagnostic options were specified, then show the full command-line
            if (this.options.debug ||
                this.options.collectLogFile ||
                this.options.networkConcurrency ||
                this.options.onlyShrinkwrap) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('Invoking package manager: ') +
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.getRealPath(packageManagerFilename) +
                    ' ' +
                    installArgs.join(' ') +
                    '\n');
            }
            // Store the tip IDs that should be printed.
            // They will be printed all at once *after* the install
            const tipIDsToBePrinted = new Set();
            const pnpmTips = [];
            for (const [customTipId, customTip] of Object.entries(_api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_12__.PNPM_CUSTOM_TIPS)) {
                if (this.rushConfiguration.customTipsConfiguration.providedCustomTipsByTipId.has(customTipId)) {
                    pnpmTips.push(customTip);
                }
            }
            const onPnpmStdoutChunk = pnpmTips.length > 0
                ? (chunk) => {
                    // Iterate over the supported custom tip metadata and try to match the chunk.
                    for (const { isMatch, tipId } of pnpmTips) {
                        if (isMatch === null || isMatch === void 0 ? void 0 : isMatch(chunk)) {
                            tipIDsToBePrinted.add(tipId);
                        }
                    }
                }
                : undefined;
            try {
                await _utilities_Utilities__WEBPACK_IMPORTED_MODULE_11__.Utilities.executeCommandAndProcessOutputWithRetryAsync({
                    command: packageManagerFilename,
                    args: installArgs,
                    workingDirectory: this.rushConfiguration.commonTempFolder,
                    environment: packageManagerEnv,
                    suppressOutput: false
                }, this.options.maxInstallAttempts, onPnpmStdoutChunk, () => {
                    if (this.rushConfiguration.packageManager === 'pnpm') {
                        this._terminal.writeWarningLine(`Deleting the "node_modules" folder`);
                        this.installRecycler.moveFolder(commonNodeModulesFolder);
                        // Leave the pnpm-store as is for the retry. This ensures that packages that have already
                        // been downloaded need not be downloaded again, thereby potentially increasing the chances
                        // of a subsequent successful install.
                        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_11__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                    }
                });
            }
            finally {
                // The try-finally is to avoid the tips NOT being printed if the install fails.
                // NOT catching the error because we want to keep the other behaviors (i.e., the error will be caught and handle in upper layers).
                if (tipIDsToBePrinted.size > 0) {
                    this._terminal.writeLine();
                    for (const tipID of tipIDsToBePrinted) {
                        this.rushConfiguration.customTipsConfiguration._showTip(this._terminal, tipID);
                    }
                }
            }
        };
        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
        if (this.options.allowShrinkwrapUpdates &&
            experiments.usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate) {
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { onlyShrinkwrap: true }));
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { allowShrinkwrapUpdates: false }));
        }
        else {
            await doInstallInternalAsync(this.options);
        }
        // If all attempts fail we just terminate. No special handling needed.
        // Ensure that node_modules folders exist after install, since the timestamps on these folders are used
        // to determine if the install can be skipped
        const projectNodeModulesFolders = [
            path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonTempFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.nodeModulesFolderName),
            ...this.rushConfiguration.projects.map((project) => {
                return path__WEBPACK_IMPORTED_MODULE_1__.join(project.projectFolder, _logic_RushConstants__WEBPACK_IMPORTED_MODULE_6__.RushConstants.nodeModulesFolderName);
            })
        ];
        for (const nodeModulesFolder of projectNodeModulesFolders) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.ensureFolder(nodeModulesFolder);
        }
        // eslint-disable-next-line no-console
        console.log('');
    }
    async postInstallAsync() {
        var _a;
        // Grab the temp shrinkwrap, as this was the most recently completed install. It may also be
        // more up-to-date than the checked-in shrinkwrap since filtered installs are not written back.
        // Note that if there are no projects, or if we're in PNPM workspace mode and there are no
        // projects with dependencies, a lockfile won't be generated.
        const tempShrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_13__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, this.rushConfiguration.pnpmOptions, this.rushConfiguration.tempShrinkwrapFilename);
        if (tempShrinkwrapFile) {
            // Write or delete all project shrinkwraps related to the install
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.forEachAsync(this.rushConfiguration.projects, async (project) => {
                var _a;
                await ((_a = tempShrinkwrapFile.getProjectShrinkwrap(project)) === null || _a === void 0 ? void 0 : _a.updateProjectShrinkwrapAsync());
            }, { concurrency: 10 });
        }
        else if (this.rushConfiguration.packageManager === 'pnpm' &&
            ((_a = this.rushConfiguration.pnpmOptions) === null || _a === void 0 ? void 0 : _a.useWorkspaces)) {
            // If we're in PNPM workspace mode and PNPM didn't create a shrinkwrap file,
            // there are no dependencies. Generate empty shrinkwrap files for all projects.
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.forEachAsync(this.rushConfiguration.projects, async (project) => {
                await _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_14__.BaseProjectShrinkwrapFile.saveEmptyProjectShrinkwrapFileAsync(project);
            }, { concurrency: 10 });
        }
        else {
            // This is an unexpected case
            throw new Error('A shrinkwrap file does not exist after after successful installation. This probably indicates a ' +
                'bug in the package manager.');
        }
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        _api_LastLinkFlag__WEBPACK_IMPORTED_MODULE_15__.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration).create();
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options) {
        super.pushConfigurationArgs(args, options);
        // Add workspace-specific args
        if (this.rushConfiguration.packageManager === 'pnpm') {
            args.push('--recursive');
            args.push('--link-workspace-packages', 'false');
            if (process.stdout.isTTY) {
                // If we're on a TTY console and something else didn't set a `--reporter` parameter,
                // explicitly set the default reporter. This fixes an issue where, when the pnpm
                // output is being monitored to match custom tips, pnpm will detect a non-TTY
                // stdout stream and use the `append-only` reporter.
                //
                // See docs here: https://pnpm.io/cli/install#--reportername
                let includesReporterArg = false;
                for (const arg of args) {
                    if (arg.startsWith('--reporter')) {
                        includesReporterArg = true;
                        break;
                    }
                }
                if (!includesReporterArg) {
                    args.push('--reporter', 'default');
                }
            }
            for (const arg of this.options.pnpmFilterArguments) {
                args.push(arg);
            }
        }
    }
}
//# sourceMappingURL=WorkspaceInstallManager.js.map

/***/ }),

/***/ 688477:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpmWorkspaceFile": () => (/* binding */ PnpmWorkspaceFile)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/BaseWorkspaceFile */ 896704);
/* harmony import */ var _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PnpmYamlCommon */ 730862);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const yamlModule = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Import.lazy('js-yaml', require);
const globEscape = __webpack_require__(/*! glob-escape */ 475376); // No @types/glob-escape package exists
class PnpmWorkspaceFile extends _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__.BaseWorkspaceFile {
    /**
     * The PNPM workspace file is used to specify the location of workspaces relative to the root
     * of your PNPM install.
     */
    constructor(workspaceYamlFilename) {
        super();
        this.workspaceFilename = workspaceYamlFilename;
        // Ignore any existing file since this file is generated and we need to handle deleting packages
        // If we need to support manual customization, that should be an additional parameter for "base file"
        this._workspacePackages = new Set();
    }
    /** @override */
    addPackage(packagePath) {
        // Ensure the path is relative to the pnpm-workspace.yaml file
        if (path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute(packagePath)) {
            packagePath = path__WEBPACK_IMPORTED_MODULE_0__.relative(path__WEBPACK_IMPORTED_MODULE_0__.dirname(this.workspaceFilename), packagePath);
        }
        // Glob can't handle Windows paths
        const globPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Path.convertToSlashes(packagePath);
        this._workspacePackages.add(globEscape(globPath));
    }
    /** @override */
    serialize() {
        // Ensure stable sort order when serializing
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortSet(this._workspacePackages);
        const workspaceYaml = {
            packages: Array.from(this._workspacePackages)
        };
        return yamlModule.safeDump(workspaceYaml, _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
}
//# sourceMappingURL=PnpmWorkspaceFile.js.map

/***/ })

};
;
//# sourceMappingURL=InstallManagerFactory.js.map