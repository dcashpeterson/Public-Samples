{"version":3,"file":"AssetProcessor.js","sourceRoot":"","sources":["../src/AssetProcessor.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAI3D,qDAAkD;AA8ErC,QAAA,iBAAiB,GAAW,IAAI,MAAM,CACjD,GAAG,qBAAS,CAAC,yBAAyB,uCAAuC,EAC7E,GAAG,CACJ,CAAC;AAEF,MAAa,cAAc;IAClB,MAAM,CAAC,qBAAqB,CACjC,OAAsC;QAEtC,MAAM,WAAW,GAAW,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QAEnD,MAAM,WAAW,GAAiB,cAAc,CAAC,oCAAoC,CACnF,OAAO,CAAC,MAAM,EACd,WAAW,EACX,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,wBAAwB,EAAE,OAAO,CAAC,mBAAmB,CAAC,CACrG,CAAC;QACF,MAAM,kBAAkB,GAAmC,cAAc,CAAC,qBAAqB,CAC7F,WAAW,CAAC,oBAAoB,EAChC,OAAO,CAAC,OAAO,EACf,OAAO,CAAC,6BAA6B,EACrC,OAAO,CAAC,aAAa,EACrB,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,CACrB,CAAC;QAEF,MAAM,eAAe,GAAiB,cAAc,CAAC,oCAAoC,CACvF,OAAO,CAAC,MAAM,EACd,OAAO,CAAC,SAAS,EACjB,GAAG,EAAE;YACH,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;QACjC,CAAC,CACF,CAAC;QACF,MAAM,sBAAsB,GAAmC,cAAc,CAAC,qBAAqB,CACjG,eAAe,CAAC,oBAAoB,EACpC,OAAO,CAAC,OAAO,EACf,OAAO,CAAC,6BAA6B,EACrC,OAAO,CAAC,aAAa,EACrB,OAAO,CAAC,SAAS,CAAC,MAAM,CACzB,CAAC;QAEF,MAAM,MAAM,GAAqC,IAAI,GAAG,EAA+B,CAAC;QACxF,KAAK,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,IAAI,kBAAkB,CAAC,MAAM,EAAE;YAClE,MAAM,QAAQ,qBAAgB,OAAO,CAAC,KAAK,CAAE,CAAC;YAC9C,QAAQ,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC;YAC/B,QAAQ,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;YAE3B,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE;gBACjB,QAAQ,EAAE,sBAAsB,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,MAAM;gBAC3D,KAAK,EAAE,QAAQ;aAChB,CAAC,CAAC;SACJ;QAED,MAAM,MAAM,GAAa;YACvB,GAAG,WAAW,CAAC,MAAM;YACrB,GAAG,kBAAkB,CAAC,MAAM;YAC5B,GAAG,eAAe,CAAC,MAAM;YACzB,GAAG,sBAAsB,CAAC,MAAM;SACjC,CAAC;QAEF,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAC7B,KAAK,CAAC,kBAAkB,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAC1E,CAAC;SACH;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,MAAM,CAAC,wBAAwB,CAAC,OAAyC;QAC9E,MAAM,WAAW,GAAW,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QAEnD,MAAM,WAAW,GAAiB,cAAc,CAAC,oCAAoC,CACnF,OAAO,CAAC,MAAM,EACd,WAAW,EACX,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,wBAAwB,EAAE,OAAO,CAAC,mBAAmB,CAAC,CACrG,CAAC;QACF,MAAM,kBAAkB,GAAsC,cAAc,CAAC,wBAAwB,CACnG,WAAW,CAAC,oBAAoB,EAChC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,EACpB,OAAO,CAAC,mBAAmB,CAC5B,CAAC;QAEF,MAAM,eAAe,GAAiB,cAAc,CAAC,oCAAoC,CACvF,OAAO,CAAC,MAAM,EACd,OAAO,CAAC,SAAS,EACjB,GAAG,EAAE;YACH,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;QACjC,CAAC,CACF,CAAC;QACF,MAAM,sBAAsB,GAAsC,cAAc,CAAC,wBAAwB,CACvG,eAAe,CAAC,oBAAoB,EACpC,OAAO,CAAC,SAAS,CAAC,MAAM,EACxB,OAAO,CAAC,mBAAmB,CAC5B,CAAC;QAEF,MAAM,MAAM,GAAa;YACvB,GAAG,WAAW,CAAC,MAAM;YACrB,GAAG,kBAAkB,CAAC,MAAM;YAC5B,GAAG,eAAe,CAAC,MAAM;YACzB,GAAG,sBAAsB,CAAC,MAAM;SACjC,CAAC;QAEF,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAC7B,KAAK,CAAC,kBAAkB,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAC1E,CAAC;SACH;QAED,MAAM,QAAQ,qBAAgB,OAAO,CAAC,KAAK,CAAE,CAAC;QAC9C,QAAQ,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,MAAM,CAAC;QACzD,QAAQ,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC;QACrD,OAAO;YACL,QAAQ,EAAE,sBAAsB,CAAC,MAAM,CAAC,MAAM;YAC9C,KAAK,EAAE,QAAQ;SAChB,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,qBAAqB,CAClC,oBAA8C,EAC9C,OAAoB,EACpB,6BAAsC,EACtC,aAAqB,EACrB,WAAmB;QAEnB,MAAM,gBAAgB,GAAsC,IAAI,GAAG,EAAgC,CAAC;QACpG,MAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC5B,MAAM,cAAc,GAAa,EAAE,CAAC;YAEpC,IAAI,QAAQ,GAAW,CAAC,CAAC;YACzB,KAAK,MAAM,OAAO,IAAI,oBAAoB,EAAE;gBAC1C,QAAQ,OAAO,CAAC,IAAI,EAAE;oBACpB,KAAK,QAAQ,CAAC,CAAC;wBACb,cAAc,CAAC,IAAI,CAAE,OAAwC,CAAC,YAAY,CAAC,CAAC;wBAC5E,MAAM;qBACP;oBAED,KAAK,WAAW,CAAC,CAAC;wBAChB,MAAM,gBAAgB,GACpB,OAA0C,CAAC;wBAC7C,IAAI,QAAQ,GAAuB,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;wBACnE,IAAI,CAAC,QAAQ,EAAE;4BACb,IAAI,6BAA6B,EAAE;gCACjC,QAAQ,GAAG,gBAAgB,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;6BACnD;iCAAM;gCACL,MAAM,CAAC,IAAI,CACT,eAAe,gBAAgB,CAAC,UAAU,SAAS,gBAAgB,CAAC,WAAW,kBAAkB;oCAC/F,cAAc,MAAM,EAAE,CACzB,CAAC;gCAEF,QAAQ,GAAG,sBAAsB,CAAC;6BACnC;yBACF;wBAED,MAAM,gBAAgB,GAAW,gBAAgB,CAAC,gBAAgB,IAAI,IAAI,CAAC;wBAE3E,0DAA0D;wBAC1D,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;wBAErD,wEAAwE;wBACxE,MAAM,yBAAyB,GAAW,gBAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBAE/F,yFAAyF;wBACzF,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,yBAAyB,GAAG,CAAC,CAAC;wBACpE,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,yBAAyB,GAAG,CAAC,CAAC;wBACpE,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,yBAAyB,GAAG,CAAC,CAAC;wBACpE,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,yBAAyB,OAAO,CAAC,CAAC;wBACxE,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,yBAAyB,OAAO,CAAC,CAAC;wBAExE,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAC9B,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,gBAAgB,CAAC,IAAI,CAAC;wBACpD,MAAM;qBACP;oBAED,KAAK,SAAS,CAAC,CAAC;wBACd,MAAM,cAAc,GAAkC,OAAwC,CAAC;wBAC/F,MAAM,QAAQ,GAAW,cAAc,CAAC,OAAO,CAAC,MAAM,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;wBAC9E,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAC9B,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC;wBAClD,MAAM;qBACP;iBACF;aACF;YAED,MAAM,cAAc,GAAW,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACvD,gBAAgB,CAAC,GAAG,CAAC,MAAM,EAAE;gBAC3B,MAAM,EAAE,cAAc;gBACtB,IAAI,EAAE,WAAW,GAAG,QAAQ;aAC7B,CAAC,CAAC;SACJ;QAED,OAAO;YACL,MAAM;YACN,MAAM,EAAE,gBAAgB;SACzB,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,wBAAwB,CACrC,oBAA8C,EAC9C,WAAmB,EACnB,mBAA2B;QAE3B,MAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,MAAM,cAAc,GAAa,EAAE,CAAC;QAEpC,IAAI,QAAQ,GAAW,CAAC,CAAC;QACzB,KAAK,MAAM,OAAO,IAAI,oBAAoB,EAAE;YAC1C,QAAQ,OAAO,CAAC,IAAI,EAAE;gBACpB,KAAK,QAAQ,CAAC,CAAC;oBACb,cAAc,CAAC,IAAI,CAAE,OAAwC,CAAC,YAAY,CAAC,CAAC;oBAC5E,MAAM;iBACP;gBAED,KAAK,WAAW,CAAC,CAAC;oBAChB,MAAM,gBAAgB,GACpB,OAA0C,CAAC;oBAC7C,MAAM,CAAC,IAAI,CACT,eAAe,gBAAgB,CAAC,UAAU,SAAS,gBAAgB,CAAC,WAAW,yBAAyB;wBACtG,sDAAsD,CACzD,CAAC;oBAEF,MAAM,QAAQ,GAAW,oCAAoC,CAAC;oBAC9D,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAC9B,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,gBAAgB,CAAC,IAAI,CAAC;oBACpD,MAAM;iBACP;gBAED,KAAK,SAAS,CAAC,CAAC;oBACd,MAAM,cAAc,GAAkC,OAAwC,CAAC;oBAC/F,MAAM,QAAQ,GAAW,cAAc,CAAC,OAAO,CAAC,mBAAmB,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;oBAC3F,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAC9B,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC;oBAClD,MAAM;iBACP;aACF;SACF;QAED,MAAM,cAAc,GAAW,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACvD,OAAO;YACL,MAAM;YACN,MAAM,EAAE;gBACN,MAAM,EAAE,cAAc;gBACtB,IAAI,EAAE,WAAW,GAAG,QAAQ;aAC7B;SACF,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,oCAAoC,CACjD,MAA0B,EAC1B,MAAc,EACd,aAA2E;QAE3E,MAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,MAAM,oBAAoB,GAA6B,EAAE,CAAC;QAE1D,IAAI,SAAS,GAAW,CAAC,CAAC;QAC1B,IAAI,WAAmC,CAAC;QACxC,OAAO,CAAC,WAAW,GAAG,yBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;YACrD,qCAAqC;YACrC,MAAM,aAAa,GAAiC;gBAClD,IAAI,EAAE,QAAQ;gBACd,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC,KAAK,CAAC;aAC7D,CAAC;YACF,oBAAoB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAEzC,MAAM,CAAC,WAAW,EAAE,gBAAgB,EAAE,YAAY,EAAE,KAAK,EAAE,uBAAuB,CAAC,GAAG,WAAW,CAAC;YAElG,IAAI,8BAAsD,CAAC;YAC3D,QAAQ,YAAY,EAAE;gBACpB,KAAK,qBAAS,CAAC,wBAAwB,CAAC,CAAC;oBACvC,MAAM,UAAU,GAA4B,MAAM,CAAC,sBAAsB,CAAC,uBAAuB,CAAC,CAAC;oBACnG,IAAI,CAAC,UAAU,EAAE;wBACf,MAAM,CAAC,IAAI,CAAC,uBAAuB,WAAW,EAAE,CAAC,CAAC;wBAClD,MAAM,sBAAsB,GAAiC;4BAC3D,IAAI,EAAE,QAAQ;4BACd,YAAY,EAAE,WAAW;yBAC1B,CAAC;wBACF,8BAA8B,GAAG,sBAAsB,CAAC;qBACzD;yBAAM;wBACL,MAAM,gBAAgB,GAAoC;4BACxD,IAAI,EAAE,WAAW;4BACjB,MAAM,EAAE,UAAU,CAAC,MAAM;4BACzB,IAAI,EAAE,WAAW,CAAC,MAAM;4BACxB,WAAW,EAAE,UAAU,CAAC,WAAW;4BACnC,gBAAgB,EAAE,gBAAgB;4BAClC,UAAU,EAAE,UAAU,CAAC,UAAU;yBAClC,CAAC;wBACF,8BAA8B,GAAG,gBAAgB,CAAC;qBACnD;oBACD,MAAM;iBACP;gBAED,KAAK,qBAAS,CAAC,6BAA6B,CAAC,CAAC;oBAC5C,MAAM,cAAc,GAAkC;wBACpD,IAAI,EAAE,SAAS;wBACf,OAAO,EAAE,CAAC,MAAc,EAAE,EAAE,CAAC,MAAM;wBACnC,IAAI,EAAE,WAAW,CAAC,MAAM;wBACxB,gBAAgB,EAAE,gBAAgB;qBACnC,CAAC;oBACF,8BAA8B,GAAG,cAAc,CAAC;oBAChD,MAAM;iBACP;gBAED,KAAK,qBAAS,CAAC,uBAAuB,CAAC,CAAC;oBACtC,MAAM,cAAc,GAAkC;wBACpD,IAAI,EAAE,SAAS;wBACf,OAAO,EAAE,aAAa;wBACtB,IAAI,EAAE,WAAW,CAAC,MAAM;wBACxB,gBAAgB,EAAE,gBAAgB;wBAClC,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;qBAC5C,CAAC;oBACF,8BAA8B,GAAG,cAAc,CAAC;oBAChD,MAAM;iBACP;gBAED,OAAO,CAAC,CAAC;oBACP,MAAM,IAAI,KAAK,CAAC,oBAAoB,YAAY,EAAE,CAAC,CAAC;iBACrD;aACF;YAED,oBAAoB,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;YAC1D,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,WAAW,CAAC,MAAM,CAAC;SACpD;QAED,MAAM,WAAW,GAAiC;YAChD,IAAI,EAAE,QAAQ;YACd,YAAY,EAAE,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC;SACvC,CAAC;QACF,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAEvC,OAAO;YACL,MAAM;YACN,oBAAoB;SACrB,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAC9B,KAAgC,EAChC,wBAAuE,EACvE,mBAA2B;QAE3B,MAAM,cAAc,GAAyB,IAAI,GAAG,EAAmB,CAAC;QACxE,MAAM,iBAAiB,GAAyB,IAAI,GAAG,EAAmB,CAAC;QAE3E,MAAM,WAAW,GAAmC,KAAK,CAAC,iBAAiB,EAAE,CAAC;QAC9E,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,MAAM,OAAO,GAA2B,UAAU,CAAC,EAAE,CAAC;YAEtD,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,KAAK,SAAS,EAAE;gBAC7C,MAAM,IAAI,KAAK,CAAC,UAAU,UAAU,CAAC,IAAI,8BAA8B,CAAC,CAAC;aAC1E;YAED,IAAI,wBAAwB,CAAC,UAAU,CAAC,EAAE;gBACxC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;aAC7B;iBAAM;gBACL,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;aAChC;SACF;QAED,IAAI,cAAc,CAAC,IAAI,KAAK,CAAC,EAAE;YAC7B,OAAO,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,CAAC;SAClD;aAAM,IAAI,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE;YACvC,OAAO,CAAC,MAAc,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SACnD;aAAM;YACL,sGAAsG;YACtG,yGAAyG;YACzG,UAAU;YACV,EAAE;YACF,2GAA2G;YAC3G,oDAAoD;YACpD,MAAM,YAAY,GAAkC,EAAE,CAAC;YACvD,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;gBAC1C,YAAY,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;aACjC;YAED,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE;gBAChD,YAAY,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;aACpC;YAED,OAAO,CAAC,MAAc,EAAE,YAAgC,EAAE,EAAE;gBAC1D,IAAI,CAAC,MAAM,EAAE;oBACX,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;iBACzC;gBAED,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC,KAAK,IAAI,CAAC,SAAS,CACzE,YAAY,CACb,IAAI,YAAY,IAAI,CAAC;YACxB,CAAC,CAAC;SACH;IACH,CAAC;CACF;AAlYD,wCAkYC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as Webpack from 'webpack';\n\nimport { Constants } from './utilities/Constants';\nimport type { ILocaleElementMap } from './interfaces';\nimport type { LocalizationPlugin, IStringSerialNumberData as IStringData } from './LocalizationPlugin';\n\ninterface IReconstructionElement {\n  kind: 'static' | 'localized' | 'dynamic';\n}\n\ninterface IStaticReconstructionElement extends IReconstructionElement {\n  kind: 'static';\n  staticString: string;\n}\n\ninterface ILocalizedReconstructionElement extends IReconstructionElement {\n  kind: 'localized';\n  values: ILocaleElementMap;\n  size: number;\n  stringName: string;\n  escapedBackslash: string;\n  locFilePath: string;\n}\n\ninterface IDynamicReconstructionElement extends IReconstructionElement {\n  kind: 'dynamic';\n  valueFn: (locale: string, token: string | undefined) => string;\n  size: number;\n  escapedBackslash: string;\n  token?: string;\n}\n\ninterface IParseResult {\n  issues: string[];\n  reconstructionSeries: IReconstructionElement[];\n}\n\ninterface IReconstructedString {\n  source: string;\n  size: number;\n}\n\ninterface ILocalizedReconstructionResult {\n  result: Map<string, IReconstructedString>;\n  issues: string[];\n}\n\ninterface INonLocalizedReconstructionResult {\n  result: IReconstructedString;\n  issues: string[];\n}\n\nexport interface IProcessAssetOptionsBase {\n  plugin: LocalizationPlugin;\n  compilation: Webpack.compilation.Compilation;\n  assetName: string;\n  asset: IAsset;\n  chunk: Webpack.compilation.Chunk;\n  noStringsLocaleName: string;\n  chunkHasLocalizedModules: (chunk: Webpack.compilation.Chunk) => boolean;\n}\n\nexport interface IProcessNonLocalizedAssetOptions extends IProcessAssetOptionsBase {}\n\nexport interface IProcessLocalizedAssetOptions extends IProcessAssetOptionsBase {\n  locales: Set<string>;\n  fillMissingTranslationStrings: boolean;\n  defaultLocale: string;\n}\n\nexport interface IAsset {\n  size(): number;\n  source(): string;\n}\n\nexport interface IProcessAssetResult {\n  filename: string;\n  asset: IAsset;\n}\n\nexport const PLACEHOLDER_REGEX: RegExp = new RegExp(\n  `${Constants.STRING_PLACEHOLDER_PREFIX}_(\\\\\\\\*)_([A-C])(\\\\+[^+]+\\\\+)?_(\\\\d+)`,\n  'g'\n);\n\nexport class AssetProcessor {\n  public static processLocalizedAsset(\n    options: IProcessLocalizedAssetOptions\n  ): Map<string, IProcessAssetResult> {\n    const assetSource: string = options.asset.source();\n\n    const parsedAsset: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\n      options.plugin,\n      assetSource,\n      this._getJsonpFunction(options.chunk, options.chunkHasLocalizedModules, options.noStringsLocaleName)\n    );\n    const reconstructedAsset: ILocalizedReconstructionResult = AssetProcessor._reconstructLocalized(\n      parsedAsset.reconstructionSeries,\n      options.locales,\n      options.fillMissingTranslationStrings,\n      options.defaultLocale,\n      options.asset.size()\n    );\n\n    const parsedAssetName: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\n      options.plugin,\n      options.assetName,\n      () => {\n        throw new Error('unsupported');\n      }\n    );\n    const reconstructedAssetName: ILocalizedReconstructionResult = AssetProcessor._reconstructLocalized(\n      parsedAssetName.reconstructionSeries,\n      options.locales,\n      options.fillMissingTranslationStrings,\n      options.defaultLocale,\n      options.assetName.length\n    );\n\n    const result: Map<string, IProcessAssetResult> = new Map<string, IProcessAssetResult>();\n    for (const [locale, { source, size }] of reconstructedAsset.result) {\n      const newAsset: IAsset = { ...options.asset };\n      newAsset.source = () => source;\n      newAsset.size = () => size;\n\n      result.set(locale, {\n        filename: reconstructedAssetName.result.get(locale)!.source,\n        asset: newAsset\n      });\n    }\n\n    const issues: string[] = [\n      ...parsedAsset.issues,\n      ...reconstructedAsset.issues,\n      ...parsedAssetName.issues,\n      ...reconstructedAssetName.issues\n    ];\n\n    if (issues.length > 0) {\n      options.compilation.errors.push(\n        Error(`localization:\\n${issues.map((issue) => `  ${issue}`).join('\\n')}`)\n      );\n    }\n\n    return result;\n  }\n\n  public static processNonLocalizedAsset(options: IProcessNonLocalizedAssetOptions): IProcessAssetResult {\n    const assetSource: string = options.asset.source();\n\n    const parsedAsset: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\n      options.plugin,\n      assetSource,\n      this._getJsonpFunction(options.chunk, options.chunkHasLocalizedModules, options.noStringsLocaleName)\n    );\n    const reconstructedAsset: INonLocalizedReconstructionResult = AssetProcessor._reconstructNonLocalized(\n      parsedAsset.reconstructionSeries,\n      options.asset.size(),\n      options.noStringsLocaleName\n    );\n\n    const parsedAssetName: IParseResult = AssetProcessor._parseStringToReconstructionSequence(\n      options.plugin,\n      options.assetName,\n      () => {\n        throw new Error('unsupported');\n      }\n    );\n    const reconstructedAssetName: INonLocalizedReconstructionResult = AssetProcessor._reconstructNonLocalized(\n      parsedAssetName.reconstructionSeries,\n      options.assetName.length,\n      options.noStringsLocaleName\n    );\n\n    const issues: string[] = [\n      ...parsedAsset.issues,\n      ...reconstructedAsset.issues,\n      ...parsedAssetName.issues,\n      ...reconstructedAssetName.issues\n    ];\n\n    if (issues.length > 0) {\n      options.compilation.errors.push(\n        Error(`localization:\\n${issues.map((issue) => `  ${issue}`).join('\\n')}`)\n      );\n    }\n\n    const newAsset: IAsset = { ...options.asset };\n    newAsset.source = () => reconstructedAsset.result.source;\n    newAsset.size = () => reconstructedAsset.result.size;\n    return {\n      filename: reconstructedAssetName.result.source,\n      asset: newAsset\n    };\n  }\n\n  private static _reconstructLocalized(\n    reconstructionSeries: IReconstructionElement[],\n    locales: Set<string>,\n    fillMissingTranslationStrings: boolean,\n    defaultLocale: string,\n    initialSize: number\n  ): ILocalizedReconstructionResult {\n    const localizedResults: Map<string, IReconstructedString> = new Map<string, IReconstructedString>();\n    const issues: string[] = [];\n\n    for (const locale of locales) {\n      const reconstruction: string[] = [];\n\n      let sizeDiff: number = 0;\n      for (const element of reconstructionSeries) {\n        switch (element.kind) {\n          case 'static': {\n            reconstruction.push((element as IStaticReconstructionElement).staticString);\n            break;\n          }\n\n          case 'localized': {\n            const localizedElement: ILocalizedReconstructionElement =\n              element as ILocalizedReconstructionElement;\n            let newValue: string | undefined = localizedElement.values[locale];\n            if (!newValue) {\n              if (fillMissingTranslationStrings) {\n                newValue = localizedElement.values[defaultLocale];\n              } else {\n                issues.push(\n                  `The string \"${localizedElement.stringName}\" in \"${localizedElement.locFilePath}\" is missing in ` +\n                    `the locale ${locale}`\n                );\n\n                newValue = '-- MISSING STRING --';\n              }\n            }\n\n            const escapedBackslash: string = localizedElement.escapedBackslash || '\\\\';\n\n            // Replace backslashes with the properly escaped backslash\n            newValue = newValue.replace(/\\\\/g, escapedBackslash);\n\n            // @todo: look into using JSON.parse(...) to get the escaping characters\n            const escapingCharacterSequence: string = escapedBackslash.substr(escapedBackslash.length / 2);\n\n            // Ensure the the quotemark, apostrophe, tab, and newline characters are properly escaped\n            newValue = newValue.replace(/\\r/g, `${escapingCharacterSequence}r`);\n            newValue = newValue.replace(/\\n/g, `${escapingCharacterSequence}n`);\n            newValue = newValue.replace(/\\t/g, `${escapingCharacterSequence}t`);\n            newValue = newValue.replace(/\\\"/g, `${escapingCharacterSequence}u0022`);\n            newValue = newValue.replace(/\\'/g, `${escapingCharacterSequence}u0027`);\n\n            reconstruction.push(newValue);\n            sizeDiff += newValue.length - localizedElement.size;\n            break;\n          }\n\n          case 'dynamic': {\n            const dynamicElement: IDynamicReconstructionElement = element as IDynamicReconstructionElement;\n            const newValue: string = dynamicElement.valueFn(locale, dynamicElement.token);\n            reconstruction.push(newValue);\n            sizeDiff += newValue.length - dynamicElement.size;\n            break;\n          }\n        }\n      }\n\n      const newAssetSource: string = reconstruction.join('');\n      localizedResults.set(locale, {\n        source: newAssetSource,\n        size: initialSize + sizeDiff\n      });\n    }\n\n    return {\n      issues,\n      result: localizedResults\n    };\n  }\n\n  private static _reconstructNonLocalized(\n    reconstructionSeries: IReconstructionElement[],\n    initialSize: number,\n    noStringsLocaleName: string\n  ): INonLocalizedReconstructionResult {\n    const issues: string[] = [];\n\n    const reconstruction: string[] = [];\n\n    let sizeDiff: number = 0;\n    for (const element of reconstructionSeries) {\n      switch (element.kind) {\n        case 'static': {\n          reconstruction.push((element as IStaticReconstructionElement).staticString);\n          break;\n        }\n\n        case 'localized': {\n          const localizedElement: ILocalizedReconstructionElement =\n            element as ILocalizedReconstructionElement;\n          issues.push(\n            `The string \"${localizedElement.stringName}\" in \"${localizedElement.locFilePath}\" appeared in an asset ` +\n              'that is not expected to contain localized resources.'\n          );\n\n          const newValue: string = '-- NOT EXPECTED TO BE LOCALIZED --';\n          reconstruction.push(newValue);\n          sizeDiff += newValue.length - localizedElement.size;\n          break;\n        }\n\n        case 'dynamic': {\n          const dynamicElement: IDynamicReconstructionElement = element as IDynamicReconstructionElement;\n          const newValue: string = dynamicElement.valueFn(noStringsLocaleName, dynamicElement.token);\n          reconstruction.push(newValue);\n          sizeDiff += newValue.length - dynamicElement.size;\n          break;\n        }\n      }\n    }\n\n    const newAssetSource: string = reconstruction.join('');\n    return {\n      issues,\n      result: {\n        source: newAssetSource,\n        size: initialSize + sizeDiff\n      }\n    };\n  }\n\n  private static _parseStringToReconstructionSequence(\n    plugin: LocalizationPlugin,\n    source: string,\n    jsonpFunction: (locale: string, chunkIdToken: string | undefined) => string\n  ): IParseResult {\n    const issues: string[] = [];\n    const reconstructionSeries: IReconstructionElement[] = [];\n\n    let lastIndex: number = 0;\n    let regexResult: RegExpExecArray | null;\n    while ((regexResult = PLACEHOLDER_REGEX.exec(source))) {\n      // eslint-disable-line no-cond-assign\n      const staticElement: IStaticReconstructionElement = {\n        kind: 'static',\n        staticString: source.substring(lastIndex, regexResult.index)\n      };\n      reconstructionSeries.push(staticElement);\n\n      const [placeholder, escapedBackslash, elementLabel, token, placeholderSerialNumber] = regexResult;\n\n      let localizedReconstructionElement: IReconstructionElement;\n      switch (elementLabel) {\n        case Constants.STRING_PLACEHOLDER_LABEL: {\n          const stringData: IStringData | undefined = plugin.getDataForSerialNumber(placeholderSerialNumber);\n          if (!stringData) {\n            issues.push(`Missing placeholder ${placeholder}`);\n            const brokenLocalizedElement: IStaticReconstructionElement = {\n              kind: 'static',\n              staticString: placeholder\n            };\n            localizedReconstructionElement = brokenLocalizedElement;\n          } else {\n            const localizedElement: ILocalizedReconstructionElement = {\n              kind: 'localized',\n              values: stringData.values,\n              size: placeholder.length,\n              locFilePath: stringData.locFilePath,\n              escapedBackslash: escapedBackslash,\n              stringName: stringData.stringName\n            };\n            localizedReconstructionElement = localizedElement;\n          }\n          break;\n        }\n\n        case Constants.LOCALE_NAME_PLACEHOLDER_LABEL: {\n          const dynamicElement: IDynamicReconstructionElement = {\n            kind: 'dynamic',\n            valueFn: (locale: string) => locale,\n            size: placeholder.length,\n            escapedBackslash: escapedBackslash\n          };\n          localizedReconstructionElement = dynamicElement;\n          break;\n        }\n\n        case Constants.JSONP_PLACEHOLDER_LABEL: {\n          const dynamicElement: IDynamicReconstructionElement = {\n            kind: 'dynamic',\n            valueFn: jsonpFunction,\n            size: placeholder.length,\n            escapedBackslash: escapedBackslash,\n            token: token.substring(1, token.length - 1)\n          };\n          localizedReconstructionElement = dynamicElement;\n          break;\n        }\n\n        default: {\n          throw new Error(`Unexpected label ${elementLabel}`);\n        }\n      }\n\n      reconstructionSeries.push(localizedReconstructionElement);\n      lastIndex = regexResult.index + placeholder.length;\n    }\n\n    const lastElement: IStaticReconstructionElement = {\n      kind: 'static',\n      staticString: source.substr(lastIndex)\n    };\n    reconstructionSeries.push(lastElement);\n\n    return {\n      issues,\n      reconstructionSeries\n    };\n  }\n\n  private static _getJsonpFunction(\n    chunk: Webpack.compilation.Chunk,\n    chunkHasLocalizedModules: (chunk: Webpack.compilation.Chunk) => boolean,\n    noStringsLocaleName: string\n  ): (locale: string, chunkIdToken: string | undefined) => string {\n    const idsWithStrings: Set<number | string> = new Set<number | string>();\n    const idsWithoutStrings: Set<number | string> = new Set<number | string>();\n\n    const asyncChunks: Set<Webpack.compilation.Chunk> = chunk.getAllAsyncChunks();\n    for (const asyncChunk of asyncChunks) {\n      const chunkId: number | string | null = asyncChunk.id;\n\n      if (chunkId === null || chunkId === undefined) {\n        throw new Error(`Chunk \"${asyncChunk.name}\"'s ID is null or undefined.`);\n      }\n\n      if (chunkHasLocalizedModules(asyncChunk)) {\n        idsWithStrings.add(chunkId);\n      } else {\n        idsWithoutStrings.add(chunkId);\n      }\n    }\n\n    if (idsWithStrings.size === 0) {\n      return () => JSON.stringify(noStringsLocaleName);\n    } else if (idsWithoutStrings.size === 0) {\n      return (locale: string) => JSON.stringify(locale);\n    } else {\n      // Generate an array [<locale>, <nostrings locale>] and an object that is used as an indexer into that\n      // object that maps chunk IDs to 0s for chunks with localized strings and 1s for chunks without localized\n      // strings\n      //\n      // This can be improved in the future. We can maybe sort the chunks such that the chunks below a certain ID\n      // number are localized and the those above are not.\n      const chunkMapping: { [chunkId: string]: number } = {};\n      for (const idWithStrings of idsWithStrings) {\n        chunkMapping[idWithStrings] = 0;\n      }\n\n      for (const idWithoutStrings of idsWithoutStrings) {\n        chunkMapping[idWithoutStrings] = 1;\n      }\n\n      return (locale: string, chunkIdToken: string | undefined) => {\n        if (!locale) {\n          throw new Error('Missing locale name.');\n        }\n\n        return `(${JSON.stringify([locale, noStringsLocaleName])})[${JSON.stringify(\n          chunkMapping\n        )}[${chunkIdToken}]]`;\n      };\n    }\n  }\n}\n"]}