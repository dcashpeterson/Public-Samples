"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CmdRunner = void 0;
const childProcess = require("child_process");
const path = require("path");
const node_core_library_1 = require("@rushstack/node-core-library");
/**
 * This base task provides support for finding and then executing a binary in a node package.
 *
 * @beta
 */
class CmdRunner {
    constructor(constants, terminal, options) {
        this._standardBuildFolders = constants;
        this._terminal = terminal;
        this._options = options;
    }
    async runCmdAsync(options) {
        const { args, onData = this._onData.bind(this), onError = this._onError.bind(this), onClose = this._onClose.bind(this) } = options;
        const packageJson = this._options.packageJson;
        if (!packageJson) {
            throw new Error(`Unable to find the package.json file for ${this._options}.`);
        }
        // Print the version
        this._terminal.writeLine(`${packageJson.name} version: ${packageJson.version}`);
        const binaryPath = path.resolve(this._options.packagePath, this._options.packageBinPath);
        if (!node_core_library_1.FileSystem.exists(binaryPath)) {
            throw new Error(`The binary is missing. This indicates that ${this._options.packageBinPath} is not ` +
                'installed correctly.');
        }
        await new Promise((resolve, reject) => {
            const nodePath = CmdRunner._nodePath;
            if (!nodePath) {
                reject(new Error('Unable to find node executable'));
                return;
            }
            // Invoke the tool and watch for log messages
            const spawnResult = childProcess.spawn(nodePath, [binaryPath, ...args], {
                cwd: this._standardBuildFolders.projectFolderPath,
                env: process.env,
                stdio: 'pipe'
            });
            if (spawnResult.stdout !== null) {
                spawnResult.stdout.on('data', onData);
            }
            if (spawnResult.stderr !== null) {
                spawnResult.stderr.on('data', (data) => {
                    this._errorHasBeenLogged = true;
                    onError(data);
                });
            }
            spawnResult.on('close', (code) => onClose(code, this._errorHasBeenLogged, resolve, reject));
        });
    }
    _onData(data) {
        this._terminal.writeLine(data.toString().trim());
    }
    _onError(data) {
        this._terminal.writeError(data.toString().trim());
    }
    _onClose(code, hasErrors, resolve, reject) {
        if (code !== 0 || hasErrors) {
            reject(new Error(`exited with code ${code}`));
        }
        else {
            resolve(code);
        }
    }
}
exports.CmdRunner = CmdRunner;
CmdRunner._nodePath = process.execPath;
//# sourceMappingURL=CmdRunner.js.map