import type { ITerminal } from '@rushstack/node-core-library';
/**
 * @public
 */
export interface IDeployFile {
    localPath: string;
    deployPath: string;
}
/**
 * @public
 */
export interface IDevDeployData {
    filesToUpload: IDeployFile[];
    loaderPath?: string;
}
/**
 * @public
 */
export interface IDevDeployOptions {
    /**
     * If true, projects will be uploaded into individual directories. This is useful if projects have files that may
     *  have conflicting names. If this is false and a collision is detected, a warning will be printed. Defaults to true.
     */
    isolateProjects?: boolean;
    /**
     * The project root path
     */
    rootPath: string;
    terminal: ITerminal;
    ignoreCollisions?: boolean;
    devDeployConfig: IDevDeployConfig;
}
/**
 * @public
 */
export interface IDevDeployConfig {
    accountName: string;
    sas: string;
    containerName: string;
    /**
     * The directory in the Azure container to use. Recommended to be set to something that includes your user name
     *  to ensure you don't clobber others' work.
     */
    folderNameInContainer?: string;
    /**
     * If false, the current project directory and its dependencies are deployed. If true, we attempt to find a
     *  rush.json file and deploy everything in the repo. Defaults to false.
     */
    useRush: boolean;
    /**
     * The number of upload retries
     */
    maxRetries?: number;
    /**
     * Include these folders alongside the "dist" directory. This is useful for deploying integration tests.
     *
     * @internal
     */
    _additionalFoldersToInclude?: string[];
    /**
     * True if the deployment is in a prod environment.
     */
    isProd?: boolean;
}
//# sourceMappingURL=DevDeployInterfaces.d.ts.map