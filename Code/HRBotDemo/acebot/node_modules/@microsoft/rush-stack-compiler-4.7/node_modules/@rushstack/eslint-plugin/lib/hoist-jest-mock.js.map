{"version":3,"file":"hoist-jest-mock.js","sourceRoot":"","sources":["../src/hoist-jest-mock.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\nimport { AST_NODE_TYPES } from '@typescript-eslint/experimental-utils';\n\nimport * as hoistJestMockPatterns from './hoistJestMockPatterns';\n\ntype MessageIds = 'error-unhoisted-jest-mock';\ntype Options = [];\n\n// Jest APIs that need to be hoisted\n// Based on HOIST_METHODS from ts-jest\nconst HOIST_METHODS = ['mock', 'unmock', 'enableAutomock', 'disableAutomock', 'deepUnmock'];\n\nconst hoistJestMock: TSESLint.RuleModule<MessageIds, Options> = {\n  meta: {\n    type: 'problem',\n    messages: {\n      'error-unhoisted-jest-mock':\n        \"Jest's module mocking APIs must be called before regular imports. Move this call so that it precedes\" +\n        ' the import found on line {{importLine}}.'\n    },\n    schema: [\n      {\n        type: 'object',\n        additionalProperties: false\n      }\n    ],\n    docs: {\n      description:\n        'Require Jest module mocking APIs to be called before other modules are imported.' +\n        ' Jest module mocking APIs such as \"jest.mock(\\'./example\\')\" must be called before the associated module' +\n        ' is imported, otherwise they will have no effect. Transpilers such as ts-jest and babel-jest automatically' +\n        ' \"hoist\" these calls, however this can produce counterintuitive results. Instead, the hoist-jest-mocks' +\n        ' lint rule requires developers to manually hoist these calls. For technical background, please read the' +\n        ' Jest documentation here: https://jestjs.io/docs/en/es6-class-mocks',\n      // Deprecated in ESLint v8; Keep for backwards compatibility\n      category: 'Possible Errors',\n      recommended: 'error',\n      url: 'https://www.npmjs.com/package/@rushstack/eslint-plugin'\n    } as TSESLint.RuleMetaDataDocs\n  },\n\n  create: (context: TSESLint.RuleContext<MessageIds, Options>) => {\n    // Returns true for a statement such as \"jest.mock()\" that needs to precede\n    // module imports (i.e. be \"hoisted\").\n    function isHoistableJestCall(node: TSESTree.Node | undefined): boolean {\n      if (node === undefined) {\n        return false;\n      }\n\n      const captures: hoistJestMockPatterns.IJestCallExpression = {};\n\n      if (hoistJestMockPatterns.jestCallExpression.match(node, captures)) {\n        if (captures.methodName && HOIST_METHODS.indexOf(captures.methodName) >= 0) {\n          return true;\n        }\n      }\n\n      // Recurse into some common expression-combining syntaxes\n      switch (node.type) {\n        case AST_NODE_TYPES.CallExpression:\n          return isHoistableJestCall(node.callee);\n        case AST_NODE_TYPES.MemberExpression:\n          return isHoistableJestCall(node.object);\n        case AST_NODE_TYPES.LogicalExpression:\n          return isHoistableJestCall(node.left) || isHoistableJestCall(node.right);\n      }\n\n      return false;\n    }\n\n    // Given part of an expression, walk upwards in the tree and find the containing statement\n    function findOuterStatement(node: TSESTree.Node): TSESTree.Node {\n      let current: TSESTree.Node | undefined = node;\n      while (current.parent) {\n        switch (current.parent.type) {\n          // Statements are always found inside a block:\n          case AST_NODE_TYPES.Program:\n          case AST_NODE_TYPES.BlockStatement:\n          case AST_NODE_TYPES.TSModuleBlock:\n            return current;\n        }\n        current = current.parent;\n      }\n      return node;\n    }\n\n    // This tracks the first require() or import expression that we found in the file.\n    let firstImportNode: TSESTree.Node | undefined = undefined;\n\n    // Avoid reporting more than one error for a given statement.\n    // Example: jest.mock('a').mock('b');\n    const reportedStatements: Set<TSESTree.Node> = new Set();\n\n    return {\n      CallExpression: (node: TSESTree.CallExpression): void => {\n        if (firstImportNode === undefined) {\n          // EXAMPLE:  const x = require('x')\n          if (hoistJestMockPatterns.requireCallExpression.match(node)) {\n            firstImportNode = node;\n          }\n        }\n\n        if (firstImportNode) {\n          // EXAMPLE:  jest.mock()\n          if (isHoistableJestCall(node)) {\n            const outerStatement: TSESTree.Node = findOuterStatement(node);\n            if (!reportedStatements.has(outerStatement)) {\n              reportedStatements.add(outerStatement);\n              context.report({\n                node,\n                messageId: 'error-unhoisted-jest-mock',\n                data: { importLine: firstImportNode.loc.start.line }\n              });\n            }\n          }\n        }\n      },\n\n      ImportExpression: (node: TSESTree.ImportExpression): void => {\n        if (firstImportNode === undefined) {\n          // EXAMPLE:  const x = import('x');\n          if (hoistJestMockPatterns.importExpression.match(node)) {\n            firstImportNode = node;\n          }\n        }\n      },\n\n      ImportDeclaration: (node: TSESTree.ImportDeclaration): void => {\n        if (firstImportNode === undefined) {\n          // EXAMPLE:  import { X } from \"Y\";\n          // IGNORE:   import type { X } from \"Y\";\n          if (node.importKind !== 'type') {\n            firstImportNode = node;\n          }\n        }\n      },\n\n      ExportDeclaration: (node: TSESTree.ExportDeclaration): void => {\n        if (firstImportNode === undefined) {\n          // EXAMPLE: export * from \"Y\";\n          // IGNORE:  export type { Y } from \"Y\";\n          if ((node as any as TSESTree.ExportNamedDeclaration).exportKind !== 'type') {\n            firstImportNode = node;\n          }\n        }\n      },\n\n      TSImportEqualsDeclaration: (node: TSESTree.TSImportEqualsDeclaration): void => {\n        if (firstImportNode === undefined) {\n          // EXAMPLE:  import x = require(\"x\");\n          firstImportNode = node;\n        }\n      }\n    };\n  }\n};\n\nexport { hoistJestMock };\n"]}