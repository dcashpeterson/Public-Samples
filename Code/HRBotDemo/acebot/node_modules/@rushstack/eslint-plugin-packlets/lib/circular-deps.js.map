{"version":3,"file":"circular-deps.js","sourceRoot":"","sources":["../src/circular-deps.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAM3D,8EAAoE;AAEpE,uDAAoD;AACpD,6DAA0E;AAC1E,iCAA8B;AAK9B,MAAM,YAAY,GAA6C;IAC7D,IAAI,EAAE;QACJ,IAAI,EAAE,SAAS;QACf,QAAQ,EAAE,EAAE,iBAAiB,EAAE,0DAA0D,EAAE;QAC3F,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,QAAQ;gBACd,oBAAoB,EAAE,KAAK;aAC5B;SACF;QACD,IAAI,EAAE;YACJ,WAAW,EAAE,kDAAkD;YAC/D,4DAA4D;YAC5D,QAAQ,EAAE,gBAAgB;YAC1B,WAAW,EAAE,MAAM;YACnB,GAAG,EAAE,iEAAiE;SAC1C;KAC/B;IAED,MAAM,EAAE,CAAC,OAAkD,EAAE,EAAE;QAC7D,gEAAgE;QAChE,MAAM,aAAa,GAAW,OAAO,CAAC,WAAW,EAAE,CAAC;QAEpD,6CAA6C;QAC7C,MAAM,OAAO,GAAe,gCAAW,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC;QAC3E,MAAM,gBAAgB,GAAuB,OAAO,CAAC,kBAAkB,EAAE,CAAC,gBAAgB,CAAW,CAAC;QAEtG,MAAM,eAAe,GAAoB,iCAAe,CAAC,gBAAgB,CACvE,aAAa,EACb,gBAAgB,CACjB,CAAC;QACF,IAAI,eAAe,CAAC,WAAW,EAAE;YAC/B,OAAO,EAAE,CAAC;SACX;QAED,OAAO;YACL,mGAAmG;YACnG,yGAAyG;YACzG,gDAAgD;YAChD,OAAO,EAAE,CAAC,IAAmB,EAAQ,EAAE;gBACrC,IAAI,eAAe,CAAC,YAAY,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;oBAC1D,MAAM,cAAc,GAClB,uCAAkB,CAAC,gCAAgC,CACjD,eAAe,CAAC,oBAAqB,EACrC,eAAe,EACf,OAAO,CACR,CAAC;oBAEJ,IAAI,cAAc,EAAE;wBAClB,MAAM,kBAAkB,GAAW,WAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;wBAElE,MAAM,oBAAoB,GAAa,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;wBAEhF,wGAAwG;wBACxG,4EAA4E;wBAC5E,oBAAoB,CAAC,IAAI,EAAE,CAAC;wBAC5B,IAAI,oBAAoB,CAAC,CAAC,CAAC,KAAK,eAAe,CAAC,oBAAoB,EAAE;4BACpE,IAAI,MAAM,GAAW,EAAE,CAAC;4BACxB,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;gCAC1C,MAAM,QAAQ,GAAW,WAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE,aAAa,CAAC,YAAY,CAAC,CAAC;gCACvF,MAAM,IAAI,IAAI,aAAa,CAAC,WAAW,sBAAsB,QAAQ,IAAI,CAAC;6BAC3E;4BAED,OAAO,CAAC,MAAM,CAAC;gCACb,IAAI,EAAE,IAAI;gCACV,SAAS,EAAE,iBAAiB;gCAC5B,IAAI,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE;6BACzB,CAAC,CAAC;yBACJ;qBACF;iBACF;YACH,CAAC;SACF,CAAC;IACJ,CAAC;CACF,CAAC;AAEO,oCAAY","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type * as ts from 'typescript';\r\nimport * as path from 'path';\r\n\r\nimport type { ParserServices, TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\r\nimport { ESLintUtils } from '@typescript-eslint/experimental-utils';\r\n\r\nimport { PackletAnalyzer } from './PackletAnalyzer';\r\nimport { DependencyAnalyzer, IPackletImport } from './DependencyAnalyzer';\r\nimport { Path } from './Path';\r\n\r\nexport type MessageIds = 'circular-import';\r\ntype Options = [];\r\n\r\nconst circularDeps: TSESLint.RuleModule<MessageIds, Options> = {\r\n  meta: {\r\n    type: 'problem',\r\n    messages: { 'circular-import': 'Packlet imports create a circular reference:\\n{{report}}' },\r\n    schema: [\r\n      {\r\n        type: 'object',\r\n        additionalProperties: false\r\n      }\r\n    ],\r\n    docs: {\r\n      description: 'Check for circular dependencies between packlets',\r\n      // Deprecated in ESLint v8; Keep for backwards compatibility\r\n      category: 'Best Practices',\r\n      recommended: 'warn',\r\n      url: 'https://www.npmjs.com/package/@rushstack/eslint-plugin-packlets'\r\n    } as TSESLint.RuleMetaDataDocs\r\n  },\r\n\r\n  create: (context: TSESLint.RuleContext<MessageIds, Options>) => {\r\n    // Example: /path/to/my-project/src/packlets/my-packlet/index.ts\r\n    const inputFilePath: string = context.getFilename();\r\n\r\n    // Example: /path/to/my-project/tsconfig.json\r\n    const program: ts.Program = ESLintUtils.getParserServices(context).program;\r\n    const tsconfigFilePath: string | undefined = program.getCompilerOptions()['configFilePath'] as string;\r\n\r\n    const packletAnalyzer: PackletAnalyzer = PackletAnalyzer.analyzeInputFile(\r\n      inputFilePath,\r\n      tsconfigFilePath\r\n    );\r\n    if (packletAnalyzer.nothingToDo) {\r\n      return {};\r\n    }\r\n\r\n    return {\r\n      // Match the first node in the source file.  Ideally we should be matching \"Program > :first-child\"\r\n      // so a warning doesn't highlight the whole file.  But that's blocked behind a bug in the query selector:\r\n      // https://github.com/estools/esquery/issues/114\r\n      Program: (node: TSESTree.Node): void => {\r\n        if (packletAnalyzer.isEntryPoint && !packletAnalyzer.error) {\r\n          const packletImports: IPackletImport[] | undefined =\r\n            DependencyAnalyzer.checkEntryPointForCircularImport(\r\n              packletAnalyzer.inputFilePackletName!,\r\n              packletAnalyzer,\r\n              program\r\n            );\r\n\r\n          if (packletImports) {\r\n            const tsconfigFileFolder: string = Path.dirname(tsconfigFilePath);\r\n\r\n            const affectedPackletNames: string[] = packletImports.map((x) => x.packletName);\r\n\r\n            // If 3 different packlets form a circular dependency, we don't need to report the same warning 3 times.\r\n            // Instead, only report the warning for the alphabetically smallest packlet.\r\n            affectedPackletNames.sort();\r\n            if (affectedPackletNames[0] === packletAnalyzer.inputFilePackletName) {\r\n              let report: string = '';\r\n              for (const packletImport of packletImports) {\r\n                const filePath: string = Path.relative(tsconfigFileFolder, packletImport.fromFilePath);\r\n                report += `\"${packletImport.packletName}\" is referenced by ${filePath}\\n`;\r\n              }\r\n\r\n              context.report({\r\n                node: node,\r\n                messageId: 'circular-import',\r\n                data: { report: report }\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nexport { circularDeps };\r\n"]}