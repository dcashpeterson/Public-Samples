'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jwt_decode = require('jwt-decode');
var msalNode = require('@azure/msal-node');
var crypto = require('crypto');
var microsoftGraphClient = require('@microsoft/microsoft-graph-client');
var identity = require('@azure/identity');
var botbuilder = require('botbuilder');
var botbuilderDialogs = require('botbuilder-dialogs');
var uuid = require('uuid');
var axios = require('axios');
var https = require('https');
var path = require('path');
var fs = require('fs');
var adaptivecardsTools = require('@microsoft/adaptivecards-tools');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var jwt_decode__default = /*#__PURE__*/_interopDefaultLegacy(jwt_decode);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error code to trace the error types.
 */
exports.ErrorCode = void 0;
(function (ErrorCode) {
    /**
     * Invalid parameter error.
     */
    ErrorCode["InvalidParameter"] = "InvalidParameter";
    /**
     * Invalid configuration error.
     */
    ErrorCode["InvalidConfiguration"] = "InvalidConfiguration";
    /**
     * Invalid certificate error.
     */
    ErrorCode["InvalidCertificate"] = "InvalidCertificate";
    /**
     * Internal error.
     */
    ErrorCode["InternalError"] = "InternalError";
    /**
     * Channel is not supported error.
     */
    ErrorCode["ChannelNotSupported"] = "ChannelNotSupported";
    /**
     * Failed to retrieve sso token
     */
    ErrorCode["FailedToRetrieveSsoToken"] = "FailedToRetrieveSsoToken";
    /**
     * Failed to process sso handler
     */
    ErrorCode["FailedToProcessSsoHandler"] = "FailedToProcessSsoHandler";
    /**
     * Cannot find command
     */
    ErrorCode["CannotFindCommand"] = "CannotFindCommand";
    /**
     * Failed to run sso step
     */
    ErrorCode["FailedToRunSsoStep"] = "FailedToRunSsoStep";
    /**
     * Failed to run dedup step
     */
    ErrorCode["FailedToRunDedupStep"] = "FailedToRunDedupStep";
    /**
     * Sso activity handler is undefined
     */
    ErrorCode["SsoActivityHandlerIsUndefined"] = "SsoActivityHandlerIsUndefined";
    /**
     * Runtime is not supported error.
     */
    ErrorCode["RuntimeNotSupported"] = "RuntimeNotSupported";
    /**
     * User failed to finish the AAD consent flow failed.
     */
    ErrorCode["ConsentFailed"] = "ConsentFailed";
    /**
     * The user or administrator has not consented to use the application error.
     */
    ErrorCode["UiRequiredError"] = "UiRequiredError";
    /**
     * Token is not within its valid time range error.
     */
    ErrorCode["TokenExpiredError"] = "TokenExpiredError";
    /**
     * Call service (AAD or simple authentication server) failed.
     */
    ErrorCode["ServiceError"] = "ServiceError";
    /**
     * Operation failed.
     */
    ErrorCode["FailedOperation"] = "FailedOperation";
    /**
     * Invalid response error.
     */
    ErrorCode["InvalidResponse"] = "InvalidResponse";
    /**
     * Identity type error.
     */
    ErrorCode["IdentityTypeNotSupported"] = "IdentityTypeNotSupported";
    /**
     * Authentication info already exists error.
     */
    ErrorCode["AuthorizationInfoAlreadyExists"] = "AuthorizationInfoAlreadyExists";
})(exports.ErrorCode || (exports.ErrorCode = {}));
/**
 * @internal
 */
class ErrorMessage {
}
// InvalidConfiguration Error
ErrorMessage.InvalidConfiguration = "{0} in configuration is invalid: {1}.";
ErrorMessage.ConfigurationNotExists = "Configuration does not exist. {0}";
ErrorMessage.ResourceConfigurationNotExists = "{0} resource configuration does not exist.";
ErrorMessage.MissingResourceConfiguration = "Missing resource configuration with type: {0}, name: {1}.";
ErrorMessage.AuthenticationConfigurationNotExists = "Authentication configuration does not exist.";
// RuntimeNotSupported Error
ErrorMessage.BrowserRuntimeNotSupported = "{0} is not supported in browser.";
ErrorMessage.NodejsRuntimeNotSupported = "{0} is not supported in Node.";
// Internal Error
ErrorMessage.FailToAcquireTokenOnBehalfOfUser = "Failed to acquire access token on behalf of user: {0}";
// ChannelNotSupported Error
ErrorMessage.OnlyMSTeamsChannelSupported = "{0} is only supported in MS Teams Channel";
ErrorMessage.FailedToProcessSsoHandler = "Failed to process sso handler: {0}";
// FailedToRetrieveSsoToken Error
ErrorMessage.FailedToRetrieveSsoToken = "Failed to retrieve sso token, user failed to finish the AAD consent flow.";
// CannotFindCommand Error
ErrorMessage.CannotFindCommand = "Cannot find command: {0}";
ErrorMessage.FailedToRunSsoStep = "Failed to run dialog to retrieve sso token: {0}";
ErrorMessage.FailedToRunDedupStep = "Failed to run dialog to remove duplicated messages: {0}";
// SsoActivityHandlerIsUndefined Error
ErrorMessage.SsoActivityHandlerIsNull = "Sso command can only be used or added when sso activity handler is not undefined";
// IdentityTypeNotSupported Error
ErrorMessage.IdentityTypeNotSupported = "{0} identity is not supported in {1}";
// AuthorizationInfoError
ErrorMessage.AuthorizationHeaderAlreadyExists = "Authorization header already exists!";
ErrorMessage.BasicCredentialAlreadyExists = "Basic credential already exists!";
// InvalidParameter Error
ErrorMessage.EmptyParameter = "Parameter {0} is empty";
ErrorMessage.DuplicateHttpsOptionProperty = "Axios HTTPS agent already defined value for property {0}";
ErrorMessage.DuplicateApiKeyInHeader = "The request already defined api key in request header with name {0}.";
ErrorMessage.DuplicateApiKeyInQueryParam = "The request already defined api key in query parameter with name {0}.";
ErrorMessage.OnlySupportInQueryActivity = "The handleMessageExtensionQueryWithToken only support in handleTeamsMessagingExtensionQuery with composeExtension/query type.";
ErrorMessage.OnlySupportInLinkQueryActivity = "The handleMessageExtensionLinkQueryWithSSO only support in handleTeamsAppBasedLinkQuery with composeExtension/queryLink type.";
/**
 * Error class with code and message thrown by the SDK.
 */
class ErrorWithCode extends Error {
    /**
     * Constructor of ErrorWithCode.
     *
     * @param {string} message - error message.
     * @param {ErrorCode} code - error code.
     */
    constructor(message, code) {
        if (!code) {
            super(message);
            return this;
        }
        super(message);
        Object.setPrototypeOf(this, ErrorWithCode.prototype);
        this.name = `${new.target.name}.${code}`;
        this.code = code;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Log level.
 */
exports.LogLevel = void 0;
(function (LogLevel) {
    /**
     * Show verbose, information, warning and error message.
     */
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    /**
     * Show information, warning and error message.
     */
    LogLevel[LogLevel["Info"] = 1] = "Info";
    /**
     * Show warning and error message.
     */
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    /**
     * Show error message.
     */
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(exports.LogLevel || (exports.LogLevel = {}));
/**
 * Update log level helper.
 *
 * @param { LogLevel } level - log level in configuration
 */
function setLogLevel(level) {
    internalLogger.level = level;
}
/**
 * Get log level.
 *
 * @returns Log level
 */
function getLogLevel() {
    return internalLogger.level;
}
class InternalLogger {
    constructor(name, logLevel) {
        this.level = undefined;
        this.defaultLogger = {
            verbose: console.debug,
            info: console.info,
            warn: console.warn,
            error: console.error,
        };
        this.name = name;
        this.level = logLevel;
    }
    error(message) {
        this.log(exports.LogLevel.Error, (x) => x.error, message);
    }
    warn(message) {
        this.log(exports.LogLevel.Warn, (x) => x.warn, message);
    }
    info(message) {
        this.log(exports.LogLevel.Info, (x) => x.info, message);
    }
    verbose(message) {
        this.log(exports.LogLevel.Verbose, (x) => x.verbose, message);
    }
    log(logLevel, logFunction, message) {
        if (message.trim() === "") {
            return;
        }
        const timestamp = new Date().toUTCString();
        let logHeader;
        if (this.name) {
            logHeader = `[${timestamp}] : @microsoft/teamsfx - ${this.name} : ${exports.LogLevel[logLevel]} - `;
        }
        else {
            logHeader = `[${timestamp}] : @microsoft/teamsfx : ${exports.LogLevel[logLevel]} - `;
        }
        const logMessage = `${logHeader}${message}`;
        if (this.level !== undefined && this.level <= logLevel) {
            if (this.customLogger) {
                logFunction(this.customLogger)(logMessage);
            }
            else if (this.customLogFunction) {
                this.customLogFunction(logLevel, logMessage);
            }
            else {
                logFunction(this.defaultLogger)(logMessage);
            }
        }
    }
}
/**
 * Logger instance used internally
 *
 * @internal
 */
const internalLogger = new InternalLogger();
/**
 * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
 *
 * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
 *
 * @example
 * ```typescript
 * setLogger({
 *   verbose: console.debug,
 *   info: console.info,
 *   warn: console.warn,
 *   error: console.error,
 * });
 * ```
 */
function setLogger(logger) {
    internalLogger.customLogger = logger;
}
/**
 * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
 *
 * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
 *
 * @example
 * ```typescript
 * setLogFunction((level: LogLevel, message: string) => {
 *   if (level === LogLevel.Error) {
 *     console.log(message);
 *   }
 * });
 * ```
 */
function setLogFunction(logFunction) {
    internalLogger.customLogFunction = logFunction;
}

// Copyright (c) Microsoft Corporation.
/**
 * Parse jwt token payload
 *
 * @param token
 *
 * @returns Payload object
 *
 * @internal
 */
function parseJwt(token) {
    try {
        const tokenObj = jwt_decode__default["default"](token);
        if (!tokenObj || !tokenObj.exp) {
            throw new ErrorWithCode("Decoded token is null or exp claim does not exists.", exports.ErrorCode.InternalError);
        }
        return tokenObj;
    }
    catch (err) {
        const errorMsg = "Parse jwt token failed in node env with error: " + err.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
    }
}
/**
 * @internal
 */
function getUserInfoFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        displayName: tokenObject.name,
        objectId: tokenObject.oid,
        tenantId: tokenObject.tid,
        preferredUserName: "",
    };
    if (tokenObject.ver === "2.0") {
        userInfo.preferredUserName = tokenObject.preferred_username;
    }
    else if (tokenObject.ver === "1.0") {
        userInfo.preferredUserName = tokenObject.upn;
    }
    return userInfo;
}
/**
 * Format string template with replacements
 *
 * ```typescript
 * const template = "{0} and {1} are fruit. {0} is my favorite one."
 * const formattedStr = formatString(template, "apple", "pear"); // formattedStr: "apple and pear are fruit. apple is my favorite one."
 * ```
 *
 * @param str string template
 * @param replacements replacement string array
 * @returns Formatted string
 *
 * @internal
 */
function formatString(str, ...replacements) {
    const args = replacements;
    return str.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != "undefined" ? args[number] : match;
    });
}
/**
 * @internal
 */
function validateScopesType(value) {
    // string
    if (typeof value === "string" || value instanceof String) {
        return;
    }
    // empty array
    if (Array.isArray(value) && value.length === 0) {
        return;
    }
    // string array
    if (Array.isArray(value) && value.length > 0 && value.every((item) => typeof item === "string")) {
        return;
    }
    const errorMsg = "The type of scopes is not valid, it must be string or string array";
    internalLogger.error(errorMsg);
    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
}
/**
 * @internal
 */
function getScopesArray(scopes) {
    const scopesArray = typeof scopes === "string" ? scopes.split(" ") : scopes;
    return scopesArray.filter((x) => x !== null && x !== "");
}
/**
 * @internal
 */
function getAuthority(authorityHost, tenantId) {
    const normalizedAuthorityHost = authorityHost.replace(/\/+$/g, "");
    return normalizedAuthorityHost + "/" + tenantId;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function createConfidentialClientApplication(authentication) {
    const authority = getAuthority(authentication.authorityHost, authentication.tenantId);
    const clientCertificate = parseCertificate(authentication.certificateContent);
    const auth = {
        clientId: authentication.clientId,
        authority: authority,
    };
    if (clientCertificate) {
        auth.clientCertificate = clientCertificate;
    }
    else {
        auth.clientSecret = authentication.clientSecret;
    }
    return new msalNode.ConfidentialClientApplication({
        auth,
    });
}
/**
 * @internal
 */
function parseCertificate(certificateContent) {
    if (!certificateContent) {
        return undefined;
    }
    const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/;
    const match = certificatePattern.exec(certificateContent);
    if (!match) {
        const errorMsg = "The certificate content does not contain a PEM-encoded certificate.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidCertificate);
    }
    const thumbprint = crypto.createHash("sha1")
        .update(Buffer.from(match[3], "base64"))
        .digest("hex")
        .toUpperCase();
    return {
        thumbprint: thumbprint,
        privateKey: certificateContent,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved like time-triggered automation job.
 *
 * @example
 * ```typescript
 * loadConfiguration(); // load configuration from environment variables
 * const credential = new AppCredential();
 * ```
 *
 * @remarks
 * Only works in in server side.
 */
class AppCredential {
    constructor(authConfig) {
        internalLogger.info("Create M365 tenant credential");
        const config = this.loadAndValidateConfig(authConfig);
        this.msalClient = createConfidentialClientApplication(config);
    }
    /**
     * Get access token for credential.
     *
     * @example
     * ```typescript
     * await credential.getToken(["User.Read.All"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read.All") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read.All", "Calendars.Read"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read.All Calendars.Read") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read.All") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|ServiceError} when get access token with authentication error.
     * @throws {@link ErrorCode|InternalError} when get access token with unknown error.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Access token with expected scopes.
     * Throw error if get access token failed.
     */
    getToken(scopes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let accessToken;
            validateScopesType(scopes);
            const scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            internalLogger.info("Get access token with scopes: " + scopesStr);
            try {
                const scopesArray = getScopesArray(scopes);
                const authenticationResult = yield this.msalClient.acquireTokenByClientCredential({
                    scopes: scopesArray,
                });
                if (authenticationResult) {
                    accessToken = {
                        token: authenticationResult.accessToken,
                        expiresOnTimestamp: authenticationResult.expiresOn.getTime(),
                    };
                }
            }
            catch (err) {
                const errorMsg = "Get M365 tenant credential failed with error: " + err.message;
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.ServiceError);
            }
            if (!accessToken) {
                const errorMsg = "Get M365 tenant credential access token failed with empty access token";
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
            }
            return accessToken;
        });
    }
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    loadAndValidateConfig(config) {
        internalLogger.verbose("Validate authentication configuration");
        if (config.clientId &&
            (config.clientSecret || config.certificateContent) &&
            config.tenantId &&
            config.authorityHost) {
            return config;
        }
        const missingValues = [];
        if (!config.clientId) {
            missingValues.push("clientId");
        }
        if (!config.clientSecret && !config.certificateContent) {
            missingValues.push("clientSecret or certificateContent");
        }
        if (!config.tenantId) {
            missingValues.push("tenantId");
        }
        if (!config.authorityHost) {
            missingValues.push("authorityHost");
        }
        const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingValues.join(", "), "undefined");
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent on-behalf-of flow to get user identity, and it is designed to be used in server side.
 *
 * @example
 * ```typescript
 * const credential = new OnBehalfOfUserCredential(ssoToken);
 * ```
 *
 * @remarks
 * Can only be used in server side.
 */
class OnBehalfOfUserCredential {
    constructor(ssoToken, config) {
        internalLogger.info("Get on behalf of user credential");
        const missingConfigurations = [];
        if (!config.clientId) {
            missingConfigurations.push("clientId");
        }
        if (!config.authorityHost) {
            missingConfigurations.push("authorityHost");
        }
        if (!config.clientSecret && !config.certificateContent) {
            missingConfigurations.push("clientSecret or certificateContent");
        }
        if (!config.tenantId) {
            missingConfigurations.push("tenantId");
        }
        if (missingConfigurations.length != 0) {
            const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingConfigurations.join(", "), "undefined");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
        }
        this.msalClient = createConfidentialClientApplication(config);
        const decodedSsoToken = parseJwt(ssoToken);
        this.ssoToken = {
            token: ssoToken,
            expiresOnTimestamp: decodedSsoToken.exp,
        };
    }
    /**
     * Get access token from credential.
     *
     * @example
     * ```typescript
     * await credential.getToken([]) // Get SSO token using empty string array
     * await credential.getToken("") // Get SSO token using empty string
     * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
     * await credential.getToken(".default") // Get Graph access token with default scope using string
     * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|InternalError} when failed to acquire access token on behalf of user with unknown error.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Access token with expected scopes.
     *
     * @remarks
     * If scopes is empty string or array, it returns SSO token.
     * If scopes is non-empty, it returns access token for target scope.
     */
    getToken(scopes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const scopesArray = getScopesArray(scopes);
            let result;
            if (!scopesArray.length) {
                internalLogger.info("Get SSO token.");
                if (Math.floor(Date.now() / 1000) > this.ssoToken.expiresOnTimestamp) {
                    const errorMsg = "Sso token has already expired.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.TokenExpiredError);
                }
                result = this.ssoToken;
            }
            else {
                internalLogger.info("Get access token with scopes: " + scopesArray.join(" "));
                let authenticationResult;
                try {
                    authenticationResult = yield this.msalClient.acquireTokenOnBehalfOf({
                        oboAssertion: this.ssoToken.token,
                        scopes: scopesArray,
                    });
                }
                catch (error) {
                    throw this.generateAuthServerError(error);
                }
                if (!authenticationResult) {
                    const errorMsg = "Access token is null";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(formatString(ErrorMessage.FailToAcquireTokenOnBehalfOfUser, errorMsg), exports.ErrorCode.InternalError);
                }
                result = {
                    token: authenticationResult.accessToken,
                    expiresOnTimestamp: authenticationResult.expiresOn.getTime(),
                };
            }
            return result;
        });
    }
    /**
     * Get basic user info from SSO token.
     *
     * @example
     * ```typescript
     * const currentUser = getUserInfo();
     * ```
     *
     * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Basic user info with user displayName, objectId and preferredUserName.
     */
    getUserInfo() {
        internalLogger.info("Get basic user info from SSO token");
        return getUserInfoFromSsoToken(this.ssoToken.token);
    }
    generateAuthServerError(err) {
        const errorMessage = err.errorMessage;
        if (err.name === "InteractionRequiredAuthError") {
            const fullErrorMsg = "Failed to get access token from AAD server, interaction required: " + errorMessage;
            internalLogger.warn(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.UiRequiredError);
        }
        else if (errorMessage && errorMessage.indexOf("AADSTS50013") >= 0) {
            const fullErrorMsg = "Failed to get access token from AAD server, assertion is invalid because of various reasons: " +
                errorMessage;
            internalLogger.error(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.TokenExpiredError);
        }
        else {
            const fullErrorMsg = formatString(ErrorMessage.FailToAcquireTokenOnBehalfOfUser, errorMessage);
            internalLogger.error(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.ServiceError);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Teams current user's identity, and it is used within Teams client applications.
 *
 * @remarks
 * Can only be used within Teams.
 */
class TeamsUserCredential {
    constructor(authConfig) {
        throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported);
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     *
     * @remarks
     * Can only be used within Teams.
     */
    login(scopes, resources) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get access token from credential.
     * @remarks
     * Can only be used within Teams.
     */
    getToken(scopes, options) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported));
    }
    /**
     * Get basic user info from SSO token
     *
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     *
     * @remarks
     * Can only be used within Teams.
     */
    getUserInfo(resources) {
        return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported));
    }
}

// Copyright (c) Microsoft Corporation.
const defaultScope = "https://graph.microsoft.com/.default";
// eslint-disable-next-line no-secrets/no-secrets
/**
 * Microsoft Graph auth provider for Teams Framework
 * @deprecated Use `TokenCredentialAuthenticationProvider` from `@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials` instead.
 */
class MsGraphAuthProvider {
    constructor(credentialOrTeamsFx, scopes) {
        this.credentialOrTeamsFx = credentialOrTeamsFx;
        let scopesStr = defaultScope;
        if (scopes) {
            validateScopesType(scopes);
            scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopesStr === "") {
                scopesStr = defaultScope;
            }
        }
        internalLogger.info(`Create Microsoft Graph Authentication Provider with scopes: '${scopesStr}'`);
        this.scopes = scopesStr;
    }
    /**
     * Get access token for Microsoft Graph API requests.
     *
     * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns Access token from the credential.
     *
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info(`Get Graph Access token with scopes: '${this.scopes.toString()}'`);
            let accessToken;
            if (this.credentialOrTeamsFx.getCredential) {
                accessToken = yield this.credentialOrTeamsFx
                    .getCredential()
                    .getToken(this.scopes);
            }
            else {
                accessToken = yield this.credentialOrTeamsFx.getToken(this.scopes);
            }
            return new Promise((resolve, reject) => {
                if (accessToken) {
                    resolve(accessToken.token);
                }
                else {
                    const errorMsg = "Graph access token is undefined or empty";
                    internalLogger.error(errorMsg);
                    reject(new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError));
                }
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Get Microsoft graph client.
 * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
 * ```typescript
 * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
 * const graph = Client.initWithMiddleware({
 *   authProvider: authProvider,
 * });
 * ```
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // Sso token example (Azure Function)
 * const ssoToken = "YOUR_TOKEN_STRING";
 * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
 * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
 * const graphClient = await createMicrosoftGraphClient(credential);
 * const profile = await graphClient.api("/me").get();
 *
 * // TeamsBotSsoPrompt example (Bot Application)
 * const requiredScopes = ["User.Read"];
 * const config: Configuration = {
 *    loginUrl: loginUrl,
 *    clientId: clientId,
 *    clientSecret: clientSecret,
 *    tenantId: tenantId
 * };
 * const prompt = new TeamsBotSsoPrompt(dialogId, {
 *    config: config
 *    scopes: ["User.Read"],
 * });
 * this.addDialog(prompt);
 *
 * const oboCredential = new OnBehalfOfAADUserCredential(
 *  getUserId(dialogContext),
 *  {
 *    clientId: "AAD_APP_ID",
 *    clientSecret: "AAD_APP_SECRET"
 *  });
 * try {
 *    const graphClient = await createMicrosoftGraphClient(credential);
 *    const profile = await graphClient.api("/me").get();
 * } catch (e) {
 *    dialogContext.beginDialog(dialogId);
 *    return Dialog.endOfTurn();
 * }
 * ```
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClient(teamsfx, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(teamsfx, scopes);
    const graphClient = microsoftGraphClient.Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}
// eslint-disable-next-line no-secrets/no-secrets
/**
 * Get Microsoft graph client.
 * @deprecated Use `TokenCredentialAuthenticationProvider` and `Client.initWithMiddleware` instead.
 * ```typescript
 * const authProvider = new TokenCredentialAuthenticationProvider(credential, { scopes: scope });
 * const graph = Client.initWithMiddleware({
 *   authProvider: authProvider,
 * });
 * ```
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // In browser: TeamsUserCredential
 * const authConfig: TeamsUserCredentialAuthConfig = {
 *   clientId: "xxx",
    initiateLoginEndpoint: "https://xxx/auth-start.html",
 * };

 * const credential = new TeamsUserCredential(authConfig);

 * const scope = "User.Read";
 * await credential.login(scope);

 * const client = createMicrosoftGraphClientWithCredential(credential, scope);

 * // In node: OnBehalfOfUserCredential
 * const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
 *   authorityHost: "xxx",
 *   clientId: "xxx",
 *   tenantId: "xxx",
 *   clientSecret: "xxx",
 * };

 * const oboCredential = new OnBehalfOfUserCredential(ssoToken, oboAuthConfig);
 * const scope = "User.Read";
 * const client = createMicrosoftGraphClientWithCredential(oboCredential, scope);

 * // In node: AppCredential
 * const appAuthConfig: AppCredentialAuthConfig = {
 *   authorityHost: "xxx",
 *   clientId: "xxx",
 *   tenantId: "xxx",
 *   clientSecret: "xxx",
 * };
 * const appCredential = new AppCredential(appAuthConfig);
 * const scope = "User.Read";
 * const client = createMicrosoftGraphClientWithCredential(appCredential, scope);
 *
 * const profile = await client.api("/me").get();
 * ```
 *
 * @param {TokenCredential} credential - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClientWithCredential(credential, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(credential, scopes);
    const graphClient = microsoftGraphClient.Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * MSSQL default scope
 * https://docs.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-connect-msi
 */
const defaultSQLScope = "https://database.windows.net/";
/**
 * Generate connection configuration consumed by tedious.
 *
 * @deprecated we recommend you compose your own Tedious configuration for better flexibility.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
 *
 * @returns Connection configuration of tedious for the SQL.
 *
 * @throws {@link ErrorCode|InvalidConfiguration} when SQL config resource configuration is invalid.
 * @throws {@link ErrorCode|InternalError} when get user MSI token failed or MSI token is invalid.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 */
function getTediousConnectionConfig(teamsfx, databaseName) {
    return __awaiter(this, void 0, void 0, function* () {
        internalLogger.info("Get SQL configuration");
        try {
            isSQLConfigurationValid(teamsfx);
        }
        catch (err) {
            throw err;
        }
        if (databaseName === "") {
            internalLogger.warn(`SQL database name is empty string`);
        }
        const dbName = databaseName !== null && databaseName !== void 0 ? databaseName : (teamsfx.hasConfig("sqlDatabaseName") ? teamsfx.getConfig("sqlDatabaseName") : undefined);
        if (!isMsiAuthentication(teamsfx)) {
            const configWithUPS = generateDefaultConfig(teamsfx, dbName);
            internalLogger.verbose("SQL configuration with username and password generated");
            return configWithUPS;
        }
        try {
            const configWithToken = yield generateTokenConfig(teamsfx, dbName);
            internalLogger.verbose("SQL configuration with MSI token generated");
            return configWithToken;
        }
        catch (error) {
            throw error;
        }
    });
}
/**
 * check configuration is an available configurations.
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns true - SQL configuration has a valid SQL endpoints, SQL username with password or identity ID.
 *          false - configuration is not valid.
 * @internal
 */
function isSQLConfigurationValid(teamsfx) {
    internalLogger.verbose("Check SQL configuration if valid");
    if (!teamsfx.hasConfig("sqlServerEndpoint")) {
        internalLogger.error("SQL configuration is not valid without SQL server endpoint exist");
        throw new ErrorWithCode("SQL configuration error without SQL server endpoint exist", exports.ErrorCode.InvalidConfiguration);
    }
    if (!(teamsfx.hasConfig("sqlUsername") && teamsfx.hasConfig("sqlPassword")) &&
        !teamsfx.hasConfig("sqlIdentityId")) {
        const errMsg = `SQL configuration is not valid without ${teamsfx.hasConfig("sqlIdentityId") ? "" : "identity id "} ${teamsfx.hasConfig("sqlUsername") ? "" : "SQL username "} ${teamsfx.hasConfig("sqlPassword") ? "" : "SQL password"} exist`;
        internalLogger.error(errMsg);
        throw new ErrorWithCode(errMsg, exports.ErrorCode.InvalidConfiguration);
    }
    internalLogger.verbose("SQL configuration is valid");
}
/**
 * Check SQL use MSI identity or username and password.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns false - login with SQL MSI identity, true - login with username and password.
 * @internal
 */
function isMsiAuthentication(teamsfx) {
    internalLogger.verbose("Check connection config using MSI access token or username and password");
    if (teamsfx.hasConfig("sqlUsername") && teamsfx.hasConfig("sqlPassword")) {
        internalLogger.verbose("Login with username and password");
        return false;
    }
    internalLogger.verbose("Login with MSI identity");
    return true;
}
/**
 * Generate tedious connection configuration with default authentication type.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
 *
 * @returns Tedious connection configuration with username and password.
 * @internal
 */
function generateDefaultConfig(teamsfx, databaseName) {
    internalLogger.verbose(`SQL server ${teamsfx.getConfig("sqlServerEndpoint")}
    , user name ${teamsfx.getConfig("sqlUsername")}
    , database name ${databaseName ? databaseName : ""}`);
    const config = {
        server: teamsfx.getConfig("sqlServerEndpoint"),
        authentication: {
            type: TediousAuthenticationType.default,
            options: {
                userName: teamsfx.getConfig("sqlUsername"),
                password: teamsfx.getConfig("sqlPassword"),
            },
        },
        options: {
            database: databaseName,
            encrypt: true,
        },
    };
    return config;
}
/**
 * Generate tedious connection configuration with azure-active-directory-access-token authentication type.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns Tedious connection configuration with access token.
 * @internal
 */
function generateTokenConfig(teamsfx, databaseName) {
    return __awaiter(this, void 0, void 0, function* () {
        internalLogger.verbose("Generate tedious config with MSI token");
        let token;
        try {
            const credential = new identity.ManagedIdentityCredential(teamsfx.getConfig("sqlIdentityId"));
            token = yield credential.getToken(defaultSQLScope);
        }
        catch (error) {
            const errMsg = "Get user MSI token failed";
            internalLogger.error(errMsg);
            throw new ErrorWithCode(errMsg, exports.ErrorCode.InternalError);
        }
        if (token) {
            const config = {
                server: teamsfx.getConfig("sqlServerEndpoint"),
                authentication: {
                    type: TediousAuthenticationType.MSI,
                    options: {
                        token: token.token,
                    },
                },
                options: {
                    database: databaseName,
                    encrypt: true,
                },
            };
            internalLogger.verbose(`Generate token configuration success
      , server endpoint is ${teamsfx.getConfig("sqlServerEndpoint")}
      , database name is ${databaseName ? databaseName : ""}`);
            return config;
        }
        internalLogger.error(`Generate token configuration
    , server endpoint is ${teamsfx.getConfig("sqlServerEndpoint")}
    , MSI token is not valid`);
        throw new ErrorWithCode("MSI token is not valid", exports.ErrorCode.InternalError);
    });
}
/**
 * tedious connection config authentication type.
 * https://tediousjs.github.io/tedious/api-connection.html
 * @internal
 */
var TediousAuthenticationType;
(function (TediousAuthenticationType) {
    TediousAuthenticationType["default"] = "default";
    TediousAuthenticationType["MSI"] = "azure-active-directory-access-token";
})(TediousAuthenticationType || (TediousAuthenticationType = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Identity type to use in authentication.
 */
exports.IdentityType = void 0;
(function (IdentityType) {
    /**
     * Represents the current user of Teams.
     */
    IdentityType["User"] = "User";
    /**
     * Represents the application itself.
     */
    IdentityType["App"] = "Application";
})(exports.IdentityType || (exports.IdentityType = {}));

// Copyright (c) Microsoft Corporation.
const invokeResponseType = "invokeResponse";
/**
 * Response body returned for a token exchange invoke activity.
 */
class TokenExchangeInvokeResponse {
    constructor(id, failureDetail) {
        this.id = id;
        this.failureDetail = failureDetail;
    }
}
/**
 * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
 * help receive oauth token, asks the user to consent if needed.
 *
 * @remarks
 * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
 * the token store.
 *
 * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
 * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
 *
 * @example
 * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
 * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
 * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
 * needed and their access token will be passed as an argument to the callers next waterfall step:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage } = require('botbuilder');
 * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
 * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 *
 * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
 *    scopes: ["User.Read"],
 * }));
 *
 * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
 *      async (step) => {
 *          return await step.beginDialog('TeamsBotSsoPrompt');
 *      },
 *      async (step) => {
 *          const token = step.result;
 *          if (token) {
 *
 *              // ... continue with task needing access token ...
 *
 *          } else {
 *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
 *              return await step.endDialog();
 *          }
 *      }
 * ]));
 * ```
 */
class TeamsBotSsoPrompt extends botbuilderDialogs.Dialog {
    constructor(authConfig, ...args) {
        super(arguments.length === 3 ? args[0] : args[1]);
        if (authConfig.getCredential) {
            const teamsfx = authConfig;
            this.authConfig = this.loadAndValidateConfig(teamsfx);
            this.initiateLoginEndpoint = teamsfx.getConfig("initiateLoginEndpoint");
            this.settings = args[1];
        }
        else {
            this.initiateLoginEndpoint = args[0];
            this.authConfig = authConfig;
            this.settings = args[2];
        }
        validateScopesType(this.settings.scopes);
        internalLogger.info("Create a new Teams Bot SSO Prompt");
    }
    /**
     * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
     * @remarks
     * If the task is successful, the result indicates whether the prompt is still
     * active after the turn has been processed by the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Begin Teams Bot SSO Prompt");
            this.ensureMsTeamsChannel(dc);
            // Initialize prompt state
            const default_timeout = 900000;
            let timeout = default_timeout;
            if (this.settings.timeout) {
                if (typeof this.settings.timeout != "number") {
                    const errorMsg = "type of timeout property in teamsBotSsoPromptSettings should be number.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
                }
                if (this.settings.timeout <= 0) {
                    const errorMsg = "value of timeout property in teamsBotSsoPromptSettings should be positive.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
                }
                timeout = this.settings.timeout;
            }
            if (this.settings.endOnInvalidMessage === undefined) {
                this.settings.endOnInvalidMessage = true;
            }
            const state = (_a = dc.activeDialog) === null || _a === void 0 ? void 0 : _a.state;
            state.state = {};
            state.options = {};
            state.expires = new Date().getTime() + timeout;
            // Send OAuth card to get SSO token
            yield this.sendOAuthCardAsync(dc.context);
            return botbuilderDialogs.Dialog.EndOfTurn;
        });
    }
    /**
     * Called when a prompt dialog is the active dialog and the user replied with a new activity.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     * The prompt generally continues to receive the user's replies until it accepts the
     * user's reply as valid input for the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @returns A `Promise` representing the asynchronous operation.
     *
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    continueDialog(dc) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Continue Teams Bot SSO Prompt");
            this.ensureMsTeamsChannel(dc);
            // Check for timeout
            const state = (_a = dc.activeDialog) === null || _a === void 0 ? void 0 : _a.state;
            const isMessage = dc.context.activity.type === botbuilder.ActivityTypes.Message;
            const isTimeoutActivityType = isMessage ||
                this.isTeamsVerificationInvoke(dc.context) ||
                this.isTokenExchangeRequestInvoke(dc.context);
            // If the incoming Activity is a message, or an Activity Type normally handled by TeamsBotSsoPrompt,
            // check to see if this TeamsBotSsoPrompt Expiration has elapsed, and end the dialog if so.
            const hasTimedOut = isTimeoutActivityType && new Date().getTime() > state.expires;
            if (hasTimedOut) {
                internalLogger.warn("End Teams Bot SSO Prompt due to timeout");
                return yield dc.endDialog(undefined);
            }
            else {
                if (this.isTeamsVerificationInvoke(dc.context) ||
                    this.isTokenExchangeRequestInvoke(dc.context)) {
                    // Recognize token
                    const recognized = yield this.recognizeToken(dc);
                    if (recognized.succeeded) {
                        return yield dc.endDialog(recognized.value);
                    }
                }
                else if (isMessage && this.settings.endOnInvalidMessage) {
                    internalLogger.warn("End Teams Bot SSO Prompt due to invalid message");
                    return yield dc.endDialog(undefined);
                }
                return botbuilderDialogs.Dialog.EndOfTurn;
            }
        });
    }
    loadAndValidateConfig(teamsfx) {
        if (teamsfx.getIdentityType() !== exports.IdentityType.User) {
            const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, teamsfx.getIdentityType().toString(), "TeamsBotSsoPrompt");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.IdentityTypeNotSupported);
        }
        const missingConfigurations = [];
        if (!teamsfx.hasConfig("initiateLoginEndpoint")) {
            missingConfigurations.push("initiateLoginEndpoint");
        }
        if (!teamsfx.hasConfig("clientId")) {
            missingConfigurations.push("clientId");
        }
        if (!teamsfx.hasConfig("tenantId")) {
            missingConfigurations.push("tenantId");
        }
        if (missingConfigurations.length != 0) {
            const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingConfigurations.join(", "), "undefined");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
        }
        let authConfig;
        if (teamsfx.getConfig("clientSecret")) {
            authConfig = {
                authorityHost: teamsfx.getConfig("authorityHost"),
                clientId: teamsfx.getConfig("clientId"),
                tenantId: teamsfx.getConfig("tenantId"),
                clientSecret: teamsfx.getConfig("clientSecret"),
            };
        }
        else {
            authConfig = {
                authorityHost: teamsfx.getConfig("authorityHost"),
                clientId: teamsfx.getConfig("clientId"),
                tenantId: teamsfx.getConfig("tenantId"),
                certificateContent: teamsfx.getConfig("certificateContent"),
            };
        }
        return authConfig;
    }
    /**
     * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
     * @param dc dialog context
     * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
     * @internal
     */
    ensureMsTeamsChannel(dc) {
        if (dc.context.activity.channelId != botbuilder.Channels.Msteams) {
            const errorMsg = formatString(ErrorMessage.OnlyMSTeamsChannelSupported, "Teams Bot SSO Prompt");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.ChannelNotSupported);
        }
    }
    /**
     * Send OAuthCard that tells Teams to obtain an authentication token for the bot application.
     * For details see https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots.
     *
     * @internal
     */
    sendOAuthCardAsync(context) {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.verbose("Send OAuth card to get SSO token");
            const account = yield botbuilder.TeamsInfo.getMember(context, context.activity.from.id);
            internalLogger.verbose("Get Teams member account user principal name: " +
                (account.userPrincipalName ? account.userPrincipalName : ""));
            const loginHint = account.userPrincipalName ? account.userPrincipalName : "";
            const signInResource = this.getSignInResource(loginHint);
            const card = botbuilder.CardFactory.oauthCard("", "Teams SSO Sign In", "Sign In", signInResource.signInLink, signInResource.tokenExchangeResource);
            card.content.buttons[0].type = botbuilder.ActionTypes.Signin;
            const msg = botbuilder.MessageFactory.attachment(card);
            // Send prompt
            yield context.sendActivity(msg);
        });
    }
    /**
     * Get sign in resource.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} if client id, tenant id or initiate login endpoint is not found in config.
     *
     * @internal
     */
    getSignInResource(loginHint) {
        internalLogger.verbose("Get sign in authentication configuration");
        const signInLink = `${this.initiateLoginEndpoint}?scope=${encodeURI(this.settings.scopes.join(" "))}&clientId=${this.authConfig.clientId}&tenantId=${this.authConfig.tenantId}&loginHint=${loginHint}`;
        internalLogger.verbose("Sign in link: " + signInLink);
        const tokenExchangeResource = {
            id: uuid.v4(),
        };
        return {
            signInLink: signInLink,
            tokenExchangeResource: tokenExchangeResource,
        };
    }
    /**
     * @internal
     */
    recognizeToken(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = dc.context;
            let tokenResponse;
            if (this.isTokenExchangeRequestInvoke(context)) {
                internalLogger.verbose("Receive token exchange request");
                // Received activity is not a token exchange request
                if (!(context.activity.value && this.isTokenExchangeRequest(context.activity.value))) {
                    const warningMsg = "The bot received an InvokeActivity that is missing a TokenExchangeInvokeRequest value. This is required to be sent with the InvokeActivity.";
                    internalLogger.warn(warningMsg);
                    yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.BAD_REQUEST, warningMsg));
                }
                else {
                    const ssoToken = context.activity.value.token;
                    const credential = new OnBehalfOfUserCredential(ssoToken, this.authConfig);
                    let exchangedToken;
                    try {
                        exchangedToken = yield credential.getToken(this.settings.scopes);
                        if (exchangedToken) {
                            yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.OK, "", context.activity.value.id));
                            const ssoTokenExpiration = parseJwt(ssoToken).exp;
                            tokenResponse = {
                                ssoToken: ssoToken,
                                ssoTokenExpiration: new Date(ssoTokenExpiration * 1000).toISOString(),
                                connectionName: "",
                                token: exchangedToken.token,
                                expiration: exchangedToken.expiresOnTimestamp.toString(),
                            };
                        }
                    }
                    catch (error) {
                        const warningMsg = "The bot is unable to exchange token. Ask for user consent.";
                        internalLogger.info(warningMsg);
                        yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.PRECONDITION_FAILED, warningMsg, context.activity.value.id));
                    }
                }
            }
            else if (this.isTeamsVerificationInvoke(context)) {
                internalLogger.verbose("Receive Teams state verification request");
                yield this.sendOAuthCardAsync(dc.context);
                yield context.sendActivity({ type: invokeResponseType, value: { status: botbuilder.StatusCodes.OK } });
            }
            return tokenResponse !== undefined
                ? { succeeded: true, value: tokenResponse }
                : { succeeded: false };
        });
    }
    /**
     * @internal
     */
    getTokenExchangeInvokeResponse(status, failureDetail, id) {
        const invokeResponse = {
            type: invokeResponseType,
            value: { status, body: new TokenExchangeInvokeResponse(id, failureDetail) },
        };
        return invokeResponse;
    }
    /**
     * @internal
     */
    isTeamsVerificationInvoke(context) {
        const activity = context.activity;
        return activity.type === botbuilder.ActivityTypes.Invoke && activity.name === botbuilder.verifyStateOperationName;
    }
    /**
     * @internal
     */
    isTokenExchangeRequestInvoke(context) {
        const activity = context.activity;
        return activity.type === botbuilder.ActivityTypes.Invoke && activity.name === botbuilder.tokenExchangeOperationName;
    }
    /**
     * @internal
     */
    isTokenExchangeRequest(obj) {
        return obj.hasOwnProperty("token");
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Initializes new Axios instance with specific auth provider
 *
 * @param apiEndpoint - Base url of the API
 * @param authProvider - Auth provider that injects authentication info to each request
 * @returns axios instance configured with specfic auth provider
 *
 * @example
 * ```typescript
 * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
 * ```
 */
function createApiClient(apiEndpoint, authProvider) {
    // Add a request interceptor
    const instance = axios__default["default"].create({
        baseURL: apiEndpoint,
    });
    instance.interceptors.request.use(function (config) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield authProvider.AddAuthenticationInfo(config));
        });
    });
    return instance;
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Bearer Token authentication
 */
class BearerTokenAuthProvider {
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken) {
        this.getToken = getToken;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getToken();
            if (!config.headers) {
                config.headers = {};
            }
            if (config.headers["Authorization"]) {
                throw new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists);
            }
            config.headers["Authorization"] = `Bearer ${token}`;
            return config;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Basic authentication
 */
class BasicAuthProvider {
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName, password) {
        if (!userName) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "username"), exports.ErrorCode.InvalidParameter);
        }
        if (!password) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "password"), exports.ErrorCode.InvalidParameter);
        }
        this.userName = userName;
        this.password = password;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        if (config.headers && config.headers["Authorization"]) {
            return Promise.reject(new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists));
        }
        if (config.auth) {
            return Promise.reject(new ErrorWithCode(ErrorMessage.BasicCredentialAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists));
        }
        config.auth = {
            username: this.userName,
            password: this.password,
        };
        return Promise.resolve(config);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles API Key authentication
 */
class ApiKeyProvider {
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName, keyValue, keyLocation) {
        if (!keyName) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "keyName"), exports.ErrorCode.InvalidParameter);
        }
        if (!keyValue) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "keyVaule"), exports.ErrorCode.InvalidParameter);
        }
        this.keyName = keyName;
        this.keyValue = keyValue;
        this.keyLocation = keyLocation;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        switch (this.keyLocation) {
            case exports.ApiKeyLocation.Header:
                if (!config.headers) {
                    config.headers = {};
                }
                if (config.headers[this.keyName]) {
                    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.DuplicateApiKeyInHeader, this.keyName), exports.ErrorCode.AuthorizationInfoAlreadyExists));
                }
                config.headers[this.keyName] = this.keyValue;
                break;
            case exports.ApiKeyLocation.QueryParams:
                if (!config.params) {
                    config.params = {};
                }
                let urlHasDefinedApiKey = false;
                if (config.url) {
                    const url = new URL(config.url, config.baseURL);
                    urlHasDefinedApiKey = url.searchParams.has(this.keyName);
                }
                if (config.params[this.keyName] || urlHasDefinedApiKey) {
                    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.DuplicateApiKeyInQueryParam, this.keyName), exports.ErrorCode.AuthorizationInfoAlreadyExists));
                }
                config.params[this.keyName] = this.keyValue;
                break;
        }
        return Promise.resolve(config);
    }
}
/**
 * Define available location for API Key location
 */
exports.ApiKeyLocation = void 0;
(function (ApiKeyLocation) {
    /**
     * The API Key is placed in request header
     */
    ApiKeyLocation[ApiKeyLocation["Header"] = 0] = "Header";
    /**
     * The API Key is placed in query parameter
     */
    ApiKeyLocation[ApiKeyLocation["QueryParams"] = 1] = "QueryParams";
})(exports.ApiKeyLocation || (exports.ApiKeyLocation = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Certificate authentication
 */
class CertificateAuthProvider {
    /**
     *
     * @param { SecureContextOptions } certOption - information about the cert used in http requests
     *
     * @throws {@link ErrorCode|InvalidParameter} - when cert option is empty.
     */
    constructor(certOption) {
        if (certOption && Object.keys(certOption).length !== 0) {
            this.certOption = certOption;
        }
        else {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "certOption"), exports.ErrorCode.InvalidParameter);
        }
    }
    /**
     * Adds authentication info to http requests.
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
     */
    AddAuthenticationInfo(config) {
        if (!config.httpsAgent) {
            config.httpsAgent = new https.Agent(this.certOption);
        }
        else {
            const existingProperties = new Set(Object.keys(config.httpsAgent.options));
            for (const property of Object.keys(this.certOption)) {
                if (existingProperties.has(property)) {
                    return Promise.reject(new ErrorWithCode(formatString(ErrorMessage.DuplicateHttpsOptionProperty, property), exports.ErrorCode.InvalidParameter));
                }
            }
            Object.assign(config.httpsAgent.options, this.certOption);
        }
        return Promise.resolve(config);
    }
}
/**
 * Helper to create SecureContextOptions from PEM format cert
 *
 * @param { string | Buffer } cert - The cert chain in PEM format
 * @param { string | Buffer } key - The private key for the cert chain
 * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
function createPemCertOption(cert, key, options) {
    if (cert.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "cert"), exports.ErrorCode.InvalidParameter);
    }
    if (key.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "key"), exports.ErrorCode.InvalidParameter);
    }
    return {
        cert,
        key,
        passphrase: options === null || options === void 0 ? void 0 : options.passphrase,
        ca: options === null || options === void 0 ? void 0 : options.ca,
    };
}
/**
 * Helper to create SecureContextOptions from PFX format cert
 *
 * @param { string | Buffer } pfx - The content of .pfx file
 * @param { {passphrase?: string} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
function createPfxCertOption(pfx, options) {
    if (pfx.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "pfx"), exports.ErrorCode.InvalidParameter);
    }
    return {
        pfx,
        passphrase: options === null || options === void 0 ? void 0 : options.passphrase,
    };
}

// Copyright (c) Microsoft Corporation.
// Following keys are used by SDK internally
const ReservedKey = new Set([
    "authorityHost",
    "tenantId",
    "clientId",
    "clientSecret",
    "initiateLoginEndpoint",
    "applicationIdUri",
    "apiEndpoint",
    "apiName",
    "sqlServerEndpoint",
    "sqlUsername",
    "sqlPassword",
    "sqlDatabaseName",
    "sqlIdentityId",
]);
/**
 * A class providing credential and configuration.
 * @deprecated Please use {@link TeamsUserCredential}
 * in browser environment and {@link OnBehalfOfUserCredential} or {@link AppCredential} in NodeJS.
 */
class TeamsFx {
    /**
     * Constructor of TeamsFx
     *
     * @param {IdentityType} identityType - Choose user or app identity
     * @param customConfig - key/value pairs of customized configuration that overrides default ones.
     *
     * @throws {@link ErrorCode|IdentityTypeNotSupported} when setting app identity in browser.
     */
    constructor(identityType, customConfig) {
        this.identityType = identityType !== null && identityType !== void 0 ? identityType : exports.IdentityType.User;
        this.configuration = new Map();
        this.loadFromEnv();
        if (customConfig) {
            const myConfig = Object.assign({}, customConfig);
            for (const key of Object.keys(myConfig)) {
                const value = myConfig[key];
                if (value) {
                    this.configuration.set(key, value);
                }
            }
        }
    }
    /**
     * Identity type set by user.
     *
     * @returns identity type.
     */
    getIdentityType() {
        return this.identityType;
    }
    /**
     * Credential instance according to identity type choice.
     *
     * @remarks If user identity is chose, will return {@link TeamsUserCredential}
     * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
     * identity is chose, will return {@link AppCredential}.
     *
     * @returns instance implements TokenCredential interface.
     */
    getCredential() {
        if (this.identityType === exports.IdentityType.User) {
            if (this.oboUserCredential) {
                return this.oboUserCredential;
            }
            const errorMsg = "SSO token is required to user identity. Please use setSsoToken().";
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
        }
        else {
            if (!this.appCredential) {
                this.appCredential = new AppCredential(Object.fromEntries(this.configuration));
            }
            return this.appCredential;
        }
    }
    /**
     * Get user information.
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     * @returns UserInfo object.
     */
    getUserInfo(resources) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.identityType !== exports.IdentityType.User) {
                const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, this.identityType.toString(), "TeamsFx");
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.IdentityTypeNotSupported);
            }
            return Promise.resolve(this.getCredential().getUserInfo());
        });
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     * @param {string[]} resources - The optional list of resources for full trust Teams apps.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes, resources) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "login"), exports.ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Set SSO token when using user identity in NodeJS.
     * @param {string} ssoToken - used for on behalf of user flow.
     * @returns self instance.
     */
    setSsoToken(ssoToken) {
        if (this.identityType !== exports.IdentityType.User) {
            throw new Error();
        }
        this.oboUserCredential = new OnBehalfOfUserCredential(ssoToken, Object.fromEntries(this.configuration));
        return this;
    }
    /**
     * Usually used by service plugins to retrieve specific config
     * @param {string} key - configuration key.
     * @returns value in configuration.
     */
    getConfig(key) {
        const value = this.configuration.get(key);
        if (!value) {
            const errorMsg = `Cannot find ${key} in configuration`;
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
        }
        return value;
    }
    /**
     * Check the value of specific key.
     * @param {string} key - configuration key.
     * @returns true if corresponding value is not empty string.
     */
    hasConfig(key) {
        const value = this.configuration.get(key);
        return !!value;
    }
    /**
     * Get all configurations.
     * @returns key value mappings.
     */
    getConfigs() {
        const config = {};
        for (const key of this.configuration.keys()) {
            const value = this.configuration.get(key);
            if (value) {
                config[key] = value;
            }
        }
        return config;
    }
    /**
     * Load configuration from environment variables.
     */
    loadFromEnv() {
        const env = process.env;
        this.configuration.set("authorityHost", env.M365_AUTHORITY_HOST);
        this.configuration.set("tenantId", env.M365_TENANT_ID);
        this.configuration.set("clientId", env.M365_CLIENT_ID);
        this.configuration.set("clientSecret", env.M365_CLIENT_SECRET);
        this.configuration.set("initiateLoginEndpoint", env.INITIATE_LOGIN_ENDPOINT);
        this.configuration.set("applicationIdUri", env.M365_APPLICATION_ID_URI);
        this.configuration.set("apiEndpoint", env.API_ENDPOINT);
        this.configuration.set("apiName", env.API_NAME);
        this.configuration.set("sqlServerEndpoint", env.SQL_ENDPOINT);
        this.configuration.set("sqlUsername", env.SQL_USER_NAME);
        this.configuration.set("sqlPassword", env.SQL_PASSWORD);
        this.configuration.set("sqlDatabaseName", env.SQL_DATABASE_NAME);
        this.configuration.set("sqlIdentityId", env.IDENTITY_ID);
        Object.keys(env).forEach((key) => {
            if (ReservedKey.has(key)) {
                internalLogger.warn(`The name of environment variable ${key} is preserved. Will not load it as configuration.`);
            }
            this.configuration.set(key, env[key]);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The target type where the notification will be sent to.
 *
 * @remarks
 * - "Channel" means to a team channel. (By default, notification to a team will be sent to its "General" channel.)
 * - "Group" means to a group chat.
 * - "Person" means to a personal chat.
 */
exports.NotificationTargetType = void 0;
(function (NotificationTargetType) {
    /**
     * The notification will be sent to a team channel.
     * (By default, notification to a team will be sent to its "General" channel.)
     */
    NotificationTargetType["Channel"] = "Channel";
    /**
     * The notification will be sent to a group chat.
     */
    NotificationTargetType["Group"] = "Group";
    /**
     * The notification will be sent to a personal chat.
     */
    NotificationTargetType["Person"] = "Person";
})(exports.NotificationTargetType || (exports.NotificationTargetType = {}));
/**
 * Options used to control how the response card will be sent to users.
 */
exports.AdaptiveCardResponse = void 0;
(function (AdaptiveCardResponse) {
    /**
     * The response card will be replaced the current one for the interactor who trigger the action.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["ReplaceForInteractor"] = 0] = "ReplaceForInteractor";
    /**
     * The response card will be replaced the current one for all users in the chat.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["ReplaceForAll"] = 1] = "ReplaceForAll";
    /**
     * The response card will be sent as a new message for all users in the chat.
     */
    AdaptiveCardResponse[AdaptiveCardResponse["NewForAll"] = 2] = "NewForAll";
})(exports.AdaptiveCardResponse || (exports.AdaptiveCardResponse = {}));
/**
 * Status code for an `application/vnd.microsoft.error` invoke response.
 */
exports.InvokeResponseErrorCode = void 0;
(function (InvokeResponseErrorCode) {
    /**
     * Invalid request.
     */
    InvokeResponseErrorCode[InvokeResponseErrorCode["BadRequest"] = 400] = "BadRequest";
    /**
     * Internal server error.
     */
    InvokeResponseErrorCode[InvokeResponseErrorCode["InternalServerError"] = 500] = "InternalServerError";
})(exports.InvokeResponseErrorCode || (exports.InvokeResponseErrorCode = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Available response type for an adaptive card invoke response.
 * @internal
 */
var InvokeResponseType;
(function (InvokeResponseType) {
    InvokeResponseType["AdaptiveCard"] = "application/vnd.microsoft.card.adaptive";
    InvokeResponseType["Message"] = "application/vnd.microsoft.activity.message";
    InvokeResponseType["Error"] = "application/vnd.microsoft.error";
})(InvokeResponseType || (InvokeResponseType = {}));
/**
 * Provides methods for formatting various invoke responses a bot can send to respond to an invoke request.
 *
 * @remarks
 * All of these functions return an `InvokeResponse` object, which can be
 * passed as input to generate a new `invokeResponse` activity.
 *
 * This example sends an invoke response that contains an adaptive card.
 *
 * ```typescript
 *
 * const myCard = {
 *    type: "AdaptiveCard",
 *    body: [
 *     {
 *       "type": "TextBlock",
 *       "text": "This is a sample card"
 *     }],
 *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
 *     version: "1.4"
 *  };
 *
 * const invokeResponse = InvokeResponseFactory.adaptiveCard(myCard);
 * await context.sendActivity({
 *    type: ActivityTypes.InvokeResponse,
 *    value: invokeResponse,
 *  });
 * ```
 */
class InvokeResponseFactory {
    /**
     * Create an invoke response from a text message.
     * The type of the invoke response is `application/vnd.microsoft.activity.message`
     * indicates the request was successfully processed.
     *
     * @param message - A text message included in a invoke response.
     *
     * @returns An `InvokeResponse` object.
     */
    static textMessage(message) {
        if (!message) {
            throw new Error("The text message cannot be null or empty");
        }
        return {
            status: botbuilder.StatusCodes.OK,
            body: {
                statusCode: botbuilder.StatusCodes.OK,
                type: InvokeResponseType.Message,
                value: message,
            },
        };
    }
    /**
     * Create an invoke response from an adaptive card.
     *
     * The type of the invoke response is `application/vnd.microsoft.card.adaptive` indicates
     * the request was successfully processed, and the response includes an adaptive card
     * that the client should display in place of the current one.
     *
     * @param card - The adaptive card JSON payload.
     *
     * @returns An `InvokeResponse` object.
     */
    static adaptiveCard(card) {
        if (!card) {
            throw new Error("The adaptive card content cannot be null or undefined");
        }
        return {
            status: botbuilder.StatusCodes.OK,
            body: {
                statusCode: botbuilder.StatusCodes.OK,
                type: InvokeResponseType.AdaptiveCard,
                value: card,
            },
        };
    }
    /**
     * Create an invoke response with error code and message.
     *
     * The type of the invoke response is `application/vnd.microsoft.error` indicates
     * the request was failed to processed.
     *
     * @param errorCode - The status code indicates error, available values:
     *  - 400 (BadRequest): indicate the incoming request was invalid.
     *  - 500 (InternalServerError): indicate an unexpected error occurred.
     * @param errorMessage - The error message.
     *
     * @returns An `InvokeResponse` object.
     */
    static errorResponse(errorCode, errorMessage) {
        return {
            status: botbuilder.StatusCodes.OK,
            body: {
                statusCode: errorCode,
                type: InvokeResponseType.Error,
                value: {
                    code: errorCode.toString(),
                    message: errorMessage,
                },
            },
        };
    }
    /**
     * Create an invoke response with status code and response value.
     * @param statusCode - The status code.
     * @param body - The value of the response body.
     *
     * @returns An `InvokeResponse` object.
     */
    static createInvokeResponse(statusCode, body) {
        return {
            status: statusCode,
            body: body,
        };
    }
}

/**
 * @internal
 */
class CardActionMiddleware {
    constructor(handlers) {
        this.actionHandlers = [];
        this.defaultMessage = "Your response was sent to the app";
        if (handlers && handlers.length > 0) {
            this.actionHandlers.push(...handlers);
        }
    }
    onTurn(context, next) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (context.activity.name === "adaptiveCard/action") {
                const action = context.activity.value.action;
                const actionVerb = action.verb;
                for (const handler of this.actionHandlers) {
                    if (((_a = handler.triggerVerb) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === (actionVerb === null || actionVerb === void 0 ? void 0 : actionVerb.toLowerCase())) {
                        let response;
                        try {
                            response = yield handler.handleActionInvoked(context, action.data);
                        }
                        catch (error) {
                            const errorResponse = InvokeResponseFactory.errorResponse(exports.InvokeResponseErrorCode.InternalServerError, error.message);
                            yield this.sendInvokeResponse(context, errorResponse);
                            throw error;
                        }
                        const responseType = (_b = response.body) === null || _b === void 0 ? void 0 : _b.type;
                        switch (responseType) {
                            case InvokeResponseType.AdaptiveCard:
                                const card = (_c = response.body) === null || _c === void 0 ? void 0 : _c.value;
                                if (!card) {
                                    const errorMessage = "Adaptive card content cannot be found in the response body";
                                    yield this.sendInvokeResponse(context, InvokeResponseFactory.errorResponse(exports.InvokeResponseErrorCode.InternalServerError, errorMessage));
                                    throw new Error(errorMessage);
                                }
                                if (card.refresh && handler.adaptiveCardResponse !== exports.AdaptiveCardResponse.NewForAll) {
                                    // Card won't be refreshed with AdaptiveCardResponse.ReplaceForInteractor.
                                    // So set to AdaptiveCardResponse.ReplaceForAll here.
                                    handler.adaptiveCardResponse = exports.AdaptiveCardResponse.ReplaceForAll;
                                }
                                const activity = botbuilder.MessageFactory.attachment(botbuilder.CardFactory.adaptiveCard(card));
                                if (handler.adaptiveCardResponse === exports.AdaptiveCardResponse.NewForAll) {
                                    yield this.sendInvokeResponse(context, InvokeResponseFactory.textMessage(this.defaultMessage));
                                    yield context.sendActivity(activity);
                                }
                                else if (handler.adaptiveCardResponse === exports.AdaptiveCardResponse.ReplaceForAll) {
                                    activity.id = context.activity.replyToId;
                                    yield context.updateActivity(activity);
                                    yield this.sendInvokeResponse(context, response);
                                }
                                else {
                                    yield this.sendInvokeResponse(context, response);
                                }
                                break;
                            case InvokeResponseType.Message:
                            case InvokeResponseType.Error:
                            default:
                                yield this.sendInvokeResponse(context, response);
                                break;
                        }
                        break;
                    }
                }
            }
            yield next();
        });
    }
    sendInvokeResponse(context, response) {
        return __awaiter(this, void 0, void 0, function* () {
            yield context.sendActivity({
                type: botbuilder.ActivityTypes.InvokeResponse,
                value: response,
            });
        });
    }
}

/**
 * A card action bot to respond to adaptive card universal actions.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.CardActionBot` instead.
 */
class CardActionBot$1 {
    /**
     * Creates a new instance of the `CardActionBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param options - initialize options
     */
    constructor(adapter, options) {
        this.middleware = new CardActionMiddleware(options === null || options === void 0 ? void 0 : options.actions);
        this.adapter = adapter.use(this.middleware);
    }
    /**
     * Registers a card action handler to the bot.
     * @param actionHandler A card action handler to be registered.
     */
    registerHandler(actionHandler) {
        if (actionHandler) {
            this.middleware.actionHandlers.push(actionHandler);
        }
    }
    /**
     * Registers card action handlers to the bot.
     * @param actionHandlers A set of card action handlers to be registered.
     */
    registerHandlers(actionHandlers) {
        if (actionHandlers) {
            this.middleware.actionHandlers.push(...actionHandlers);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
class CommandResponseMiddleware {
    constructor(handlers, ssoHandlers, activityHandler) {
        this.commandHandlers = [];
        this.ssoCommandHandlers = [];
        handlers = handlers !== null && handlers !== void 0 ? handlers : [];
        ssoHandlers = ssoHandlers !== null && ssoHandlers !== void 0 ? ssoHandlers : [];
        this.hasSsoCommand = ssoHandlers.length > 0;
        this.ssoActivityHandler = activityHandler;
        if (this.hasSsoCommand && !this.ssoActivityHandler) {
            internalLogger.error(ErrorMessage.SsoActivityHandlerIsNull);
            throw new ErrorWithCode(ErrorMessage.SsoActivityHandlerIsNull, exports.ErrorCode.SsoActivityHandlerIsUndefined);
        }
        this.commandHandlers.push(...handlers);
        for (const ssoHandler of ssoHandlers) {
            this.addSsoCommand(ssoHandler);
        }
    }
    addSsoCommand(ssoHandler) {
        var _a;
        (_a = this.ssoActivityHandler) === null || _a === void 0 ? void 0 : _a.addCommand((context, tokenResponse, message) => __awaiter(this, void 0, void 0, function* () {
            const matchResult = this.shouldTrigger(ssoHandler.triggerPatterns, message.text);
            message.matches = Array.isArray(matchResult) ? matchResult : void 0;
            const response = yield ssoHandler.handleCommandReceived(context, message, tokenResponse);
            yield this.processResponse(context, response);
        }), ssoHandler.triggerPatterns);
        this.ssoCommandHandlers.push(ssoHandler);
        this.hasSsoCommand = true;
    }
    onTurn(context, next) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (context.activity.type === botbuilder.ActivityTypes.Message) {
                // Invoke corresponding command handler for the command response
                const commandText = this.getActivityText(context.activity);
                let alreadyProcessed = false;
                for (const handler of this.commandHandlers) {
                    const matchResult = this.shouldTrigger(handler.triggerPatterns, commandText);
                    // It is important to note that the command bot will stop processing handlers
                    // when the first command handler is matched.
                    if (!!matchResult) {
                        const message = {
                            text: commandText,
                        };
                        message.matches = Array.isArray(matchResult) ? matchResult : void 0;
                        const response = yield handler.handleCommandReceived(context, message);
                        yield this.processResponse(context, response);
                        alreadyProcessed = true;
                        break;
                    }
                }
                if (!alreadyProcessed) {
                    for (const handler of this.ssoCommandHandlers) {
                        const matchResult = this.shouldTrigger(handler.triggerPatterns, commandText);
                        if (!!matchResult) {
                            yield ((_a = this.ssoActivityHandler) === null || _a === void 0 ? void 0 : _a.run(context));
                            break;
                        }
                    }
                }
            }
            else {
                if (this.hasSsoCommand) {
                    yield ((_b = this.ssoActivityHandler) === null || _b === void 0 ? void 0 : _b.run(context));
                }
            }
            yield next();
        });
    }
    processResponse(context, response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof response === "string") {
                yield context.sendActivity(response);
            }
            else {
                const replyActivity = response;
                if (replyActivity) {
                    yield context.sendActivity(replyActivity);
                }
            }
        });
    }
    matchPattern(pattern, text) {
        if (text) {
            if (typeof pattern === "string") {
                const regExp = new RegExp(pattern, "i");
                return regExp.test(text);
            }
            if (pattern instanceof RegExp) {
                const matches = text.match(pattern);
                return matches !== null && matches !== void 0 ? matches : false;
            }
        }
        return false;
    }
    shouldTrigger(patterns, text) {
        const expressions = Array.isArray(patterns) ? patterns : [patterns];
        for (const ex of expressions) {
            const arg = this.matchPattern(ex, text);
            if (arg)
                return arg;
        }
        return false;
    }
    getActivityText(activity) {
        let text = activity.text;
        const removedMentionText = botbuilder.TurnContext.removeRecipientMention(activity);
        if (removedMentionText) {
            text = removedMentionText
                .toLowerCase()
                .replace(/\n|\r\n/g, "")
                .trim();
        }
        return text;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.CommandBot` instead.
 */
class CommandBot$1 {
    /**
     * Creates a new instance of the `CommandBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param options - initialize options
     */
    constructor(adapter, options, ssoCommandActivityHandler, ssoConfig) {
        this.ssoConfig = ssoConfig;
        this.middleware = new CommandResponseMiddleware(options === null || options === void 0 ? void 0 : options.commands, options === null || options === void 0 ? void 0 : options.ssoCommands, ssoCommandActivityHandler);
        this.adapter = adapter.use(this.middleware);
    }
    /**
     * Registers a command into the command bot.
     *
     * @param command The command to register.
     */
    registerCommand(command) {
        if (command) {
            this.middleware.commandHandlers.push(command);
        }
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The commands to register.
     */
    registerCommands(commands) {
        if (commands) {
            this.middleware.commandHandlers.push(...commands);
        }
    }
    /**
     * Registers a sso command into the command bot.
     *
     * @param command The command to register.
     */
    registerSsoCommand(ssoCommand) {
        this.validateSsoActivityHandler();
        this.middleware.addSsoCommand(ssoCommand);
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The commands to register.
     */
    registerSsoCommands(ssoCommands) {
        if (ssoCommands.length > 0) {
            this.validateSsoActivityHandler();
            for (const ssoCommand of ssoCommands) {
                this.middleware.addSsoCommand(ssoCommand);
            }
        }
    }
    validateSsoActivityHandler() {
        if (!this.middleware.ssoActivityHandler) {
            internalLogger.error(ErrorMessage.SsoActivityHandlerIsNull);
            throw new ErrorWithCode(ErrorMessage.SsoActivityHandlerIsNull, exports.ErrorCode.SsoActivityHandlerIsUndefined);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function cloneConversation(conversation) {
    return JSON.parse(JSON.stringify(conversation));
}
/**
 * @internal
 */
function getKey(reference) {
    var _a, _b;
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return `_${(_a = reference.conversation) === null || _a === void 0 ? void 0 : _a.tenantId}_${(_b = reference.conversation) === null || _b === void 0 ? void 0 : _b.id}`;
}
/**
 * @internal
 */
function getTargetType(conversationReference) {
    var _a;
    const conversationType = (_a = conversationReference.conversation) === null || _a === void 0 ? void 0 : _a.conversationType;
    if (conversationType === "personal") {
        return exports.NotificationTargetType.Person;
    }
    else if (conversationType === "groupChat") {
        return exports.NotificationTargetType.Group;
    }
    else if (conversationType === "channel") {
        return exports.NotificationTargetType.Channel;
    }
    else {
        return undefined;
    }
}
/**
 * @internal
 */
function getTeamsBotInstallationId(context) {
    var _a, _b, _c;
    const teamId = (_c = (_b = (_a = context.activity) === null || _a === void 0 ? void 0 : _a.channelData) === null || _b === void 0 ? void 0 : _b.team) === null || _c === void 0 ? void 0 : _c.id;
    if (teamId) {
        return teamId;
    }
    // Fallback to use conversation id.
    // The conversation id is equal to team id only when the bot app is installed into the General channel.
    if (context.activity.conversation.name === undefined) {
        return context.activity.conversation.id;
    }
    return undefined;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
var ActivityType;
(function (ActivityType) {
    ActivityType[ActivityType["CurrentBotInstalled"] = 0] = "CurrentBotInstalled";
    ActivityType[ActivityType["CurrentBotMessaged"] = 1] = "CurrentBotMessaged";
    ActivityType[ActivityType["CurrentBotUninstalled"] = 2] = "CurrentBotUninstalled";
    ActivityType[ActivityType["TeamDeleted"] = 3] = "TeamDeleted";
    ActivityType[ActivityType["TeamRestored"] = 4] = "TeamRestored";
    ActivityType[ActivityType["Unknown"] = 5] = "Unknown";
})(ActivityType || (ActivityType = {}));
/**
 * @internal
 */
class NotificationMiddleware {
    constructor(options) {
        this.conversationReferenceStore = options.conversationReferenceStore;
    }
    onTurn(context, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const type = this.classifyActivity(context.activity);
            switch (type) {
                case ActivityType.CurrentBotInstalled:
                case ActivityType.TeamRestored: {
                    const reference = botbuilder.TurnContext.getConversationReference(context.activity);
                    yield this.conversationReferenceStore.add(getKey(reference), reference, {
                        overwrite: true,
                    });
                    break;
                }
                case ActivityType.CurrentBotMessaged: {
                    yield this.tryAddMessagedReference(context);
                    break;
                }
                case ActivityType.CurrentBotUninstalled:
                case ActivityType.TeamDeleted: {
                    const reference = botbuilder.TurnContext.getConversationReference(context.activity);
                    yield this.conversationReferenceStore.remove(getKey(reference), reference);
                    break;
                }
            }
            yield next();
        });
    }
    classifyActivity(activity) {
        var _a, _b;
        const activityType = activity.type;
        if (activityType === "installationUpdate") {
            const action = (_a = activity.action) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (action === "add") {
                return ActivityType.CurrentBotInstalled;
            }
            else {
                return ActivityType.CurrentBotUninstalled;
            }
        }
        else if (activityType === "conversationUpdate") {
            const eventType = (_b = activity.channelData) === null || _b === void 0 ? void 0 : _b.eventType;
            if (eventType === "teamDeleted") {
                return ActivityType.TeamDeleted;
            }
            else if (eventType === "teamRestored") {
                return ActivityType.TeamRestored;
            }
        }
        else if (activityType === "message") {
            return ActivityType.CurrentBotMessaged;
        }
        return ActivityType.Unknown;
    }
    tryAddMessagedReference(context) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const conversationType = (_a = reference === null || reference === void 0 ? void 0 : reference.conversation) === null || _a === void 0 ? void 0 : _a.conversationType;
            if (conversationType === "personal" || conversationType === "groupChat") {
                yield this.conversationReferenceStore.add(getKey(reference), reference, { overwrite: false });
            }
            else if (conversationType === "channel") {
                const teamId = (_d = (_c = (_b = context.activity) === null || _b === void 0 ? void 0 : _b.channelData) === null || _c === void 0 ? void 0 : _c.team) === null || _d === void 0 ? void 0 : _d.id;
                const channelId = (_f = (_e = context.activity.channelData) === null || _e === void 0 ? void 0 : _e.channel) === null || _f === void 0 ? void 0 : _f.id;
                // `teamId === channelId` means General channel. Ignore messaging in non-General channel.
                if (teamId !== undefined && (channelId === undefined || teamId === channelId)) {
                    const teamReference = cloneConversation(reference);
                    teamReference.conversation.id = teamId;
                    yield this.conversationReferenceStore.add(getKey(teamReference), teamReference, {
                        overwrite: false,
                    });
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
class LocalFileStorage {
    constructor(fileDir) {
        var _a;
        this.localFileName = (_a = process.env.TEAMSFX_NOTIFICATION_STORE_FILENAME) !== null && _a !== void 0 ? _a : ".notification.localstore.json";
        this.filePath = path__namespace.resolve(fileDir, this.localFileName);
    }
    read(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                return undefined;
            }
            const data = yield this.readFromFile();
            return data[key];
        });
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                return [];
            }
            const data = yield this.readFromFile();
            return Object.entries(data).map((entry) => entry[1]);
        });
    }
    write(key, object) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                yield this.writeToFile({ [key]: object });
                return;
            }
            const data = yield this.readFromFile();
            yield this.writeToFile(Object.assign(data, { [key]: object }));
        });
    }
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.storeFileExists()) {
                const data = yield this.readFromFile();
                if (data[key] !== undefined) {
                    delete data[key];
                    yield this.writeToFile(data);
                }
            }
        });
    }
    storeFileExists() {
        return new Promise((resolve) => {
            try {
                fs__namespace.access(this.filePath, (err) => {
                    if (err) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            catch (error) {
                resolve(false);
            }
        });
    }
    readFromFile() {
        return new Promise((resolve, reject) => {
            try {
                fs__namespace.readFile(this.filePath, { encoding: "utf-8" }, (err, rawData) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(JSON.parse(rawData));
                    }
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    writeToFile(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    const rawData = JSON.stringify(data, undefined, 2);
                    fs__namespace.writeFile(this.filePath, rawData, { encoding: "utf-8" }, (err) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
}
/**
 * @internal
 */
class DefaultConversationReferenceStore {
    constructor(storage) {
        this.storage = storage;
    }
    add(key, reference, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.overwrite) {
                yield this.storage.write(key, reference);
                return true;
            }
            const ref = yield this.storage.read(key);
            if (ref === undefined) {
                yield this.storage.write(key, reference);
                return true;
            }
            return false;
        });
    }
    remove(key, reference) {
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.storage.read(key);
            if (ref === undefined) {
                return false;
            }
            yield this.storage.delete(key);
            return true;
        });
    }
    list(pageSize, continuationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.storage.list();
            return {
                data,
                continuationToken: "",
            };
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @param target - the notification target.
 * @param text - the plain text message.
 * @param onError - an optional error handler that can catch exceptions during message sending.
 * If not defined, error will be handled by `BotAdapter.onTurnError`.
 * @returns the response of sending message.
 */
function sendMessage$1(target, text, onError) {
    return target.sendMessage(text, onError);
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @param target - the notification target.
 * @param card - the adaptive card raw JSON.
 * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
 * If not defined, error will be handled by `BotAdapter.onTurnError`.
 * @returns the response of sending adaptive card message.
 */
function sendAdaptiveCard$1(target, card, onError) {
    return target.sendAdaptiveCard(card, onError);
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel$1 {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         */
        this.type = exports.NotificationTargetType.Channel;
        this.parent = parent;
        this.info = info;
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity(text);
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity({
                            attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                        });
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        const reference = botbuilder.TurnContext.getConversationReference(context.activity);
        const channelConversation = cloneConversation(reference);
        channelConversation.conversation.id = this.info.id || "";
        return channelConversation;
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member$1 {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         */
        this.type = exports.NotificationTargetType.Person;
        this.parent = parent;
        this.account = account;
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity(text);
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity({
                            attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                        });
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const personalConversation = cloneConversation(reference);
            const connectorClient = context.turnState.get(this.parent.adapter.ConnectorClientKey);
            const conversation = yield connectorClient.conversations.createConversation({
                isGroup: false,
                tenantId: context.activity.conversation.tenantId,
                bot: context.activity.recipient,
                members: [this.account],
                channelData: {},
            });
            personalConversation.conversation.id = conversation.id;
            return personalConversation;
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.TeamsBotInstallation` instead.
 */
class TeamsBotInstallation$1 {
    /**
     * Constructor
     *
     * @remarks
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - the bound `BotFrameworkAdapter`.
     * @param conversationReference - the bound `ConversationReference`.
     */
    constructor(adapter, conversationReference) {
        this.adapter = adapter;
        this.conversationReference = conversationReference;
        this.type = getTargetType(conversationReference);
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @param onError - an optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.adapter.continueConversation(this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield context.sendActivity(text);
                    response.id = res === null || res === void 0 ? void 0 : res.id;
                }
                catch (error) {
                    if (onError) {
                        yield onError(context, error);
                    }
                    else {
                        throw error;
                    }
                }
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @param onError - an optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     * @returns the response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.adapter.continueConversation(this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield context.sendActivity({
                        attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                    });
                    response.id = res === null || res === void 0 ? void 0 : res.id;
                }
                catch (error) {
                    if (onError) {
                        yield onError(context, error);
                    }
                    else {
                        throw error;
                    }
                }
            }));
            return response;
        });
    }
    /**
     * Get channels from this bot installation.
     *
     * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = [];
            if (this.type !== exports.NotificationTargetType.Channel) {
                return channels;
            }
            let teamsChannels = [];
            yield this.adapter.continueConversation(this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const teamId = getTeamsBotInstallationId(context);
                if (teamId !== undefined) {
                    teamsChannels = yield botbuilder.TeamsInfo.getTeamChannels(context, teamId);
                }
            }));
            for (const channel of teamsChannels) {
                channels.push(new Channel$1(this, channel));
            }
            return channels;
        });
    }
    /**
     * Get members from this bot installation.
     *
     * @returns an array of members from where the bot is installed.
     */
    members() {
        return __awaiter(this, void 0, void 0, function* () {
            const members = [];
            yield this.adapter.continueConversation(this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                let continuationToken;
                do {
                    const pagedMembers = yield botbuilder.TeamsInfo.getPagedMembers(context, undefined, continuationToken);
                    continuationToken = pagedMembers.continuationToken;
                    for (const member of pagedMembers.members) {
                        members.push(new Member$1(this, member));
                    }
                } while (continuationToken !== undefined);
            }));
            return members;
        });
    }
    /**
     * Get team details from this bot installation
     *
     * @returns the team details if bot is installed into a team, otherwise returns undefined.
     */
    getTeamDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.type !== exports.NotificationTargetType.Channel) {
                return undefined;
            }
            let teamDetails;
            yield this.adapter.continueConversation(this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const teamId = getTeamsBotInstallationId(context);
                if (teamId !== undefined) {
                    teamDetails = yield botbuilder.TeamsInfo.getTeamDetails(context, teamId);
                }
            }));
            return teamDetails;
        });
    }
}
/**
 * Provide utilities to send notification to varies targets (e.g., member, group, channel).
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.NotificationBot` instead.
 */
class NotificationBot$1 {
    /**
     * constructor of the notification bot.
     *
     * @remarks
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - the bound `BotFrameworkAdapter`
     * @param options - initialize options
     */
    constructor(adapter, options) {
        var _a, _b;
        const storage = (_a = options === null || options === void 0 ? void 0 : options.storage) !== null && _a !== void 0 ? _a : new LocalFileStorage(path__namespace.resolve(process.env.RUNNING_ON_AZURE === "1" ? (_b = process.env.TEMP) !== null && _b !== void 0 ? _b : "./" : "./"));
        this.conversationReferenceStore = new DefaultConversationReferenceStore(storage);
        this.adapter = adapter.use(new NotificationMiddleware({
            conversationReferenceStore: this.conversationReferenceStore,
        }));
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * The result is retrieving from the persisted storage.
     *
     * @returns - an array of {@link TeamsBotInstallation}.
     */
    installations() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.conversationReferenceStore === undefined || this.adapter === undefined) {
                throw new Error("NotificationBot has not been initialized.");
            }
            const { data: references } = yield this.conversationReferenceStore.list();
            const targets = [];
            for (const reference of references) {
                // validate connection
                let valid = true;
                yield this.adapter.continueConversation(reference, (context) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        // try get member to see if the installation is still valid
                        yield botbuilder.TeamsInfo.getPagedMembers(context, 1);
                    }
                    catch (error) {
                        if (error.code === "BotNotInConversationRoster") {
                            valid = false;
                        }
                    }
                }));
                if (valid) {
                    targets.push(new TeamsBotInstallation$1(this.adapter, reference));
                }
                else {
                    yield this.conversationReferenceStore.remove(getKey(reference), reference);
                }
            }
            return targets;
        });
    }
    /**
     * Returns the first {@link Member} where predicate is true, and undefined otherwise.
     *
     * @param predicate find calls predicate once for each member of the installation,
     * until it finds one where predicate returns true. If such a member is found, find
     * immediately returns that member. Otherwise, find returns undefined.
     * @param scope the scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     * @returns the first {@link Member} where predicate is true, and undefined otherwise.
     */
    findMember(predicate, scope) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const target of yield this.installations()) {
                if (this.matchSearchScope(target, scope)) {
                    for (const member of yield target.members()) {
                        if (yield predicate(member)) {
                            return member;
                        }
                    }
                }
            }
            return;
        });
    }
    /**
     * Returns the first {@link Channel} where predicate is true, and undefined otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
     *
     * @param predicate find calls predicate once for each channel of the installation,
     * until it finds one where predicate returns true. If such a channel is found, find
     * immediately returns that channel. Otherwise, find returns undefined.
     * @returns the first {@link Channel} where predicate is true, and undefined otherwise.
     */
    findChannel(predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const target of yield this.installations()) {
                if (target.type === exports.NotificationTargetType.Channel) {
                    const teamDetails = yield target.getTeamDetails();
                    for (const channel of yield target.channels()) {
                        if (yield predicate(channel, teamDetails)) {
                            return channel;
                        }
                    }
                }
            }
            return;
        });
    }
    /**
     * Returns all {@link Member} where predicate is true, and empty array otherwise.
     *
     * @param predicate find calls predicate for each member of the installation.
     * @param scope the scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     * @returns an array of {@link Member} where predicate is true, and empty array otherwise.
     */
    findAllMembers(predicate, scope) {
        return __awaiter(this, void 0, void 0, function* () {
            const members = [];
            for (const target of yield this.installations()) {
                if (this.matchSearchScope(target, scope)) {
                    for (const member of yield target.members()) {
                        if (yield predicate(member)) {
                            members.push(member);
                        }
                    }
                }
            }
            return members;
        });
    }
    /**
     * Returns all {@link Channel} where predicate is true, and empty array otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
     *
     * @param predicate find calls predicate for each channel of the installation.
     * @returns an array of {@link Channel} where predicate is true, and empty array otherwise.
     */
    findAllChannels(predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = [];
            for (const target of yield this.installations()) {
                if (target.type === exports.NotificationTargetType.Channel) {
                    const teamDetails = yield target.getTeamDetails();
                    for (const channel of yield target.channels()) {
                        if (yield predicate(channel, teamDetails)) {
                            channels.push(channel);
                        }
                    }
                }
            }
            return channels;
        });
    }
    matchSearchScope(target, scope) {
        scope = scope !== null && scope !== void 0 ? scope : exports.SearchScope.All;
        return ((target.type === exports.NotificationTargetType.Channel && (scope & exports.SearchScope.Channel) !== 0) ||
            (target.type === exports.NotificationTargetType.Group && (scope & exports.SearchScope.Group) !== 0) ||
            (target.type === exports.NotificationTargetType.Person && (scope & exports.SearchScope.Person) !== 0));
    }
}
/**
 * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
 * The search scope is a flagged enum and it can be combined with `|`.
 * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
 */
exports.SearchScope = void 0;
(function (SearchScope) {
    /**
     * Search members from the installations in personal chat only.
     */
    SearchScope[SearchScope["Person"] = 1] = "Person";
    /**
     * Search members from the installations in group chat only.
     */
    SearchScope[SearchScope["Group"] = 2] = "Group";
    /**
     * Search members from the installations in Teams channel only.
     */
    SearchScope[SearchScope["Channel"] = 4] = "Channel";
    /**
     * Search members from all installations including personal chat, group chat and Teams channel.
     */
    SearchScope[SearchScope["All"] = 7] = "All";
})(exports.SearchScope || (exports.SearchScope = {}));

// Copyright (c) Microsoft Corporation.
let DIALOG_NAME = "BotSsoExecutionDialog";
let TEAMS_SSO_PROMPT_ID = "TeamsFxSsoPrompt";
let COMMAND_ROUTE_DIALOG = "CommandRouteDialog";
/**
 * Sso execution dialog, use to handle sso command
 */
class BotSsoExecutionDialog extends botbuilderDialogs.ComponentDialog {
    constructor(dedupStorage, ssoPromptSettings, authConfig, ...args) {
        var _a;
        super((_a = (authConfig.getCredential ? args[0] : args[1])) !== null && _a !== void 0 ? _a : DIALOG_NAME);
        this.dedupStorageKeys = [];
        // Map to store the commandId and triggerPatterns, key: commandId, value: triggerPatterns
        this.commandMapping = new Map();
        const dialogName = authConfig.getCredential ? args[0] : args[1];
        if (dialogName) {
            DIALOG_NAME = dialogName;
            TEAMS_SSO_PROMPT_ID = dialogName + TEAMS_SSO_PROMPT_ID;
            COMMAND_ROUTE_DIALOG = dialogName + COMMAND_ROUTE_DIALOG;
        }
        let ssoDialog;
        if (authConfig.getCredential) {
            ssoDialog = new TeamsBotSsoPrompt(authConfig, TEAMS_SSO_PROMPT_ID, ssoPromptSettings);
        }
        else {
            ssoDialog = new TeamsBotSsoPrompt(authConfig, args[0], TEAMS_SSO_PROMPT_ID, ssoPromptSettings);
        }
        this.addDialog(ssoDialog);
        this.initialDialogId = COMMAND_ROUTE_DIALOG;
        this.dedupStorage = dedupStorage;
        this.dedupStorageKeys = [];
        const commandRouteDialog = new botbuilderDialogs.WaterfallDialog(COMMAND_ROUTE_DIALOG, [
            this.commandRouteStep.bind(this),
        ]);
        this.addDialog(commandRouteDialog);
    }
    /**
     * Add TeamsFxBotSsoCommandHandler instance
     * @param handler {@link BotSsoExecutionDialogHandler} callback function
     * @param triggerPatterns The trigger pattern
     */
    addCommand(handler, triggerPatterns) {
        const commandId = this.getCommandHash(triggerPatterns);
        const dialog = new botbuilderDialogs.WaterfallDialog(commandId, [
            this.ssoStep.bind(this),
            this.dedupStep.bind(this),
            (stepContext) => __awaiter(this, void 0, void 0, function* () {
                const tokenResponse = stepContext.result.tokenResponse;
                const context = stepContext.context;
                const message = stepContext.result.message;
                try {
                    if (tokenResponse) {
                        yield handler(context, tokenResponse, message);
                    }
                    else {
                        throw new Error(ErrorMessage.FailedToRetrieveSsoToken);
                    }
                    return yield stepContext.endDialog();
                }
                catch (error) {
                    const errorMsg = formatString(ErrorMessage.FailedToProcessSsoHandler, error.message);
                    internalLogger.error(errorMsg);
                    return yield stepContext.endDialog(new ErrorWithCode(errorMsg, exports.ErrorCode.FailedToProcessSsoHandler));
                }
            }),
        ]);
        this.commandMapping.set(commandId, triggerPatterns);
        this.addDialog(dialog);
    }
    getCommandHash(patterns) {
        const expressions = Array.isArray(patterns) ? patterns : [patterns];
        const patternStr = expressions.join();
        const patternStrWithoutSpecialChar = patternStr.replace(/[^a-zA-Z0-9]/g, "");
        const hash = crypto.createHash("sha256").update(patternStr).digest("hex").toLowerCase();
        return patternStrWithoutSpecialChar + hash;
    }
    /**
     * The run method handles the incoming activity (in the form of a DialogContext) and passes it through the dialog system.
     *
     * @param context The context object for the current turn.
     * @param accessor The instance of StatePropertyAccessor for dialog system.
     */
    run(context, accessor) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogSet = new botbuilderDialogs.DialogSet(accessor);
            dialogSet.add(this);
            const dialogContext = yield dialogSet.createContext(context);
            this.ensureMsTeamsChannel(dialogContext);
            const results = yield dialogContext.continueDialog();
            if (results && results.status === botbuilderDialogs.DialogTurnStatus.empty) {
                yield dialogContext.beginDialog(this.id);
            }
            else if (results &&
                results.status === botbuilderDialogs.DialogTurnStatus.complete &&
                results.result instanceof Error) {
                throw results.result;
            }
        });
    }
    getActivityText(activity) {
        let text = activity.text;
        const removedMentionText = botbuilder.TurnContext.removeRecipientMention(activity);
        if (removedMentionText) {
            text = removedMentionText
                .toLowerCase()
                .replace(/\n|\r\n/g, "")
                .trim();
        }
        return text;
    }
    commandRouteStep(stepContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const turnContext = stepContext.context;
            const text = this.getActivityText(turnContext.activity);
            const commandId = this.getMatchesCommandId(text);
            if (commandId) {
                return yield stepContext.beginDialog(commandId);
            }
            const errorMsg = formatString(ErrorMessage.CannotFindCommand, turnContext.activity.text);
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.CannotFindCommand);
        });
    }
    ssoStep(stepContext) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const turnContext = stepContext.context;
                const text = this.getActivityText(turnContext.activity);
                const message = {
                    text,
                };
                stepContext.options.commandMessage = message;
                return yield stepContext.beginDialog(TEAMS_SSO_PROMPT_ID);
            }
            catch (error) {
                const errorMsg = formatString(ErrorMessage.FailedToRunSsoStep, error.message);
                internalLogger.error(errorMsg);
                return yield stepContext.endDialog(new ErrorWithCode(errorMsg, exports.ErrorCode.FailedToRunSsoStep));
            }
        });
    }
    dedupStep(stepContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenResponse = stepContext.result;
            if (!tokenResponse) {
                internalLogger.error(ErrorMessage.FailedToRetrieveSsoToken);
                return yield stepContext.endDialog(new ErrorWithCode(ErrorMessage.FailedToRetrieveSsoToken, exports.ErrorCode.FailedToRunSsoStep));
            }
            try {
                // Only dedup after ssoStep to make sure that all Teams client would receive the login request
                if (tokenResponse && (yield this.shouldDedup(stepContext.context))) {
                    return botbuilderDialogs.Dialog.EndOfTurn;
                }
                return yield stepContext.next({
                    tokenResponse,
                    message: stepContext.options.commandMessage,
                });
            }
            catch (error) {
                const errorMsg = formatString(ErrorMessage.FailedToRunDedupStep, error.message);
                internalLogger.error(errorMsg);
                return yield stepContext.endDialog(new ErrorWithCode(errorMsg, exports.ErrorCode.FailedToRunDedupStep));
            }
        });
    }
    /**
     * Called when the component is ending.
     *
     * @param context Context for the current turn of conversation.
     */
    onEndDialog(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversationId = context.activity.conversation.id;
            const currentDedupKeys = this.dedupStorageKeys.filter((key) => key.indexOf(conversationId) > 0);
            yield this.dedupStorage.delete(currentDedupKeys);
            this.dedupStorageKeys = this.dedupStorageKeys.filter((key) => key.indexOf(conversationId) < 0);
        });
    }
    /**
     * If a user is signed into multiple Teams clients, the Bot might receive a "signin/tokenExchange" from each client.
     * Each token exchange request for a specific user login will have an identical activity.value.Id.
     * Only one of these token exchange requests should be processed by the bot. For a distributed bot in production,
     * this requires a distributed storage to ensure only one token exchange is processed.
     * @param context Context for the current turn of conversation.
     * @returns boolean value indicate whether the message should be removed
     */
    shouldDedup(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const storeItem = {
                eTag: context.activity.value.id,
            };
            const key = this.getStorageKey(context);
            const storeItems = { [key]: storeItem };
            try {
                yield this.dedupStorage.write(storeItems);
                this.dedupStorageKeys.push(key);
            }
            catch (err) {
                if (err instanceof Error && err.message.indexOf("eTag conflict")) {
                    return true;
                }
                throw err;
            }
            return false;
        });
    }
    getStorageKey(context) {
        if (!context || !context.activity || !context.activity.conversation) {
            throw new Error("Invalid context, can not get storage key!");
        }
        const activity = context.activity;
        const channelId = activity.channelId;
        const conversationId = activity.conversation.id;
        if (activity.type !== botbuilder.ActivityTypes.Invoke || activity.name !== botbuilder.tokenExchangeOperationName) {
            throw new Error("TokenExchangeState can only be used with Invokes of signin/tokenExchange.");
        }
        const value = activity.value;
        if (!value || !value.id) {
            throw new Error("Invalid signin/tokenExchange. Missing activity.value.id.");
        }
        return `${channelId}/${conversationId}/${value.id}`;
    }
    matchPattern(pattern, text) {
        if (text) {
            if (typeof pattern === "string") {
                const regExp = new RegExp(pattern, "i");
                return regExp.test(text);
            }
            if (pattern instanceof RegExp) {
                const matches = text.match(pattern);
                return matches !== null && matches !== void 0 ? matches : false;
            }
        }
        return false;
    }
    isPatternMatched(patterns, text) {
        const expressions = Array.isArray(patterns) ? patterns : [patterns];
        for (const ex of expressions) {
            const matches = this.matchPattern(ex, text);
            return !!matches;
        }
        return false;
    }
    getMatchesCommandId(text) {
        for (const command of this.commandMapping) {
            const pattern = command[1];
            if (this.isPatternMatched(pattern, text)) {
                return command[0];
            }
        }
        return undefined;
    }
    /**
     * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
     * @param dc dialog context
     * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
     * @internal
     */
    ensureMsTeamsChannel(dc) {
        if (dc.context.activity.channelId != botbuilder.Channels.Msteams) {
            const errorMsg = formatString(ErrorMessage.OnlyMSTeamsChannelSupported, "SSO execution dialog");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.ChannelNotSupported);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Default SSO execution activity handler
 */
class DefaultBotSsoExecutionActivityHandler extends botbuilder.TeamsActivityHandler {
    /**
     * Creates a new instance of the DefaultBotSsoExecutionActivityHandler.
     * @param ssoConfig configuration for SSO command bot
     *
     * @remarks
     * In the constructor, it uses BotSsoConfig parameter which from {@link ConversationBot} options to initialize {@link BotSsoExecutionDialog}.
     * It also need to register an event handler for the message event which trigger {@link BotSsoExecutionDialog} instance.
     */
    constructor(ssoConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super();
        const memoryStorage = new botbuilder.MemoryStorage();
        const userState = (_b = (_a = ssoConfig.dialog) === null || _a === void 0 ? void 0 : _a.userState) !== null && _b !== void 0 ? _b : new botbuilder.UserState(memoryStorage);
        const conversationState = (_d = (_c = ssoConfig.dialog) === null || _c === void 0 ? void 0 : _c.conversationState) !== null && _d !== void 0 ? _d : new botbuilder.ConversationState(memoryStorage);
        const dedupStorage = (_f = (_e = ssoConfig.dialog) === null || _e === void 0 ? void 0 : _e.dedupStorage) !== null && _f !== void 0 ? _f : memoryStorage;
        const _l = ssoConfig.aad, { scopes } = _l, customConfig = __rest(_l, ["scopes"]);
        const settings = {
            scopes: scopes,
            timeout: (_h = (_g = ssoConfig.dialog) === null || _g === void 0 ? void 0 : _g.ssoPromptConfig) === null || _h === void 0 ? void 0 : _h.timeout,
            endOnInvalidMessage: (_k = (_j = ssoConfig.dialog) === null || _j === void 0 ? void 0 : _j.ssoPromptConfig) === null || _k === void 0 ? void 0 : _k.endOnInvalidMessage,
        };
        this.ssoExecutionDialog = new BotSsoExecutionDialog(dedupStorage, settings, customConfig, customConfig.initiateLoginEndpoint);
        this.conversationState = conversationState;
        this.dialogState = conversationState.createProperty("DialogState");
        this.userState = userState;
        this.onMessage((context, next) => __awaiter(this, void 0, void 0, function* () {
            yield this.ssoExecutionDialog.run(context, this.dialogState);
            yield next();
        }));
    }
    /**
     * Add TeamsFxBotSsoCommandHandler instance to SSO execution dialog
     * @param handler {@link BotSsoExecutionDialogHandler} callback function
     * @param triggerPatterns The trigger pattern
     *
     * @remarks
     * This function is used to add SSO command to {@link BotSsoExecutionDialog} instance.
     */
    addCommand(handler, triggerPatterns) {
        this.ssoExecutionDialog.addCommand(handler, triggerPatterns);
    }
    /**
     * Called to initiate the event emission process.
     * @param context The context object for the current turn.
     */
    run(context) {
        const _super = Object.create(null, {
            run: { get: () => super.run }
        });
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield _super.run.call(this, context);
            }
            finally {
                yield this.conversationState.saveChanges(context, false);
                yield this.userState.saveChanges(context, false);
            }
        });
    }
    /**
     * Receives invoke activities with Activity name of 'signin/verifyState'.
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query.
     * @returns A promise that represents the work queued.
     *
     * @remarks
     * It should trigger {@link BotSsoExecutionDialog} instance to handle signin process
     */
    handleTeamsSigninVerifyState(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ssoExecutionDialog.run(context, this.dialogState);
        });
    }
    /**
     * Receives invoke activities with Activity name of 'signin/tokenExchange'
     * @param context A context object for this turn.
     * @param query Signin state (part of signin action auth flow) verification invoke query
     * @returns A promise that represents the work queued.
     *
     * @remarks
     * It should trigger {@link BotSsoExecutionDialog} instance to handle signin process
     */
    handleTeamsSigninTokenExchange(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ssoExecutionDialog.run(context, this.dialogState);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @example
 * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
 *
 * ```typescript
 * // register through constructor
 * const conversationBot = new ConversationBot({
 *   command: {
 *     enabled: true,
 *     commands: [ new HelloWorldCommandHandler() ],
 *   },
 * });
 *
 * // register through `register*` API
 * conversationBot.command.registerCommand(new HelpCommandHandler());
 * ```
 *
 * For notification, you can enable notification at initialization, then send notifications at any time.
 *
 * ```typescript
 * // enable through constructor
 * const conversationBot = new ConversationBot({
 *   notification: {
 *     enabled: true,
 *   },
 * });
 *
 * // get all bot installations and send message
 * for (const target of await conversationBot.notification.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await conversationBot.notification.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 *
 * @remarks
 * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
 *
 * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 *
 * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
 */
/**
 * @deprecated Use `BotBuilderCloudAdapter.ConversationBot` instead.
 */
class ConversationBot$1 {
    /**
     * Creates new instance of the `ConversationBot`.
     *
     * @remarks
     * It's recommended to create your own adapter and storage for production environment instead of the default one.
     *
     * @param options - initialize options
     */
    constructor(options) {
        var _a, _b, _c, _d;
        if (options.adapter) {
            this.adapter = options.adapter;
        }
        else {
            this.adapter = this.createDefaultAdapter(options.adapterConfig);
        }
        let ssoCommandActivityHandler;
        if (options === null || options === void 0 ? void 0 : options.ssoConfig) {
            if ((_a = options.ssoConfig.dialog) === null || _a === void 0 ? void 0 : _a.CustomBotSsoExecutionActivityHandler) {
                ssoCommandActivityHandler =
                    new options.ssoConfig.dialog.CustomBotSsoExecutionActivityHandler(options.ssoConfig);
            }
            else {
                ssoCommandActivityHandler = new DefaultBotSsoExecutionActivityHandler(options.ssoConfig);
            }
        }
        if ((_b = options.command) === null || _b === void 0 ? void 0 : _b.enabled) {
            this.command = new CommandBot$1(this.adapter, options.command, ssoCommandActivityHandler, options.ssoConfig);
        }
        if ((_c = options.notification) === null || _c === void 0 ? void 0 : _c.enabled) {
            this.notification = new NotificationBot$1(this.adapter, options.notification);
        }
        if ((_d = options.cardAction) === null || _d === void 0 ? void 0 : _d.enabled) {
            this.cardAction = new CardActionBot$1(this.adapter, options.cardAction);
        }
    }
    createDefaultAdapter(adapterConfig) {
        const adapter = adapterConfig === undefined
            ? new botbuilder.BotFrameworkAdapter({
                appId: process.env.BOT_ID,
                appPassword: process.env.BOT_PASSWORD,
            })
            : new botbuilder.BotFrameworkAdapter(adapterConfig);
        // the default error handler
        adapter.onTurnError = (context, error) => __awaiter(this, void 0, void 0, function* () {
            // This check writes out errors to console.
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            console.error(`[onTurnError] unhandled error: ${error}`);
            // Send a trace activity, which will be displayed in Bot Framework Emulator
            yield context.sendTraceActivity("OnTurnError Trace", 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${error}`, "https://www.botframework.com/schemas/error", "TurnError");
            // Send a message to the user
            yield context.sendActivity(`The bot encountered unhandled error: ${error.message}`);
            yield context.sendActivity("To continue to run this bot, please fix the bot source code.");
        });
        return adapter;
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - an Express or Restify style request object.
     * @param res - an Express or Restify style response object.
     * @param logic - the additional function to handle bot context.
     *
     * @example
     * For example, to use with Restify:
     * ``` typescript
     * // The default/empty behavior
     * server.post("api/messages", conversationBot.requestHandler);
     *
     * // Or, add your own logic
     * server.post("api/messages", async (req, res) => {
     *   await conversationBot.requestHandler(req, res, async (context) => {
     *     // your-own-context-logic
     *   });
     * });
     * ```
     */
    requestHandler(req, res, logic) {
        return __awaiter(this, void 0, void 0, function* () {
            if (logic === undefined) {
                // create empty logic
                logic = () => __awaiter(this, void 0, void 0, function* () { });
            }
            yield this.adapter.processActivity(req, res, logic);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provides utility method to build bot message with cards that supported in Teams.
 */
class MessageBuilder {
    /**
     * Build a bot message activity attached with adaptive card.
     *
     * @param cardTemplate The adaptive card template.
     * @param data card data used to render the template.
     * @returns A bot message activity attached with an adaptive card.
     *
     * @example
     * ```javascript
     * const cardTemplate = {
     *   type: "AdaptiveCard",
     *   body: [
     *     {
     *       "type": "TextBlock",
     *       "text": "${title}",
     *       "size": "Large"
     *     },
     *     {
     *       "type": "TextBlock",
     *       "text": "${description}"
     *     }],
     *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
     *     version: "1.4"
     *  };
     *
     * type CardData = {
     *   title: string,
     *   description: string
     * };
     * const card = MessageBuilder.attachAdaptiveCard<CardData>(
     *   cardTemplate, {
     *   title: "sample card title",
     *   description: "sample card description"
     * });
     * ```
     */
    static attachAdaptiveCard(cardTemplate, data) {
        return {
            attachments: [botbuilder.CardFactory.adaptiveCard(adaptivecardsTools.AdaptiveCards.declare(cardTemplate).render(data))],
        };
    }
    /**
     * Build a bot message activity attached with an adaptive card.
     *
     * @param card The adaptive card content.
     * @returns A bot message activity attached with an adaptive card.
     */
    static attachAdaptiveCardWithoutData(card) {
        return {
            attachments: [botbuilder.CardFactory.adaptiveCard(adaptivecardsTools.AdaptiveCards.declareWithoutData(card).render())],
        };
    }
    /**
     * Build a bot message activity attached with an hero card.
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     *
     * @returns A bot message activity attached with a hero card.
     *
     * @example
     * ```javascript
     * const message = MessageBuilder.attachHeroCard(
     *      'sample title',
     *      ['https://example.com/sample.jpg'],
     *      ['action']
     * );
     * ```
     */
    static attachHeroCard(title, images, buttons, other) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.heroCard(title, images, buttons, other));
    }
    /**
     * Returns an attachment for a sign-in card.
     *
     * @param title The title for the card's sign-in button.
     * @param url The URL of the sign-in page to use.
     * @param text Optional. Additional text to include on the card.
     *
     * @returns A bot message activity attached with a sign-in card.
     *
     * @remarks
     * For channels that don't natively support sign-in cards, an alternative message is rendered.
     */
    static attachSigninCard(title, url, text) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.signinCard(title, url, text));
    }
    /**
     * Build a bot message activity attached with an Office 365 connector card.
     *
     * @param card A description of the Office 365 connector card.
     * @returns A bot message activity attached with an Office 365 connector card.
     */
    static attachO365ConnectorCard(card) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.o365ConnectorCard(card));
    }
    /**
     * Build a message activity attached with a receipt card.
     * @param card A description of the receipt card.
     * @returns A message activity attached with a receipt card.
     */
    static AttachReceiptCard(card) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.receiptCard(card));
    }
    /**
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     * @returns A message activity attached with a thumbnail card
     */
    static attachThumbnailCard(title, images, buttons, other) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.thumbnailCard(title, images, buttons, other));
    }
    /**
     * Add an attachement to a bot activity.
     * @param attachement The attachment object to attach.
     * @returns A message activity with an attachment.
     */
    static attachContent(attachement) {
        return {
            attachments: [attachement],
        };
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Retrieve the OAuth Sign in Link to use in the MessagingExtensionResult Suggested Actions.
 * This method only work on MessageExtension with Query now.
 *
 * @param {OnBehalfOfCredentialAuthConfig} authConfig - User custom the message extension authentication configuration.
 * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
 * @param {string | string[]} scopes - The list of scopes for which the token will have access.
 *
 * @returns SignIn link SilentAuth CardAction with 200 status code.
 */
function getSignInResponseForMessageExtensionWithSilentAuthConfig(authConfig, initiateLoginEndpoint, scopes) {
    const scopesArray = getScopesArray(scopes);
    const signInLink = `${initiateLoginEndpoint}?scope=${encodeURI(scopesArray.join(" "))}&clientId=${authConfig.clientId}&tenantId=${authConfig.tenantId}`;
    return {
        composeExtension: {
            type: "silentAuth",
            suggestedActions: {
                actions: [
                    {
                        type: "openUrl",
                        value: signInLink,
                        title: "Message Extension OAuth",
                    },
                ],
            },
        },
    };
}
/**
 *  Retrieve the OAuth Sign in Link to use in the MessagingExtensionResult Suggested Actions.
 * This method just a workaround for link unfurling now.
 *
 * @param {OnBehalfOfCredentialAuthConfig} authConfig - User custom the message extension authentication configuration.
 * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
 * @param {string | string[]} scopes - The list of scopes for which the token will have access.
 *
 * @returns SignIn link Auth CardAction with 200 status code.
 */
function getSignInResponseForMessageExtensionWithAuthConfig(authConfig, initiateLoginEndpoint, scopes) {
    const scopesArray = getScopesArray(scopes);
    const signInLink = `${initiateLoginEndpoint}?scope=${encodeURI(scopesArray.join(" "))}&clientId=${authConfig.clientId}&tenantId=${authConfig.tenantId}`;
    return {
        composeExtension: {
            type: "auth",
            suggestedActions: {
                actions: [
                    {
                        type: "openUrl",
                        value: signInLink,
                        title: "Message Extension OAuth",
                    },
                ],
            },
        },
    };
}
/**
 * Retrieve the OAuth Sign in Link to use in the MessagingExtensionResult Suggested Actions.
 * This method only work on MessageExtension with Query now.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param {string | string[]} scopes - The list of scopes for which the token will have access.
 *
 * @returns SignIn link CardAction with 200 status code.
 */
function getSignInResponseForMessageExtension(teamsfx, scopes) {
    const scopesArray = getScopesArray(scopes);
    const signInLink = `${teamsfx.getConfig("initiateLoginEndpoint")}?scope=${encodeURI(scopesArray.join(" "))}&clientId=${teamsfx.getConfig("clientId")}&tenantId=${teamsfx.getConfig("tenantId")}`;
    return {
        composeExtension: {
            type: "silentAuth",
            suggestedActions: {
                actions: [
                    {
                        type: "openUrl",
                        value: signInLink,
                        title: "Message Extension OAuth",
                    },
                ],
            },
        },
    };
}
/**
 * execution in message extension with SSO token.
 *
 * @param {TurnContext} context - The context object for the current turn.
 * @param {OnBehalfOfCredentialAuthConfig} authConfig - User custom the message extension authentication configuration.
 * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
 * @param {string[]} scopes - The list of scopes for which the token will have access.
 * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
 *
 * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
 * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
 * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
 *
 * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
 */
function executionWithTokenAndConfig(context, authConfig, initiateLoginEndpoint, scopes, logic) {
    return __awaiter(this, void 0, void 0, function* () {
        const valueObj = context.activity.value;
        if (!valueObj.authentication || !valueObj.authentication.token) {
            internalLogger.verbose("No AccessToken in request, return silentAuth for AccessToken");
            return getSignInResponseForMessageExtensionWithSilentAuthConfig(authConfig, initiateLoginEndpoint, scopes);
        }
        try {
            const credential = new OnBehalfOfUserCredential(valueObj.authentication.token, authConfig);
            const token = yield credential.getToken(scopes);
            const ssoTokenExpiration = parseJwt(valueObj.authentication.token).exp;
            const tokenRes = {
                ssoToken: valueObj.authentication.token,
                ssoTokenExpiration: new Date(ssoTokenExpiration * 1000).toISOString(),
                token: token.token,
                expiration: token.expiresOnTimestamp.toString(),
                connectionName: "",
            };
            if (logic) {
                return yield logic(tokenRes);
            }
        }
        catch (err) {
            if (err instanceof ErrorWithCode &&
                err.code === exports.ErrorCode.UiRequiredError &&
                context.activity.name === "composeExtension/query") {
                internalLogger.verbose("User not consent yet, return 412 to user consent first.");
                const response = { status: 412 };
                yield context.sendActivity({ value: response, type: botbuilder.ActivityTypes.InvokeResponse });
                return;
            }
            else if (err instanceof ErrorWithCode &&
                err.code === exports.ErrorCode.UiRequiredError &&
                context.activity.name === "composeExtension/queryLink") {
                internalLogger.verbose("User not consent yet, return auth card for user login");
                const response = getSignInResponseForMessageExtensionWithAuthConfig(authConfig, initiateLoginEndpoint, scopes);
                yield context.sendActivity({
                    value: { status: 200, body: response },
                    type: botbuilder.ActivityTypes.InvokeResponse,
                });
                return;
            }
            throw err;
        }
    });
}
/**
 * execution in message extension with SSO token.
 * @deprecated Use {@link executionWithTokenAndConfig} instead.
 *
 * @param {TurnContext} context - The context object for the current turn.
 * @param {AuthenticationConfiguration} config - User custom the message extension authentication configuration.
 * @param {string[]} scopes - The list of scopes for which the token will have access.
 * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
 *
 * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
 * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
 * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
 *
 * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
 */
function executionWithToken(context, config, scopes, logic) {
    return __awaiter(this, void 0, void 0, function* () {
        const valueObj = context.activity.value;
        if (!valueObj.authentication || !valueObj.authentication.token) {
            internalLogger.verbose("No AccessToken in request, return silentAuth for AccessToken");
            return getSignInResponseForMessageExtension(new TeamsFx(exports.IdentityType.User, config), scopes);
        }
        try {
            const teamsfx = new TeamsFx(exports.IdentityType.User, config).setSsoToken(valueObj.authentication.token);
            const token = yield teamsfx.getCredential().getToken(scopes);
            const ssoTokenExpiration = parseJwt(valueObj.authentication.token).exp;
            const tokenRes = {
                ssoToken: valueObj.authentication.token,
                ssoTokenExpiration: new Date(ssoTokenExpiration * 1000).toISOString(),
                token: token.token,
                expiration: token.expiresOnTimestamp.toString(),
                connectionName: "",
            };
            if (logic) {
                return yield logic(tokenRes);
            }
        }
        catch (err) {
            if (err instanceof ErrorWithCode && err.code === exports.ErrorCode.UiRequiredError) {
                internalLogger.verbose("User not consent yet, return 412 to user consent first.");
                const response = { status: 412 };
                yield context.sendActivity({ value: response, type: botbuilder.ActivityTypes.InvokeResponse });
                return;
            }
            throw err;
        }
    });
}
// eslint-disable-next-line no-secrets/no-secrets
/**
 * Users execute query in message extension with SSO or access token.
 * @deprecated Use {@link handleMessageExtensionQueryWithSSO} instead.
 *
 * @param {TurnContext} context - The context object for the current turn.
 * @param {AuthenticationConfiguration} config - User custom the message extension authentication configuration.
 * @param {string| string[]} scopes - The list of scopes for which the token will have access.
 * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
 *
 * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension query.
 * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
 * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
 * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
 *
 * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
 */
function handleMessageExtensionQueryWithToken(context, config, scopes, logic) {
    return __awaiter(this, void 0, void 0, function* () {
        if (context.activity.name != "composeExtension/query") {
            internalLogger.error(ErrorMessage.OnlySupportInQueryActivity);
            throw new ErrorWithCode(formatString(ErrorMessage.OnlySupportInQueryActivity), exports.ErrorCode.FailedOperation);
        }
        return yield executionWithToken(context, config !== null && config !== void 0 ? config : {}, scopes, logic);
    });
}
/**
 * Users execute query in message extension with SSO or access token.
 *
 * @param {TurnContext} context - The context object for the current turn.
 * @param {OnBehalfOfCredentialAuthConfig} config - User custom the message extension authentication configuration.
 * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
 * @param {string| string[]} scopes - The list of scopes for which the token will have access.
 * @param {function} logic - Business logic when executing the query in message extension with SSO or access token.
 *
 * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension query.
 * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
 * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
 * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
 *
 * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
 */
function handleMessageExtensionQueryWithSSO(context, config, initiateLoginEndpoint, scopes, logic) {
    return __awaiter(this, void 0, void 0, function* () {
        if (context.activity.name != "composeExtension/query") {
            internalLogger.error(ErrorMessage.OnlySupportInQueryActivity);
            throw new ErrorWithCode(formatString(ErrorMessage.OnlySupportInQueryActivity), exports.ErrorCode.FailedOperation);
        }
        return yield executionWithTokenAndConfig(context, config !== null && config !== void 0 ? config : {}, initiateLoginEndpoint, scopes, logic);
    });
}
/**
 * Users execute link query in message extension with SSO or access token.
 *
 * @param {TurnContext} context - The context object for the current turn.
 * @param {OnBehalfOfCredentialAuthConfig} config - User custom the message extension authentication configuration.
 * @param {initiateLoginEndpoint} initiateLoginEndpoint - Login page for Teams to redirect to.
 * @param {string| string[]} scopes - The list of scopes for which the token will have access.
 * @param {function} logic - Business logic when executing the link query in message extension with SSO or access token.
 *
 * @throws {@link ErrorCode|InternalError} when User invoke not response to message extension link query.
 * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
 * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
 * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
 *
 * @returns A MessageExtension Response for the activity. If the logic not return any, return void instead.
 */
function handleMessageExtensionLinkQueryWithSSO(context, config, initiateLoginEndpoint, scopes, logic) {
    return __awaiter(this, void 0, void 0, function* () {
        if (context.activity.name != "composeExtension/queryLink") {
            internalLogger.error(ErrorMessage.OnlySupportInLinkQueryActivity);
            throw new ErrorWithCode(formatString(ErrorMessage.OnlySupportInLinkQueryActivity), exports.ErrorCode.FailedOperation);
        }
        return yield executionWithTokenAndConfig(context, config !== null && config !== void 0 ? config : {}, initiateLoginEndpoint, scopes, logic);
    });
}

/**
 * A card action bot to respond to adaptive card universal actions.
 */
class CardActionBot {
    /**
     * Create a new instance of the `CardActionBot`.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param options - The initialize options.
     */
    constructor(adapter, options) {
        this.middleware = new CardActionMiddleware(options === null || options === void 0 ? void 0 : options.actions);
        this.adapter = adapter.use(this.middleware);
    }
    /**
     * Register a card action handler to the bot.
     *
     * @param actionHandler - A card action handler to be registered.
     */
    registerHandler(actionHandler) {
        if (actionHandler) {
            this.middleware.actionHandlers.push(actionHandler);
        }
    }
    /**
     * Register card action handlers to the bot.
     *
     * @param actionHandlers - A set of card action handlers to be registered.
     */
    registerHandlers(actionHandlers) {
        if (actionHandlers) {
            this.middleware.actionHandlers.push(...actionHandlers);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 */
class CommandBot {
    // eslint-disable-next-line no-secrets/no-secrets
    /**
     * Create a new instance of the `CommandBot`.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param options - The initialize options
     * @param ssoCommandActivityHandler - SSO execution activity handler.
     * @param ssoConfig - SSO configuration for Bot SSO.
     */
    constructor(adapter, options, ssoCommandActivityHandler, ssoConfig) {
        this.ssoConfig = ssoConfig;
        this.middleware = new CommandResponseMiddleware(options === null || options === void 0 ? void 0 : options.commands, options === null || options === void 0 ? void 0 : options.ssoCommands, ssoCommandActivityHandler);
        this.adapter = adapter.use(this.middleware);
    }
    /**
     * Register a command into the command bot.
     *
     * @param command - The command to be registered.
     */
    registerCommand(command) {
        if (command) {
            this.middleware.commandHandlers.push(command);
        }
    }
    /**
     * Register commands into the command bot.
     *
     * @param commands - The commands to be registered.
     */
    registerCommands(commands) {
        if (commands) {
            this.middleware.commandHandlers.push(...commands);
        }
    }
    /**
     * Register a sso command into the command bot.
     *
     * @param ssoCommand - The sso command to be registered.
     */
    registerSsoCommand(ssoCommand) {
        this.validateSsoActivityHandler();
        this.middleware.addSsoCommand(ssoCommand);
    }
    /**
     * Register sso commands into the command bot.
     *
     * @param ssoCommands - The sso commands to be registered.
     */
    registerSsoCommands(ssoCommands) {
        if (ssoCommands.length > 0) {
            this.validateSsoActivityHandler();
            for (const ssoCommand of ssoCommands) {
                this.middleware.addSsoCommand(ssoCommand);
            }
        }
    }
    validateSsoActivityHandler() {
        if (!this.middleware.ssoActivityHandler) {
            internalLogger.error(ErrorMessage.SsoActivityHandlerIsNull);
            throw new ErrorWithCode(ErrorMessage.SsoActivityHandlerIsNull, exports.ErrorCode.SsoActivityHandlerIsUndefined);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @param target - The notification target.
 * @param text - The plain text message.
 * @param onError - An optional error handler that can catch exceptions during message sending.
 * If not defined, error will be handled by `BotAdapter.onTurnError`.
 *
 * @returns The response of sending message.
 */
function sendMessage(target, text, onError) {
    return target.sendMessage(text, onError);
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @param target - The notification target.
 * @param card - The adaptive card raw JSON.
 * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
 * If not defined, error will be handled by `BotAdapter.onTurnError`.
 *
 * @returns The response of sending adaptive card message.
 */
function sendAdaptiveCard(target, card, onError) {
    return target.sendAdaptiveCard(card, onError);
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         */
        this.type = exports.NotificationTargetType.Channel;
        this.parent = parent;
        this.info = info;
    }
    /**
     * Send a plain text message.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity(text);
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity({
                            attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                        });
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        const reference = botbuilder.TurnContext.getConversationReference(context.activity);
        const channelConversation = cloneConversation(reference);
        channelConversation.conversation.id = this.info.id || "";
        return Promise.resolve(channelConversation);
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         */
        this.type = exports.NotificationTargetType.Person;
        this.parent = parent;
        this.account = account;
    }
    /**
     * Send a plain text message.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity(text);
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, this.parent.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversationAsync(this.parent.botAppId, conversation, (ctx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield ctx.sendActivity({
                            attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                        });
                        response.id = res === null || res === void 0 ? void 0 : res.id;
                    }
                    catch (error) {
                        if (onError) {
                            yield onError(ctx, error);
                        }
                        else {
                            throw error;
                        }
                    }
                }));
            }));
            return response;
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const personalConversation = cloneConversation(reference);
            const connectorClient = context.turnState.get(this.parent.adapter.ConnectorClientKey);
            const conversation = yield connectorClient.conversations.createConversation({
                isGroup: false,
                tenantId: context.activity.conversation.tenantId,
                bot: context.activity.recipient,
                members: [this.account],
                channelData: {},
            });
            personalConversation.conversation.id = conversation.id;
            return personalConversation;
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
class TeamsBotInstallation {
    /**
     * Constructor
     *
     * @remarks
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - The bound `CloudAdapter`.
     * @param conversationReference - The bound `ConversationReference`.
     * @param botAppId - The bot app id.
     */
    constructor(adapter, conversationReference, botAppId) {
        this.adapter = adapter;
        this.conversationReference = conversationReference;
        this.type = getTargetType(conversationReference);
        this.botAppId = botAppId;
    }
    /**
     * Send a plain text message.
     *
     * @param text - The plain text message.
     * @param onError - An optional error handler that can catch exceptions during message sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending message.
     */
    sendMessage(text, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.adapter.continueConversationAsync(this.botAppId, this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield context.sendActivity(text);
                    response.id = res === null || res === void 0 ? void 0 : res.id;
                }
                catch (error) {
                    if (onError) {
                        yield onError(context, error);
                    }
                    else {
                        throw error;
                    }
                }
            }));
            return response;
        });
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - The adaptive card raw JSON.
     * @param onError - An optional error handler that can catch exceptions during adaptive card sending.
     * If not defined, error will be handled by `BotAdapter.onTurnError`.
     *
     * @returns The response of sending adaptive card message.
     */
    sendAdaptiveCard(card, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {};
            yield this.adapter.continueConversationAsync(this.botAppId, this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield context.sendActivity({
                        attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                    });
                    response.id = res === null || res === void 0 ? void 0 : res.id;
                }
                catch (error) {
                    if (onError) {
                        yield onError(context, error);
                    }
                    else {
                        throw error;
                    }
                }
            }));
            return response;
        });
    }
    /**
     * Get channels from this bot installation.
     *
     * @returns An array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = [];
            if (this.type !== exports.NotificationTargetType.Channel) {
                return channels;
            }
            let teamsChannels = [];
            yield this.adapter.continueConversationAsync(this.botAppId, this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const teamId = getTeamsBotInstallationId(context);
                if (teamId !== undefined) {
                    teamsChannels = yield botbuilder.TeamsInfo.getTeamChannels(context, teamId);
                }
            }));
            for (const channel of teamsChannels) {
                channels.push(new Channel(this, channel));
            }
            return channels;
        });
    }
    /**
     * Gets a pagined list of members from this bot installation.
     *
     * @param pageSize - Suggested number of entries on a page.
     * @param continuationToken - A continuation token.
     * @returns An array of members from where the bot is installed.
     */
    getPagedMembers(pageSize, continuationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = {
                data: [],
                continuationToken: "",
            };
            yield this.adapter.continueConversationAsync(this.botAppId, this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const pagedMembers = yield botbuilder.TeamsInfo.getPagedMembers(context, pageSize, continuationToken);
                result = {
                    data: pagedMembers.members.map((m) => new Member(this, m)),
                    continuationToken: pagedMembers.continuationToken,
                };
            }));
            return result;
        });
    }
    /**
     * Get members from this bot installation.
     *
     * @returns An array of members from where the bot is installed.
     *
     * @deprecated Use `getPagedMembers` instead.
     */
    members() {
        return __awaiter(this, void 0, void 0, function* () {
            const members = [];
            let continuationToken;
            do {
                const pagedData = yield this.getPagedMembers(undefined, continuationToken);
                continuationToken = pagedData.continuationToken;
                members.push(...pagedData.data);
            } while (continuationToken);
            return members;
        });
    }
    /**
     * Get team details from this bot installation
     *
     * @returns The team details if bot is installed into a team, otherwise returns `undefined`.
     */
    getTeamDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.type !== exports.NotificationTargetType.Channel) {
                return undefined;
            }
            let teamDetails;
            yield this.adapter.continueConversationAsync(this.botAppId, this.conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                const teamId = getTeamsBotInstallationId(context);
                if (teamId !== undefined) {
                    teamDetails = yield botbuilder.TeamsInfo.getTeamDetails(context, teamId);
                }
            }));
            return teamDetails;
        });
    }
}
/**
 * Provide utilities to send notification to varies targets (e.g., member, group, channel).
 */
class NotificationBot {
    /**
     * Constructor of the notification bot.
     *
     * @remarks
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - The bound `CloudAdapter`
     * @param options - The initialize options
     */
    constructor(adapter, options) {
        var _a, _b, _c;
        if (options === null || options === void 0 ? void 0 : options.store) {
            this.conversationReferenceStore = options.store;
        }
        else {
            const storage = (_a = options === null || options === void 0 ? void 0 : options.storage) !== null && _a !== void 0 ? _a : new LocalFileStorage(path__namespace.resolve(process.env.RUNNING_ON_AZURE === "1" ? (_b = process.env.TEMP) !== null && _b !== void 0 ? _b : "./" : "./"));
            this.conversationReferenceStore = new DefaultConversationReferenceStore(storage);
        }
        this.adapter = adapter.use(new NotificationMiddleware({
            conversationReferenceStore: this.conversationReferenceStore,
        }));
        this.botAppId = ((_c = options === null || options === void 0 ? void 0 : options.botAppId) !== null && _c !== void 0 ? _c : process.env.BOT_ID);
    }
    /**
     * Create a {@link TeamsBotInstallation} instance with conversation reference.
     *
     * @param conversationReference - The bound `ConversationReference`.
     * @returns - The {@link TeamsBotInstallation} instance or null.
     */
    buildTeamsBotInstallation(conversationReference) {
        if (!conversationReference) {
            throw new Error("conversationReference is required.");
        }
        return new TeamsBotInstallation(this.adapter, conversationReference, this.botAppId);
    }
    /**
     * Validate the installation by getting paged memebers.
     *
     * @param conversationReference The bound `ConversationReference`.
     * @returns Returns false if recieves `BotNotInConversationRoster` error, otherwise returns true.
     */
    validateInstallation(conversationReference) {
        return __awaiter(this, void 0, void 0, function* () {
            let isValid = true;
            yield this.adapter.continueConversationAsync(this.botAppId, conversationReference, (context) => __awaiter(this, void 0, void 0, function* () {
                try {
                    // try get member to see if the installation is still valid
                    yield botbuilder.TeamsInfo.getPagedMembers(context, 1);
                }
                catch (error) {
                    if (error.code === "BotNotInConversationRoster") {
                        isValid = false;
                    }
                }
            }));
            return isValid;
        });
    }
    /**
     * Gets a pagined list of targets where the bot is installed.
     *
     * @remarks
     * The result is retrieving from the persisted storage.
     *
     * @param pageSize - Suggested number of entries on a page.
     * @param continuationToken - A continuation token.
     *
     * @returns An array of {@link TeamsBotInstallation} with paged data and continuation token.
     */
    getPagedInstallations(pageSize, continuationToken, validationEnabled = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.conversationReferenceStore === undefined || this.adapter === undefined) {
                throw new Error("NotificationBot has not been initialized.");
            }
            const references = yield this.conversationReferenceStore.list(pageSize, continuationToken);
            const targets = [];
            for (const reference of references.data) {
                // validate connection
                let valid;
                if (validationEnabled) {
                    // try get member to see if the installation is still valid
                    valid = yield this.validateInstallation(reference);
                }
                if (!validationEnabled || (validationEnabled && valid)) {
                    targets.push(new TeamsBotInstallation(this.adapter, reference, this.botAppId));
                }
                else {
                    yield this.conversationReferenceStore.remove(getKey(reference), reference);
                }
            }
            return {
                data: targets,
                continuationToken: references.continuationToken,
            };
        });
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * The result is retrieving from the persisted storage.
     *
     * @returns An array of {@link TeamsBotInstallation}.
     *
     * @deprecated Use getPagedInstallations instead.
     */
    installations() {
        return __awaiter(this, void 0, void 0, function* () {
            let continuationToken;
            const targets = [];
            do {
                const result = yield this.getPagedInstallations(undefined, continuationToken);
                continuationToken = result.continuationToken;
                targets.push(...result.data);
            } while (continuationToken);
            return targets;
        });
    }
    /**
     * Return the first {@link Member} where predicate is true, and undefined otherwise.
     *
     * @param predicate - Find calls predicate once for each member of the installation,
     * until it finds one where predicate returns true. If such a member is found, find
     * immediately returns that member. Otherwise, find returns undefined.
     * @param scope - The scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     *
     * @returns The first {@link Member} where predicate is true, and `undefined` otherwise.
     */
    findMember(predicate, scope) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const target of yield this.installations()) {
                if (this.matchSearchScope(target, scope)) {
                    for (const member of yield target.members()) {
                        if (yield predicate(member)) {
                            return member;
                        }
                    }
                }
            }
            return;
        });
    }
    /**
     * Return the first {@link Channel} where predicate is true, and undefined otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise undefined will be returned.)
     *
     * @param predicate - Find calls predicate once for each channel of the installation,
     * until it finds one where predicate returns true. If such a channel is found, find
     * immediately returns that channel. Otherwise, find returns `undefined`.
     *
     * @returns The first {@link Channel} where predicate is true, and `undefined` otherwise.
     */
    findChannel(predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const target of yield this.installations()) {
                if (target.type === exports.NotificationTargetType.Channel) {
                    const teamDetails = yield target.getTeamDetails();
                    for (const channel of yield target.channels()) {
                        if (yield predicate(channel, teamDetails)) {
                            return channel;
                        }
                    }
                }
            }
            return;
        });
    }
    /**
     * Return all {@link Member} where predicate is true, and empty array otherwise.
     *
     * @param predicate - Find calls predicate for each member of the installation.
     * @param scope - The scope to find members from the installations
     * (personal chat, group chat, Teams channel).
     *
     * @returns An array of {@link Member} where predicate is true, and empty array otherwise.
     */
    findAllMembers(predicate, scope) {
        return __awaiter(this, void 0, void 0, function* () {
            const members = [];
            for (const target of yield this.installations()) {
                if (this.matchSearchScope(target, scope)) {
                    for (const member of yield target.members()) {
                        if (yield predicate(member)) {
                            members.push(member);
                        }
                    }
                }
            }
            return members;
        });
    }
    /**
     * Return all {@link Channel} where predicate is true, and empty array otherwise.
     * (Ensure the bot app is installed into the `General` channel, otherwise empty array will be returned.)
     *
     * @param predicate - Find calls predicate for each channel of the installation.
     *
     * @returns An array of {@link Channel} where predicate is true, and empty array otherwise.
     */
    findAllChannels(predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = [];
            for (const target of yield this.installations()) {
                if (target.type === exports.NotificationTargetType.Channel) {
                    const teamDetails = yield target.getTeamDetails();
                    for (const channel of yield target.channels()) {
                        if (yield predicate(channel, teamDetails)) {
                            channels.push(channel);
                        }
                    }
                }
            }
            return channels;
        });
    }
    matchSearchScope(target, scope) {
        scope = scope !== null && scope !== void 0 ? scope : SearchScope.All;
        return ((target.type === exports.NotificationTargetType.Channel && (scope & SearchScope.Channel) !== 0) ||
            (target.type === exports.NotificationTargetType.Group && (scope & SearchScope.Group) !== 0) ||
            (target.type === exports.NotificationTargetType.Person && (scope & SearchScope.Person) !== 0));
    }
}
/**
 * The search scope when calling {@link NotificationBot.findMember} and {@link NotificationBot.findAllMembers}.
 * The search scope is a flagged enum and it can be combined with `|`.
 * For example, to search from personal chat and group chat, use `SearchScope.Person | SearchScope.Group`.
 */
var SearchScope;
(function (SearchScope) {
    /**
     * Search members from the installations in personal chat only.
     */
    SearchScope[SearchScope["Person"] = 1] = "Person";
    /**
     * Search members from the installations in group chat only.
     */
    SearchScope[SearchScope["Group"] = 2] = "Group";
    /**
     * Search members from the installations in Teams channel only.
     */
    SearchScope[SearchScope["Channel"] = 4] = "Channel";
    /**
     * Search members from all installations including personal chat, group chat and Teams channel.
     */
    SearchScope[SearchScope["All"] = 7] = "All";
})(SearchScope || (SearchScope = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @example
 * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
 *
 * ```typescript
 * import { BotBuilderCloudAdapter } from "@microsoft/teamsfx";
 * import ConversationBot = BotBuilderCloudAdapter.ConversationBot;
 *
 * // register through constructor
 * const conversationBot = new ConversationBot({
 *   command: {
 *     enabled: true,
 *     commands: [ new HelloWorldCommandHandler() ],
 *   },
 * });
 *
 * // register through `register*` API
 * conversationBot.command.registerCommand(new HelpCommandHandler());
 * ```
 *
 * For notification, you can enable notification at initialization, then send notifications at any time.
 *
 * ```typescript
 * import { BotBuilderCloudAdapter } from "@microsoft/teamsfx";
 * import ConversationBot = BotBuilderCloudAdapter.ConversationBot;
 *
 * // enable through constructor
 * const conversationBot = new ConversationBot({
 *   notification: {
 *     enabled: true,
 *   },
 * });
 *
 * // get all bot installations and send message
 * for (const target of await conversationBot.notification.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await conversationBot.notification.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 *
 * @remarks
 * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
 *
 * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 *
 * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
 */
class ConversationBot {
    /**
     * Create new instance of the `ConversationBot`.
     *
     * @remarks
     * It's recommended to create your own adapter and storage for production environment instead of the default one.
     *
     * @param options - The initialize options.
     */
    constructor(options) {
        var _a, _b, _c, _d;
        if (options.adapter) {
            this.adapter = options.adapter;
        }
        else {
            this.adapter = this.createDefaultAdapter(options.adapterConfig);
        }
        let ssoCommandActivityHandler;
        if (options === null || options === void 0 ? void 0 : options.ssoConfig) {
            if ((_a = options.ssoConfig.dialog) === null || _a === void 0 ? void 0 : _a.CustomBotSsoExecutionActivityHandler) {
                ssoCommandActivityHandler =
                    new options.ssoConfig.dialog.CustomBotSsoExecutionActivityHandler(options.ssoConfig);
            }
            else {
                ssoCommandActivityHandler = new DefaultBotSsoExecutionActivityHandler(options.ssoConfig);
            }
        }
        if ((_b = options.command) === null || _b === void 0 ? void 0 : _b.enabled) {
            this.command = new CommandBot(this.adapter, options.command, ssoCommandActivityHandler, options.ssoConfig);
        }
        if ((_c = options.notification) === null || _c === void 0 ? void 0 : _c.enabled) {
            this.notification = new NotificationBot(this.adapter, options.notification);
        }
        if ((_d = options.cardAction) === null || _d === void 0 ? void 0 : _d.enabled) {
            this.cardAction = new CardActionBot(this.adapter, options.cardAction);
        }
    }
    createDefaultAdapter(adapterConfig) {
        const credentialsFactory = adapterConfig === undefined
            ? new botbuilder.ConfigurationServiceClientCredentialFactory({
                MicrosoftAppId: process.env.BOT_ID,
                MicrosoftAppPassword: process.env.BOT_PASSWORD,
                MicrosoftAppType: "MultiTenant",
            })
            : new botbuilder.ConfigurationServiceClientCredentialFactory(adapterConfig);
        const botFrameworkAuthentication = new botbuilder.ConfigurationBotFrameworkAuthentication({}, credentialsFactory);
        const adapter = new botbuilder.CloudAdapter(botFrameworkAuthentication);
        // the default error handler
        adapter.onTurnError = (context, error) => __awaiter(this, void 0, void 0, function* () {
            // This check writes out errors to console.
            console.error(`[onTurnError] unhandled error`, error);
            // Only send error message for user messages, not for other message types so the bot doesn't spam a channel or chat.
            if (context.activity.type === "message") {
                // Send a trace activity, which will be displayed in Bot Framework Emulator
                yield context.sendTraceActivity("OnTurnError Trace", error instanceof Error ? error.message : error, "https://www.botframework.com/schemas/error", "TurnError");
                // Send a message to the user
                yield context.sendActivity(`The bot encountered unhandled error: ${error.message}`);
                yield context.sendActivity("To continue to run this bot, please fix the bot source code.");
            }
        });
        return adapter;
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - An incoming HTTP [Request](xref:botbuilder.Request).
     * @param res - The corresponding HTTP [Response](xref:botbuilder.Response).
     * @param logic - The additional function to handle bot context.
     *
     * @example
     * For example, to use with Restify:
     * ``` typescript
     * // The default/empty behavior
     * server.use(restify.plugins.bodyParser());
     * server.post("api/messages", conversationBot.requestHandler);
     *
     * // Or, add your own logic
     * server.use(restify.plugins.bodyParser());
     * server.post("api/messages", async (req, res) => {
     *   await conversationBot.requestHandler(req, res, async (context) => {
     *     // your-own-context-logic
     *   });
     * });
     * ```
     */
    requestHandler(req, res, logic) {
        return __awaiter(this, void 0, void 0, function* () {
            if (logic === undefined) {
                // create empty logic
                logic = () => __awaiter(this, void 0, void 0, function* () { });
            }
            yield this.adapter.process(req, res, logic);
        });
    }
}

var conversationWithCloudAdapter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ConversationBot: ConversationBot,
  BotSsoExecutionDialog: BotSsoExecutionDialog,
  Channel: Channel,
  Member: Member,
  NotificationBot: NotificationBot,
  sendAdaptiveCard: sendAdaptiveCard,
  sendMessage: sendMessage,
  TeamsBotInstallation: TeamsBotInstallation,
  get SearchScope () { return SearchScope; },
  CommandBot: CommandBot,
  CardActionBot: CardActionBot
});

exports.ApiKeyProvider = ApiKeyProvider;
exports.AppCredential = AppCredential;
exports.BasicAuthProvider = BasicAuthProvider;
exports.BearerTokenAuthProvider = BearerTokenAuthProvider;
exports.BotBuilderCloudAdapter = conversationWithCloudAdapter;
exports.BotSsoExecutionDialog = BotSsoExecutionDialog;
exports.CardActionBot = CardActionBot$1;
exports.CertificateAuthProvider = CertificateAuthProvider;
exports.Channel = Channel$1;
exports.CommandBot = CommandBot$1;
exports.ConversationBot = ConversationBot$1;
exports.ErrorWithCode = ErrorWithCode;
exports.InvokeResponseFactory = InvokeResponseFactory;
exports.Member = Member$1;
exports.MessageBuilder = MessageBuilder;
exports.MsGraphAuthProvider = MsGraphAuthProvider;
exports.NotificationBot = NotificationBot$1;
exports.OnBehalfOfUserCredential = OnBehalfOfUserCredential;
exports.TeamsBotInstallation = TeamsBotInstallation$1;
exports.TeamsBotSsoPrompt = TeamsBotSsoPrompt;
exports.TeamsFx = TeamsFx;
exports.TeamsUserCredential = TeamsUserCredential;
exports.createApiClient = createApiClient;
exports.createMicrosoftGraphClient = createMicrosoftGraphClient;
exports.createMicrosoftGraphClientWithCredential = createMicrosoftGraphClientWithCredential;
exports.createPemCertOption = createPemCertOption;
exports.createPfxCertOption = createPfxCertOption;
exports.getLogLevel = getLogLevel;
exports.getTediousConnectionConfig = getTediousConnectionConfig;
exports.handleMessageExtensionLinkQueryWithSSO = handleMessageExtensionLinkQueryWithSSO;
exports.handleMessageExtensionQueryWithSSO = handleMessageExtensionQueryWithSSO;
exports.handleMessageExtensionQueryWithToken = handleMessageExtensionQueryWithToken;
exports.sendAdaptiveCard = sendAdaptiveCard$1;
exports.sendMessage = sendMessage$1;
exports.setLogFunction = setLogFunction;
exports.setLogLevel = setLogLevel;
exports.setLogger = setLogger;
//# sourceMappingURL=index.node.cjs.js.map
