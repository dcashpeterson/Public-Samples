import { OperationStatus } from './OperationStatus';
import type { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';
import type { RushConfiguration } from '../../api/RushConfiguration';
import type { RushConfigurationProject } from '../../api/RushConfigurationProject';
import type { ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';
import type { IPhase } from '../../api/CommandLineConfiguration';
export interface IOperationRunnerOptions {
    rushProject: RushConfigurationProject;
    rushConfiguration: RushConfiguration;
    commandToRun: string;
    projectChangeAnalyzer: ProjectChangeAnalyzer;
    displayName: string;
    phase: IPhase;
    /**
     * The set of phases being executed in the current command, for validation of rush-project.json
     */
    selectedPhases: Iterable<IPhase>;
}
/**
 * An `IOperationRunner` subclass that performs an operation via a shell command.
 * Currently contains the build cache logic, pending extraction as separate operations.
 * Supports skipping an operation if allowed and it is already up-to-date.
 */
export declare class ShellOperationRunner implements IOperationRunner {
    readonly name: string;
    readonly reportTiming: boolean;
    readonly silent: boolean;
    readonly cacheable: boolean;
    readonly warningsAreAllowed: boolean;
    private readonly _commandToRun;
    private readonly _logFilenameIdentifier;
    private readonly _rushProject;
    private readonly _rushConfiguration;
    constructor(options: IOperationRunnerOptions);
    executeAsync(context: IOperationRunnerContext): Promise<OperationStatus>;
    getConfigHash(): string;
    private _executeAsync;
}
/**
 * When running a command from the "scripts" block in package.json, if the command
 * contains Unix-style path slashes and the OS is Windows, the package managers will
 * convert slashes to backslashes.  This is a complicated undertaking.  For example, they
 * need to convert "node_modules/bin/this && ./scripts/that --name keep/this"
 * to "node_modules\bin\this && .\scripts\that --name keep/this", and they don't want to
 * convert ANY of the slashes in "cmd.exe /c echo a/b".  NPM and PNPM use npm-lifecycle for this,
 * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a
 * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.
 *
 * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write
 * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).
 * It's very tricky for a developer to guess what's safe to do without testing every OS.
 * Even simple path separators are not portable, so NPM added heuristics to figure out which
 * slashes are part of a path or not, and convert them.  These workarounds end up having tons
 * of special cases.  They probably could have implemented their own entire minimal cross-platform
 * shell language with less code and less confusion than npm-lifecycle's approach.
 *
 * We've deprecated shell operators inside package.json.  Instead, we advise people to move their
 * scripts into conventional script files, and put only a file path in package.json.  So, for
 * Rush's workaround here, we really only care about supporting the small set of cases seen in the
 * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched
 * (i.e. err on the side of not breaking anything).  We could revisit this later if someone
 * complains about it, but so far nobody has.  :-)
 */
export declare function convertSlashesForWindows(command: string): string;
//# sourceMappingURL=ShellOperationRunner.d.ts.map