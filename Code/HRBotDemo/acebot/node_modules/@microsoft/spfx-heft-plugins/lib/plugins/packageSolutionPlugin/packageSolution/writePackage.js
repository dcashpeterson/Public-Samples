"use strict";
/**
 * Writes a package xml object to disk, in both raw and zipped format
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeODCFileAsync = exports.writeXmlFileAsync = exports.writeIconAsync = exports.writeFeatureAsync = exports.cleanRawPackageDirectoryAsync = exports.writePackageAsync = void 0;
const path = __importStar(require("path"));
const jszip_1 = __importDefault(require("jszip"));
const node_core_library_1 = require("@rushstack/node-core-library");
const utilities_1 = require("../utilities");
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */
async function writePackageAsync(terminal, solution, config, noSpppkg) {
    const zip = new jszip_1.default();
    await cleanRawPackageDirectoryAsync(terminal, config);
    await Promise.all([
        writeODCFileAsync(terminal, solution.manifest, config, zip),
        writeXmlFileAsync(terminal, solution.relationships, config, zip),
        writeXmlFileAsync(terminal, solution.contentTypesXml, config, zip),
        writeIconAsync(terminal, solution.icon, config, zip)
    ]
        .concat(solution.customFiles.map((customFile) => writeXmlFileAsync(terminal, customFile, config, zip)))
        .concat(solution.features.map((feature) => writeFeatureAsync(terminal, feature, config, zip))));
    if (!noSpppkg) {
        const zipFile = await zip.generateAsync({
            type: 'nodebuffer',
            compression: 'DEFLATE',
            compressionOptions: { level: 9 }
        });
        await writeFileAsync(terminal, config.paths.zippedPackage, zipFile);
    }
}
exports.writePackageAsync = writePackageAsync;
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */
async function cleanRawPackageDirectoryAsync(terminal, config) {
    await node_core_library_1.FileSystem.deleteFolderAsync(config.paths.debugDir);
    terminal.writeLine(`Cleaned ${config.paths.debugDir}`);
}
exports.cleanRawPackageDirectoryAsync = cleanRawPackageDirectoryAsync;
async function writeFeatureAsync(terminal, feature, config, zip) {
    await Promise.all([
        writeODCFileAsync(terminal, feature, config, zip),
        writeXmlFileAsync(terminal, feature.config, config, zip)
    ]
        .concat((feature.clientSideResources || []).map((resource) => writeXmlFileAsync(terminal, resource, config, zip)))
        .concat(feature.assets.elementFiles.map((asset) => writeXmlFileAsync(terminal, asset, config, zip)))
        .concat(feature.assets.elementManifests.map((asset) => writeXmlFileAsync(terminal, asset, config, zip)))
        .concat(feature.assets.upgradeActions.map((asset) => writeXmlFileAsync(terminal, asset, config, zip)))
        .concat(feature.components.map((component) => writeXmlFileAsync(terminal, component, config, zip))));
}
exports.writeFeatureAsync = writeFeatureAsync;
/**
 * Write the app icon related files: The icon file itself, and the config.xml
 * If there is no icon it does nothing.
 * If the icon path is invalid, it throws an error.
 */
async function writeIconAsync(terminal, icon, config, zip) {
    if (icon) {
        const filepath = path.join(config.paths.packageDir, icon.path);
        if (node_core_library_1.FileSystem.getStatistics(filepath).isFile()) {
            await Promise.all([
                node_core_library_1.FileSystem.readFileToBufferAsync(filepath).then((data) => {
                    return writeFileToPathAsync(terminal, icon.path, data, config, zip);
                }),
                writeXmlFileAsync(terminal, icon.config, config, zip),
                writeXmlFileAsync(terminal, icon.relationships, config, zip)
            ]);
        }
        else {
            throw new Error(`Icon with path "${icon.path}" was not found.`);
        }
    }
}
exports.writeIconAsync = writeIconAsync;
async function writeXmlFileAsync(terminal, file, config, zip) {
    await writeFileToPathAsync(terminal, file.filename, file.contents, config, zip);
}
exports.writeXmlFileAsync = writeXmlFileAsync;
async function writeODCFileAsync(terminal, file, config, zip) {
    await Promise.all([
        writeFileToPathAsync(terminal, file.filename, file.contents, config, zip),
        writeXmlFileAsync(terminal, file.relationships, config, zip)
    ]);
}
exports.writeODCFileAsync = writeODCFileAsync;
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */
async function writeFileToPathAsync(terminal, filename, contents, config, zip) {
    const filepath = path.join(config.paths.debugDir, filename);
    await (0, utilities_1.serialAsync)([
        () => writeFileAsync(terminal, filepath, contents),
        () => addFileToZipAsync(filename, contents, zip)
    ]);
}
/**
 * Wraps fsx.writeFile in a promise
 */
async function writeFileAsync(terminal, filename, contents) {
    node_core_library_1.FileSystem.writeFile(filename, contents, { ensureFolderExists: true });
    terminal.writeLine(`Created file: ${filename}`);
}
/**
 * Adds a file to a zip package
 */
async function addFileToZipAsync(filepath, content, zip) {
    const directories = filepath.split(path.sep);
    const file = directories.pop();
    for (const dir of directories) {
        zip = zip.folder(dir);
    }
    zip.file(file, content);
}
//# sourceMappingURL=writePackage.js.map