{"version":3,"file":"scripts/PnpmfileShim.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wC","sources":["webpack://@microsoft/rush-lib/webpack/bootstrap","webpack://@microsoft/rush-lib/webpack/runtime/define property getters","webpack://@microsoft/rush-lib/webpack/runtime/hasOwnProperty shorthand","webpack://@microsoft/rush-lib/webpack/runtime/make namespace object","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmfileShim.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar _a;\nlet settings;\nlet allPreferredVersions;\nlet allowedAlternativeVersions;\nlet userPnpmfile;\nlet semver;\n// Initialize all external aspects of the pnpmfile shim. When using the shim, settings\n// are always expected to be available. Init must be called before running any hook that\n// depends on a resource obtained from or related to the settings, and will require modules\n// once so they aren't repeatedly required in the hook functions.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction init(context) {\n    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:\n    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134\n    // So we need to normalize the context format before we move on\n    if (typeof context !== 'object' || Array.isArray(context)) {\n        context = {\n            log: (message) => { },\n            originalContext: context\n        };\n    }\n    if (!settings) {\n        // Initialize the settings from file\n        if (!context.pnpmfileShimSettings) {\n            context.pnpmfileShimSettings = __non_webpack_require__('./pnpmfileSettings.json');\n        }\n        settings = context.pnpmfileShimSettings;\n    }\n    else if (!context.pnpmfileShimSettings) {\n        // Reuse the already initialized settings\n        context.pnpmfileShimSettings = settings;\n    }\n    if (!allPreferredVersions && settings.allPreferredVersions) {\n        allPreferredVersions = new Map(Object.entries(settings.allPreferredVersions));\n    }\n    if (!allowedAlternativeVersions && settings.allowedAlternativeVersions) {\n        allowedAlternativeVersions = new Map(Object.entries(settings.allowedAlternativeVersions).map(([packageName, versions]) => {\n            return [packageName, new Set(versions)];\n        }));\n    }\n    // If a userPnpmfilePath is provided, we expect it to exist\n    if (!userPnpmfile && settings.userPnpmfilePath) {\n        userPnpmfile = require(settings.userPnpmfilePath);\n    }\n    // If a semverPath is provided, we expect it to exist\n    if (!semver && settings.semverPath) {\n        semver = require(settings.semverPath);\n    }\n    // Return the normalized context\n    return context;\n}\n// Set the preferred versions on the dependency map. If the version on the map is an allowedAlternativeVersion\n// then skip it. Otherwise, check to ensure that the common version is a subset of the specified version. If\n// it is, then replace the specified version with the preferredVersion\nfunction setPreferredVersions(dependencies) {\n    var _a;\n    for (const [name, version] of Object.entries(dependencies || {})) {\n        const preferredVersion = allPreferredVersions === null || allPreferredVersions === void 0 ? void 0 : allPreferredVersions.get(name);\n        if (preferredVersion && !((_a = allowedAlternativeVersions === null || allowedAlternativeVersions === void 0 ? void 0 : allowedAlternativeVersions.get(name)) === null || _a === void 0 ? void 0 : _a.has(version))) {\n            let preferredVersionRange;\n            let versionRange;\n            try {\n                preferredVersionRange = new semver.Range(preferredVersion);\n                versionRange = new semver.Range(version);\n            }\n            catch (_b) {\n                // Swallow invalid range errors\n            }\n            if (preferredVersionRange &&\n                versionRange &&\n                semver.subset(preferredVersionRange, versionRange, { includePrerelease: true })) {\n                dependencies[name] = preferredVersion;\n            }\n        }\n    }\n}\nexport const hooks = {\n    // Call the original pnpmfile (if it exists)\n    afterAllResolved: (lockfile, context) => {\n        var _a;\n        context = init(context);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)\n            ? userPnpmfile.hooks.afterAllResolved(lockfile, context)\n            : lockfile;\n    },\n    // Set the preferred versions in the package, then call the original pnpmfile (if it exists)\n    readPackage: (pkg, context) => {\n        var _a;\n        context = init(context);\n        setPreferredVersions(pkg.dependencies);\n        setPreferredVersions(pkg.devDependencies);\n        setPreferredVersions(pkg.optionalDependencies);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;\n    },\n    // Call the original pnpmfile (if it exists)\n    filterLog: (_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.filterLog\n};\n//# sourceMappingURL=PnpmfileShim.js.map"],"names":[],"sourceRoot":""}