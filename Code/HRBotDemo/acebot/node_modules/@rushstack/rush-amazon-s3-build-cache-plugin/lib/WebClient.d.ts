/// <reference types="node" />
import * as fetch from 'node-fetch';
/**
 * For use with {@link WebClient}.
 *
 * @public
 */
export type WebClientResponse = fetch.Response;
/**
 * For use with {@link WebClient}.
 *
 * @public
 */
export interface IWebFetchOptionsBase {
    timeoutMs?: number;
    verb?: 'GET' | 'PUT';
    headers?: fetch.Headers;
}
/**
 * For use with {@link WebClient}.
 *
 * @public
 */
export interface IGetFetchOptions extends IWebFetchOptionsBase {
    verb: 'GET' | never;
}
/**
 * For use with {@link WebClient}.
 *
 * @public
 */
export interface IPutFetchOptions extends IWebFetchOptionsBase {
    verb: 'PUT';
    body?: Buffer;
}
/**
 * For use with {@link WebClient}.
 * @public
 */
export declare enum WebClientProxy {
    None = 0,
    Detect = 1,
    Fiddler = 2
}
/**
 * A helper for issuing HTTP requests.
 *
 * @public
 */
export declare class WebClient {
    readonly standardHeaders: fetch.Headers;
    accept: string | undefined;
    userAgent: string | undefined;
    proxy: WebClientProxy;
    constructor();
    static mergeHeaders(target: fetch.Headers, source: fetch.Headers): void;
    addBasicAuthHeader(userName: string, password: string): void;
    fetchAsync(url: string, options?: IGetFetchOptions | IPutFetchOptions): Promise<WebClientResponse>;
}
//# sourceMappingURL=WebClient.d.ts.map