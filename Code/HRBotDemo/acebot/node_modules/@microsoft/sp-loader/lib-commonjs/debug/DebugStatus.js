"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugStatus = void 0;
var tslib_1 = require("tslib");
var ensureDebugComponents_1 = tslib_1.__importDefault(require("./ensureDebugComponents"));
/**
 * State of whether debug is allowed or not.
 * "false" means debug has not been confirmed or is prohibited, and "true" means debug is allowed.
 */
var _loaderDebugAllowed = false;
var _manifestsDebugAllowed = false;
var _debugAllowedPromise;
var DebugStatus = /** @class */ (function () {
    function DebugStatus() {
    }
    DebugStatus.confirmDebugAllowed = function (options) {
        // Initially set values from sessionStorage options.
        _loaderDebugAllowed = options.loaderDebugAlreadyAllowed || false;
        _manifestsDebugAllowed = options.manifestsDebugAlreadyAllowed || false;
        if (DebugStatus._requiresPrompt(options)) {
            if (!_debugAllowedPromise) {
                _debugAllowedPromise = new Promise(function (resolve) {
                    // Download the prompt
                    (0, ensureDebugComponents_1.default)()
                        .then(function (debugComponents) {
                        // Show the prompt
                        return debugComponents.showDebugPrompt(options).then(function (allowed) {
                            _debugAllowedPromise = undefined;
                            if (options.loaderRequested) {
                                _loaderDebugAllowed = allowed;
                            }
                            if (options.manifestsRequested) {
                                _manifestsDebugAllowed = allowed;
                            }
                            resolve(allowed);
                        });
                    })
                        // eslint-disable-next-line no-console
                        .catch(console.error);
                });
                return _debugAllowedPromise;
            }
            else {
                throw new Error('Debug prompt is currently being shown and cannot be shown again until it has been dismissed.');
            }
        }
        else {
            return Promise.resolve(DebugStatus.peekDebugAllowed(options));
        }
    };
    DebugStatus.dangerouslyEnableDebug = function () {
        _loaderDebugAllowed = true;
        _manifestsDebugAllowed = true;
    };
    /**
     * Determines if all requested debug URLs are allowed.
     * @param options - IDebugPromptOptions.
     */
    DebugStatus.peekDebugAllowed = function (options) {
        return ((!options.loaderRequested || _loaderDebugAllowed) &&
            (!options.manifestsRequested || _manifestsDebugAllowed));
    };
    /**
     * Only require the prompt when a debug URL is requested and not already allowed.
     * @param options - IDebugPromptOptions.
     */
    DebugStatus._requiresPrompt = function (options) {
        return ((options.loaderRequested && !_loaderDebugAllowed) ||
            (options.manifestsRequested && !_manifestsDebugAllowed));
    };
    return DebugStatus;
}());
exports.DebugStatus = DebugStatus;
//# sourceMappingURL=DebugStatus.js.map