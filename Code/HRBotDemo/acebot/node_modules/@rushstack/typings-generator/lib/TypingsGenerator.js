"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypingsGenerator = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const fast_glob_1 = __importDefault(require("fast-glob"));
const path = __importStar(require("path"));
const os_1 = require("os");
const chokidar = __importStar(require("chokidar"));
/**
 * This is a simple tool that generates .d.ts files for non-TS files.
 *
 * @public
 */
class TypingsGenerator {
    constructor(options) {
        var _a;
        this._options = Object.assign(Object.assign({}, options), { readFile: (_a = options.readFile) !== null && _a !== void 0 ? _a : ((filePath, relativePath) => node_core_library_1.FileSystem.readFileAsync(filePath)) });
        if (options.filesToIgnore) {
            throw new Error('The filesToIgnore option is no longer supported. Please use globsToIgnore instead.');
        }
        if (!options.generatedTsFolder) {
            throw new Error('generatedTsFolder must be provided');
        }
        if (!options.srcFolder) {
            throw new Error('srcFolder must be provided');
        }
        this.sourceFolderPath = options.srcFolder;
        if (node_core_library_1.Path.isUnder(options.srcFolder, options.generatedTsFolder)) {
            throw new Error('srcFolder must not be under generatedTsFolder');
        }
        if (node_core_library_1.Path.isUnder(options.generatedTsFolder, options.srcFolder)) {
            throw new Error('generatedTsFolder must not be under srcFolder');
        }
        if (!options.fileExtensions || options.fileExtensions.length === 0) {
            throw new Error('At least one file extension must be provided.');
        }
        this.ignoredFileGlobs = options.globsToIgnore || [];
        if (!options.terminal) {
            this._options.terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider({ verboseEnabled: true }));
        }
        this._options.fileExtensions = this._normalizeFileExtensions(options.fileExtensions);
        this._dependenciesOfFile = new Map();
        this._consumersOfFile = new Map();
        this._relativePaths = new Map();
        this.inputFileGlob = `**/*+(${this._options.fileExtensions.join('|')})`;
    }
    /**
     * Generate typings for the provided input files.
     *
     * @param relativeFilePaths - The input files to process, relative to the source folder. If not provided,
     * all input files will be processed.
     */
    async generateTypingsAsync(relativeFilePaths) {
        let checkFilePaths = true;
        if (!(relativeFilePaths === null || relativeFilePaths === void 0 ? void 0 : relativeFilePaths.length)) {
            checkFilePaths = false; // Don't check file paths if we generate them
            relativeFilePaths = await (0, fast_glob_1.default)(this.inputFileGlob, {
                cwd: this.sourceFolderPath,
                ignore: this.ignoredFileGlobs,
                onlyFiles: true
            });
        }
        await this._reprocessFiles(relativeFilePaths, checkFilePaths);
    }
    async runWatcherAsync() {
        await node_core_library_1.FileSystem.ensureFolderAsync(this._options.generatedTsFolder);
        await new Promise((resolve, reject) => {
            const watcher = chokidar.watch(this.inputFileGlob, {
                cwd: this.sourceFolderPath,
                ignored: this.ignoredFileGlobs
            });
            const queue = new Set();
            let timeout;
            let processing = false;
            let flushAfterCompletion = false;
            const flushInternal = () => {
                processing = true;
                const toProcess = Array.from(queue);
                queue.clear();
                this._reprocessFiles(toProcess, false)
                    .then(() => {
                    processing = false;
                    // If the timeout was invoked again, immediately reexecute with the changed files.
                    if (flushAfterCompletion) {
                        flushAfterCompletion = false;
                        flushInternal();
                    }
                })
                    .catch(reject);
            };
            const debouncedFlush = () => {
                timeout = undefined;
                if (processing) {
                    // If the callback was invoked while processing is ongoing, indicate that we should flush immediately
                    // upon completion of the current change batch.
                    flushAfterCompletion = true;
                    return;
                }
                flushInternal();
            };
            const onChange = (relativePath) => {
                queue.add(relativePath);
                if (timeout) {
                    clearTimeout(timeout);
                }
                setTimeout(debouncedFlush, 100);
            };
            watcher.on('add', onChange);
            watcher.on('change', onChange);
            watcher.on('unlink', async (relativePath) => {
                await Promise.all(this._getOutputFilePathsWithoutCheck(relativePath).map(async (outputFile) => {
                    await node_core_library_1.FileSystem.deleteFileAsync(outputFile);
                }));
            });
            watcher.on('error', reject);
        });
    }
    /**
     * Register file dependencies that may effect the typings of a consumer file.
     * Note: This feature is only useful in watch mode.
     * The registerDependency method must be called in the body of parseAndGenerateTypings every
     * time because the registry for a file is cleared at the beginning of processing.
     */
    registerDependency(consumer, rawDependency) {
        // Need to normalize slashes in the dependency path
        const dependency = path.resolve(this._options.srcFolder, rawDependency);
        let dependencies = this._dependenciesOfFile.get(consumer);
        if (!dependencies) {
            dependencies = new Set();
            this._dependenciesOfFile.set(consumer, dependencies);
        }
        dependencies.add(dependency);
        let consumers = this._consumersOfFile.get(dependency);
        if (!consumers) {
            consumers = new Set();
            this._consumersOfFile.set(dependency, consumers);
        }
        consumers.add(consumer);
    }
    getOutputFilePaths(relativePath) {
        if (path.isAbsolute(relativePath)) {
            throw new Error(`"${relativePath}" must be relative`);
        }
        return this._getOutputFilePathsWithoutCheck(relativePath);
    }
    _getOutputFilePathsWithoutCheck(relativePath) {
        var _a, _b;
        const typingsFilePaths = this._getTypingsFilePaths(relativePath);
        const additionalPaths = (_b = (_a = this._options).getAdditionalOutputFiles) === null || _b === void 0 ? void 0 : _b.call(_a, relativePath);
        return additionalPaths ? [...typingsFilePaths, ...additionalPaths] : Array.from(typingsFilePaths);
    }
    async _reprocessFiles(relativePaths, checkFilePaths) {
        // Build a queue of resolved paths
        const toProcess = new Set();
        for (const rawPath of relativePaths) {
            if (checkFilePaths && path.isAbsolute(rawPath)) {
                throw new Error(`"${rawPath}" must be relative`);
            }
            const relativePath = node_core_library_1.Path.convertToSlashes(rawPath);
            const resolvedPath = path.resolve(this._options.srcFolder, rawPath);
            this._relativePaths.set(resolvedPath, relativePath);
            toProcess.add(resolvedPath);
        }
        // Expand out all registered consumers, according to the current dependency graph
        for (const file of toProcess) {
            const consumers = this._consumersOfFile.get(file);
            if (consumers) {
                for (const consumer of consumers) {
                    toProcess.add(consumer);
                }
            }
        }
        // Map back to the relative paths so that the information is available
        await node_core_library_1.Async.forEachAsync(toProcess, async (resolvedPath) => {
            const relativePath = this._relativePaths.get(resolvedPath);
            if (!relativePath) {
                throw new Error(`Missing relative path for file ${resolvedPath}`);
            }
            await this._parseFileAndGenerateTypingsAsync(relativePath, resolvedPath);
        }, { concurrency: 20 });
    }
    async _parseFileAndGenerateTypingsAsync(relativePath, resolvedPath) {
        // Clear registered dependencies prior to reprocessing.
        this._clearDependencies(resolvedPath);
        try {
            const fileContents = await this._options.readFile(resolvedPath, relativePath);
            const typingsData = await this._options.parseAndGenerateTypings(fileContents, resolvedPath, relativePath);
            // Typings data will be undefined when no types should be generated for the parsed file.
            if (typingsData === undefined) {
                return;
            }
            const prefixedTypingsData = [
                '// This file was generated by a tool. Modifying it will produce unexpected behavior',
                '',
                typingsData
            ].join(os_1.EOL);
            const generatedTsFilePaths = this._getTypingsFilePaths(relativePath);
            for (const generatedTsFilePath of generatedTsFilePaths) {
                await node_core_library_1.FileSystem.writeFileAsync(generatedTsFilePath, prefixedTypingsData, {
                    ensureFolderExists: true,
                    convertLineEndings: node_core_library_1.NewlineKind.OsDefault
                });
            }
        }
        catch (e) {
            this._options.terminal.writeError(`Error occurred parsing and generating typings for file "${resolvedPath}": ${e}`);
        }
    }
    /**
     * Removes the consumer from all extant dependencies
     */
    _clearDependencies(consumer) {
        const dependencies = this._dependenciesOfFile.get(consumer);
        if (dependencies) {
            for (const dependency of dependencies) {
                this._consumersOfFile.get(dependency).delete(consumer);
            }
            dependencies.clear();
        }
    }
    *_getTypingsFilePaths(relativePath) {
        const { generatedTsFolder, secondaryGeneratedTsFolders } = this._options;
        const dtsFilename = `${relativePath}.d.ts`;
        yield path.resolve(generatedTsFolder, dtsFilename);
        if (secondaryGeneratedTsFolders) {
            for (const secondaryGeneratedTsFolder of secondaryGeneratedTsFolders) {
                yield path.resolve(secondaryGeneratedTsFolder, dtsFilename);
            }
        }
    }
    _normalizeFileExtensions(fileExtensions) {
        const result = new Set();
        for (const fileExtension of fileExtensions) {
            if (!fileExtension.startsWith('.')) {
                result.add(`.${fileExtension}`);
            }
            else {
                result.add(fileExtension);
            }
        }
        return Array.from(result);
    }
}
exports.TypingsGenerator = TypingsGenerator;
//# sourceMappingURL=TypingsGenerator.js.map