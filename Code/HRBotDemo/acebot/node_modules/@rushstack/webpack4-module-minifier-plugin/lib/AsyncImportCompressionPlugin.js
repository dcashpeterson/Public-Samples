"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncImportCompressionPlugin = void 0;
const webpack_1 = __importDefault(require("webpack"));
const { Template } = webpack_1.default;
const Constants_1 = require("./Constants");
const PLUGIN_NAME = 'AsyncImportCompressionPlugin';
const TAP_AFTER = {
    name: PLUGIN_NAME,
    stage: Constants_1.STAGE_AFTER
};
const ASYNC_IMPORT_PREFIX = '__IMPORT_ASYNC';
const ASYNC_IMPORT_REGEX = /__IMPORT_ASYNC[^\)]+/g;
function getImportDependency(compilation) {
    for (const key of compilation.dependencyTemplates.keys()) {
        if (key.name === 'ImportDependency') {
            return key;
        }
    }
    throw new Error(`Could not find ImportDependency!`);
}
function getImportTypeExpression(module, originModule) {
    var _a, _b;
    const exportsType = (_a = module.buildMeta) === null || _a === void 0 ? void 0 : _a.exportsType;
    const strict = (_b = originModule.buildMeta) === null || _b === void 0 ? void 0 : _b.strictHarmonyModule;
    // Logic translated from:
    // https://github.com/webpack/webpack/blob/3956274f1eada621e105208dcab4608883cdfdb2/lib/RuntimeTemplate.js#L110-L122
    if (exportsType === 'namespace') {
        // Use the raw module directly
        return '';
    }
    else if (exportsType === 'named') {
        // Create a new namespace object and forward all exports
        return ',3';
    }
    else if (strict) {
        // Synthetic default export
        return ',1';
    }
    else {
        // If modules is marked __esModule, return raw module, otherwise create a new namespace object and forward all exports
        return ',7';
    }
}
function needChunkOnDemandLoadingCode(chunk) {
    for (const chunkGroup of chunk.groupsIterable) {
        if (chunkGroup.getNumberOfChildren() > 0) {
            return true;
        }
    }
    return false;
}
/**
 * Plugin that replaces `Promise.all([__webpack_require__.e(1), __webpack_require__.e(12)]).then(__webpack_require__.t.bind(123,7))`
 * with more concise expressions like `__webpack_require__.ee([1,12],123,7)`, etc.
 *
 * Also ensures that the code seen by the minifier does not contain chunk ids, and is therefore portable across chunks/compilations.
 */
class AsyncImportCompressionPlugin {
    constructor(minifierHooks) {
        this._minifierHooks = minifierHooks;
    }
    apply(compiler) {
        const asyncImportMap = new Map();
        const asyncImportGroups = new Map();
        let rankedImportGroups;
        this._minifierHooks.postProcessCodeFragment.tap({
            name: PLUGIN_NAME,
            stage: -1
        }, (source, context) => {
            const code = source.original().source();
            let localImports;
            ASYNC_IMPORT_REGEX.lastIndex = -1;
            // RegExp.exec uses null or an array as the return type, explicitly
            let match = null;
            while ((match = ASYNC_IMPORT_REGEX.exec(code))) {
                const token = match[0];
                if (!localImports) {
                    if (!context.module) {
                        context.compilation.errors.push(new Error(`Unexpected async import ${token} in non-module context ${context.loggingName}`));
                        return source;
                    }
                    localImports = asyncImportMap.get(context.module);
                    if (!localImports) {
                        context.compilation.errors.push(new Error(`Unexpected async import ${token} in module ${context.loggingName}`));
                        return source;
                    }
                }
                const localImport = localImports.get(token);
                if (!localImport) {
                    context.compilation.errors.push(new Error(`Missing metadata for ${token} in module ${context.loggingName}`));
                    return source;
                }
                const { meta, module } = localImport;
                const chunkExpression = meta.index < 0 ? JSON.stringify(meta.chunkIds) : `${meta.index}`;
                const mapped = this._minifierHooks.finalModuleId.call(module.id, context.compilation);
                const idExpr = mapped === undefined ? module.id : mapped;
                // Replace with a reference or array of ideas, the target module id, and the type of import
                source.replace(match.index, ASYNC_IMPORT_REGEX.lastIndex - 1, `${chunkExpression},${JSON.stringify(idExpr)}${getImportTypeExpression(module, context.module)}`);
            }
            return source;
        });
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            asyncImportMap.clear();
            asyncImportGroups.clear();
            compilation.hooks.beforeChunkAssets.tap(TAP_AFTER, () => {
                const ImportDependency = getImportDependency(compilation);
                for (const module of compilation.modules) {
                    const toProcess = module.modules || [module];
                    for (const child of toProcess) {
                        child.hasDependencies((dep) => {
                            if (dep instanceof ImportDependency) {
                                const { module: targetModule } = dep;
                                if (targetModule) {
                                    let localAsyncImports = asyncImportMap.get(module);
                                    if (!localAsyncImports) {
                                        asyncImportMap.set(module, (localAsyncImports = new Map()));
                                    }
                                    const chunkGroup = dep.block.chunkGroup;
                                    const chunkIds = chunkGroup
                                        ? chunkGroup.chunks.map((chunk) => chunk.id).sort()
                                        : [];
                                    const idString = chunkIds.join(';');
                                    let meta = asyncImportGroups.get(idString);
                                    if (!meta) {
                                        asyncImportGroups.set(idString, (meta = {
                                            chunkCount: chunkIds.length,
                                            chunkIds: chunkIds,
                                            count: 0,
                                            index: -1
                                        }));
                                    }
                                    meta.count++;
                                    const stringKey = `${targetModule.id}`.replace(/[^A-Za-z0-9_$]/g, '_');
                                    const key = `${ASYNC_IMPORT_PREFIX}${stringKey}`;
                                    localAsyncImports.set(key, {
                                        meta,
                                        module: targetModule
                                    });
                                }
                            }
                        });
                    }
                }
                const rankedImports = [...asyncImportGroups]
                    .filter((x) => x[1].count > 1)
                    .sort((x, y) => {
                    let diff = y[1].count - x[1].count;
                    if (!diff) {
                        diff = y[1].chunkCount - x[1].chunkCount;
                    }
                    if (!diff) {
                        diff = x[0] > y[0] ? 1 : x[0] < y[0] ? -1 : 0;
                    }
                    return diff;
                });
                for (let i = 0, len = rankedImports.length; i < len; i++) {
                    rankedImports[i][1].index = i;
                    // console.log(rankedImports[i]);
                }
                rankedImportGroups = rankedImports.map((x) => x[1]);
                const { dependencyTemplates } = compilation;
                const defaultImplementation = dependencyTemplates.get(ImportDependency);
                if (!defaultImplementation) {
                    compilation.errors.push(new Error(`Could not find ImportDependencyTemplate`));
                }
                const customTemplate = {
                    apply(dep, source, runtime) {
                        if (dep.module) {
                            const stringKey = `${dep.module.id}`.replace(/[^A-Za-z0-9_$]/g, '_');
                            const key = `${ASYNC_IMPORT_PREFIX}${stringKey}`;
                            const content = `__webpack_require__.ee(${key})`;
                            source.replace(dep.block.range[0], dep.block.range[1] - 1, content);
                        }
                        else {
                            defaultImplementation === null || defaultImplementation === void 0 ? void 0 : defaultImplementation.apply(dep, source, runtime);
                        }
                    }
                };
                // Have to do this after the official plugin in order to override
                // Typings in webpack are incorrect. This is a DependencyTemplate object
                dependencyTemplates.set(ImportDependency, customTemplate);
            });
            compilation.mainTemplate.hooks.requireExtensions.tap(PLUGIN_NAME, (source, chunk) => {
                if (!needChunkOnDemandLoadingCode(chunk)) {
                    return source;
                }
                const { requireFn } = compilation.mainTemplate;
                return Template.asString([
                    `var asyncImportChunkGroups = [`,
                    rankedImportGroups
                        ? rankedImportGroups.map((x) => Template.indent(JSON.stringify(x.chunkIds))).join(',\n')
                        : '',
                    `];`,
                    `${requireFn}.ee = function (groupOrId, moduleId, importType) {`,
                    Template.indent([
                        `return Promise.all((Array.isArray(groupOrId) ? groupOrId : asyncImportChunkGroups[groupOrId]).map(function (x) { return ${requireFn}.e(x); }))`,
                        `.then(importType ? ${requireFn}.t.bind(0,moduleId,importType) : ${requireFn}.bind(0,moduleId));`
                    ]),
                    `};`,
                    source
                ]);
            });
        });
    }
}
exports.AsyncImportCompressionPlugin = AsyncImportCompressionPlugin;
//# sourceMappingURL=AsyncImportCompressionPlugin.js.map