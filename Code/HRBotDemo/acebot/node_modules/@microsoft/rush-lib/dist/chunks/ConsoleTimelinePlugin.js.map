{"version":3,"file":"chunks/ConsoleTimelinePlugin.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACqD;AACpB;AACmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qEAAuB;AAC5B,KAAK,mEAAqB;AAC1B,KAAK,oEAAsB;AAC3B,KAAK,uEAAyB;AAC9B,KAAK,6EAA+B;AACpC,KAAK,qEAAuB;AAC5B,KAAK,gFAAkC;AACvC,KAAK,qEAAuB;AAC5B,KAAK,qEAAuB;AAC5B,KAAK,qEAAuB;AAC5B,KAAK,uEAAyB;AAC9B,KAAK,kEAAoB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK,qEAAuB,GAAG,2DAAa;AAC5C,KAAK,mEAAqB,GAAG,2DAAa;AAC1C,KAAK,oEAAsB,GAAG,2DAAa;AAC3C,KAAK,uEAAyB,GAAG,2DAAa;AAC9C,KAAK,6EAA+B,GAAG,2DAAa;AACpD,KAAK,qEAAuB,GAAG,0DAAY;AAC3C,KAAK,gFAAkC,GAAG,2DAAa;AACvD,KAAK,qEAAuB,GAAG,wDAAU;AACzC,KAAK,qEAAuB,GAAG,wDAAU;AACzC,KAAK,qEAAuB,GAAG,0DAAY;AAC3C,KAAK,uEAAyB,GAAG,0DAAY;AAC7C,KAAK,kEAAoB,GAAG,yDAAW;AACvC;AACA;AACA;AACA;AACA;AACO,0BAA0B,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAW;AACjC;AACA,YAAY,uDAAW;AACvB,8BAA8B,uDAAW,oCAAoC,EAAE,OAAO,EAAE,wDAAY,uDAAuD;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C,uBAAuB,8BAA8B;AACrD,iCAAiC,SAAS;AAC1C,iCAAiC,+CAA+C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAW,qCAAqC,EAAE,oBAAoB;AAC1G;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ConsoleTimelinePlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PrintUtilities } from '@rushstack/terminal';\nimport colors from 'colors/safe';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'ConsoleTimelinePlugin';\n/* Sample output:\n==============================================================================================================================\n          @rushstack/tree-pattern (build) ###########-------------------------------------------------------------------- 3.3s\n          @rushstack/eslint-patch (build) ########----------------------------------------------------------------------- 2.2s\n           @rushstack/eslint-patch (test) -------%----------------------------------------------------------------------- 0.0s\n@rushstack/eslint-plugin-security (build) ----------########################--------------------------------------------- 6.8s\n@rushstack/eslint-plugin-packlets (build) ----------############################----------------------------------------- 8.1s\n         @rushstack/eslint-plugin (build) ----------##############################--------------------------------------- 8.7s\n           @rushstack/tree-pattern (test) ----------#####---------------------------------------------------------------- 1.2s\n @rushstack/eslint-plugin-security (test) ---------------------------------############---------------------------------- 3.3s\n @rushstack/eslint-plugin-packlets (test) -------------------------------------#####------------------------------------- 1.1s\n         @rushstack/eslint-config (build) ---------------------------------------%--------------------------------------- 0.0s\n          @rushstack/eslint-plugin (test) ---------------------------------------#############--------------------------- 3.8s\n          @rushstack/eslint-config (test) ---------------------------------------%--------------------------------------- 0.0s\n     @rushstack/node-core-library (build) ---------------------------------------################################-------- 9.5s\n      @rushstack/node-core-library (test) ----------------------------------------------------------------------######### 2.2s\n==============================================================================================================================\nLEGEND:                                                                                                      Total Work: 50.3s\n  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op                                                 Wall Clock: 23.7s\n                                                                                                       Max Parallelism Used: 5\n                                                                                                     Avg Parallelism Used: 2.1\nBY PHASE:\n      _phase:build 38.6s\n       _phase:test 11.7s\n*/\n/**\n * Phased command plugin that emits a timeline to the console.\n */\nexport class ConsoleTimelinePlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {\n            _printTimeline({\n                terminal: this._terminal,\n                result,\n                cobuildConfiguration: context.cobuildConfiguration\n            });\n        });\n    }\n}\n/**\n * Timeline - a wider column width for printing the timeline summary\n */\nconst TIMELINE_WIDTH = 109;\n/**\n * Timeline - symbols representing each operation status\n */\nconst TIMELINE_CHART_SYMBOLS = {\n    [OperationStatus.Waiting]: '?',\n    [OperationStatus.Ready]: '?',\n    [OperationStatus.Queued]: '?',\n    [OperationStatus.Executing]: '?',\n    [OperationStatus.RemoteExecuting]: '?',\n    [OperationStatus.Success]: '#',\n    [OperationStatus.SuccessWithWarning]: '!',\n    [OperationStatus.Failure]: '!',\n    [OperationStatus.Blocked]: '.',\n    [OperationStatus.Skipped]: '%',\n    [OperationStatus.FromCache]: '%',\n    [OperationStatus.NoOp]: '%'\n};\n/**\n * Timeline - colorizer for each operation status\n */\nconst TIMELINE_CHART_COLORIZER = {\n    [OperationStatus.Waiting]: colors.yellow,\n    [OperationStatus.Ready]: colors.yellow,\n    [OperationStatus.Queued]: colors.yellow,\n    [OperationStatus.Executing]: colors.yellow,\n    [OperationStatus.RemoteExecuting]: colors.yellow,\n    [OperationStatus.Success]: colors.green,\n    [OperationStatus.SuccessWithWarning]: colors.yellow,\n    [OperationStatus.Failure]: colors.red,\n    [OperationStatus.Blocked]: colors.red,\n    [OperationStatus.Skipped]: colors.green,\n    [OperationStatus.FromCache]: colors.green,\n    [OperationStatus.NoOp]: colors.gray\n};\n/**\n * Print a more detailed timeline and analysis of CPU usage for the build.\n * @internal\n */\nexport function _printTimeline({ terminal, result, cobuildConfiguration }) {\n    //\n    // Gather the operation records we'll be displaying. Do some inline max()\n    // finding to reduce the number of times we need to loop through operations.\n    //\n    var _a, _b;\n    const durationByPhase = new Map();\n    const data = [];\n    let longestNameLength = 0;\n    let longestDurationLength = 0;\n    let allStart = Infinity;\n    let allEnd = -Infinity;\n    let workDuration = 0;\n    for (const [operation, operationResult] of result.operationResults) {\n        if ((_a = operation.runner) === null || _a === void 0 ? void 0 : _a.silent) {\n            continue;\n        }\n        const { stopwatch } = operationResult;\n        const { startTime, endTime } = stopwatch;\n        if (startTime && endTime) {\n            const nameLength = ((_b = operation.name) === null || _b === void 0 ? void 0 : _b.length) || 0;\n            if (nameLength > longestNameLength) {\n                longestNameLength = nameLength;\n            }\n            const { duration } = stopwatch;\n            const durationString = duration.toFixed(1);\n            const durationLength = durationString.length;\n            if (durationLength > longestDurationLength) {\n                longestDurationLength = durationLength;\n            }\n            if (endTime > allEnd) {\n                allEnd = endTime;\n            }\n            if (startTime < allStart) {\n                allStart = startTime;\n            }\n            workDuration += duration;\n            const { associatedPhase } = operation;\n            if (associatedPhase) {\n                durationByPhase.set(associatedPhase, (durationByPhase.get(associatedPhase) || 0) + duration);\n            }\n            data.push({\n                startTime,\n                endTime,\n                durationString,\n                name: operation.name,\n                status: operationResult.status,\n                isExecuteByOtherCobuildRunner: !!operationResult.cobuildRunnerId &&\n                    operationResult.cobuildRunnerId !== (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildRunnerId)\n            });\n        }\n    }\n    data.sort((a, b) => a.startTime - b.startTime);\n    //\n    // Determine timing for all tasks (wall clock and execution times)\n    //\n    const allDuration = allEnd - allStart;\n    const allDurationSeconds = allDuration / 1000;\n    //\n    // Do some calculations to determine what size timeline chart we need.\n    //\n    const maxWidth = PrintUtilities.getConsoleWidth() || TIMELINE_WIDTH;\n    const chartWidth = maxWidth - longestNameLength - longestDurationLength - 4;\n    //\n    // Loop through all operations, assembling some statistics about operations and\n    // phases, if applicable.\n    //\n    const busyCpus = [];\n    function getOpenCPU(time) {\n        const len = busyCpus.length;\n        for (let i = 0; i < len; i++) {\n            if (busyCpus[i] <= time) {\n                return i;\n            }\n        }\n        return len;\n    }\n    // Start with a newline\n    terminal.writeLine('');\n    terminal.writeLine('='.repeat(maxWidth));\n    let hasCobuildSymbol = false;\n    function getChartSymbol(record) {\n        const { isExecuteByOtherCobuildRunner, status } = record;\n        if (isExecuteByOtherCobuildRunner) {\n            hasCobuildSymbol = true;\n            return 'C';\n        }\n        return TIMELINE_CHART_SYMBOLS[status];\n    }\n    for (const record of data) {\n        const { startTime, endTime, durationString, name, status } = record;\n        // Track busy CPUs\n        const openCpu = getOpenCPU(startTime);\n        busyCpus[openCpu] = endTime;\n        // Build timeline chart\n        const startIdx = Math.floor(((startTime - allStart) * chartWidth) / allDuration);\n        const endIdx = Math.floor(((endTime - allStart) * chartWidth) / allDuration);\n        const length = endIdx - startIdx + 1;\n        const chart = colors.gray('-'.repeat(startIdx)) +\n            TIMELINE_CHART_COLORIZER[status](getChartSymbol(record).repeat(length)) +\n            colors.gray('-'.repeat(chartWidth - endIdx));\n        terminal.writeLine(`${colors.cyan(name.padStart(longestNameLength))} ${chart} ${colors.white(durationString.padStart(longestDurationLength) + 's')}`);\n    }\n    terminal.writeLine('='.repeat(maxWidth));\n    //\n    // Format legend and summary areas\n    //\n    const usedCpus = busyCpus.length;\n    const legend = [\n        'LEGEND:',\n        '  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op',\n        '',\n        ''\n    ];\n    if (hasCobuildSymbol) {\n        legend[2] = '  [C] Cobuild';\n    }\n    const summary = [\n        `Total Work: ${workDuration.toFixed(1)}s`,\n        `Wall Clock: ${allDurationSeconds.toFixed(1)}s`,\n        `Max Parallelism Used: ${usedCpus}`,\n        `Avg Parallelism Used: ${(workDuration / allDurationSeconds).toFixed(1)}`\n    ];\n    terminal.writeLine(legend[0] + summary[0].padStart(maxWidth - legend[0].length));\n    terminal.writeLine(legend[1] + summary[1].padStart(maxWidth - legend[1].length));\n    terminal.writeLine(legend[2] + summary[2].padStart(maxWidth - legend[2].length));\n    terminal.writeLine(legend[3] + summary[3].padStart(maxWidth - legend[3].length));\n    //\n    // Include time-by-phase, if phases are enabled\n    //\n    if (durationByPhase.size > 0) {\n        terminal.writeLine('BY PHASE:');\n        let maxPhaseName = 16;\n        for (const phase of durationByPhase.keys()) {\n            const len = phase.name.length;\n            if (len > maxPhaseName) {\n                maxPhaseName = len;\n            }\n        }\n        for (const [phase, duration] of durationByPhase.entries()) {\n            terminal.writeLine(`  ${colors.cyan(phase.name.padStart(maxPhaseName))} ${duration.toFixed(1)}s`);\n        }\n    }\n    terminal.writeLine('');\n}\n//# sourceMappingURL=ConsoleTimelinePlugin.js.map"],"names":[],"sourceRoot":""}