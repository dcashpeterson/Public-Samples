{"version":3,"file":"hoist-jest-mock.js","sourceRoot":"","sources":["../src/hoist-jest-mock.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\r\nimport { AST_NODE_TYPES } from '@typescript-eslint/experimental-utils';\r\n\r\nimport * as hoistJestMockPatterns from './hoistJestMockPatterns';\r\n\r\ntype MessageIds = 'error-unhoisted-jest-mock';\r\ntype Options = [];\r\n\r\n// Jest APIs that need to be hoisted\r\n// Based on HOIST_METHODS from ts-jest\r\nconst HOIST_METHODS = ['mock', 'unmock', 'enableAutomock', 'disableAutomock', 'deepUnmock'];\r\n\r\nconst hoistJestMock: TSESLint.RuleModule<MessageIds, Options> = {\r\n  meta: {\r\n    type: 'problem',\r\n    messages: {\r\n      'error-unhoisted-jest-mock':\r\n        \"Jest's module mocking APIs must be called before regular imports. Move this call so that it precedes\" +\r\n        ' the import found on line {{importLine}}.'\r\n    },\r\n    schema: [\r\n      {\r\n        type: 'object',\r\n        additionalProperties: false\r\n      }\r\n    ],\r\n    docs: {\r\n      description:\r\n        'Require Jest module mocking APIs to be called before other modules are imported.' +\r\n        ' Jest module mocking APIs such as \"jest.mock(\\'./example\\')\" must be called before the associated module' +\r\n        ' is imported, otherwise they will have no effect. Transpilers such as ts-jest and babel-jest automatically' +\r\n        ' \"hoist\" these calls, however this can produce counterintuitive results. Instead, the hoist-jest-mocks' +\r\n        ' lint rule requires developers to manually hoist these calls. For technical background, please read the' +\r\n        ' Jest documentation here: https://jestjs.io/docs/en/es6-class-mocks',\r\n      // Deprecated in ESLint v8; Keep for backwards compatibility\r\n      category: 'Possible Errors',\r\n      recommended: 'error',\r\n      url: 'https://www.npmjs.com/package/@rushstack/eslint-plugin'\r\n    } as TSESLint.RuleMetaDataDocs\r\n  },\r\n\r\n  create: (context: TSESLint.RuleContext<MessageIds, Options>) => {\r\n    // Returns true for a statement such as \"jest.mock()\" that needs to precede\r\n    // module imports (i.e. be \"hoisted\").\r\n    function isHoistableJestCall(node: TSESTree.Node | undefined): boolean {\r\n      if (node === undefined) {\r\n        return false;\r\n      }\r\n\r\n      const captures: hoistJestMockPatterns.IJestCallExpression = {};\r\n\r\n      if (hoistJestMockPatterns.jestCallExpression.match(node, captures)) {\r\n        if (captures.methodName && HOIST_METHODS.indexOf(captures.methodName) >= 0) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      // Recurse into some common expression-combining syntaxes\r\n      switch (node.type) {\r\n        case AST_NODE_TYPES.CallExpression:\r\n          return isHoistableJestCall(node.callee);\r\n        case AST_NODE_TYPES.MemberExpression:\r\n          return isHoistableJestCall(node.object);\r\n        case AST_NODE_TYPES.LogicalExpression:\r\n          return isHoistableJestCall(node.left) || isHoistableJestCall(node.right);\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    // Given part of an expression, walk upwards in the tree and find the containing statement\r\n    function findOuterStatement(node: TSESTree.Node): TSESTree.Node {\r\n      let current: TSESTree.Node | undefined = node;\r\n      while (current.parent) {\r\n        switch (current.parent.type) {\r\n          // Statements are always found inside a block:\r\n          case AST_NODE_TYPES.Program:\r\n          case AST_NODE_TYPES.BlockStatement:\r\n          case AST_NODE_TYPES.TSModuleBlock:\r\n            return current;\r\n        }\r\n        current = current.parent;\r\n      }\r\n      return node;\r\n    }\r\n\r\n    // This tracks the first require() or import expression that we found in the file.\r\n    let firstImportNode: TSESTree.Node | undefined = undefined;\r\n\r\n    // Avoid reporting more than one error for a given statement.\r\n    // Example: jest.mock('a').mock('b');\r\n    const reportedStatements: Set<TSESTree.Node> = new Set();\r\n\r\n    return {\r\n      CallExpression: (node: TSESTree.CallExpression): void => {\r\n        if (firstImportNode === undefined) {\r\n          // EXAMPLE:  const x = require('x')\r\n          if (hoistJestMockPatterns.requireCallExpression.match(node)) {\r\n            firstImportNode = node;\r\n          }\r\n        }\r\n\r\n        if (firstImportNode) {\r\n          // EXAMPLE:  jest.mock()\r\n          if (isHoistableJestCall(node)) {\r\n            const outerStatement: TSESTree.Node = findOuterStatement(node);\r\n            if (!reportedStatements.has(outerStatement)) {\r\n              reportedStatements.add(outerStatement);\r\n              context.report({\r\n                node,\r\n                messageId: 'error-unhoisted-jest-mock',\r\n                data: { importLine: firstImportNode.loc.start.line }\r\n              });\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      ImportExpression: (node: TSESTree.ImportExpression): void => {\r\n        if (firstImportNode === undefined) {\r\n          // EXAMPLE:  const x = import('x');\r\n          if (hoistJestMockPatterns.importExpression.match(node)) {\r\n            firstImportNode = node;\r\n          }\r\n        }\r\n      },\r\n\r\n      ImportDeclaration: (node: TSESTree.ImportDeclaration): void => {\r\n        if (firstImportNode === undefined) {\r\n          // EXAMPLE:  import { X } from \"Y\";\r\n          // IGNORE:   import type { X } from \"Y\";\r\n          if (node.importKind !== 'type') {\r\n            firstImportNode = node;\r\n          }\r\n        }\r\n      },\r\n\r\n      ExportDeclaration: (node: TSESTree.ExportDeclaration): void => {\r\n        if (firstImportNode === undefined) {\r\n          // EXAMPLE: export * from \"Y\";\r\n          // IGNORE:  export type { Y } from \"Y\";\r\n          if ((node as any as TSESTree.ExportNamedDeclaration).exportKind !== 'type') {\r\n            firstImportNode = node;\r\n          }\r\n        }\r\n      },\r\n\r\n      TSImportEqualsDeclaration: (node: TSESTree.TSImportEqualsDeclaration): void => {\r\n        if (firstImportNode === undefined) {\r\n          // EXAMPLE:  import x = require(\"x\");\r\n          firstImportNode = node;\r\n        }\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nexport { hoistJestMock };\r\n"]}