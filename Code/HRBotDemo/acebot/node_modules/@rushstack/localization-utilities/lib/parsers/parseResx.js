"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseResx = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const xmldoc_1 = require("xmldoc");
/**
 * @public
 */
function parseResx(options) {
    const writeError = options.terminal.writeErrorLine.bind(options.terminal);
    const writeWarning = options.terminal.writeWarningLine.bind(options.terminal);
    const loggingFunctions = {
        logError: (message) => writeError(message),
        logWarning: (message) => writeWarning(message),
        logFileError: (message, filePath, line, position) => {
            _logWithLocation(writeError, message, filePath, line, position);
        },
        logFileWarning: (message, filePath, line, position) => {
            _logWithLocation(writeWarning, message, filePath, line, position);
        }
    };
    return _readResxAsLocFileInternal({
        ...options,
        loggingFunctions
    });
}
exports.parseResx = parseResx;
function _readResxAsLocFileInternal(options) {
    const { ignoreString } = options;
    const xmlDocument = new xmldoc_1.XmlDocument(options.content);
    if (xmlDocument.name !== 'root') {
        _logErrorWithLocation(options, `Expected RESX to have a "root" element, found "${xmlDocument.name}"`, xmlDocument);
    }
    const locFile = {};
    for (const childNode of xmlDocument.children) {
        switch (childNode.type) {
            case 'element': {
                switch (childNode.name) {
                    case 'data': {
                        const stringName = childNode.attr.name;
                        if (!stringName) {
                            _logErrorWithLocation(options, 'Unexpected missing or empty string name', childNode);
                        }
                        else {
                            if (locFile.hasOwnProperty(stringName)) {
                                _logErrorWithLocation(options, `Duplicate string value "${stringName}"`, childNode);
                            }
                            const locString = _readDataElement(options, childNode);
                            if (locString && !(ignoreString === null || ignoreString === void 0 ? void 0 : ignoreString(options.filePath, stringName))) {
                                locFile[stringName] = locString;
                            }
                        }
                        break;
                    }
                    // Other allowed elements
                    case 'xsd:schema':
                    case 'resheader':
                        break;
                    default:
                        _logErrorWithLocation(options, `Unexpected RESX element ${childNode.name}`, childNode);
                }
                break;
            }
            case 'text': {
                if (childNode.text.trim() !== '') {
                    _logErrorWithLocation(options, 'Found unexpected non-empty text node in RESX');
                }
                break;
            }
            case 'comment':
                break;
            default:
                _logErrorWithLocation(options, `Unexpected ${childNode.type} child in RESX`);
                break;
        }
    }
    return locFile;
}
function _readDataElement(options, dataElement) {
    let foundCommentElement = false;
    let foundValueElement = false;
    let comment = undefined;
    let value = undefined;
    for (const childNode of dataElement.children) {
        switch (childNode.type) {
            case 'element': {
                switch (childNode.name) {
                    case 'value': {
                        if (foundValueElement) {
                            _logErrorWithLocation(options, 'Duplicate <value> element found', childNode);
                        }
                        else {
                            foundValueElement = true;
                            value = _readTextElement(options, childNode);
                            if (value && options.resxNewlineNormalization) {
                                value = node_core_library_1.Text.convertTo(value, options.resxNewlineNormalization);
                            }
                        }
                        break;
                    }
                    case 'comment': {
                        if (foundCommentElement) {
                            _logErrorWithLocation(options, 'Duplicate <comment> element found', childNode);
                        }
                        else {
                            foundCommentElement = true;
                            comment = _readTextElement(options, childNode);
                        }
                        break;
                    }
                    default:
                        _logErrorWithLocation(options, `Unexpected RESX element ${childNode.name}`, childNode);
                        break;
                }
                break;
            }
            case 'text': {
                if (childNode.text.trim() !== '') {
                    _logErrorWithLocation(options, 'Found unexpected non-empty text node in RESX <data> element', dataElement);
                }
                break;
            }
            case 'comment':
                break;
            default:
                _logErrorWithLocation(options, `Unexpected ${childNode.type} child in RESX <data> element`, dataElement);
        }
    }
    if (!foundValueElement) {
        _logErrorWithLocation(options, 'Missing string value in <data> element', dataElement);
    }
    else {
        if (comment === undefined && options.ignoreMissingResxComments === false) {
            _logWarningWithLocation(options, 'Missing string comment in <data> element', dataElement);
        }
        return {
            value: value || '',
            comment
        };
    }
}
function _readTextElement(options, element) {
    let foundText = undefined;
    for (const childNode of element.children) {
        switch (childNode.type) {
            case 'cdata':
            case 'text': {
                if (foundText !== undefined) {
                    _logErrorWithLocation(options, 'More than one child node found containing text content', element);
                    break;
                }
                foundText = childNode.type === 'text' ? childNode.text : childNode.cdata;
                break;
            }
            case 'comment':
                break;
            case 'element':
                _logErrorWithLocation(options, `Unexpected element`, childNode);
                break;
            default:
                _logErrorWithLocation(options, `Unexpected ${element.type} child`, element);
                break;
        }
    }
    return foundText;
}
function _logErrorWithLocation(options, message, element) {
    if (element) {
        options.loggingFunctions.logFileError(message, options.filePath, element.line + 1, element.column + 1);
    }
    else {
        options.loggingFunctions.logFileError(message, options.filePath);
    }
}
function _logWarningWithLocation(options, message, element) {
    if (element) {
        options.loggingFunctions.logFileWarning(message, options.filePath, element.line + 1, element.column + 1);
    }
    else {
        options.loggingFunctions.logFileWarning(message, options.filePath);
    }
}
function _logWithLocation(loggingFn, message, filePath, line, position) {
    let location;
    if (position !== undefined) {
        location = `${filePath}(${line},${position})`;
    }
    else if (line !== undefined) {
        location = `${filePath}(${line})`;
    }
    else {
        location = filePath;
    }
    loggingFn(`${location}: ${message}`);
}
//# sourceMappingURL=parseResx.js.map