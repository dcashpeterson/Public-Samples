{"version":3,"file":"commons.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6B;AAC+E;AACnD;AACS;AAClE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,8CAA8C,0CAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kFAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kFAA+B;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAAkB;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,8EAAoB;AAC5B,gCAAgC,0EAAgB;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA,4CAA4C,qFAA2B,CAAC,mEAAU;AACzC;AACzC;;;;;;;;;;;;;;;;;;ACtJA;AACA;AAC6B;AACmD;AACzB;AACvD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAS,2CAA2C,+FAA6C;AAC7I,2CAA2C,yFAA6B;AACxE;AACA;AACA,+CAA+C,sCAAS,2CAA2C,kGAAgD;AACnJ,8CAA8C,yFAA6B;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AAC6B;AACyE;AACN;AACzC;AACS;AACM;AACN;AACJ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+FAA+F;AACjH;AACA,uCAAuC,iGAA0C;AACjF;AACA,wCAAwC,sGAA+C;AACvF;AACA,sCAAsC,wGAA4B;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAY,2CAA2C,kFAAgC;AACtG;AACA;AACA,qCAAqC,uFAA6B;AAClE,4CAA4C,yFAAqC;AACjF;AACA;AACA,8BAA8B,qFAAyB;AACvD;AACA;AACA,+EAA+E,qCAAqC,KAAK,EAAE;AAC3H,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,6BAA6B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,qFAA2B,CAAC,6DAAU;AACzC;AACnC;;;;;;;;;;;;;;;;;;;AChGA;AACA;AAC6B;AAC2B;AACrB;AACnC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO,GAAG,qBAAqB;AACrE,iBAAiB,qBAAqB;AACtC,yBAAyB,sCAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa,GAAG,aAAa;AAChE;AACA,sBAAsB,cAAc,GAAG,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;;;;;;;;;;;;;;;ACdA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACgF;AAC5C;AACkC;AACf;AACC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D,gCAAgC,gGAAyC;AACzE;AACA,+BAA+B,+FAAwC,IAAI,wCAAM;AACjF;AACA,kBAAkB,gHAAyD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC,GAAG,+EAA6B,CAAC;AAC5F;AACA;AACA;AACA;AACA,gCAAgC,uFAA6B;AAC7D;AACA;AACA,gBAAgB,oFAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gCAAgC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0DAA0D,sBAAsB,GAAG,qBAAqB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qFAA2B,CAAC,yDAAU;AACzC;AAChC;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACgF;AACzB;AACM;AAC7D;AACA,iBAAiB,+EAA6B;AAC9C,UAAU,gFAA8B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB,+EAA6B;AAC9C,UAAU,kFAAgC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+EAA6B,CAAC;AACjF;AACA;AACA,0CAA0C,mFAAiC,CAAC,eAAe,WAAW;AACtG;AACA;AACA;AACA,0CAA0C,mFAAiC,CAAC,eAAe,WAAW;AACtG;AACA,4CAA4C,+EAA6B,CAAC;AAC1E;AACA;AACA;AACA;AACA,0CAA0C,mFAAiC,CAAC,eAAe,WAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mFAAiC,CAAC,kBAAkB,WAAW;AACjH,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mFAAiC,CAAC,kBAAkB,WAAW;AACjH,kEAAkE,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mFAAiC,CAAC,iBAAiB,aAAa;AAC1G;AACA;AACA;AACA;AACA,yBAAyB,iFAA+B;AACxD;AACA;AACA;AACA,0EAA0E,cAAc,uJAAuJ;AAC/O;AACA;AACA;AACA,sDAAsD,mFAAiC,CAAC;AACxF,wCAAwC,uBAAuB,wBAAwB,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mFAAiC,CAAC;AAC5F,4CAA4C,uBAAuB,wBAAwB,UAAU;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAA+B;AACxD,0EAA0E,cAAc,iCAAiC;AACzH;AACA;AACA,yBAAyB,+EAA6B;AACtD;AACA;AACA;AACA;AACA;AACA,+CAA+C,gFAA8B;AAC7E,+CAA+C,kFAAgC;AAC/E,0DAA0D,iFAA+B;AACzF,2CAA2C,mFAAiC,EAAE,qBAAqB,uBAAuB;AAC1H,iDAAiD,iFAA+B,CAAC;AACjF,qCAAqC,+EAA6B,CAAC,QAAQ,iFAA+B,CAAC;AAC3G;AACA;AACA,2CAA2C,mFAAiC,EAAE,qBAAqB,uBAAuB;AAC1H,iHAAiH,uBAAuB;AACxI;AACA,wDAAwD,gFAA8B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gFAA8B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kFAAgC;AACnE;AACA;AACA,uDAAuD,gFAA8B,CAAC;AACtF;AACA,qEAAqE,mCAAmC,aAAa,iFAA+B,+RAA+R;AACnb;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB,gLAAgL;AAC1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mFAAiC,CAAC,mBAAmB,6BAA6B;AACpI,+DAA+D,iCAAiC;AAChG,mFAAmF,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mFAAiC,EAAE,uBAAuB,6BAA6B;AACtI,sEAAsE,sBAAsB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mFAAiC,EAAE,uBAAuB,6BAA6B;AACtI,oEAAoE,oBAAoB;AACxF;AACA;AACA;AACA;AACA,uCAAuC,mFAAiC,EAAE,uBAAuB,6BAA6B;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mFAAiC,CAAC;AACxE,8BAA8B,iBAAiB,gBAAgB,uEAAuE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kFAAwB;AACtD;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA,mEAAmE,wCAAwC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAa;AAC/C;AACA;AACA,qBAAqB,oFAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA,6BAA6B,iFAA+B;AAC5D,6BAA6B,+EAA6B;AAC1D;AACA,qCAAqC,gFAA8B;AACnE;AACA;AACA;AACA,qCAAqC,kFAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA,+DAA+D,yCAAyC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,yIAAyI;AACzI;AACA;AACA;AACA,uCAAuC,qFAA2B,CAAC,8DAAU;AACzC;AACpC;;;;;;;;;;;;;;;;;;;;;;;AC5aA;AACA;AAC4B;AACC;AACwF;AAC3D;AACD;AACO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAc;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAc;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAAa,WAAW,KAAK,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B,iCAAiC,kFAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAgB;AACxB;AACA,qCAAqC,gFAAsB;AAC3D,eAAe,wDAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa,qCAAqC,0BAA0B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA,QAAQ,uFAAsC;AAC9C;AACA;AACA;AACA;AACA,QAAQ,uFAAsC;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB,gFAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qFAA2B,CAAC,iEAAU;AACzC;AACvC;;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AAC6B;AACmD;AAC3B;AACO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAAwB;AACpD;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0CAAa,kBAAkB;AAC1E,sDAAsD,cAAc;AACpE;AACA;AACA,2CAA2C,0CAAa,kBAAkB;AAC1E,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gDAAgD;AAC/F,0FAA0F,4CAA4C;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA,8CAA8C,yEAAwB;AACtE;AACA;AACA;AACA;AACA;AACA,sCAAsC,qFAA2B,CAAC,6DAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,QAAQ,mBAAmB;AAC3B,QAAQ,sBAAsB;AAC9B;AACA,0EAA0E;AACvC;AACnC;;;;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACyB;AACI;AACqB;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAA6D;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wCAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,iCAAiC,KAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAc;AACnC,2EAA2E,qCAAQ;AACnF,2BAA2B,uCAAU;AACrC;AACA;AACA,oDAAoD,qCAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,oCAAoC,sCAAS;AAC7C;AACA,kDAAkD,gEAAgB;AAClE,+BAA+B,sCAAS;AACxC;AACA,8BAA8B,OAAO,EAAE,qCAAQ,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACpC;;;;;;;;;;;;;;;;;AC9fA;AACA;AACoD;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AACgF;AACpB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA,iCAAiC,kFAAwB;AACzD;AACA;AACA;AACA,uCAAuC,qFAA2B,CAAC,6DAAU;AACzC;AACpC;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AAC6B;AAC6C;AACP;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,oBAAoB,sCAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+CAA+C,IAAI;AAClG;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+EAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uFAA6B;AAC3D;AACA;AACA,8BAA8B,uFAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA,oGAAoG,UAAU;AAC9G,6CAA6C,uBAAuB;AACpE,6CAA6C,uBAAuB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,6CAA6C,qMAAqM;AAClP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACoD;AACmB;AAChE;AACP;AACA;AACA;AACA;AACA;AACO,2BAA2B,6DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACiC;AAC4C;AACpB;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAY,iBAAiB,8CAAiB;AAC3D,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA,aAAa;AACb,kDAAkD;AAClD;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA,aAAa;AACb,8CAA8C;AAC9C;AACA,aAAa;AACb,6CAA6C;AAC7C;AACA,aAAa;AACb,yCAAyC;AACzC;AACA,aAAa;AACb,gFAAgF;AAChF,YAAY,0EAAgB;AAC5B,YAAY,0EAAgB;AAC5B;AACA;AACA,8CAA8C,SAAS,KAAK,UAAU;AACtE;AACA;AACA;AACA,+CAA+C,uEAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa,oCAAoC,0BAA0B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/PA;AACA;AACiE;AACjE;AACA;AACA;AACA;AACA;AACA,qCAAqC,2EAAiB,GAAG;AACzD;AACA;AACA;AACA;AACA,wCAAwC,2EAAiB;AACzD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AAC8B;AAC9B;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AAC6B;AACmD;AAC3C;AACgC;AACR;AACF;AACsB;AACX;AACL;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa,yGAAiD;AAC9D,YAAY,+EAA2B;AACvC;AACA,aAAa,mGAAqC;AAClD;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA,SAAS;AACT;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAqC,kCAAkC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gFAA0B,kCAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iHAAuD;AAC/F;AACA,0BAA0B,uEAAa;AACvC;AACA,0CAA0C,yCAAY;AACtD,wCAAwC,oGAA0C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mGAA4C;AAChE;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACgB;AAChB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AAC6B;AACI;AACqD;AACpC;AACf;AACmC;AACf;AACW;AACxB;AACgC;AACJ;AACM;AACzB;AACoB;AACE;AACA;AACH;AACZ;AACH;AACF;AACiB;AACY;AACH;AACG;AAC7B;AACe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mFAAiC;AACrC,IAAI,+FAA6C;AACjD,IAAI,kFAAgC;AACpC,IAAI,+EAA6B;AACjC,IAAI,mFAAiC;AACrC,IAAI,sFAAoC;AACxC,IAAI,kFAAgC;AACpC,IAAI,mFAAiC;AACrC,IAAI,kGAAgD;AACpD,IAAI,sFAAoC;AACxC,IAAI,iFAA+B;AACnC,IAAI,uFAAqC;AACzC,IAAI,yFAAuC;AAC3C,IAAI,kFAAgC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAiC;AACzC;AACA,iBAAiB,8CAAiB;AAClC;AACA,+CAA+C,gDAAgD;AAC/F;AACA,iBAAiB,6CAAgB;AACjC,iFAAiF,iBAAiB;AAClG;AACA,4DAA4D,gDAAgD;AAC5G;AACA;AACA;AACA,oBAAoB,2GAAoD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C,4BAA4B,yCAAY,CAAC,sCAAS,sBAAsB,gFAA8B;AACtG,sCAAsC,sCAAS;AAC/C;AACA,YAAY,sGAA+C;AAC3D,gBAAgB,sCAAS,oBAAoB,kFAAgC;AAC7E,mCAAmC,sCAAS;AAC5C,8BAA8B,yCAAY,CAAC,sCAAS;AACpD,4BAA4B,yCAAY,CAAC,sCAAS;AAClD,+BAA+B,yCAAY,CAAC,sCAAS;AACrD,6BAA6B,sCAAS,oBAAoB,qFAAmC;AAC7F,0CAA0C,sCAAS;AACnD;AACA;AACA,sCAAsC,sCAAS,8BAA8B,mFAAiC;AAC9G,4CAA4C,+EAAwB;AACpE,0CAA0C,sCAAS,8BAA8B,yFAAuC;AACxH,6CAA6C,+EAAwB;AACrE,8BAA8B,uFAAuB,uCAAuC;AAC5F,+BAA+B,0FAAwB,wCAAwC;AAC/F;AACA,+BAA+B,mHAAgD,IAAI,4BAA4B,GAAG,kFAAgC,CAAC;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C,mCAAmC,8GAA2C,wCAAwC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,wBAAwB;AACvG,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,6CAA6C,iFAAiB;AAC9D;AACA;AACA;AACA,6CAA6C,mFAAkB;AAC/D;AACA;AACA;AACA,6CAA6C,mFAAkB;AAC/D;AACA;AACA,sCAAsC,sCAAS;AAC/C,0CAA0C,yCAAY,CAAC,sCAAS,2BAA2B,oBAAoB,oCAAoC,oBAAoB;AACvK;AACA,2BAA2B,uCAAU;AACrC,gDAAgD,sCAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mFAAiC;AAC/C,cAAc,gFAA8B;AAC5C,0CAA0C,4EAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU,uCAAuC;AAC/E,kDAAkD,sCAAS,8BAA8B,uFAAqC;AAC9H,8CAA8C,oFAA0B;AACxE,+CAA+C,sCAAS,8BAA8B,kFAAgC;AACtH,2CAA2C,8EAAuB;AAClE;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA,gCAAgC,gFAAwB;AACxD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yBAAyB;AACnF,2HAA2H,oBAAoB;AAC/I;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAY;AACnD;AACA;AACA,sCAAsC,uEAAa;AACnD;AACA,uCAAuC,gEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0CAAa;AAC9C;AACA,mCAAmC,yCAAY;AAC/C;AACA,gBAAgB,sCAAS;AACzB,mCAAmC,kBAAkB,aAAa,oBAAoB;AACtF,wDAAwD,oCAAoC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAY,CAAC,oDAAY,MAAM,yCAAY;AAC3D,gBAAgB,yCAAY,CAAC,oDAAY,MAAM,yCAAY;AAC3D;AACA,oBAAoB,sCAAS,CAAC,oDAAY;AAC1C,sDAAsD,kBAAkB;AACxE,4BAA4B,kCAAkC,2CAA2C,oDAAY,CAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uFAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,qCAAqC,sCAAS;AAC9C,gBAAgB,2EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+FAA6C;AAC1E;AACA;AACA;AACA,iCAAiC,gFAA8B,CAAC,GAAG,aAAa;AAChF;AACA;AACA,iCAAiC,gFAA8B,CAAC,GAAG,aAAa,GAAG,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA,4CAA4C,uBAAuB;AACnE,YAAY,iFAAuB;AACnC;AACA;AACA,+BAA+B,wFAA8B;AAC7D;AACA,yBAAyB,sFAA4B,CAAC,sCAAS;AAC/D;AACA;AACA;AACA;AACA,kCAAkC,yCAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE,wBAAwB,uBAAuB;AAC/C;AACA;AACA,uCAAuC,sCAAS,yBAAyB,sFAAoC;AAC7G,YAAY,2EAAiB;AAC7B,2FAA2F;AAC3F;AACA,6BAA6B,8EAA4B,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B,GAAG,6BAA6B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B,uCAAuC,uEAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sCAAS,6CAA6C,sFAAoC,kBAAkB,sFAAoC;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mGAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAO,CAAC,yCAA6B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS,6CAA6C,sFAAoC,kBAAkB,iFAA+B;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6EAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA,uBAAuB;AACvB,2CAA2C,KAAK;AAChD,oCAAoC;AACpC;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8DAAY;AACtE;AACA,qCAAqC,0CAAa;AAClD,6CAA6C,kFAAgC,eAAe,qCAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAY;AACzC;AACA;AACA,gBAAgB,6EAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA,uBAAuB;AACvB,2CAA2C,KAAK;AAChD,oCAAoC;AACpC;AACA;AACA,eAAe,sCAAS,6CAA6C,sFAAoC;AACzG;AACA;AACA,gCAAgC,qFAA2B,CAAC,uDAAU;AACzC;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;ACnvBA;AACA;AAC6B;AACI;AACwC;AAClB;AACG;AACkC;AACZ;AAChF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAsE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA,sEAAsE,yCAAyC;AAC/G,uCAAuC,0BAA0B;AACjE;AACA,6BAA6B,sCAAS;AACtC,oCAAoC,sCAAS,qBAAqB,mFAAyB;AAC3F;AACA,oCAAoC,6EAAmB;AACvD;AACA;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C,mEAAmE,yBAAyB,KAAK,oBAAoB;AACrH;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD,qCAAqC,sCAAS,qBAAqB,qFAAmC,EAAE,kFAAgC;AACxI;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wBAAwB;AACnF;AACA;AACA,gDAAgD,wBAAwB;AACxE,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE,oCAAoC,sBAAsB;AAC1D;AACA,aAAa,yCAAY;AACzB,0CAA0C,yBAAyB;AACnE,iCAAiC,oBAAoB;AACrD;AACA,iCAAiC,gHAAoD;AACrF;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,8FAA6C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA,iCAAiC,sCAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,2BAA2B,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2EAAmB;AAC/E;AACA,qCAAqC,uFAA+B;AACpE,qCAAqC,qFAA6B;AAClE,wCAAwC,6CAAgB;AACxD;AACA;AACA;AACA,qCAAqC,yFAAiC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5QA;AACA;AAC6B;AACsB;AACmB;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yCAAyC,4GAAqD;AAC9F;AACA;AACA;AACA;AACA,wBAAwB,sCAAS,CAAC,yEAAuB;AACzD;AACA;AACA;AACA;AACA,gCAAgC,sCAAS,oBAAoB,sBAAsB;AACnF;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AAC8B;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAA0B,CAAC,OAAO,cAAc;AAC3E;AACA;AACA;AACA;AACA,+DAA+D,cAAc,+BAA+B,+CAAY,CAAC;AACzH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA;AACA;AACgF;AACnB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B,iCAAiC,kFAAwB;AACzD;AACA;AACA;AACA,uCAAuC,qFAA2B,CAAC,8DAAU;AACzC;AACpC;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACiF;AACA;AAC9B;AACI;AACwB;AAClB;AACQ;AACrE,4CAA4C,0EAAiB;AAC7D,uCAAuC,yFAAuC,CAAC;AAC/E,sBAAsB,8DAAU;AAChC;AACA;AACA,6BAA6B,+EAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,4EAA4E,oBAAoB,IAAI,0BAA0B,mBAAmB,IAAI;AACrQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,gFAAuB;AACpD;AACA;AACA,CAAC;AACD,gDAAgD,0EAAiB;AACjE;AACA,sBAAsB,8DAAkB;AACxC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uFAAuB;AACnE,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oBAAoB;AAC5F,wCAAwC,wDAAwD;AAChG;AACA,wCAAwC,cAAc,kCAAkC,iBAAiB;AACzG;AACA;AACA,wEAAwE,oBAAoB;AAC5F,wCAAwC,wDAAwD;AAChG;AACA;AACA,4CAA4C,iBAAiB;AAC7D,wCAAwC,cAAc,MAAM,4CAA4C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+EAAqB;AACrE;AACA;AACA,gFAAgF,UAAU;AAC1F;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,uFAAuF,gCAAgC,GAAG,iBAAiB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB;AAChC;AACA;AACA;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA,gCAAgC,uFAAmC;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAyD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,mCAAmC,oBAAoB;AAC9H,2BAA2B,yDAAyD;AACpF;AACA;AACA;AACA;AACA,yDAAyD,kCAAkC;AAC3F,2CAA2C,0BAA0B;AACrE;AACA,kCAAkC,+EAAqB,+CAA+C,+EAAqB;AAC3H,8EAA8E,0BAA0B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACoC;AACpC;;;;;;;;;;;;;;;;;;;;;AC7RA;AACA;AACgF;AACnD;AACsB;AACI;AACY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAAe;AACrD;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAS;AAClD;AACA;AACA,yCAAyC,uFAA6B;AACtE;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yEAAuB;AACtD,yCAAyC,sCAAS,iBAAiB,+FAA6C;AAChH;AACA;AACA;AACA,gCAAgC,qFAA2B,CAAC,oEAAU;AACrC;AACjC;;;;;;;;;;;;;;;ACzCA;AACA;AACwD;AACjD,4CAA4C,iEAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;AACpB;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACiC;AACmB;AAC2C;AACtC;AACzD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAkB;AAChD;AACA;AACA;AACA,kFAAkF,wFAA+B;AACjH;AACA,wDAAwD,yFAAgC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4EAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sFAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wFAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAAa;AACzC;AACA;AACA,kBAAkB,4EAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAAa;AAChD;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB,aAAa,aAAa;AACvF,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAAa;AAC/C;AACA,+CAA+C,eAAe,KAAK,YAAY;AAC/E;AACA;AACA;AACA,+BAA+B,qEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAa;AAC7C;AACA,uCAAuC,qEAAS;AAChD,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA,gDAAgD,iBAAiB,aAAa,aAAa;AAC3F,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAAa;AAC/C;AACA;AACA,yDAAyD,eAAe,KAAK,YAAY;AACzF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtSA;AACA;AACgF;AAChC;AACiB;AAC1D;AACP;AACA;AACA;AACA,CAAC,0DAA0D;AACpD;AACP;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,wBAAwB,2BAA2B;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB,OAAO,iBAAiB,KAAK,WAAW;AAC9G;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA,kCAAkC,kFAAwB;AAC1D;AACA,2BAA2B,8DAAkB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,uEAAa,0CAA0C,0BAA0B;AAC7F;AACA;AACA;AACA,yCAAyC,qFAA2B,CAAC,kEAAU;AACzC;AACtC;;;;;;;;;;;;;;;;AC3HA;AACA;AAC0D;AACR;AAClD;AACA;AACA;AACO,gCAAgC,2DAAc;AACrD;AACA;AACA,8BAA8B,qFAAmC;AACjE;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACiC;AACJ;AAC6B;AACR;AAClD;AACA;AACA;AACO,iCAAiC,2DAAc;AACtD;AACA;AACA,+BAA+B,wFAAsC;AACrE,kCAAkC,0CAAa;AAC/C;AACA;AACA,oCAAoC,kFAAgC;AACpE;AACA;AACA,oCAAoC,kFAAgC;AACpE;AACA;AACA;AACA,8CAA8C,sCAAS;AACvD;AACA;AACA;;;;;;;;;;;;;;;;AC1BA;AACA;AAC0D;AACR;AAClD;AACA;AACA;AACO,iCAAiC,2DAAc;AACtD;AACA;AACA,+BAA+B,sFAAoC;AACnE;AACA;AACA;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACiC;AACoB;AACE;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAU,CAAC,yEAAwB;AACzD;AACA,sBAAsB,yDAAa,CAAC,yEAAwB;AAC5D;AACA;AACA;AACA,sBAAsB,yEAAwB;AAC9C,6BAA6B,8EAA4B,CAAC;AAC1D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACiC;AACJ;AACqD;AACoC;AACjE;AACQ;AACN;AACoB;AAC3B;AACM;AACF;AACE;AACJ;AAC0B;AACd;AACN;AACN;AACA;AACM;AACJ;AACE;AACJ;AACI;AACA;AAC0B;AACxB;AAC8B;AACR;AACN;AACzB;AACY;AACQ;AACf;AACa;AACJ;AACW;AACjE,oCAAoC,yEAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,iFAAuB;AAC5D,6BAA6B,kEAAQ;AACrC,gEAAgE;AAChE;AACA,qCAAqC,6FAAyC;AAC9E;AACA;AACA,aAAa;AACb;AACA,yCAAyC,+FAA2C;AACpF;AACA;AACA;AACA;AACA;AACA,QAAQ,wGAAgD;AACxD;AACA;AACA;AACA,SAAS;AACT,oCAAoC,mEAAgB;AACpD,+BAA+B,qEAAW;AAC1C;AACA;AACA,SAAS;AACT,iCAAiC,yEAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,yCAAyC;AAC9D;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB,KAAK,yBAAyB,IAAI,aAAa;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sGAA8C;AAC1D;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uFAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAS;AACxC,+BAA+B,gEAAY;AAC3C,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,4DAAU;AACzC,+BAA+B,sFAAuB;AACtD,+BAA+B,wEAAgB;AAC/C,+BAA+B,kEAAa;AAC5C,+BAA+B,4DAAU;AACzC,+BAA+B,4DAAU;AACzC,+BAA+B,kEAAa;AAC5C,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,4DAAU;AACzC,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,gEAAY;AAC3C,+BAA+B,0FAAyB;AACxD,+BAA+B,gGAA4B;AAC3D,+BAA+B,wFAAwB;AACvD,+BAA+B,kEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAS,gDAAgD,oFAAiC;AAClI;AACA,yCAAyC,0GAA8C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAiC,EAAE,qBAAqB,aAAa;AACpG;AACA;AACA;AACA,iBAAiB,kFAA+B;AAChD;AACA;AACA;AACA,iBAAiB,kFAA+B;AAChD;AACA;AACA,uCAAuC,oFAAiC,EAAE,qBAAqB,aAAa;AAC5G,0CAA0C,kFAA+B,CAAC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oFAAiC,EAAE,qBAAqB,aAAa;AACxG,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iFAA8B;AAC3D,6BAA6B,mFAAgC;AAC7D,+BAA+B,oFAAiC,EAAE,qBAAqB,aAAa;AACpG,qCAAqC,kFAA+B,CAAC;AACrE,yBAAyB,gFAA6B,CAAC,QAAQ,kFAA+B,CAAC;AAC/F;AACA;AACA,2BAA2B,kFAAkB,+BAA+B,2BAA2B,kFAAkF;AACzL;AACA;AACA;AACA;AACA,2BAA2B,kFAAkB,+BAA+B,yBAAyB,0UAA0U,uFAAoC,mHAAmH;AACtkB;AACA;AACA,+BAA+B,8EAAoB;AACnD;AACA;AACA;AACA;AACA,4BAA4B,yEAAwB;AACpD;AACA,+BAA+B,sDAAU;AACzC;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpTA;AACA;AACwE;AACjE;AACP;AACA,QAAQ,iGAAyC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAC6B;AACgC;AACM;AAC6G;AAC3H;AACE;AACI;AACN;AACc;AACnE;AACA;AACA;AACA,2BAA2B,8EAAoB;AAC/C;AACA,uCAAuC,yEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC,gGAA4C;AAC9E;AACA;AACA,SAAS;AACT,QAAQ,wGAAgD;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,mBAAmB;AAChI;AACA;AACA,kCAAkC,sCAAS;AAC3C,aAAa,2EAAiB;AAC9B;AACA,+CAA+C,kBAAkB;AACjE,qCAAqC,qEAAW;AAChD,sBAAsB,8EAAoB;AAC1C;AACA,aAAa,2EAAiB;AAC9B;AACA,4CAA4C,qEAAW;AACvD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,iFAAuB;AAClI;AACA;AACA,SAAS;AACT,6BAA6B,kEAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA,6GAA6G,SAAS;AACtH,qCAAqC,qEAAW;AAChD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yEAAwB,gBAAgB,2BAA2B;AACjH,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAAwB,qBAAqB,YAAY;AAC3G,6CAA6C,qEAAW;AACxD,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAAwB,qBAAqB,YAAY;AAC3G;AACA,6CAA6C,qEAAW;AACxD,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yEAAwB,uBAAuB,YAAY;AAC/G;AACA;AACA;AACA;AACA;AACA,yCAAyC,gHAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yEAAwB;AAC9E;AACA,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,oDAAoD,sCAAS,iDAAiD,kFAAgC;AAC9I;AACA,sDAAsD,yEAAwB;AAC9E,8FAA8F,wBAAwB;AACtH,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAAwB,qBAAqB,YAAY;AAC3G,6CAA6C,qEAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wEAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAoB;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yCAAyC,GAAG,mFAAyB,CAAC;AAC3H,0CAA0C,uEAAa;AACvD;AACA;AACA,qBAAqB,+EAAmB;AACxC,2DAA2D,yCAAyC,GAAG,qFAAmC,CAAC;AAC3I,qDAAqD,qCAAqC,QAAQ,qFAAmC,CAAC;AACtI;AACA,wBAAwB,2EAAiB;AACzC,wBAAwB,sFAA4B;AACpD;AACA,+CAA+C,4BAA4B;AAC3E;AACA,6CAA6C,sBAAsB;AACnE,wBAAwB,8EAAoB;AAC5C;AACA;AACA,yBAAyB;AACzB;AACA;AACA,4BAA4B,2EAAiB;AAC7C;AACA,oDAAoD,sBAAsB;AAC1E,4BAA4B,iFAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,kFAAgC,CAAC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAY;AAC7C;AACA,qCAAqC,mEAAgB;AACrD,iCAAiC,6DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yFAAuC;AACvE;AACA;AACA;AACA,kDAAkD,wLAET;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrVA;AACA;AACiC;AACsB;AACY;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAW,iCAAiC,cAAc;AACtE,YAAY,uDAAW,OAAO,8EAA4B,CAAC;AAC3D,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAW,iCAAiC,cAAc,mBAAmB,YAAY;AAC7G;AACA;AACA;AACA,iCAAiC,gGAAwC;AACzE;AACA,cAAc,wFAAgC;AAC9C;AACA;AACA,kBAAkB,aAAa,GAAG,iBAAiB;AACnD;AACA;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACiC;AACJ;AAC0C;AACK;AACzB;AACY;AAC5B;AAC0B;AACM;AACX;AACjD;AACP;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAsC,CAAC,mDAAY;AAC/D;AACA;AACA;AACA,sCAAsC,gGAA4C;AAClF;AACA,aAAa;AACb,YAAY,wGAAgD;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,2EAAiB;AAC3D;AACA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA,0CAA0C,uEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU,wBAAwB,iBAAiB;AAC/E;AACA;AACA;AACA;AACA,sEAAsE,EAAE;AACxE;AACA;AACA,mCAAmC,yDAAa,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gFAA8B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA,kCAAkC,yCAAY;AAC9C,6BAA6B,mFAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,sDAAU,qCAAqC,SAAS;AACpF;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAW,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+EAA8B,MAAM,sEAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAW,CAAC,qEAAW;AAC3C;AACA,oBAAoB,mFAAyB;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA,8EAA8E,EAAE;AAChF;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACiC;AACiC;AACI;AAC/D,wBAAwB,2EAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,SAAS,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA,sCAAsC,2EAAmB;AACzD,qBAAqB,8CAAiB,iCAAiC,yCAAY;AACnF,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,SAAS,yBAAyB;AACvG,sDAAsD,gCAAgC,2BAA2B,QAAQ;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kCAAkC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7HA;AACA;AACkD;AAClD;AACA;AACA;AACO,qCAAqC,2DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D,0EAA0E,wBAAwB;AAClG;AACA;AACA;AACA;AACA;AACA,yCAAyC,gPAC6C;AACtF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACiC;AACiB;AACL;AACW;AACF;AACoB;AACpB;AACoC;AAC5C;AACY;AACuB;AACjF;AACA;AACA;AACO,gCAAgC,2DAAc;AACrD;AACA;AACA,6BAA6B,kEAAQ,KAAK,iFAAuB,GAAG,wCAAwC;AAC5G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,wFAAsC;AACrE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,yFAAuC;AACjE,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,mDAAmD,qEAA0B;AAC7E;AACA;AACA,QAAQ,wHAA8C;AACtD;AACA,SAAS;AACT,0BAA0B,iEAAe;AACzC,QAAQ,oEAAoB;AAC5B;AACA;AACA,0CAA0C,2FAAiC;AAC3E;AACA;AACA,kBAAkB,6FAAmC;AACrD;AACA,sCAAsC,iEAAoB;AAC1D,iCAAiC,8DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E;AACA;AACA,kDAAkD,2LAEN;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA,+BAA+B,wDAAY,SAAS,iBAAiB,0BAA0B,qBAAqB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,4DAA4D,4KAA4K;AACxO;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvIA;AACA;AACiC;AACJ;AACkC;AACP;AACU;AACC;AACb;AACtD;AACA;AACA;AACA;AACO,uCAAuC,yEAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAAmB;AACxC;AACA,gCAAgC,sDAAU;AAC1C;AACA;AACA;AACA;AACA,aAAa,qGAAiD;AAC9D;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB,oBAAoB,2CAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0CAA0C,uEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sFAAoC;AACtD;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AAC6B;AACkB;AACd;AACkF;AACxD;AACH;AACN;AACA;AACI;AACgB;AACI;AACpC;AACgB;AACtD;AACA;AACA;AACO,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,2CAAG;AAC3B,6BAA6B,kEAAQ,KAAK,iFAAuB,GAAG,gCAAgC;AACpG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,wBAAwB,UAAU,0BAA0B;AACnF,mBAAmB,gBAAgB;AACnC,SAAS;AACT;AACA;AACA;AACA,gFAAgF,gBAAgB;AAChG,SAAS;AACT;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG,SAAS;AACT;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,oCAAoC;AAClE,2BAA2B,gCAAgC;AAC3D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kHAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,6DAAU,CAAC,kEAAe;AAC1F,uCAAuC,4CAA4C,MAAM,2CAA2C;AACpI,uDAAuD,oCAAoC;AAC3F,wBAAwB,6DAAU,CAAC,kEAAe,EAAE,uBAAuB,4CAA4C;AACvH,sCAAsC,2CAA2C;AACjF;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAU,CAAC,kEAAe;AAClE;AACA,+CAA+C,6DAAU,CAAC,kEAAe;AACzE;AACA,wCAAwC,kBAAkB,4CAA4C,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE,mBAAmB,4CAA4C,MAAM,2CAA2C;AAChH;AACA;AACA;AACA,2CAA2C,6EAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+EAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAoB;AAC5B;AACA;AACA,yBAAyB,yEAAW;AACpC,sCAAsC,0CAAa;AACnD;AACA;AACA;AACA,mBAAmB,sCAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C,aAAa;AACb,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,6DAAU,CAAC,kEAAe;AAChD;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAU,CAAC,oEAAiB;AAC7C;AACA;AACA,iBAAiB,6DAAU,CAAC,mEAAgB;AAC5C,iBAAiB,6DAAU,CAAC,mEAAgB;AAC5C,iBAAiB,6DAAU,CAAC,mEAAgB;AAC5C,iBAAiB,6DAAU,CAAC,kEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,qDAAqD,4FAA2C;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8FAA6C;AACvG;AACA;AACA,2CAA2C,6DAAU,CAAC,mEAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDACM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,wDAAU;AACzC;AACA,2BAA2B,2EAAiB;AAC5C;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAoB,qBAAqB,0BAA0B;AAC3E;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAwB;AACpC;AACA;AACA;AACA,aAAa;AACb,YAAY,2EAAwB;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACjlBA;AACA;AACiC;AACiB;AACwC;AAC5C;AACmC;AAC1E,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,kEAAQ,KAAK,iFAAuB,GAAG,gCAAgC;AACpG,mDAAmD,qEAA0B;AAC7E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa,aAAa,QAAQ;AAC1D,8CAA8C,QAAQ;AACtD;AACA,QAAQ,yGAA+B;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CA;AACA;AAC6B;AACqB;AAC6B;AACxE,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,8BAA8B,QAAQ,kJAAwD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAa,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,6BAA6B,0CAAa,mBAAmB;AAC7D;AACA;AACA;AACA,cAAc,yCAAY;AAC1B,cAAc,sCAAS;AACvB;AACA,cAAc,yCAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,gDAAgD,oGAAqC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,mBAAmB,QAAQ,sIAEJ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACiC;AACJ;AAC+E;AAChD;AACtB;AAC2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,qEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA;AACA,+BAA+B,wFAA8B;AAC7D;AACA;AACA;AACA;AACA,6BAA6B,sCAAS;AACtC,0BAA0B,kFAAwB;AAClD;AACA;AACA;AACA;AACA,8BAA8B,sDAAU,kCAAkC,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAgB,CAAC;AACpD;AACA,+BAA+B,sCAAS;AACxC,iBAAiB,2EAAiB;AAClC;AACA,0BAA0B,uEAAa;AACvC;AACA,oCAAoC,sCAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2EAAiB;AACvD;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa,iBAAiB,gBAAgB;AACtE;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA,sBAAsB,6EAAmB,eAAe,oBAAoB,wEAAc,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa,wDAAwD,uBAAuB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa,sDAAsD,uBAAuB;AACxH;AACA;AACA;AACA,8BAA8B,uEAAa,uDAAuD,uBAAuB;AACzH;AACA;AACA;AACA,8BAA8B,uEAAa,8DAA8D,uBAAuB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAa;AAC/C,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAoB;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,sDAAsD,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAY;AACnC;AACA,0BAA0B,uEAAa,mDAAmD,aAAa;AACvG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzSA;AACA;AACiC;AACgD;AAC/B;AACQ;AACnD,sCAAsC,2DAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT,YAAY,2EAAiB;AAC7B;AACA,gBAAgB,wFAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC,QAAQ,uEAAa;AACrB;AACA,+BAA+B,+EAAqB;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACiC;AACiB;AACqB;AACsB;AAC5B;AACjE,gCAAgC,sEAAgB,CAAC;AAC1C,+BAA+B,2DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,oHAA6C;AAC9E,YAAY,2EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC;AACA;AACA;AACA,kFAAkF,iBAAiB;AACnG;AACA,gCAAgC,6EAAmB;AACnD;AACA,QAAQ,8EAAoB;AAC5B;AACA,gCAAgC,+EAAqB;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACiF;AACzB;AACiB;AAClE,4BAA4B,iEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,iFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,kEAAQ,KAAK,iFAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzDA;AACA;AACkD;AAC3C,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,kLAEN;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACuF;AACrC;AACoB;AACG;AAClE,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,wCAAwC,iFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,kEAAQ,KAAK,iFAAuB;AACjE;AACA,QAAQ,wEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAA2B;AAClE,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,QAAQ,kHAAmB;AAC/D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2EAA2B;AACtE;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClLA;AACA;AACiC;AACJ;AACI;AACyB;AACF;AACd;AACsB;AACI;AACN;AACJ;AACR;AACE;AACkB;AACL;AACX;AAChB;AAC/B,4BAA4B,2DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc,8EAAmC,2BAA2B,qBAAqB;AACjG;AACA,yCAAyC,sCAAS;AAClD;AACA,uCAAuC,sCAAS;AAChD;AACA;AACA;AACA;AACA,YAAY,8FAAuC;AACnD;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA,wCAAwC,mEAAe;AACvD;AACA;AACA;AACA,2BAA2B,wDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC,oBAAoB,oBAAoB;AAC1G;AACA;AACA;AACA,kCAAkC,gEAAa;AAC/C;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,2EAA8B;AACtH;AACA;AACA;AACA;AACA,8CAA8C,qEAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,yEAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,0BAA0B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,GAAG,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAA4B;AACxC;AACA;AACA;AACA,oBAAoB,iFAA2B;AAC/C;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAA2B;AAC/C,QAAQ,kFAA4B;AACpC;AACA;AACA;AACA,gCAAgC,sCAAS;AACzC;AACA;AACA,kBAAkB,sCAAS;AAC3B,YAAY,yEAAe;AAC3B;AACA,iCAAiC,sCAAS;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,IAAI,4BAA4B;AAC3D;AACA;AACA,sBAAsB,KAAK,GAAG,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kFAA+B;AACvC;AACA,QAAQ,sEAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,2BAA2B,SAAS,cAAc,yBAAyB;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzbA;AACA;AACiC;AACiB;AACI;AACE;AACE;AACnD,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,iEAAe;AACzC,kCAAkC,+DAAa;AAC/C,iCAAiC,6DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAY,uEAAuE,qBAAqB;AACpH;AACA;AACA;;;;;;;;;;;;;;;;;ACxCA;AACA;AACiF;AACf;AAC3D,2BAA2B,2EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,iFAAuB;AAC5D,6BAA6B,kEAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB,gBAAgB,aAAa;AAC9G;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACiC;AACJ;AACqB;AACQ;AACE;AACrD,yBAAyB,qEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,yCAAY;AAChD,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,QAAQ,mHAAmB;AAC3D,8CAA8C,cAAc,OAAO,QAAQ,OAAO,cAAc;AAChG;AACA;AACA,iCAAiC,6EAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,8DAA2B;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,6EAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1MA;AACA;AAC8E;AAC5B;AAC3C,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,mFAAoB;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACkD;AACQ;AACnD,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACwD;AACjD,2BAA2B,iEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEA;AACA;AACkD;AACQ;AACnD,wCAAwC,2DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACuG;AACrD;AAC0B;AAClB;AACnD,2CAA2C,2DAAc;AAChE;AACA;AACA,wBAAwB,iGAA+C;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,kEAAQ,KAAK,iFAAuB;AACjE,8CAA8C,4GAAkD;AAChG;AACA;AACA,kDAAkD,2BAA2B;AAC7E,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF,mBAAmB,oCAAoC;AACvD;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF,mBAAmB,oCAAoC;AACvD,mBAAmB,2BAA2B;AAC9C,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9EA;AACA;AACkD;AAC3C,uCAAuC,2DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,oBAAoB,IAAI,qBAAqB;AAC9D,YAAY,gPAAqF;AACjG,YAAY,qLAAuF;AACnG;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACiC;AACkC;AAChB;AACa;AAC0B;AACpB;AACpB;AACE;AACd;AACoB;AACnD;AACA;AACA,4BAA4B,2DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,wFAAsC;AACrE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,8EAAmC;AACjD;AACA;AACA,SAAS;AACT,wBAAwB,2CAAG;AAC3B;AACA;AACA,2CAA2C,sKAEN;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,kGAAkG,4EAAkB,CAAC,wDAAQ;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0CAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+EAAqB,CAAC,wDAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+FAA2C;AACtE;AACA;AACA;AACA;AACA,+BAA+B,6GAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mFAAyB;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrNA;AACA;AACyB;AACzB;AACA;AACA;AACA;AACO,0DAA0D,oCAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACuF;AACrC;AACsD;AACV;AACJ;AACoB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC,mGAA0B;AACjE;AACA,uCAAuC,6GAA+B;AACtE,uCAAuC,+FAAwB;AAC/D,kDAAkD,mHAAkC;AACpF;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,GAAG,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,6DAAe;AACzC;AACA,QAAQ,6EAA+B,CAAC,6DAAe,QAAQ,4EAA8B;AAC7F;AACA,QAAQ,0EAA4B;AACpC;AACA;AACA;AACA,QAAQ,0EAA4B,CAAC,6DAAe,qBAAqB,yEAA2B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAe;AAC5C;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C;AACA;AACA;AACA,QAAQ,0EAA4B;AACpC,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE,mCAAmC,0CAA0C;AAC7E,yCAAyC,gDAAgD;AACzF,6BAA6B,oCAAoC;AACjE,2BAA2B,kCAAkC;AAC7D,iCAAiC,wCAAwC;AACzE,0CAA0C,0CAA0C;AACpF,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oFAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,eAAe,cAAc,MAAM,YAAY;AAC7H,4CAA4C,4EAA4E,oBAAoB,gBAAgB;AAC5J,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClSA;AACA;AAC2D;AACD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,mEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,mFAAiC,EAAE,uBAAuB,mBAAmB,yCAAyC,wBAAwB;AACrL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AAC6B;AACI;AAC+D;AAC1C;AACA;AACA;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,+DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA,YAAY,4EAA0B;AACtC;AACA,0CAA0C,sCAAS;AACnD,iBAAiB,2EAAiB;AAClC,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA,oCAAoC,sCAAS;AAC7C,iBAAiB,2EAAiB;AAClC,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA,gCAAgC,uEAAa;AAC7C;AACA,uDAAuD,gBAAgB;AACvE,yEAAyE,wBAAwB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sCAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAe;AACzC,yBAAyB,mFAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,sDAAU,qCAAqC,SAAS;AACvF,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAe,2BAA2B,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,SAAS,IAAI,wCAAwC,qCAAqC,QAAQ;AAC1L;AACA,kGAAkG,aAAa;AAC/G;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACiC;AAC4D;AACf;AACxB;AACgB;AAChB;AACuC;AACnC;AACoB;AACjB;AACe;AACH;AACY;AACU;AAClD;AAC6B;AACD;AACgC;AAC1C;AACO;AACqB;AACb;AACH;AACgB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,+DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,sFAAoC;AACpI;AACA;AACA;AACA;AACA,yBAAyB,mFAAkB;AAC3C,6BAA6B,kEAAQ;AACrC;AACA;AACA,YAAY,0FAAqB;AACjC;AACA,YAAY,oGAA0B;AACtC,YAAY,gGAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC,oGAAyC;AAC9E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wCAAwC,iFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4IAA4I,gEAAgE;AAC5M,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA,kCAAkC,uEAAa,oCAAoC,UAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB,QAAQ,iQAEW;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC,qFAAqC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAgB;AAC9B;AACA;AACA,0BAA0B,kEAAe;AACzC;AACA;AACA,oBAAoB,wBAAwB,QAAQ,sMAEO;AAC3D;AACA;AACA;AACA,YAAY,+GAA+B;AAC3C,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+FAAoC;AAChF,yCAAyC,yFAAiC;AAC1E;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iGAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,iFAAgB;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,4GAAgD;AACxE,8CAA8C,gFAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAS;AACpD;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAA+E;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAA+E;AAC/F;AACA;AACA,gBAAgB,yEAAyE;AACzF;AACA,gBAAgB,iBAAiB,QAAQ,sKAEJ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D,sBAAsB,EAAE,oDAAoD;AACtI;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oCAAoC,yEAAsB;AAC1D;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB,SAAS,sCAAsC;AAC3H;AACA;AACA,0CAA0C,uDAAW,OAAO;AAC5D;AACA;AACA,0EAA0E,qCAAqC;AAC/G,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8BAA8B;AACrG;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAwE;AACxF,qCAAqC,mGAAyB;AAC9D,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,wCAAwC,uFAAuB;AAC/D;AACA;AACA,oCAAoC,iBAAiB,GAAG,qBAAqB;AAC7E,kCAAkC,uFAAuB;AACzD,mCAAmC,wDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAoB;AACrD,2CAA2C,iBAAiB,GAAG,qBAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAU,SAAS,iBAAiB,aAAa,qBAAqB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8EAA8E;AACxJ;AACA,0KAA0K;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uFAAuB;AACpD;AACA;AACA,6BAA6B,kGAAkC;AAC/D;AACA;AACA,6BAA6B,uFAAuB;AACpD;AACA;AACA,6BAA6B,uFAAuB;AACpD;AACA;AACA,6BAA6B,yFAAyB;AACtD;AACA;AACA,6BAA6B,uFAAuB;AACpD;AACA;AACA,6BAA6B,oFAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA,gCAAgC,gFAA8B;AAC9D,gCAAgC,kFAAgC;AAChE;AACA;AACA;AACA,QAAQ,qEAAoB;AAC5B,sCAAsC,gEAAkB;AACxD;AACA;AACA,gCAAgC,gFAA8B;AAC9D,gCAAgC,kFAAgC;AAChE;AACA;AACA;AACA,sCAAsC,iEAAmB;AACzD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACliBA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA;AACsE;AACV;AACiD;AAC/B;AACG;AACA;AACT;AACN;AAC6B;AACK;AAC9C;AACe;AACK;AACA;AACN;AACW;AAC2B;AAC1B;AACmB;AAC7C;AACF;AACC;AACD;AACwB;AAC+D;AAC7D;AAC5C;AACoC;AACI;AAC6C;AACjD;AACb;AACY;AACT;AACS;AACK;AAChB;AACwC;AACkB;AACpH;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACiC;AACJ;AAC8D;AACxC;AACQ;AACE;AACI;AACjB;AACS;AACY;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,yGAAiD;AACnI;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA,4BAA4B,8EAAoB;AAChD;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B,iDAAiD,WAAW,6DAA6D,UAAU;AACnI;AACA,cAAc,oGAAwC,kDAAkD,mFAAuC;AAC/I;AACA,oCAAoC,0CAAa;AACjD,uEAAuE,oBAAoB;AAC3F,2BAA2B,0EAAgB;AAC3C;AACA;AACA,wCAAwC,sCAAS,wBAAwB,+EAAmC;AAC5G,oCAAoC,sCAAS;AAC7C,gCAAgC,uEAAa;AAC7C,wCAAwC,iEAAe;AACvD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC,sBAAsB,GAAG,+EAAmC,CAAC;AACtG,gCAAgC,kBAAkB;AAClD,0EAA0E,2EAAiB;AAC3F;AACA,oBAAoB,2EAAiB;AACrC;AACA,oBAAoB,sFAA4B;AAChD;AACA;AACA,gBAAgB,qEAAmB;AACnC,yFAAyF,sBAAsB;AAC/G,gBAAgB,0EAAwB;AACxC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,8EAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oGAAwC,kDAAkD,mFAAuC;AAC/I,6CAA6C,sCAAS;AACtD,oBAAoB,gFAAsB;AAC1C;AACA;AACA,mFAAmF,6BAA6B;AAChH;AACA,kBAAkB,gFAAsB;AACxC,8BAA8B,6EAAmB,4BAA4B,oBAAoB,wEAAc,EAAE;AACjH;AACA,kBAAkB,oFAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oFAA0B,CAAC,sCAAS;AAC1D;AACA;AACA;AACA,kCAAkC,0EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAmB;AAC3B,QAAQ,0EAAwB;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,uDAAW;AAC/D,YAAY,0EAAwB;AACpC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,gFAAsB;AAC1C;AACA;AACA,sCAAsC,kFAAwB;AAC9D,gCAAgC,wEAAc;AAC9C,SAAS;AACT;AACA,oDAAoD,wDAAY;AAChE,2DAA2D,wBAAwB;AACnF;AACA;AACA,oDAAoD,wDAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzKA;AACA;AACuF;AAC3B;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAA2B,CAAC,6DAAU;AAC7D;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,+BAA+B,kFAAwB;AACvD;AACA;AACA;AACA;AACA,2DAA2D,UAAU,uBAAuB,YAAY;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,YAAY;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,kCAAkC,uEAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,SAAS;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,QAAQ,mHAAmB;AAC/D,qDAAqD,wCAAwC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kBAAkB,4EAAkB;AACpC,4CAA4C,4EAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD,EAAE,cAAc;AAChG,kBAAkB,4EAAkB;AACpC;AACA,kCAAkC,SAAS;AAC3C;AACA,0BAA0B,oFAA0B;AACpD;AACA,aAAa,IAAI,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACsD;AACV;AACQ;AACM;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAAe;AACtE;AACA;AACA,gCAAgC,qDAAW;AAC3C,iCAAiC,uFAAwC;AACzE,+BAA+B,kFAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,8EAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oFAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AAC6B;AACI;AAC+C;AAC1B;AACD;AACK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C,qCAAqC,yCAAY;AACjD,gBAAgB,2EAAiB;AACjC;AACA;AACA,qBAAqB,2EAAiB;AACtC;AACA;AACA;AACA;AACA,gBAAgB,8EAAoB,CAAC,sCAAS;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,sCAAS;AAC/C;AACA,2BAA2B,IAAI,IAAI,qCAAqC;AACxE,yCAAyC,mBAAmB,GAAG,kBAAkB;AACjF;AACA;AACA,gBAAgB,uEAAa;AAC7B,gBAAgB,8EAAoB,CAAC,sCAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA;AACA,YAAY,2EAAiB;AAC7B,wBAAwB,kFAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA,8BAA8B,cAAc,EAAE,IAAI;AAClD;AACA,+BAA+B,WAAW,EAAE,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM,EAAE,UAAU;AAChD;AACA,iCAAiC,gBAAgB,EAAE,IAAI;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAAiB;AAC/B,mIAAmI,oEAAiB;AACpJ;AACA;AACA;AACA;AACA;AACA,gCAAgC,qFAA2B,CAAC,2DAAU;AACxC;AAC9B;;;;;;;;;;;;;;;;;;;;ACrMA;AACA;AAC0F;AACvC;AACkB;AACT;AACO;AACnE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yEAAyE,mBAAmB;AAC5F;AACA;AACA,2IAA2I;AAC3I;AACA;AACA;AACA;AACA,mCAAmC,mGAA2C;AAC9E,iCAAiC,mBAAmB,GAAG,eAAe;AACtE,2BAA2B,qFAA2B,CAAC,6DAAU;AACjE;AACA;AACA,+BAA+B,uFAA6B;AAC5D;AACA;AACA,iBAAiB,qFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAAgB,wBAAwB,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA,cAAc,sEAAoB;AAClC;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA,aAAa,+EAAmB;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAkB;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChIA;AACA;AACiC;AACyB;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAmE;AAC5F,uCAAuC,uEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AAC4C;AACiB;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAqB;AAC5C;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,4CAA4C,cAAc;AACjG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACiC;AACkB;AACT;AACS;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kDAAK,SAAS;AACtE;AACA;AACA,8BAA8B,iEAAe;AAC7C;AACA,+BAA+B,wDAAY,8BAA8B,kDAAK,QAAQ;AACtF;AACA;AACA;AACA;AACA,oBAAoB,mFAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAwB,yDAAa,gBAAgB,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,wDAAY,2BAA2B,qBAAqB;AAC3F;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACoC;AACP;AACF;AACM;AACiB;AACoC;AACf;AACpB;AACO;AACiB;AACxB;AAC5C;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iGAAsC,IAAI,+EAAqB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAmC;AACtD;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAgB;AAC3C;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,aAAa;AAC/F;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,QAAQ,mBAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6EAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gHAAgH,mBAAmB;AACnI;AACA,0BAA0B,mBAAmB,GAAG,gDAAgD;AAChG;AACA;AACA;AACA,0FAA0F,0BAA0B;AACpH,kFAAkF,kBAAkB;AACpG;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAc;AAC7B;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,EAAE,QAAQ;AACnD;AACA;AACA,oCAAoC,KAAK,GAAG,QAAQ;AACpD;AACA;AACA,0BAA0B,sCAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe,EAAE,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAoB;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB;AAChE;AACA;AACA,0EAA0E,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2FAAwC;AAC3D;AACA;AACA,YAAY,qFAAuB;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kFAAkF,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AAC1B;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kCAAkC;AAClC,8BAA8B;AAC9B,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACiC;AACA;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAY;AACrC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAgB;AAC5B;AACA,0BAA0B,sDAAU,6BAA6B,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa,6BAA6B,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa,6BAA6B,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa,6BAA6B,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa,6BAA6B,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3GA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AAC6B;AACI;AACL;AACkE;AACvB;AACI;AAC/C;AACiD;AAC7B;AACe;AACR;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAa;AAClC;AACA;AACA;AACA,wBAAwB,qCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAiB;AAC9C;AACA;AACA,gCAAgC,uEAA2B;AAC3D;AACA,gCAAgC,uEAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD,gBAAgB,wFAAwF;AACxG;AACA,yBAAyB,yEAAW;AACpC;AACA,4BAA4B,4EAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+EAAqB,CAAC,0CAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,8CAA8C,qFAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,GAAG,eAAe;AACnE;AACA,qBAAqB;AACrB,0CAA0C,uFAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAkB;AACpC;AACA;AACA;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA,mCAAmC,+EAAqB,CAAC,0CAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qHAA0D;AAC7G;AACA,kCAAkC,6CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,gCAAgC,yEAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6GAA+C;AACzG;AACA,kEAAkE,+EAAqB,CAAC,0CAAa;AACrG;AACA;AACA,0BAA0B,4EAAkB;AAC5C,oCAAoC,gFAAsB;AAC1D,0EAA0E,SAAS;AACnF;AACA;AACA,qBAAqB;AACrB;AACA,qCAAqC,+EAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,EAAE;AAClG;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AACA;AACsD;AACH;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA,YAAY,2EAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA;AACA,wBAAwB,6EAA8B;AACtD,QAAQ,2EAA4B;AACpC;AACA;AACA,gCAAgC,QAAQ,GAAG,eAAe;AAC1D;AACA;AACA,qBAAqB,aAAa,GAAG,eAAe,GAAG,eAAe;AACtE,qBAAqB,aAAa,GAAG,eAAe;AACpD;AACA;AACA;AACA;AACA,wBAAwB,6EAA8B;AACtD,0BAA0B,0FAAwC,qEAAqE,0EAA2B;AAClK;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAA4B;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AAC6B;AACI;AACQ;AACyD;AAC7C;AACF;AACkC;AAC9B;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA,kCAAkC,uEAAa;AAC/C;AACA,gCAAgC,qCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,qBAAqB,aAAa,+BAA+B;AACzH;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAgB;AACzD,0BAA0B,uCAAU;AACpC,gDAAgD,oEAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D,2DAAyB;AACpF,gCAAgC,UAAU;AAC1C;AACA;AACA,8CAA8C,EAAE,oCAAoC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAa;AAC7C;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA,0BAA0B,yEAAe;AACzC;AACA;AACA,2BAA2B,uCAAuC,IAAI,SAAS,EAAE,aAAa,EAAE,kBAAkB;AAClH;AACA,YAAY,0EAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,qEAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mFAAiC;AAC7F,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,iBAAiB,mEAAgB;AACjC;AACA,iBAAiB,mEAAgB;AACjC;AACA,iBAAiB,mEAAgB;AACjC;AACA,iBAAiB,oEAAiB;AAClC;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAgB;AACvC;AACA,uBAAuB,mEAAgB;AACvC;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA,YAAY,8CAAiB;AAC7B;AACA,yBAAyB,uCAAU;AACnC;AACA,qBAAqB,uCAAU;AAC/B,oBAAoB,YAAY,GAAG,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAQ,IAAI,SAAS,WAAW,SAAS;AACrE,qBAAqB,yCAAY;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC,IAAI,6DAAU,qBAAqB;AACvG,uBAAuB,oBAAoB,KAAK,WAAW;AAC3D;AACA;AACA;AACA,+BAA+B,qCAAqC,eAAe,oBAAoB,KAAK,WAAW;AACvH;AACA,4BAA4B,sCAAS,wBAAwB,mFAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAU,uBAAuB,IAAI,kBAAkB;AAC1F;AACA,SAAS;AACT;AACA,YAAY,uEAAa,6BAA6B,0BAA0B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oEAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qEAAmB;AACxE;AACA;AACA,+DAA+D,mFAAiC;AAChG,+CAA+C,WAAW;AAC1D;AACA;AACA,kEAAkE,oEAAiB;AACnF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,oEAAiB;AAC7F;AACA;AACA,sEAAsE,wEAAqB;AAC3F,6BAA6B,uCAAU;AACvC;AACA,sBAAsB,WAAW,GAAG,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wGAAwG;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA,gCAAgC,+EAAqB,CAAC,6DAAU;AAChE;AACA;AACA,2DAA2D,6BAA6B,KAAK,eAAe;AAC5G;AACA;AACA,8BAA8B,uEAAa,wBAAwB,4BAA4B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAiB;AACnD,gDAAgD,yCAAyC;AACzF;AACA,sCAAsC,oEAAiB;AACvD,iEAAiE,qCAAqC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAS;AACjC;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAe;AACtD;AACA;AACA,sCAAsC,oEAAiB;AACvD,6CAA6C,8CAAiB;AAC9D;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,2CAA2C,uCAAU;AACrD;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAS;AACzD;AACA;AACA,2FAA2F,oEAAiB;AAC5G;AACA,sBAAsB,uCAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAS;AACrC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qEAAmB;AAC3D,iFAAiF,mFAAiC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAiB;AAC3D,iCAAiC,oEAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C,8BAA8B,wEAAqB;AACnD,8BAA8B,mEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAmB;AAClE;AACA,yDAAyD,mFAAiC;AAC1F;AACA;AACA;AACA,2CAA2C,qEAAmB;AAC9D;AACA,qDAAqD,mFAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAqB;AACjD,iDAAiD,eAAe;AAChE,0DAA0D,yBAAyB;AACnF,4BAA4B,qBAAqB;AACjD,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjkBA;AACA;AACiC;AACJ;AAC8B;AACJ;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wCAAwC,sCAAS,2CAA2C,sFAAoC;AAChI,4CAA4C,mEAAa;AACzD,0CAA0C,sCAAS,8BAA8B,sFAAoC;AACrH,2CAA2C,mEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAa;AACtC;AACA;AACA;AACA;AACA;AACA,kCAAkC,sFAAoC;AACtE;AACA;AACA,kCAAkC,yCAAY;AAC9C;AACA;AACA;AACA,yBAAyB,0CAAa;AACtC;AACA,aAAa,4CAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa,uDAAuD,sCAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpFA;AACA;AAC6F;AAC9B;AACJ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAmB;AAC9C;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qFAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAc,CAAC,EAAE,kBAAkB;AACtD,YAAY,8EAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAkB,kBAAkB,mBAAmB,wEAAc,EAAE;AACtF;AACA;AACA,4BAA4B,qFAA2B,CAAC,4DAAU;AACzC;AACzB;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACzB;;;;;;;;;;;;;;AC7OA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACiC;AACJ;AACI;AAC+C;AAC3B;AACE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU,CAAC,yEAAwB;AAC7D,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA,kCAAkC,gCAAgC;AAClE;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY,CAAC,gFAAsB;AACpE;AACA;AACA,mCAAmC,gFAAsB;AACzD;AACA;AACA;AACA;AACA,4BAA4B,yDAAa,CAAC,yEAAwB;AAClE;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa,CAAC,yEAAwB;AAClE;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa,KAAK,OAAO;AACrD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS,SAAS,qFAAmC;AAC3F,gBAAgB,2EAAiB;AACjC;AACA,kCAAkC,wFAA8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7HA;AACA;AAC4D;AACG;AACA;AACxD;AACP;AACA;AACA;AACA,uBAAuB,kFAA8B;AACrD;AACA,uBAAuB,qFAA+B;AACtD;AACA,uBAAuB,qFAA+B;AACtD;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA,uBAAuB,oFAAgC;AACvD;AACA,uBAAuB,uFAAiC;AACxD;AACA,uBAAuB,uFAAiC;AACxD;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiE;AACuH;AACxL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAwB,EAAE;AACnE;AACA,KAAK;AACL;AACA,oBAAoB,kFAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kFAA4B,EAAE;AACvE;AACA,KAAK;AACL;AACA,oBAAoB,mFAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mFAA6B,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA,oBAAoB,sFAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sFAAgC,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,cAAc,sFAA4B;AAC1C;AACA,cAAc,4EAAkB;AAChC;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB;AAChC;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAsC,GAAG,kBAAkB;AAC7F;AACA;AACA;AACA;AACA,kCAAkC,kFAAwB;AAC1D;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY,eAAe;AAC/E;AACA,sBAAsB,mFAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE,kCAAkC,uEAAiB,CAAC,GAAG,WAAW;AAClE,kCAAkC,kFAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChKA;AACA;AACyB;AACI;AACuC;AACjC;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE,qCAAqC,oCAAO;AAC5C;AACA;AACA,4BAA4B,oCAAO;AACnC,8BAA8B,oCAAO;AACrC,kDAAkD,wCAAW;AAC7D,iDAAiD,uCAAU;AAC3D,aAAa,kKAAkK,mDAAY,EAAE;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa,0BAA0B,uDAAuD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B,0BAA0B,wFAA8B;AACxD;AACA;AACA;AACA,qCAAqC,sCAAS;AAC9C,kCAAkC,kFAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,+EAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA,eAAe,sCAAS;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACiC;AACJ;AACmD;AAC7B;AAC0B;AACnB;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,sBAAsB,8EAAoB;AAC1C;AACA,QAAQ,oFAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C,gBAAgB,2EAAiB;AACjC;AACA,uCAAuC,kBAAkB;AACzD,gBAAgB,iFAA+B;AAC/C;AACA;AACA,8CAA8C,4GAA+C;AAC7F,gBAAgB,2EAAiB;AACjC;AACA,wCAAwC,0BAA0B;AAClE,gBAAgB,+EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACoE;AACnB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB,GAAG,+BAA+B,0BAA0B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B,GAAG,mFAAuC,CAAC;AAC3F;AACA;AACA;AACA;AACA;AACA,cAAc,oFAA0B,mCAAmC,yBAAyB;AACpG;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACiC;AACA;AACyB;AACO;AACC;AAClE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2FAAsC,UAAU,gFAA8B;AAC9F;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+EAA6B;AAC7E;AACA,uDAAuD,+EAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,iBAAiB,iFAA+B;AAChD,iBAAiB,+EAA6B;AAC9C,uBAAuB,6CAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa,4BAA4B,gCAAgC;AACzG,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA;AACA,mCAAmC,EAAE,sBAAsB,kBAAkB;AAC7E;AACA;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,aAAa;AAChF;AACA;AACA,2CAA2C,EAAE,sBAAsB,yEAAyE;AAC5I;AACA;AACA,yEAAyE,eAAe,aAAa,UAAU;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,8BAA8B;AACjG;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,mCAAmC;AACtG;AACA;AACA,yEAAyE,eAAe,aAAa,UAAU;AAC/G;AACA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA,aAAa;AACb;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA,iFAAiF,eAAe,GAAG;AACnG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChGA;AACA;AAC6B;AAC6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mFAAyB,oCAAoC,0BAA0B;AACrG,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AAC6B;AACI;AAC+C;AAC/B;AACa;AACgB;AAC9E;AACA;AACA,gBAAgB,+FAA+F;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sFAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,0CAA0C;AACxG,mFAAmF,sFAA4B,IAAI,kBAAkB,GAAG,iBAAiB;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kDAAkD;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAkB;AACnD,+CAA+C,yBAAyB,GAAG,aAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,mFAAyB;AACnD,sCAAsC,8EAAoB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8BAA8B,oFAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,wGAA6C,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0FAAgC;AACzE;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa,GAAG,WAAW;AACxE;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA,sDAAsD,SAAS,GAAG,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,GAAG,aAAa;AAClE;AACA,uCAAuC,yFAA+B;AACtE;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yFAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB;AAChC,gCAAgC,kBAAkB,GAAG,gCAAgC;AACrF,qCAAqC,gFAAsB;AAC3D;AACA;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,yCAAyC,cAAc,GAAG,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA,uBAAuB,2EAA+B,CAAC;AACvD,oBAAoB,uEAA2B;AAC/C;AACA;AACA,oBAAoB,uEAA2B;AAC/C;AACA,oBAAoB,uEAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,+BAA+B;AACrE,4BAA4B,uEAA2B;AACvD;AACA;AACA;AACA;AACA,wBAAwB,uEAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;AAC7B;;;;;;;;;;;;;;;;;;ACvUA;AACA;AACkE;AACrC;AAC7B;AACA,YAAY,gBAAgB,QAAQ,mHAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sFAAsF,sCAAsC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAe,wBAAwB,sCAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA,eAAe,gFAAkB;AACjC;AACA,YAAY,2BAA2B;AACvC,6BAA6B,gFAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxEA;AACA;AAC6D;AAC7D;AACO;AACP;AACA,gBAAgB,wHAAwH;AACxI,gBAAgB,yDAAyD;AACzE,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DA;AACA;AAC6D;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtGA;AACA;AAC6B;AAC2D;AACrB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA,2BAA2B,qEAAW,iCAAiC,iBAAiB;AACxF,mCAAmC,kFAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,2BAA2B;AACxH;AACA;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qFAA2B,CAAC,iEAAU;AACzC;AACvC;;;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;AACiC;AACJ;AACgE;AACjC;AACN;AACE;AACjD;AACP;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sCAAS,qCAAqC,mFAAyB;AACjH;AACA;AACA,QAAQ,uEAAa,iDAAiD,qBAAqB;AAC3F;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA,YAAY,iFAAuB;AACnC;AACA;AACA;AACA,4CAA4C,eAAe,GAAG,sBAAsB;AACpF;AACA,yCAAyC,sCAAS;AAClD,yCAAyC,iEAAe;AACxD;AACA,SAAS;AACT,wEAAwE,yBAAyB;AACjG,2BAA2B,0EAAgB;AAC3C,+DAA+D,yBAAyB;AACxF;AACA,8CAA8C,uDAAW,eAAe,gBAAgB,UAAU,sBAAsB;AACxH;AACA,YAAY,qFAAmC;AAC/C;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wEAAwE,gBAAgB,UAAU,sBAAsB;AACxH;AACA;AACA,uDAAuD,gBAAgB,UAAU,uBAAuB,KAAK,yBAAyB;AACtI;AACA;AACA;AACA,QAAQ,iFAAuB;AAC/B;AACA,8CAA8C,sCAAS,wCAAwC,eAAe;AAC9G,2DAA2D,8BAA8B;AACzF,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA,YAAY,iFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+FAAqC;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA,qDAAqD,gBAAgB;AACrE;AACA,6DAA6D,mCAAmC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtMA;AACA;AACwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,gHAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACmF;AACnB;AACH;AACtD,gCAAgC,wEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C,kCAAkC;AAClC;AACA,8CAA8C,uBAAuB,QAAQ,cAAc;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;ACtFA;AACA;AACoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAuB,sBAAsB,qEAAuB;AAClG;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAuB;AAC3D,kCAAkC,mEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA,uCAAuC,uCAAuC;AAC9E;AACA,kCAAkC,qEAAuB;AACzD,kCAAkC,qEAAuB;AACzD,kCAAkC,qEAAuB;AACzD,kCAAkC,gFAAkC;AACpE,kCAAkC,uEAAyB;AAC3D,kCAAkC,kEAAoB;AACtD,kCAAkC,qEAAuB;AACzD;AACA;AACA;AACA,uCAAuC,oEAAsB,sBAAsB,uEAAyB;AAC5G;AACA;AACA;AACA,uCAAuC,qEAAuB;AAC9D;AACA;AACA;AACA;AACA,uCAAuC,6EAA+B;AACtE;AACA;AACA;AACA;AACA,uCAAuC,mEAAqB;AAC5D;AACA,sDAAsD,cAAc,0BAA0B,YAAY;AAC1G;AACA;AACA;AACA;AACA,gCAAgC,oEAAsB;AACtD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,6EAA+B;AAC9F;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA,uCAAuC,QAAQ;AAC/C;AACA,qCAAqC,6EAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACiC;AACgE;AACnC;AACsB;AAC5B;AAC4B;AAChC;AACC;AACe;AACnB;AAC6B;AACpB;AACL;AACC;AACsB;AAC5E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAA0F;AAC1G;AACA,oBAAoB,qFAAqF;AACzG;AACA,sBAAsB,6DAAW;AACjC;AACA,kBAAkB,4EAAkB;AACpC,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mFAAuC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAgB;AAC1D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,yCAAyC,qBAAqB;AAC9D,4BAA4B,qDAAqD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAW;AACnC;AACA,yBAAyB;AACzB;AACA,qCAAqC,8CAAiB;AACtD;AACA,oCAAoC,qDAAqD;AACzF;AACA;AACA,4CAA4C,uEAA2B;AACvE;AACA,4CAA4C,uEAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kHAAkH;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0HAA0H,oBAAoB;AAC9I;AACA;AACA,6HAA6H,oBAAoB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,EAAE,mFAAkC;AACpF;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAyB;AACxD;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,+BAA+B,6EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG,oBAAoB,6DAA6D;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAoB;AACzC,qBAAqB,6EAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yFAAyF;AAC7G;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD,4BAA4B,8BAA8B;AAC1D,4BAA4B,wBAAwB,EAAE,mFAAkC;AACxF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD,oDAAoD,qEAAuB,MAAM,QAAQ,GAAG,UAAU;AACtG;AACA,6BAA6B,gFAAkC;AAC/D,6BAA6B,qEAAuB;AACpD,6BAA6B,qEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,oDAAoD,qEAAuB;AAC3E,gCAAgC,gFAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,qEAAuB;AACzF,wCAAwC,gFAAkC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,qBAAqB,qEAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,sCAAsC,gBAAgB;AACzF;AACA;AACA;AACA,0CAA0C,gHAAgH;AAC1J;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wDAAwD,oGAAyC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,sIAAsI;AACvL;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wCAAwC,oGAAyC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,oFAAoF;AACxH;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA,oDAAoD,8DAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,6BAA6B,2HAA2H;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,wGAAwG;AACxI;AACA;AACA,6CAA6C,kFAAoB;AACjE,uBAAuB,kEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yCAAyC,uEAAsB;AAC/D;AACA,aAAa;AACb,kDAAkD,sEAAqB;AACvE;AACA,mCAAmC,wEAAc;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kEAAiB;AAChE;AACA,aAAa;AACb,wCAAwC,wEAAgB;AACxD;AACA;AACA,wCAAwC,wEAAgB;AACxD;AACA,+CAA+C,0FAAwB;AACvE;AACA,SAAS;AACT,mBAAmB,kEAAQ;AAC3B;AACA,0CAA0C,4FAA4F;AACtI;AACA;AACA;AACA;AACA,6DAA6D,mEAAkB,mCAAmC,sBAAsB;AACxI;AACA;AACA;AACA,8CAA8C,oFAAoF;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2FAAsB;AAC5D,gGAAgG,iDAAiD;AACjJ;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzkBA;AACA;AAC6B;AAC0D;AAClC;AACD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAA2D;AAC3E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,4EAAkB;AACpC,wBAAwB,YAAY;AACpC,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4DAA4D,sCAAsC;AAClG,wCAAwC,qDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,sBAAsB;AAC1G;AACA;AACA;AACA,yCAAyC,yEAAe;AACxD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,yEAAwB;AAClD;AACA,qCAAqC,yEAAe;AACpD,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,oBAAoB,0CAA0C;AAC9D;AACA;AACA,+CAA+C,kFAAwB;AACvE;AACA;AACA;AACA,qBAAqB,oFAA0B;AAC/C;AACA;AACA,wEAAwE,gBAAgB,IAAI,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAuB;AAClD;AACA;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA;AACA,gBAAgB,oFAA0B;AAC1C;AACA,gBAAgB,oFAA0B;AAC1C;AACA,SAAS;AACT;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qEAAuB,eAAe,gFAAkC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD,2CAA2C,qEAAuB,gBAAgB,kEAAoB;AACtG;AACA,sBAAsB,4EAAkB;AACxC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,KAAK,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACiC;AAC0C;AACf;AACqB;AACC;AAC9B;AACkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAW,gBAAgB,uDAAW;AACvE;AACA;AACA,4CAA4C,2BAA2B,KAAK,sBAAsB;AAClG,wCAAwC,wDAAY,2BAA2B,uDAAW;AAC1F;AACA;AACA;AACA;AACA,mCAAmC,uDAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2JAA2J;AAC3K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uEAAsB;AAC5E,4CAA4C,sEAAqB;AACjE;AACA,+BAA+B,+EAAqB;AACpD,2BAA2B,4DAAc;AACzC,SAAS;AACT,mCAAmC,sEAAc;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,wCAAwC,gBAAgB;AACxH;AACA;AACA;AACA;AACA;AACA,mCAAmC,qEAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB,WAAW,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAoB;AAClD;AACA,sBAAsB,qEAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,cAAc,qEAAuB;AACrC;AACA,kBAAkB,gFAAkC;AACpD,kBAAkB,qEAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAuB;AACxC;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,yCAAyC,sDAAU,KAAK,KAAK;AAC7D;AACA;AACA,iDAAiD,qEAAuB;AACxE;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,yDAAyD,mBAAmB,mBAAmB,KAAK;AACpG;AACA,+CAA+C,qEAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,qEAAuB;AAC7E;AACA,kCAAkC,uEAAa,sBAAsB,oBAAoB,6BAA6B,qBAAqB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAyB;AAC1C;AACA,mEAAmE,wDAAY,KAAK,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAuB;AACxC;AACA,mEAAmE,wDAAY,KAAK,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kEAAoB;AACrC;AACA,mEAAmE,uDAAW,KAAK,KAAK;AACxF;AACA;AACA;AACA,iBAAiB,qEAAuB;AACxC;AACA,mEAAmE,wDAAY,KAAK,KAAK,8BAA8B,4BAA4B;AACnJ;AACA;AACA;AACA,iBAAiB,gFAAkC;AACnD;AACA,mEAAmE,yDAAa,KAAK,KAAK,+BAA+B,4BAA4B;AACrJ;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3RA;AACA;AACsD;AACO;AACT;AACE;AACgB;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAS;AACtC,mCAAmC,gEAAe;AAClD;AACA,gBAAgB,6CAA6C;AAC7D;AACA,sBAAsB,uEAAa,yBAAyB,uFAAuF,iBAAiB,oGAAoG;AACxQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+EAAwB;AACzE;AACA;AACA,aAAa;AACb;AACA;AACA,yDAAyD,qEAAuB,GAAG,mEAAqB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA,4BAA4B,6EAA+B;AAC3D;AACA;AACA;AACA,sBAAsB,uEAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,6EAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChKA;AACA;AACA,qBAAqB,SAAI,IAAI,SAAI;AACjC;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACyB;AACwC;AACP;AACT;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,qBAAqB;AACrC,gBAAgB,gBAAgB;AAChC;AACA,kCAAkC,+EAAmC,CAAC,GAAG,4EAAgC,CAAC,aAAa,WAAW;AAClI,6BAA6B,mEAAkB;AAC/C;AACA;AACA,SAAS;AACT,mCAAmC,qBAAqB;AACxD,wCAAwC,qBAAqB;AAC7D,2BAA2B,cAAc,GAAG,sBAAsB;AAClE,gCAAgC,cAAc,GAAG,2BAA2B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6EAA6E;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB;AAChC;AACA,sBAAsB,kFAAwB;AAC9C;AACA;AACA,qBAAqB,oFAA0B;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA,4BAA4B,gDAAmB;AAC/C;AACA,aAAa;AACb;AACA,uGAAuG,mFAAmF;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAAwB;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,oFAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9HA;AACA;AACiC;AAC4B;AACT;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,iBAAiB,qEAAuB;AACxC,iBAAiB,uEAAyB;AAC1C,iBAAiB,qEAAuB;AACxC,iBAAiB,gFAAkC;AACnD,iBAAiB,qEAAuB;AACxC,iBAAiB,qEAAuB;AACxC,iBAAiB,kEAAoB;AACrC;AACA;AACA;AACA,0BAA0B,uEAAa,iCAAiC,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAuB,sBAAsB,0DAAY;AAC7F,oCAAoC,kEAAoB,sBAAsB,yDAAW;AACzF,oCAAoC,uEAAyB,sBAAsB,0DAAY;AAC/F,oCAAoC,qEAAuB,sBAAsB,0DAAY;AAC7F,mCAAmC,gFAAkC,sBAAsB,2DAAa;AACxG,oCAAoC,qEAAuB,sBAAsB,0DAAY;AAC7F,mCAAmC,qEAAuB,sBAAsB,wDAAU;AAC1F;AACA;AACA,aAAa,qEAAuB;AACpC;AACA;AACA,aAAa,gFAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAuB;AAC9D;AACA;AACA,oCAAoC,eAAe,EAAE,YAAY,EAAE,KAAK;AACxE;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,IAAI,eAAe;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAW,SAAS,EAAE,8BAA8B,EAAE,uDAAW,KAAK,6CAA6C,KAAK,EAAE,wDAAY,QAAQ,EAAE,uDAAW,QAAQ;AACjM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB,EAAE,uDAAuD;AACvG,2BAA2B,OAAO,IAAI,aAAa;AACnD;AACA;AACA;AACA;AACA,0BAA0B,uDAAW,SAAS,EAAE,2BAA2B,EAAE,uDAAW,KAAK,wCAAwC,GAAG;AACxI;AACA;;;;;;;;;;;;;;;;ACtKA;AACA;AACmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD,mCAAmC,eAAe,GAAG,4BAA4B;AACjF,2BAA2B,cAAc,GAAG,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB,wBAAwB,uDAAuD;AAC/G;AACA;AACA;AACA;AACA,gCAAgC,4EAAkB;AAClD;AACA;AACA,gBAAgB,oFAA0B;AAC1C;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AAC8B;AAC9B;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvCA;AACA;AACwC;AACY;AACQ;AAC5D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,2FAA2F;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qEAAmB;AACtD;AACA,wBAAwB,qEAAuB;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAS;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,qEAAmB;AAC1D;AACA,4BAA4B,qEAAuB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,mBAAmB;AACvD;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB,EAAE,WAAW;AAChD;AACA;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACqF;AAC9B;AACW;AACjB;AAC1C,iCAAiC,iEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAA2D;AAC3E;AACA;AACA;AACA,SAAS;AACT,QAAQ,+EAAqB;AAC7B,QAAQ,+EAAqB;AAC7B,gBAAgB,+DAA+D;AAC/E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAqB;AACjC;AACA;AACA,YAAY,+EAAqB;AACjC;AACA,0BAA0B,yEAAe;AACzC;AACA,6BAA6B,qDAAqD;AAClF,oCAAoC,kGAA6C;AACjF,mCAAmC,oBAAoB,GAAG,sBAAsB;AAChF,+BAA+B,gBAAgB;AAC/C,oCAAoC,gBAAgB;AACpD,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,qCAAqC,cAAc,GAAG,4EAAgC,CAAC;AACvF,YAAY,iFAAuB;AACnC,wBAAwB,4EAAgC;AACxD;AACA,+CAA+C,UAAU,GAAG,YAAY;AACxE,oDAAoD,UAAU,GAAG,iBAAiB;AAClF,2BAA2B,cAAc,GAAG,gBAAgB;AAC5D,gCAAgC,cAAc,GAAG,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,8BAA8B,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AAC0F;AACkC;AAC9D;AACR;AACF;AACF;AACQ;AAC0B;AACN;AAC9E;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,kHAAuD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sEAAqB;AACnE;AACA;AACA,mCAAmC,+EAAqB;AACxD,aAAa;AACb,2CAA2C,kEAAiB;AAC5D;AACA,aAAa;AACb,4CAA4C,oEAAmB;AAC/D;AACA,6BAA6B,wEAAc;AAC3C,aAAa;AACb,yCAAyC,uEAAsB;AAC/D;AACA,aAAa;AACb,2CAA2C,kEAAiB;AAC5D;AACA,aAAa;AACb,kDAAkD,sEAAqB;AACvE;AACA,mCAAmC,wEAAc;AACjD;AACA,aAAa;AACb,yCAAyC,wEAAgB;AACzD,yCAAyC,yFAAwB;AACjE;AACA,aAAa;AACb,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,+BAA+B,wFAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAAc,kCAAkC,KAAK;AACrG,oCAAoC,qEAAuB;AAC3D;AACA;AACA,oCAAoC,gFAAkC;AACtE;AACA;AACA,oCAAoC,qEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA,yBAAyB,qEAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACiD;AACW;AAC4B;AACpC;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,2EAA2E;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB,uBAAuB,WAAW;AACtG;AACA;AACA;AACA,iDAAiD,uEAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uCAAuC,qEAAmB;AAC1D;AACA,4BAA4B,kEAAoB;AAChD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,EAAE,gCAAgC;AAC7E,8CAA8C,+EAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gFAAoC;AAC5F,kBAAkB,qBAAqB,GAAG,uBAAuB;AACjE;AACA;AACA;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACoE;AACoC;AAC1B;AACf;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gHAAsC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yGAA8C;AAC1D,iCAAiC,yGAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAwB;AACvD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa,kCAAkC,0BAA0B;AACrF;AACA;AACA;AACA,uCAAuC,qFAA2B,CAAC,6DAAU;AACzC;AACpC;;;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACiC;AACsC;AACO;AAC7B;AACjD;AACA;AACA;AACO,wCAAwC,sFAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,6BAA6B;AACxG;AACA;AACA;AACA,sEAAsE;AACtE,8EAA8E;AAC9E;AACA;AACA;AACA,gCAAgC,0EAA8B,CAAC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,GAAG,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,8BAA8B,MAAM,eAAe,SAAS;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CACN;AAC3B;AACA;AACA,2BAA2B,KAAK,GAAG,QAAQ,GAAG,aAAa;AAC3D;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,2CAA2C,0EAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkB,yCAAyC,0BAA0B;AACnG;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtKA;AACA;AAC6B;AACI;AACL;AACK;AAC4E;AAC7C;AACH;AACE;AACd;AAC+B;AAChB;AACQ;AACF;AACtE,mBAAmB,qEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yCAAY;AACrB,qEAAqE,GAAG;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qEAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA,mBAAmB,qEAAmB,wBAAwB,kBAAkB,GAAG,kBAAkB;AACrG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,wEAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF,8EAA8E;AAC9E,gFAAgF;AAChF,4EAA4E;AAC5E,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C,kCAAkC;AAClC;AACA,8CAA8C,uBAAuB,QAAQ,cAAc;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,wDAAiB;AAChC;AACA;AACA;AACA;AACA,qDAAqD,+EAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU,QAAQ,2EAA+B,EAAE;AAC/E;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iFAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+EAAqB,CAAC,0CAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDACN;AAC/B;AACA;AACA,yCAAyC,YAAY,GAAG,aAAa;AACrE;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0FAAqC;AACrF;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,oCAAoC,EAAE,iFAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wEAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAuB;AACpD;AACA,6BAA6B,2EAAsB;AACnD,qEAAqE,4EAAuB;AAC5F;AACA;AACA;AACA,6BAA6B,uEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA,yBAAyB,4EAAuB;AAChD;AACA;AACA;AACA,yBAAyB,2EAAsB;AAC/C;AACA;AACA;AACA,yBAAyB,uEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6IAA6I;AAC7I,6HAA6H;AAC7H,mIAAmI;AACnI,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA,yBAAyB,4EAAuB;AAChD;AACA;AACA;AACA;AACA,yBAAyB,wEAAmB;AAC5C;AACA,2CAA2C;AAC3C;AACA,yBAAyB,uEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,KAAK;AACnG,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDACN;AAC3B;AACA;AACA,+BAA+B,UAAU,GAAG,aAAa;AACzD;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK,GAAG,QAAQ;AAC/E;AACA;AACA;AACA;AACA,+DAA+D,KAAK,GAAG,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,kBAAkB;AACtG,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yEAA2B;AACrF;AACA;AACA;;;;;;;;;;;;;;AC3sBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAC6B;AAC8D;AAChD;AAC6C;AACxF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0FAA0F,iCAAiC;AAC3H;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,iCAAiC;AAC3H;AACA;AACA,6BAA6B,sCAAS;AACtC;AACA,cAAc,kFAAwB;AACtC,2BAA2B,uEAAiB,CAAC,GAAG,0EAAoB,CAAC;AACrE;AACA,SAAS;AACT;AACA;AACA,cAAc,4EAAkB,uBAAuB,sCAAS;AAChE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oFAA0B;AACtC,YAAY,oFAA0B;AACtC,mCAAmC,gFAAsB;AACzD,yCAAyC,gFAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAoB,GAAG,iDAAiD;AAChG;AACA;AACA;AACA,gCAAgC,2EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAc;AAClC;AACA;AACA;AACA,mBAAmB,4DAA0B;AAC7C;AACA;AACA;AACA;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnGA;AACA;AACuF;AACtC;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc,4EAAkB;AAChC,gDAAgD,wCAAwC;AACxF,qCAAqC,gFAAsB;AAC3D;AACA;AACA;AACA,SAAS,IAAI,gBAAgB;AAC7B;AACA;AACA,yGAAyG,MAAM;AAC/G;AACA;AACA,wDAAwD,kFAAsC,CAAC;AAC/F;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiC;AACmC;AACd;AACzB;AACoB;AAC1C;AACP,oBAAoB,qCAAG;AACvB;AACA;AACA;AACA;AACA,oBAAoB,uDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,gBAAgB,sDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA,yBAAyB,8EAAoB;AAC7C;AACA;AACA,6CAA6C,kFAAsC,CAAC;AACpF;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAW;AAChC;AACA,yBAAyB,0FAAwC;AACjE;AACA,4BAA4B,UAAU,GAAG,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,uDAAW;AACzF;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kFAAsC,CAAC;AAC5E;AACA;AACA,gBAAgB,sDAAU;AAC1B,cAAc,8EAAoB;AAClC;AACO;AACP;AACA,QAAQ,uDAAW;AACnB,QAAQ,uDAAW,uCAAuC,uDAAuD;AACjH;AACA;AACA;;;;;;;;;;;;;;;;;ACvHA;AACA;AACmD;AACY;AACN;AAClD;AACP;AACA,QAAQ,qDAAuB;AAC/B,cAAc,6DAA+B;AAC7C;AACA;AACA;AACA,YAAY,2DAA6B;AACzC;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACiE;AACjE;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B,2FAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc,sEAAsE;AACvL;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,0CAA0C,yEAAqB;AAC/D,wCAAwC,8CAA8C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACiF;AAC1E;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,yDAAyD,iBAAiB,eAAe,cAAc;AACvG,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AACA;AACoE;AAC7D;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,gDAAgD,iBAAiB,eAAe,cAAc;AAC9F,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnBA;AACA;AACoE;AAC7D;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,2DAA2D,iBAAiB,eAAe,cAAc;AACzG,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxBA;AACA;AACgF;AACjB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B,iCAAiC,kFAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qFAA2B,CAAC,6DAAU;AACzC;AACpC;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiC;AACI;AACF;AACgD;AACnF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAY,CAAC,wCAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA,qBAAqB,0CAAa;AAClC,sBAAsB,2CAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAwB,GAAG,mBAAmB;AAChF,QAAQ,wDAA2B,CAAC,0CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAgB;AAC5B,gCAAgC,8CAAiB;AACjD;AACA;AACA;AACA,8BAA8B,sDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,sBAAsB,sDAAU;AAChC;AACA,kBAAkB,8EAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChIA;AACA;AAC6B;AAC4I;AACpH;AACC;AACgB;AAChB;AACN;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,kEAAQ,KAAK,iFAAuB;AACjE;AACA,SAAS;AACT,6CAA6C,+EAAwB,CAAC,sCAAS;AAC/E,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAoB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,UAAU;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAAyB;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4CAA4C,qEAAyB;AACrE;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAW;AAC1D;AACA;AACA;AACA;AACA,oCAAoC,oEAAwB;AAC5D;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,oEAAU;AAC/C;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA,mCAAmC,4EAAgC;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,oEAAU;AAC/C;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,mEAAmE,gBAAgB,IAAI,oBAAoB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAAgB;AAC9C;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAS,CAAC,yEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAY;AAC7C;AACA,YAAY,2EAAiB;AAC7B,iCAAiC,6EAAmB,cAAc,oBAAoB,wEAAc,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,wBAAwB,kBAAkB;AAC1C;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,uCAAuC,iBAAiB;AACxD;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7YA;AACA;AACqC;AACF;AACF;AACyB;AACZ;AAC9C,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAY;AACtC,0BAA0B,uDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAiB;AACzB,QAAQ,+CAAkB;AAC1B,uBAAuB,wDAAY,gBAAgB,uDAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAiB;AAC7B;AACA,gBAAgB,+CAAkB;AAClC;AACA,YAAY,gDAAmB;AAC/B;AACA;AACA;AACA,QAAQ,8CAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAkB;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,qDAAwB,GAAG,OAAO,0CAAa,EAAE;AACnF;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAc;AACrC,qBAAqB,wDAAY;AACjC,qBAAqB,uDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9LA;AACA;AACiC;AACmC;AACP;AACiB;AACc;AAC5B;AAChE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,6GAA6G,cAAc,oCAAoC;AAC/J;AACA,6EAA6E;AAC7E,6GAA6G,cAAc,yEAAyE;AACpM;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,0BAA0B,qGAAmC;AAC7D;AACA,8BAA8B,uFAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAU,UAAU,mCAAmC;AACvF,8FAA8F,oGAA0C;AACxI;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA,oCAAoC,wDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uEAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrMA;AACA;AACiD;AACmC;AACR;AACrE,kDAAkD,qFAA2B;AACpF;AACA;AACA,qDAAqD,gFAAoC,CAAC;AAC1F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,+BAA+B,0EAAsB;AACrD,+BAA+B,gFAAoC,EAAE,gBAAgB,0EAAsB,CAAC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAqB,0BAA0B,0EAAsB,4DAA4D,0EAAsB;AAC1K;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTA;AACA;AAC4E;AACrE,2CAA2C,qFAA2B;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,gHAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACgE;AACiB;AAChC;AACiB;AAClE,uBAAuB,qEAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2FAAsC;AACtD,gBAAgB,0EAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C,kCAAkC;AAClC;AACA,8CAA8C,mBAAmB,QAAQ,cAAc;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2FAAsC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AAC8B;AAC9B;;;;;;;;;;;;;;;;ACjKA;AACA;AACmG;AACnG;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAwB;AAC5D;AACA;AACA;AACA;AACA,2CAA2C,oDAAe;AAC1D;AACA;AACA;AACA;AACA,4CAA4C,6CAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAe;AACzD;AACA;AACA;AACA,0CAA0C,wDAAmB;AAC7D;AACA;AACA;AACA,yCAAyC,oDAAe;AACxD;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAQ;AAC7C;AACA;AACA;AACA;AACA,6BAA6B,6CAAQ;AACrC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AAC6B;AACuC;AACV;AACA;AACJ;AACtD;AACA;AACA;AACO,wCAAwC,+DAAgB;AAC/D;AACA;AACA,iCAAiC,+DAAa;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,sCAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAS,gBAAgB,0FAAwC;AAC9F;AACA,yBAAyB,kFAAwB;AACjD,QAAQ,6EAAmB;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,WAAW,gDAAgD,YAAY;AACtH;AACA;AACA;AACA,gDAAgD,sCAAS;AACzD,iBAAiB,2EAAiB;AAClC,kEAAkE,WAAW,UAAU,YAAY;AACnG,wBAAwB,yBAAyB;AACjD;AACA,YAAY,6EAAmB;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sCAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA,gBAAgB,4FAAkC;AAClD;AACA,sEAAsE,iBAAiB,eAAe,iBAAiB,wBAAwB,oBAAoB;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,kGAAkG,0FAAwC;AAClK;AACA;AACA,eAAe,sCAAS,mHAAmH,mFAAiC;AAC5K;AACA;AACA;;;;;;;;;;;;;;;AC7FA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACO,kCAAkC,+DAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AAC+F;AAClE;AACiD;AACpB;AACtB;AACoC;AACxE;AACA,kBAAkB,kDAAkD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mGAAwC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAS;AACrB;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,oCAAoC,mBAAmB,KAAK,EAAE;AACjG;AACA;AACA,sBAAsB,uEAAa,6BAA6B,mBAAmB;AACnF;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA,sBAAsB,uEAAa,yEAAyE,mBAAmB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC,aAAa,2EAAiB;AAC9B,sBAAsB,uEAAa,gCAAgC,WAAW,qBAAqB,gBAAgB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAa;AACzC;AACA;AACA,gBAAgB,4FAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,qDAAqD,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C,eAAe,6EAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAAiB;AAClC,oEAAoE,aAAa;AACjF;AACA,2CAA2C,kFAAwB;AACnE;AACA;AACA,mCAAmC,YAAY,0CAA0C,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,qBAAqB,0FAAwC;AACrF;AACA;AACA,+BAA+B,qFAA2B,CAAC,sEAAU;AACzC;AAC5B;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAO,CAAC,yBAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;AACnB;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACiF;AACR;AACY;AAClD;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4EAAqC;AAChF;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA,yCAAyC,+EAAqB;AAC9D;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kFAAmB;AAC1C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,uBAAuB,8FAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,8BAA8B,8HAAyD;AACvF;AACA,gBAAgB,sFAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,oBAAoB,WAAW,KAAK,EAAE;AACzE;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzKA;AACA;AACsE;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,oDAAe;AAC7C;AACA;AACA;AACA,6CAA6C,oDAAe;AAC5D;AACA;AACA;AACA,0CAA0C,4CAAO;AACjD,uBAAuB,oDAAe;AACtC,SAAS;AACT;AACA;AACA;AACA,uCAAuC,oDAAe;AACtD;AACA;AACA;AACA,oCAAoC,4CAAO;AAC3C,uBAAuB,oDAAe;AACtC,SAAS;AACT;AACA;AACA;AACA,iCAAiC,oDAAe;AAChD;AACA;AACA;AACA,kCAAkC,sDAAiB;AACnD;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CA;AACA;AAC6D;AACnB;AACW;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yBAAyB,8DAAkB;AAC3C;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AACA;AACwD;AACjD;AACP;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AAC+C;AACtB;AACA;AACI;AACyC;AAC9B;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,yCAAY;AAC1C;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAY;AACxB;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAA+B;AACvC,QAAQ,mEAA2B,4FAA4F,EAAE;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAY;AAC/C;AACA,6BAA6B,oFAA0B;AACvD;AACA;AACA,qCAAqC,yCAAY;AACjD;AACA;AACA;AACA;AACA,oBAAoB,+EAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAW;AACvB;AACA;AACA;AACA;AACA,0CAA0C,yEAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA,wCAAwC,yEAAyE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wFAA8B;AACjE;AACA;AACA,8BAA8B,sCAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB,GAAG,aAAa,GAAG,QAAQ;AAC5E;AACA,YAAY,0CAAa;AACzB;AACA;AACA;AACA,gBAAgB,oFAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oFAA0B;AACnD;AACA,qCAAqC,WAAW,GAAG,WAAW;AAC9D;AACA;AACA;AACA;AACA,gBAAgB,+EAAqB;AACrC;AACA;AACA;AACA,QAAQ,+EAAqB;AAC7B;AACA;AACA;;;;;;;;;;;;;;;;AChKA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sFAA4B;AAC7C,iBAAiB,0FAAgC;AACjD;AACA;AACA;AACA,oDAAoD,sDAAsD;AAC1G;AACA;AACA,iBAAiB,wFAA8B;AAC/C;AACA;AACA;AACA,wDAAwD,sDAAsD;AAC9G;AACA;AACA;AACA,iBAAiB,wFAA8B;AAC/C,oDAAoD,sDAAsD;AAC1G;AACA;AACA;AACA,iBAAiB,0FAAgC;AACjD,oDAAoD,sDAAsD;AAC1G;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AACwC;AACP;AAC1B;AACP;AACA;AACA;AACA,gCAAgC,gFAAwC;AACxE;AACA;AACA,wBAAwB,yCAAY;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA,wCAAwC,gFAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACiE;AACjE;AACA;AACA;AACO,8BAA8B,2GAAiD;AACtF;AACA;AACA;AACO,4BAA4B,sBAAsB;AACzD;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACO,6BAA6B,sBAAsB,QAAQ,kBAAkB;AACpF;;;;;;;;;;;;;;ACxBA;AACA;AACiE;AACU;AAC3E,gBAAgB,2GAAiD;AACjE;AACA;AACA,oDAAoD,WAAW;AAC/D,gBAAgB,iGAAsC;AACtD;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP,0BAA0B,6DAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB,QAAQ,0BAA0B,EAAE,oBAAoB;AAClG;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AAC6B;AACT;AAC8D;AACtD;AAC+C;AACpE;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,iGAAsC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA,cAAc,sFAA4B,CAAC,yCAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sFAA4B,CAAC,yCAAY;AACvD,2BAA2B,yEAAe;AAC1C;AACA,2BAA2B,sBAAsB;AACjD,yBAAyB,yBAAyB,EAAE,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAAgB;AAC7C;AACA,SAAS;AACT,+EAA+E,MAAM;AACrF,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAW;AAC/C,2FAA2F,YAAY;AACvG;AACA;AACA;AACA;AACA,YAAY,kDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E,0BAA0B,gFAAsB;AAChD;AACA;AACA;AACA;AACA,eAAe,+EAAqB;AACpC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AAC+C;AACtB;AACI;AACY;AAC0C;AACtC;AACR;AACrC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAY;AACvC,aAAa,2EAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,iBAAiB,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iFAAuB,wDAAwD,EAAE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sFAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAuB;AACnC;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAAiB;AAClC;AACA;AACA,+BAA+B,kFAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,oDAAuB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gDAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAY;AACtC,YAAY,2EAAiB;AAC7B;AACA;AACA;AACA,QAAQ,sFAA4B;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa,iBAAiB,sCAAS,YAAY,mFAAyB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAiB;AAC7B;AACA,oCAAoC,WAAW;AAC/C;AACA,kCAAkC,gBAAgB;AAClD,YAAY,6EAAmB,GAAG,6BAA6B;AAC/D;AACA;AACA,gBAAgB,2EAAiB;AACjC;AACA;AACA,wCAAwC,gBAAgB;AACxD,gBAAgB,+EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC,sPAAsP;AAClV,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,2CAAc;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAY;AACpC;AACA,sBAAsB,QAAQ,EAAE,2CAAc,CAAC,EAAE,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA,iCAAiC,gDAAmB;AACpD,sCAAsC,+CAAW;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,KAAK;AAC/E;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAS;AACV;AACrB;;;;;;;;;;;;;;;;;;;;;;;ACjhBA;AACA;AACyB;AACU;AACC;AACkB;AACtD;AACA;AACA;AACA;AACA,8BAA8B,qEAAW;AACzC;AACA,iBAAiB,gBAAgB;AACjC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA,mCAAmC,+CAAa;AAChD;AACA,sCAAsC,4CAAe,EAAE,EAAE,wCAAW,IAAI,EAAE,oCAAO,GAAG;AACpF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAuB;AAC3C,+BAA+B,oDAAuB;AACtD;AACA,yBAAyB,mDAAsB;AAC/C,+BAA+B,mDAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA+I;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAa;AAClC;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACyB;AACI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAe;AACxC;AACA;AACA,gEAAgE,SAAS;AACzE,iCAAiC,KAAK,KAAK;AAC3C,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAkE,cAAc;AAClG,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB,IAAI;AACpD,0BAA0B,gBAAgB;AAC1C;AACA,IAAI,6CAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B,sCAAS;AACrC,4BAA4B,sCAAS;AACrC;AACA,YAAY,0CAAa;AACzB;AACA;AACA,iBAAiB,0CAAa;AAC9B;AACA,oCAAoC,gBAAgB,IAAI;AACxD,YAAY,0CAAa;AACzB;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACO;AACP,+BAA+B,kBAAkB;AACjD;AACA,SAAS,0CAAa;AACtB;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/api/ApprovedPackagesConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ApprovedPackagesPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/api/BuildCacheConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeFile.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeManagement.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CobuildConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CommandLineConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CommonVersionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CustomTipsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/EnvironmentConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/EventHooks.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ExperimentsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/LastInstallFlag.js","webpack://@microsoft/rush-lib/./lib-esnext/api/LastLinkFlag.js","webpack://@microsoft/rush-lib/./lib-esnext/api/PackageJsonEditor.js","webpack://@microsoft/rush-lib/./lib-esnext/api/PackageNameParsers.js","webpack://@microsoft/rush-lib/./lib-esnext/api/Rush.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushConfigurationProject.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushGlobalFolder.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushInternals.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushPluginsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushProjectConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushUserConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/SaveCallbackPackageJsonEditor.js","webpack://@microsoft/rush-lib/./lib-esnext/api/Variants.js","webpack://@microsoft/rush-lib/./lib-esnext/api/VersionPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/api/VersionPolicyConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/NpmPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/PackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/PnpmPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/YarnPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/CommandLineMigrationAdvisor.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushCommandLineParser.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushPnpmCommandLine.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushPnpmCommandLineParser.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushStartupBanner.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushXCommandLine.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/AddAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseAddAndRemoveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseInstallAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseRushAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ChangeAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/CheckAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/DeployAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitDeployAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InstallAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/LinkAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ListAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/PublishAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/PurgeAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/RemoveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ScanAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/SetupAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UnlinkAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateCloudCredentialsAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpgradeInteractiveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/VersionAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/parsing/ParseParallelism.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/parsing/SelectionParameterSet.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/BaseScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/GlobalScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/PhasedScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/index.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Autoinstaller.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangeFiles.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangelogGenerator.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/CredentialCache.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/DependencyAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/DependencySpecifier.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/EventHooksManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Git.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/GitStatusParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/JsonSchemaUrls.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/LookupByPath.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/NodeJsCompatibility.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PrereleaseToken.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectChangeAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectCommandSet.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PublishGit.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PublishUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PurgeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/RepoStateFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/RushConstants.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Selection.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/SetupChecks.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ShrinkwrapFileFactory.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/StandardScriptUpdater.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Telemetry.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/UnlinkManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BasePackageManagerOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseProjectShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/CacheEntryId.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/FileSystemBuildCacheProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/ProjectBuildCache.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/getHashesForGlobsAsync.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/cobuild/CobuildLock.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/cobuild/DisjointSet.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/DeployScenarioConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/installManager/InstallHelpers.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/AsyncOperationQueue.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/CacheableOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/LegacySkipPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/NullOperationRunner.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/Operation.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationError.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationExecutionManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationExecutionRecord.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationMetadataManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationResultSummarizerPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationStateFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationStatus.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/PeriodicCallback.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/PhasedOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ProjectLogWritable.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ShellOperationRunner.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ShellOperationRunnerPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ValidateOperationsPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmProjectShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmYamlCommon.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmfileConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmfileShim.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/EnvironmentPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/GitEmailPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/PolicyValidator.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/ShrinkwrapFilePolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/GitChangedProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/NamedProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/TagProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/VersionPolicyProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/ArtifactoryConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/KeyboardLoop.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/SetupPackageRegistry.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/TerminalInput.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinder.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderCommonVersions.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderEntity.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderProject.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/yarn/YarnOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/yarn/YarnShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PhasedCommandHooks.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/AutoinstallerPluginLoader.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/BuiltInPluginLoader.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/PluginLoaderBase.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/RushSdk.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginManager.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/RushLifeCycle.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/RushSession.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/logging/Logger.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/AsyncRecycler.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/CollatedTerminalProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Npm.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/NullTerminalProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/OverlappingPathAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/PathConstants.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/SetRushLibPath.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Stopwatch.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/TarExecutable.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Utilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/WebClient.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/npmrcUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/objectUtilities.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem, NewlineKind, InternalError } from '@rushstack/node-core-library';\nimport { JsonSchemaUrls } from '../logic/JsonSchemaUrls';\nimport schemaJson from '../schemas/approved-packages.schema.json';\n/**\n * An item returned by ApprovedPackagesConfiguration\n * @public\n */\nexport class ApprovedPackagesItem {\n    /**\n     * @internal\n     */\n    constructor(packageName) {\n        /**\n         * The project categories that are allowed to use this package.\n         */\n        this.allowedCategories = new Set();\n        this.packageName = packageName;\n    }\n}\n/**\n * This represents the JSON file specified via the \"approvedPackagesFile\" option in rush.json.\n * @public\n */\nclass ApprovedPackagesConfiguration {\n    constructor(jsonFilename) {\n        this.items = [];\n        this._itemsByName = new Map();\n        this._jsonFilename = jsonFilename;\n        this.clear();\n    }\n    /**\n     * Clears all the settings, returning to an empty state.\n     */\n    clear() {\n        this._itemsByName.clear();\n        this._loadedJson = {\n            // Ensure this comes first in the key ordering\n            $schema: '',\n            packages: []\n        };\n    }\n    getItemByName(packageName) {\n        return this._itemsByName.get(packageName);\n    }\n    addOrUpdatePackage(packageName, reviewCategory) {\n        let changed = false;\n        let item = this._itemsByName.get(packageName);\n        if (!item) {\n            item = new ApprovedPackagesItem(packageName);\n            this._addItem(item);\n            changed = true;\n        }\n        if (reviewCategory && !item.allowedCategories.has(reviewCategory)) {\n            item.allowedCategories.add(reviewCategory);\n            changed = true;\n        }\n        return changed;\n    }\n    /**\n     * If the file exists, calls loadFromFile().\n     */\n    tryLoadFromFile(approvedPackagesPolicyEnabled) {\n        if (!FileSystem.exists(this._jsonFilename)) {\n            return false;\n        }\n        this.loadFromFile();\n        if (!approvedPackagesPolicyEnabled) {\n            // eslint-disable-next-line no-console\n            console.log(`Warning: Ignoring \"${path.basename(this._jsonFilename)}\" because the` +\n                ` \"approvedPackagesPolicy\" setting was not specified in rush.json`);\n        }\n        return false;\n    }\n    /**\n     * Loads the configuration data from the filename that was passed to the constructor.\n     */\n    loadFromFile() {\n        const approvedPackagesJson = JsonFile.loadAndValidate(this._jsonFilename, ApprovedPackagesConfiguration._jsonSchema);\n        this.clear();\n        for (const browserPackage of approvedPackagesJson.packages) {\n            this._addItemJson(browserPackage, this._jsonFilename);\n        }\n    }\n    /**\n     * Loads the configuration data to the filename that was passed to the constructor.\n     */\n    saveToFile() {\n        // Update the JSON structure that we already loaded, preserving any existing state\n        // (which passed schema validation).\n        // eslint-disable-next-line dot-notation\n        this._loadedJson['$schema'] = JsonSchemaUrls.approvedPackages;\n        this._loadedJson.packages = [];\n        this.items.sort((a, b) => {\n            return a.packageName.localeCompare(b.packageName);\n        });\n        for (const item of this.items) {\n            // Sort the items from the set.\n            const allowedCategories = Array.from(item.allowedCategories);\n            allowedCategories.sort();\n            const itemJson = {\n                name: item.packageName,\n                allowedCategories: allowedCategories\n            };\n            this._loadedJson.packages.push(itemJson);\n        }\n        // Save the file\n        let body = JsonFile.stringify(this._loadedJson);\n        // Unindent the allowedCategories array to improve readability\n        body = body.replace(/(\"allowedCategories\": +\\[)([^\\]]+)/g, (substring, ...args) => {\n            return args[0] + args[1].replace(/\\s+/g, ' ');\n        });\n        // Add a header\n        body = '// DO NOT ADD COMMENTS IN THIS FILE.  They will be lost when the Rush tool resaves it.\\n' + body;\n        FileSystem.writeFile(this._jsonFilename, body, {\n            convertLineEndings: NewlineKind.CrLf\n        });\n    }\n    /**\n     * Helper function only used by the constructor when loading the file.\n     */\n    _addItemJson(itemJson, jsonFilename) {\n        if (this._itemsByName.has(itemJson.name)) {\n            throw new Error(`Error loading package review file ${jsonFilename}:\\n` +\n                ` the name \"${itemJson.name}\" appears more than once`);\n        }\n        const item = new ApprovedPackagesItem(itemJson.name);\n        if (itemJson.allowedCategories) {\n            for (const allowedCategory of itemJson.allowedCategories) {\n                item.allowedCategories.add(allowedCategory);\n            }\n        }\n        this._addItem(item);\n    }\n    /**\n     * Helper function that adds an already created ApprovedPackagesItem to the\n     * list and set.\n     */\n    _addItem(item) {\n        if (this._itemsByName.has(item.packageName)) {\n            throw new InternalError('Duplicate key');\n        }\n        this.items.push(item);\n        this._itemsByName.set(item.packageName, item);\n    }\n}\nApprovedPackagesConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { ApprovedPackagesConfiguration };\n//# sourceMappingURL=ApprovedPackagesConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { ApprovedPackagesConfiguration } from './ApprovedPackagesConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * This is a helper object for RushConfiguration.\n * It exposes the \"approvedPackagesPolicy\" feature from rush.json.\n * @public\n */\nexport class ApprovedPackagesPolicy {\n    /** @internal */\n    constructor(rushConfiguration, rushConfigurationJson) {\n        const approvedPackagesPolicy = rushConfigurationJson.approvedPackagesPolicy || {};\n        this.enabled = !!rushConfigurationJson.approvedPackagesPolicy;\n        this.ignoredNpmScopes = new Set(approvedPackagesPolicy.ignoredNpmScopes);\n        this.reviewCategories = new Set(approvedPackagesPolicy.reviewCategories);\n        if (this.enabled) {\n            if (!this.reviewCategories.size) {\n                throw new Error(`The \"approvedPackagesPolicy\" feature is enabled rush.json, but the reviewCategories` +\n                    ` list is not configured.`);\n            }\n        }\n        // Load browser-approved-packages.json\n        const browserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants.browserApprovedPackagesFilename);\n        this.browserApprovedPackages = new ApprovedPackagesConfiguration(browserApprovedPackagesPath);\n        this.browserApprovedPackages.tryLoadFromFile(this.enabled);\n        // Load nonbrowser-approved-packages.json\n        const nonbrowserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants.nonbrowserApprovedPackagesFilename);\n        this.nonbrowserApprovedPackages = new ApprovedPackagesConfiguration(nonbrowserApprovedPackagesPath);\n        this.nonbrowserApprovedPackages.tryLoadFromFile(this.enabled);\n    }\n}\n//# sourceMappingURL=ApprovedPackagesPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { FileSystemBuildCacheProvider } from '../logic/buildCache/FileSystemBuildCacheProvider';\nimport { RushConstants } from '../logic/RushConstants';\nimport { RushUserConfiguration } from './RushUserConfiguration';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { CacheEntryId } from '../logic/buildCache/CacheEntryId';\nimport schemaJson from '../schemas/build-cache.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/build-cache.json\" config file.\n * This file provides configuration options for cached project build output.\n * @beta\n */\nclass BuildCacheConfiguration {\n    constructor({ getCacheEntryId, buildCacheJson, rushUserConfiguration, rushConfiguration, cloudCacheProvider }) {\n        var _a;\n        this.buildCacheEnabled = (_a = EnvironmentConfiguration.buildCacheEnabled) !== null && _a !== void 0 ? _a : buildCacheJson.buildCacheEnabled;\n        this.cacheWriteEnabled =\n            !!this.buildCacheEnabled && EnvironmentConfiguration.buildCacheWriteAllowed !== false;\n        this.getCacheEntryId = getCacheEntryId;\n        this.localCacheProvider = new FileSystemBuildCacheProvider({\n            rushUserConfiguration: rushUserConfiguration,\n            rushConfiguration: rushConfiguration\n        });\n        this.cloudCacheProvider = cloudCacheProvider;\n    }\n    /**\n     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.\n     * If the file has not been created yet, then undefined is returned.\n     */\n    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);\n        if (!FileSystem.exists(jsonFilePath)) {\n            return undefined;\n        }\n        return await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n    }\n    /**\n     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.\n     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.\n     */\n    static async loadAndRequireEnabledAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);\n        if (!FileSystem.exists(jsonFilePath)) {\n            terminal.writeErrorLine(`The build cache feature is not enabled. This config file is missing:\\n` + jsonFilePath);\n            terminal.writeLine(`\\nThe Rush website documentation has instructions for enabling the build cache.`);\n            throw new AlreadyReportedError();\n        }\n        const buildCacheConfiguration = await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n        if (!buildCacheConfiguration.buildCacheEnabled) {\n            terminal.writeErrorLine(`The build cache feature is not enabled. You can enable it by editing this config file:\\n` +\n                jsonFilePath);\n            throw new AlreadyReportedError();\n        }\n        return buildCacheConfiguration;\n    }\n    /**\n     * Gets the absolute path to the build-cache.json file in the specified rush workspace.\n     */\n    static getBuildCacheConfigFilePath(rushConfiguration) {\n        return path.resolve(rushConfiguration.commonRushConfigFolder, RushConstants.buildCacheFilename);\n    }\n    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {\n        const buildCacheJson = await JsonFile.loadAndValidateAsync(jsonFilePath, BuildCacheConfiguration._jsonSchema);\n        const rushUserConfiguration = await RushUserConfiguration.initializeAsync();\n        let getCacheEntryId;\n        try {\n            getCacheEntryId = CacheEntryId.parsePattern(buildCacheJson.cacheEntryNamePattern);\n        }\n        catch (e) {\n            terminal.writeErrorLine(`Error parsing cache entry name pattern \"${buildCacheJson.cacheEntryNamePattern}\": ${e}`);\n            throw new AlreadyReportedError();\n        }\n        let cloudCacheProvider;\n        // Don't configure a cloud cache provider if local-only\n        if (buildCacheJson.cacheProvider !== 'local-only') {\n            const cloudCacheProviderFactory = rushSession.getCloudBuildCacheProviderFactory(buildCacheJson.cacheProvider);\n            if (!cloudCacheProviderFactory) {\n                throw new Error(`Unexpected cache provider: ${buildCacheJson.cacheProvider}`);\n            }\n            cloudCacheProvider = await cloudCacheProviderFactory(buildCacheJson);\n        }\n        return new BuildCacheConfiguration({\n            buildCacheJson,\n            getCacheEntryId,\n            rushConfiguration,\n            rushUserConfiguration,\n            rushSession,\n            cloudCacheProvider\n        });\n    }\n}\nBuildCacheConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { BuildCacheConfiguration };\n//# sourceMappingURL=BuildCacheConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile } from '@rushstack/node-core-library';\nimport { Git } from '../logic/Git';\n/**\n * This class represents a single change file.\n */\nexport class ChangeFile {\n    /**\n     * @internal\n     */\n    constructor(changeFileData, rushConfiguration) {\n        if (!changeFileData) {\n            throw new Error(`changeFileData does not have a value`);\n        }\n        if (!rushConfiguration) {\n            throw new Error(`rushConfiguration does not have a value`);\n        }\n        this._changeFileData = changeFileData;\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Adds a change entry into the change file\n     * @param data - change information\n     */\n    addChange(data) {\n        this._changeFileData.changes.push(data);\n    }\n    /**\n     * Gets all the change entries about the specified package from the change file.\n     * @param packageName - package name\n     */\n    getChanges(packageName) {\n        const changes = [];\n        for (const info of this._changeFileData.changes) {\n            if (info.packageName === packageName) {\n                changes.push(info);\n            }\n        }\n        return changes;\n    }\n    /**\n     * Writes the change file to disk in sync mode.\n     * Returns the file path.\n     * @returns the path to the file that was written (based on generatePath())\n     */\n    writeSync() {\n        const filePath = this.generatePath();\n        JsonFile.save(this._changeFileData, filePath, {\n            ensureFolderExists: true\n        });\n        return filePath;\n    }\n    /**\n     * Generates a file path for storing the change file to disk.\n     * Note that this value may change if called twice in a row,\n     * as it is partially based on the current date/time.\n     */\n    generatePath() {\n        let branch = undefined;\n        const git = new Git(this._rushConfiguration);\n        const repoInfo = git.getGitInfo();\n        branch = repoInfo && repoInfo.branch;\n        if (!branch) {\n            // eslint-disable-next-line no-console\n            console.log('Could not automatically detect git branch name, using timestamp instead.');\n        }\n        // example filename: yourbranchname_2017-05-01-20-20.json\n        const filename = branch\n            ? this._escapeFilename(`${branch}_${this._getTimestamp()}.json`)\n            : `${this._getTimestamp()}.json`;\n        const filePath = path.join(this._rushConfiguration.changesFolder, ...this._changeFileData.packageName.split('/'), filename);\n        return filePath;\n    }\n    /**\n     * Gets the current time, formatted as YYYY-MM-DD-HH-MM\n     * Optionally will include seconds\n     */\n    _getTimestamp(useSeconds = false) {\n        // Create a date string with the current time\n        // dateString === \"2016-10-19T22:47:49.606Z\"\n        const dateString = new Date().toJSON();\n        // Parse out 2 capture groups, the date and the time\n        const dateParseRegex = /([0-9]{4}-[0-9]{2}-[0-9]{2}).*([0-9]{2}:[0-9]{2}:[0-9]{2})/;\n        // matches[1] === \"2016-10-19\"\n        // matches[2] === \"22:47:49\"\n        const matches = dateString.match(dateParseRegex);\n        if (matches) {\n            // formattedDate === \"2016-10-19\"\n            const formattedDate = matches[1];\n            let formattedTime;\n            if (useSeconds) {\n                // formattedTime === \"22-47-49\"\n                formattedTime = matches[2].replace(':', '-');\n            }\n            else {\n                // formattedTime === \"22-47\"\n                const timeParts = matches[2].split(':');\n                formattedTime = `${timeParts[0]}-${timeParts[1]}`;\n            }\n            return `${formattedDate}-${formattedTime}`;\n        }\n        return undefined;\n    }\n    _escapeFilename(filename, replacer = '-') {\n        // Removes / ? < > \\ : * | \", really anything that isn't a letter, number, '.' '_' or '-'\n        const badCharacters = /[^a-zA-Z0-9._-]/g;\n        return filename.replace(badCharacters, replacer);\n    }\n}\n//# sourceMappingURL=ChangeFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Represents all of the types of change requests.\n */\nexport var ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"none\"] = 0] = \"none\";\n    ChangeType[ChangeType[\"dependency\"] = 1] = \"dependency\";\n    ChangeType[ChangeType[\"hotfix\"] = 2] = \"hotfix\";\n    ChangeType[ChangeType[\"patch\"] = 3] = \"patch\";\n    ChangeType[ChangeType[\"minor\"] = 4] = \"minor\";\n    ChangeType[ChangeType[\"major\"] = 5] = \"major\";\n})(ChangeType || (ChangeType = {}));\n//# sourceMappingURL=ChangeManagement.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ChangeFile } from './ChangeFile';\n/**\n * A class that helps with programmatically interacting with Rush's change files.\n * @public\n */\nexport class ChangeManager {\n    /**\n     * Creates a change file that has a 'none' type.\n     * @param rushConfiguration - The rush configuration we are working with\n     * @param projectName - The name of the project for which to create a change file\n     * @param emailAddress - The email address which should be associated with this change\n     * @returns the path to the file that was created, or undefined if no file was written\n     */\n    static createEmptyChangeFiles(rushConfiguration, projectName, emailAddress) {\n        const projectInfo = rushConfiguration.getProjectByName(projectName);\n        if (projectInfo && projectInfo.shouldPublish) {\n            const changefile = {\n                // eslint-disable-line @typescript-eslint/no-explicit-any\n                changes: [\n                    {\n                        comment: '',\n                        packageName: projectName,\n                        type: 'none'\n                    }\n                ],\n                packageName: projectName,\n                email: emailAddress\n            };\n            return new ChangeFile(changefile, rushConfiguration).writeSync();\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=ChangeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/cobuild.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/cobuild.json\" config file.\n * This file provides configuration options for the Rush Cobuild feature.\n * @beta\n */\nclass CobuildConfiguration {\n    constructor(options) {\n        var _a;\n        const { cobuildJson, cobuildLockProviderFactory } = options;\n        this.cobuildContextId = EnvironmentConfiguration.cobuildContextId;\n        this.cobuildFeatureEnabled = this.cobuildContextId ? cobuildJson.cobuildFeatureEnabled : false;\n        this.cobuildRunnerId = EnvironmentConfiguration.cobuildRunnerId || uuidv4();\n        this.cobuildLeafProjectLogOnlyAllowed =\n            (_a = EnvironmentConfiguration.cobuildLeafProjectLogOnlyAllowed) !== null && _a !== void 0 ? _a : false;\n        this._cobuildLockProviderFactory = cobuildLockProviderFactory;\n        this._cobuildJson = cobuildJson;\n    }\n    /**\n     * Attempts to load the cobuild.json data from the standard file path `common/config/rush/cobuild.json`.\n     * If the file has not been created yet, then undefined is returned.\n     */\n    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = CobuildConfiguration.getCobuildConfigFilePath(rushConfiguration);\n        try {\n            return await CobuildConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n        }\n        catch (err) {\n            if (!FileSystem.isNotExistError(err)) {\n                throw err;\n            }\n        }\n    }\n    static getCobuildConfigFilePath(rushConfiguration) {\n        return `${rushConfiguration.commonRushConfigFolder}/${RushConstants.cobuildFilename}`;\n    }\n    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {\n        let cobuildJson;\n        try {\n            cobuildJson = await JsonFile.loadAndValidateAsync(jsonFilePath, CobuildConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (FileSystem.isNotExistError(e)) {\n                return undefined;\n            }\n            throw e;\n        }\n        if (!(cobuildJson === null || cobuildJson === void 0 ? void 0 : cobuildJson.cobuildFeatureEnabled)) {\n            return undefined;\n        }\n        const cobuildLockProviderFactory = rushSession.getCobuildLockProviderFactory(cobuildJson.cobuildLockProvider);\n        if (!cobuildLockProviderFactory) {\n            throw new Error(`Unexpected cobuild lock provider: ${cobuildJson.cobuildLockProvider}`);\n        }\n        return new CobuildConfiguration({\n            cobuildJson,\n            rushConfiguration,\n            rushSession,\n            cobuildLockProviderFactory\n        });\n    }\n    async createLockProviderAsync(terminal) {\n        if (this.cobuildFeatureEnabled) {\n            terminal.writeLine(`Running cobuild (runner ${this.cobuildContextId}/${this.cobuildRunnerId})`);\n            const cobuildLockProvider = await this._cobuildLockProviderFactory(this._cobuildJson);\n            this._cobuildLockProvider = cobuildLockProvider;\n            await this._cobuildLockProvider.connectAsync();\n        }\n    }\n    async destroyLockProviderAsync() {\n        var _a;\n        if (this.cobuildFeatureEnabled) {\n            await ((_a = this._cobuildLockProvider) === null || _a === void 0 ? void 0 : _a.disconnectAsync());\n        }\n    }\n    getCobuildLockProvider() {\n        if (!this._cobuildLockProvider) {\n            throw new Error(`Cobuild lock provider has not been created`);\n        }\n        return this._cobuildLockProvider;\n    }\n}\nCobuildConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { CobuildConfiguration };\n//# sourceMappingURL=CobuildConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/command-line.schema.json';\nconst DEFAULT_BUILD_COMMAND_JSON = {\n    commandKind: RushConstants.bulkCommandKind,\n    name: RushConstants.buildCommandName,\n    summary: \"Build all projects that haven't been built, or have changed since they were last built.\",\n    description: 'This command is similar to \"rush rebuild\", except that \"rush build\" performs' +\n        ' an incremental build. In other words, it only builds projects whose source files have changed' +\n        ' since the last successful build. The analysis requires a Git working tree, and only considers' +\n        ' source files that are tracked by Git and whose path is under the project folder. (For more details' +\n        ' about this algorithm, see the documentation for the \"package-deps-hash\" NPM package.) The incremental' +\n        ' build state is tracked in a per-project folder called \".rush/temp\" which should NOT be added to Git. The' +\n        ' build command is tracked by the \"arguments\" field in the \"package-deps_build.json\" file contained' +\n        ' therein; a full rebuild is forced whenever the command has changed (e.g. \"--production\" or not).',\n    safeForSimultaneousRushProcesses: false,\n    enableParallelism: true,\n    incremental: true\n};\nconst DEFAULT_REBUILD_COMMAND_JSON = {\n    commandKind: RushConstants.bulkCommandKind,\n    name: RushConstants.rebuildCommandName,\n    summary: 'Clean and rebuild the entire set of projects.',\n    description: 'This command assumes that the package.json file for each project contains' +\n        ' a \"scripts\" entry for \"npm run build\" that performs a full clean build.' +\n        ' Rush invokes this script to build each project that is registered in rush.json.' +\n        ' Projects are built in parallel where possible, but always respecting the dependency' +\n        ' graph for locally linked projects.  The number of simultaneous processes will be' +\n        ' based on the number of machine cores unless overridden by the --parallelism flag.' +\n        ' (For an incremental build, see \"rush build\" instead of \"rush rebuild\".)',\n    safeForSimultaneousRushProcesses: false,\n    enableParallelism: true,\n    incremental: false\n};\n/**\n * Custom Commands and Options for the Rush Command Line\n */\nclass CommandLineConfiguration {\n    /**\n     * Use CommandLineConfiguration.loadFromFile()\n     *\n     * @internal\n     */\n    constructor(commandLineJson, options = {}) {\n        var _a, _b, _c;\n        this.commands = new Map();\n        this.phases = new Map();\n        this.parameters = [];\n        /**\n         * These path will be prepended to the PATH environment variable\n         */\n        this.additionalPathFolders = [];\n        /**\n         * A map of bulk command names to their corresponding synthetic phase identifiers\n         */\n        this._syntheticPhasesByTranslatedBulkCommandName = new Map();\n        const phasesJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.phases;\n        if (phasesJson) {\n            const phaseNameRegexp = new RegExp(`^${RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`);\n            for (const phase of phasesJson) {\n                if (this.phases.has(phase.name)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\" is specified ` +\n                        'more than once.');\n                }\n                if (!phase.name.match(phaseNameRegexp)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s name ` +\n                        'is not a valid phase name. Phase names must begin with the ' +\n                        `required prefix \"${RushConstants.phaseNamePrefix}\" followed by a name containing ` +\n                        'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +\n                        'must not end with a hyphen.');\n                }\n                if (phase.ignoreMissingScript !== undefined && phase.missingScriptBehavior !== undefined) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s defines ` +\n                        'both \"ignoreMissingScript\" and \"missingScriptBehavior\". If using the \"missingScriptBehavior\", ' +\n                        `remove \"ignoreMissingScript\", since it subsumes the functionality.`);\n                }\n                // This is a completely fresh object. Avoid use of the `...` operator in its construction\n                // to guarantee monomorphism.\n                const processedPhase = {\n                    name: phase.name,\n                    isSynthetic: false,\n                    logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(phase.name),\n                    associatedParameters: new Set(),\n                    dependencies: {\n                        self: new Set(),\n                        upstream: new Set()\n                    },\n                    missingScriptBehavior: (_a = phase.missingScriptBehavior) !== null && _a !== void 0 ? _a : (phase.ignoreMissingScript ? 'log' : 'error'),\n                    allowWarningsOnSuccess: !!phase.allowWarningsOnSuccess\n                };\n                this.phases.set(phase.name, processedPhase);\n            }\n            // Resolve phase names to the underlying objects\n            for (const rawPhase of phasesJson) {\n                // The named phase not existing was already handled in the loop above\n                const phase = this.phases.get(rawPhase.name);\n                const selfDependencies = (_b = rawPhase.dependencies) === null || _b === void 0 ? void 0 : _b.self;\n                const upstreamDependencies = (_c = rawPhase.dependencies) === null || _c === void 0 ? void 0 : _c.upstream;\n                if (selfDependencies) {\n                    for (const dependencyName of selfDependencies) {\n                        const dependency = this.phases.get(dependencyName);\n                        if (!dependency) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", the self ` +\n                                `dependency phase \"${dependencyName}\" does not exist.`);\n                        }\n                        phase.dependencies.self.add(dependency);\n                    }\n                }\n                if (upstreamDependencies) {\n                    for (const dependencyName of upstreamDependencies) {\n                        const dependency = this.phases.get(dependencyName);\n                        if (!dependency) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", ` +\n                                `the upstream dependency phase \"${dependencyName}\" does not exist.`);\n                        }\n                        phase.dependencies.upstream.add(dependency);\n                    }\n                }\n            }\n            // Do the recursive stuff after the dependencies have been converted\n            const safePhases = new Set();\n            const cycleDetector = new Set();\n            for (const phase of this.phases.values()) {\n                this._checkForPhaseSelfCycles(phase, cycleDetector, safePhases);\n            }\n        }\n        const commandsJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands;\n        let buildCommandPhases;\n        let buildCommandOriginalPhases;\n        if (commandsJson) {\n            for (const command of commandsJson) {\n                if (this.commands.has(command.name)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the command \"${command.name}\" is specified ` +\n                        'more than once.');\n                }\n                let normalizedCommand;\n                switch (command.commandKind) {\n                    case RushConstants.phasedCommandKind: {\n                        const originalPhases = new Set();\n                        const commandPhases = new Set();\n                        const watchPhases = new Set();\n                        normalizedCommand = Object.assign(Object.assign({}, command), { isSynthetic: false, associatedParameters: new Set(), originalPhases, phases: commandPhases, watchPhases, alwaysWatch: false, alwaysInstall: undefined });\n                        for (const phaseName of command.phases) {\n                            const phase = this.phases.get(phaseName);\n                            if (!phase) {\n                                throw new Error(`In ${RushConstants.commandLineFilename}, in the \"phases\" property of the ` +\n                                    `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`);\n                            }\n                            originalPhases.add(phase);\n                            commandPhases.add(phase);\n                        }\n                        // Apply implicit phase dependency expansion\n                        // The equivalent of the \"--to\" operator used for projects\n                        // Appending to the set while iterating it accomplishes a full breadth-first search\n                        for (const phase of commandPhases) {\n                            for (const dependency of phase.dependencies.self) {\n                                commandPhases.add(dependency);\n                            }\n                            for (const dependency of phase.dependencies.upstream) {\n                                commandPhases.add(dependency);\n                            }\n                        }\n                        const { watchOptions, installOptions } = command;\n                        if (watchOptions) {\n                            normalizedCommand.alwaysWatch = watchOptions.alwaysWatch;\n                            normalizedCommand.watchDebounceMs = watchOptions.debounceMs;\n                            // No implicit phase dependency expansion for watch mode.\n                            for (const phaseName of watchOptions.watchPhases) {\n                                const phase = this.phases.get(phaseName);\n                                if (!phase) {\n                                    throw new Error(`In ${RushConstants.commandLineFilename}, in the \"watchPhases\" property of the ` +\n                                        `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`);\n                                }\n                                watchPhases.add(phase);\n                            }\n                        }\n                        if (installOptions) {\n                            normalizedCommand.alwaysInstall = installOptions.alwaysInstall;\n                        }\n                        break;\n                    }\n                    case RushConstants.globalCommandKind: {\n                        normalizedCommand = Object.assign(Object.assign({}, command), { associatedParameters: new Set() });\n                        break;\n                    }\n                    case RushConstants.bulkCommandKind: {\n                        // Translate the bulk command into a phased command\n                        normalizedCommand = this._translateBulkCommandToPhasedCommand(command);\n                        break;\n                    }\n                }\n                if (normalizedCommand.name === RushConstants.buildCommandName ||\n                    normalizedCommand.name === RushConstants.rebuildCommandName) {\n                    if (normalizedCommand.commandKind === RushConstants.globalCommandKind) {\n                        throw new Error(`${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                            `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                            `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`);\n                    }\n                    else if (command.safeForSimultaneousRushProcesses) {\n                        throw new Error(`${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                            `\"safeForSimultaneousRushProcesses=true\". This configuration is not supported for \"${normalizedCommand.name}\".`);\n                    }\n                    else if (normalizedCommand.name === RushConstants.buildCommandName) {\n                        // Record the build command phases in case we need to construct a synthetic \"rebuild\" command\n                        buildCommandPhases = normalizedCommand.phases;\n                        buildCommandOriginalPhases = normalizedCommand.originalPhases;\n                    }\n                }\n                this.commands.set(normalizedCommand.name, normalizedCommand);\n            }\n        }\n        if (!options.doNotIncludeDefaultBuildCommands) {\n            let buildCommand = this.commands.get(RushConstants.buildCommandName);\n            if (!buildCommand) {\n                // If the build command was not specified in the config file, add the default build command\n                buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);\n                buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;\n                buildCommandPhases = buildCommand.phases;\n                buildCommandOriginalPhases = buildCommand.originalPhases;\n                this.commands.set(buildCommand.name, buildCommand);\n            }\n            if (!this.commands.has(RushConstants.rebuildCommandName)) {\n                // If a rebuild command was not specified in the config file, add the default rebuild command\n                if (!buildCommandPhases || !buildCommandOriginalPhases) {\n                    throw new Error(`Phases for the \"${RushConstants.buildCommandName}\" were not found.`);\n                }\n                const rebuildCommand = Object.assign(Object.assign({}, DEFAULT_REBUILD_COMMAND_JSON), { commandKind: RushConstants.phasedCommandKind, isSynthetic: true, phases: buildCommandPhases, disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache, associatedParameters: buildCommand.associatedParameters, originalPhases: buildCommandOriginalPhases, watchPhases: new Set(), alwaysWatch: false, alwaysInstall: undefined });\n                this.commands.set(rebuildCommand.name, rebuildCommand);\n            }\n        }\n        const parametersJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.parameters;\n        if (parametersJson) {\n            for (const parameter of parametersJson) {\n                const normalizedParameter = Object.assign(Object.assign({}, parameter), { associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [], associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : [] });\n                this.parameters.push(normalizedParameter);\n                // Do some basic validation\n                switch (normalizedParameter.parameterKind) {\n                    case 'choice': {\n                        const alternativeNames = normalizedParameter.alternatives.map((x) => x.name);\n                        if (normalizedParameter.defaultValue &&\n                            alternativeNames.indexOf(normalizedParameter.defaultValue) < 0) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, the parameter \"${normalizedParameter.longName}\",` +\n                                ` specifies a default value \"${normalizedParameter.defaultValue}\"` +\n                                ` which is not one of the defined alternatives: \"${alternativeNames.toString()}\"`);\n                        }\n                        break;\n                    }\n                }\n                let parameterHasAssociatedCommands = false;\n                if (normalizedParameter.associatedCommands) {\n                    for (const associatedCommandName of normalizedParameter.associatedCommands) {\n                        const syntheticPhase = this._syntheticPhasesByTranslatedBulkCommandName.get(associatedCommandName);\n                        if (syntheticPhase) {\n                            // If this parameter was associated with a bulk command, include the association\n                            // with the synthetic phase\n                            normalizedParameter.associatedPhases.push(syntheticPhase.name);\n                        }\n                        const associatedCommand = this.commands.get(associatedCommandName);\n                        if (!associatedCommand) {\n                            throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                                `that is associated with a command \"${associatedCommandName}\" that does not exist or does ` +\n                                'not support custom parameters.');\n                        }\n                        else {\n                            associatedCommand.associatedParameters.add(normalizedParameter);\n                            parameterHasAssociatedCommands = true;\n                        }\n                    }\n                }\n                if (normalizedParameter.associatedPhases) {\n                    for (const associatedPhaseName of normalizedParameter.associatedPhases) {\n                        const associatedPhase = this.phases.get(associatedPhaseName);\n                        if (!associatedPhase) {\n                            throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                                `that is associated with a phase \"${associatedPhaseName}\" that does not exist.`);\n                        }\n                    }\n                }\n                if (!parameterHasAssociatedCommands) {\n                    throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\"` +\n                        ` that lists no associated commands.`);\n                }\n                // In the presence of plugins, there is utility to defining parameters that are associated with a phased\n                // command but no phases. Don't enforce that a parameter is associated with at least one phase.\n            }\n        }\n    }\n    /**\n     * Performs a depth-first search to detect cycles in the directed graph of phase \"self\" dependencies.\n     *\n     * @param phase The phase node currently being checked\n     * @param phasesInPath The current path from the start node to `phase`\n     * @param cycleFreePhases Phases that have already been fully walked and confirmed to not be in any cycles\n     */\n    _checkForPhaseSelfCycles(phase, phasesInPath, cycleFreePhases) {\n        if (cycleFreePhases.has(phase)) {\n            // phase is known to not be reachable from itself, i.e. not in a cycle. Skip.\n            return;\n        }\n        for (const dependency of phase.dependencies.self) {\n            if (phasesInPath.has(dependency)) {\n                throw new Error(`In ${RushConstants.commandLineFilename}, there exists a cycle within the ` +\n                    `set of ${dependency.name} dependencies: ${Array.from(phasesInPath, (phaseInPath) => phaseInPath.name).join(', ')}`);\n            }\n            else {\n                phasesInPath.add(dependency);\n                this._checkForPhaseSelfCycles(dependency, phasesInPath, cycleFreePhases);\n                phasesInPath.delete(dependency);\n            }\n        }\n        // phase is not reachable from itself, mark for skipping\n        cycleFreePhases.add(phase);\n    }\n    /**\n     * Load the command-line.json configuration file from the specified path. Note that this\n     * does not include the default build settings. This option is intended to be used to load\n     * command-line.json files from plugins. To load a common/config/rush/command-line.json file,\n     * use {@see loadFromFileOrDefault} instead.\n     *\n     * If the file does not exist, this function returns `undefined`\n     */\n    static tryLoadFromFile(jsonFilePath) {\n        let commandLineJson;\n        try {\n            commandLineJson = JsonFile.loadAndValidate(jsonFilePath, CommandLineConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        if (commandLineJson) {\n            return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: true });\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Loads the configuration from the specified file and applies any omitted default build\n     * settings.  If the file does not exist, then a default instance is returned.\n     * If the file contains errors, then an exception is thrown.\n     */\n    static loadFromFileOrDefault(jsonFilePath) {\n        let commandLineJson = undefined;\n        if (jsonFilePath) {\n            try {\n                commandLineJson = JsonFile.load(jsonFilePath);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n            // merge commands specified in command-line.json and default (re)build settings\n            // Ensure both build commands are included and preserve any other commands specified\n            if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands) {\n                for (let i = 0; i < commandLineJson.commands.length; i++) {\n                    const command = commandLineJson.commands[i];\n                    // Determine if we have a set of default parameters\n                    let commandDefaultDefinition = {};\n                    switch (command.commandKind) {\n                        case RushConstants.phasedCommandKind:\n                        case RushConstants.bulkCommandKind: {\n                            switch (command.name) {\n                                case RushConstants.buildCommandName: {\n                                    commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;\n                                    break;\n                                }\n                                case RushConstants.rebuildCommandName: {\n                                    commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;\n                                    break;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    // Merge the default parameters into the repo-specified parameters\n                    commandLineJson.commands[i] = Object.assign(Object.assign({}, commandDefaultDefinition), command);\n                }\n                CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilePath);\n            }\n        }\n        return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: false });\n    }\n    prependAdditionalPathFolder(pathFolder) {\n        this.additionalPathFolders.unshift(pathFolder);\n    }\n    /**\n     * This function replaces colons (\":\") with underscores (\"_\").\n     *\n     * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.\n     * Replacing colons with underscores produces a filesystem-safe name.\n     */\n    _normalizeNameForLogFilenameIdentifiers(name) {\n        return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe\n    }\n    _translateBulkCommandToPhasedCommand(command) {\n        const phaseName = command.name;\n        const phase = {\n            name: phaseName,\n            isSynthetic: true,\n            logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(command.name),\n            associatedParameters: new Set(),\n            dependencies: {\n                self: new Set(),\n                upstream: new Set()\n            },\n            missingScriptBehavior: command.ignoreMissingScript ? 'log' : 'error',\n            allowWarningsOnSuccess: !!command.allowWarningsInSuccessfulBuild,\n            shellCommand: command.shellCommand\n        };\n        if (!command.ignoreDependencyOrder) {\n            phase.dependencies.upstream.add(phase);\n        }\n        this.phases.set(phaseName, phase);\n        this._syntheticPhasesByTranslatedBulkCommandName.set(command.name, phase);\n        const phases = new Set([phase]);\n        const translatedCommand = Object.assign(Object.assign({}, command), { commandKind: 'phased', isSynthetic: true, associatedParameters: new Set(), phases, originalPhases: phases, \n            // Bulk commands used the same phases for watch as for regular execution. Preserve behavior.\n            watchPhases: command.watchForChanges ? phases : new Set(), alwaysWatch: !!command.watchForChanges, alwaysInstall: undefined });\n        return translatedCommand;\n    }\n}\nCommandLineConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { CommandLineConfiguration };\n//# sourceMappingURL=CommandLineConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport crypto from 'crypto';\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, MapExtensions, ProtectableMap, FileSystem, Sort } from '@rushstack/node-core-library';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { JsonSchemaUrls } from '../logic/JsonSchemaUrls';\nimport schemaJson from '../schemas/common-versions.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/common-versions.json\" config file.\n * This config file stores dependency version information that affects all projects in the repo.\n * @public\n */\nclass CommonVersionsConfiguration {\n    constructor(commonVersionsJson, filePath) {\n        this._modified = false;\n        this._preferredVersions = new ProtectableMap({\n            onSet: this._onSetPreferredVersions.bind(this)\n        });\n        this.preferredVersions = this._preferredVersions.protectedView;\n        if (commonVersionsJson && commonVersionsJson.implicitlyPreferredVersions !== undefined) {\n            this.implicitlyPreferredVersions = commonVersionsJson.implicitlyPreferredVersions;\n        }\n        else {\n            this.implicitlyPreferredVersions = undefined;\n        }\n        this._allowedAlternativeVersions = new ProtectableMap({\n            onSet: this._onSetAllowedAlternativeVersions.bind(this)\n        });\n        this.allowedAlternativeVersions = this._allowedAlternativeVersions.protectedView;\n        if (commonVersionsJson) {\n            try {\n                CommonVersionsConfiguration._deserializeTable(this.preferredVersions, commonVersionsJson.preferredVersions);\n                CommonVersionsConfiguration._deserializeTable(this.allowedAlternativeVersions, commonVersionsJson.allowedAlternativeVersions);\n            }\n            catch (e) {\n                throw new Error(`Error loading \"${path.basename(filePath)}\": ${e.message}`);\n            }\n        }\n        this.filePath = filePath;\n    }\n    /**\n     * Loads the common-versions.json data from the specified file path.\n     * If the file has not been created yet, then an empty object is returned.\n     */\n    static loadFromFile(jsonFilename) {\n        let commonVersionsJson = undefined;\n        if (FileSystem.exists(jsonFilename)) {\n            commonVersionsJson = JsonFile.loadAndValidate(jsonFilename, CommonVersionsConfiguration._jsonSchema);\n        }\n        return new CommonVersionsConfiguration(commonVersionsJson, jsonFilename);\n    }\n    static _deserializeTable(map, object) {\n        if (object) {\n            for (const [key, value] of Object.entries(object)) {\n                map.set(key, value);\n            }\n        }\n    }\n    static _serializeTable(map) {\n        const table = {};\n        const keys = [...map.keys()];\n        keys.sort();\n        for (const key of keys) {\n            table[key] = map.get(key);\n        }\n        return table;\n    }\n    /**\n     * Get a sha1 hash of the preferred versions.\n     */\n    getPreferredVersionsHash() {\n        // Sort so that the hash is stable\n        const orderedPreferredVersions = new Map(this._preferredVersions.protectedView);\n        Sort.sortMapKeys(orderedPreferredVersions);\n        // JSON.stringify does not support maps, so we need to convert to an object first\n        const preferredVersionsObj = MapExtensions.toObject(orderedPreferredVersions);\n        return crypto.createHash('sha1').update(JSON.stringify(preferredVersionsObj)).digest('hex');\n    }\n    /**\n     * Writes the \"common-versions.json\" file to disk, using the filename that was passed to loadFromFile().\n     */\n    save() {\n        if (this._modified) {\n            JsonFile.save(this._serialize(), this.filePath, { updateExistingFile: true });\n            this._modified = false;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns preferredVersions.\n     */\n    getAllPreferredVersions() {\n        const allPreferredVersions = new Map();\n        MapExtensions.mergeFromMap(allPreferredVersions, this.preferredVersions);\n        return allPreferredVersions;\n    }\n    _onSetPreferredVersions(source, key, value) {\n        PackageNameParsers.permissive.validate(key);\n        this._modified = true;\n        return value;\n    }\n    _onSetAllowedAlternativeVersions(source, key, value) {\n        PackageNameParsers.permissive.validate(key);\n        this._modified = true;\n        return value;\n    }\n    _serialize() {\n        const result = {\n            $schema: JsonSchemaUrls.commonVersions\n        };\n        if (this._preferredVersions.size) {\n            result.preferredVersions = CommonVersionsConfiguration._serializeTable(this.preferredVersions);\n        }\n        if (this._allowedAlternativeVersions.size) {\n            result.allowedAlternativeVersions = CommonVersionsConfiguration._serializeTable(this.allowedAlternativeVersions);\n        }\n        return result;\n    }\n}\nCommonVersionsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { CommonVersionsConfiguration };\n//# sourceMappingURL=CommonVersionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport schemaJson from '../schemas/custom-tips.schema.json';\n/**\n * An identifier representing a Rush message that can be customized by\n * defining a custom tip in `common/config/rush/custom-tips.json`.\n * @remarks\n * Custom tip ids always start with the `TIP_` prefix.\n *\n * @privateRemarks\n * Events from the Rush process should with \"TIP_RUSH_\".\n * Events from a PNPM subprocess should start with \"TIP_PNPM_\".\n *\n * @beta\n */\nexport var CustomTipId;\n(function (CustomTipId) {\n    CustomTipId[\"TIP_RUSH_INCONSISTENT_VERSIONS\"] = \"TIP_RUSH_INCONSISTENT_VERSIONS\";\n    CustomTipId[\"TIP_PNPM_UNEXPECTED_STORE\"] = \"TIP_PNPM_UNEXPECTED_STORE\";\n    CustomTipId[\"TIP_PNPM_NO_MATCHING_VERSION\"] = \"TIP_PNPM_NO_MATCHING_VERSION\";\n    CustomTipId[\"TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE\"] = \"TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE\";\n    CustomTipId[\"TIP_PNPM_PEER_DEP_ISSUES\"] = \"TIP_PNPM_PEER_DEP_ISSUES\";\n    CustomTipId[\"TIP_PNPM_OUTDATED_LOCKFILE\"] = \"TIP_PNPM_OUTDATED_LOCKFILE\";\n    CustomTipId[\"TIP_PNPM_TARBALL_INTEGRITY\"] = \"TIP_PNPM_TARBALL_INTEGRITY\";\n    CustomTipId[\"TIP_PNPM_MISMATCHED_RELEASE_CHANNEL\"] = \"TIP_PNPM_MISMATCHED_RELEASE_CHANNEL\";\n    CustomTipId[\"TIP_PNPM_INVALID_NODE_VERSION\"] = \"TIP_PNPM_INVALID_NODE_VERSION\";\n})(CustomTipId || (CustomTipId = {}));\n/**\n * The severity of a custom tip.\n * It determines the printing severity (\"Error\" = red, \"Warning\" = yellow, \"Info\" = normal).\n *\n * @beta\n */\nexport var CustomTipSeverity;\n(function (CustomTipSeverity) {\n    CustomTipSeverity[\"Warning\"] = \"Warning\";\n    CustomTipSeverity[\"Error\"] = \"Error\";\n    CustomTipSeverity[\"Info\"] = \"Info\";\n})(CustomTipSeverity || (CustomTipSeverity = {}));\n/**\n * The type of the custom tip.\n *\n * @remarks\n * There might be types like `git` in the future.\n *\n * @beta\n */\nexport var CustomTipType;\n(function (CustomTipType) {\n    CustomTipType[\"rush\"] = \"rush\";\n    CustomTipType[\"pnpm\"] = \"pnpm\";\n})(CustomTipType || (CustomTipType = {}));\nexport const RUSH_CUSTOM_TIPS = {\n    [CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS]: {\n        tipId: CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.rush\n    }\n};\nexport const PNPM_CUSTOM_TIPS = {\n    [CustomTipId.TIP_PNPM_UNEXPECTED_STORE]: {\n        tipId: CustomTipId.TIP_PNPM_UNEXPECTED_STORE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_UNEXPECTED_STORE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION]: {\n        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Example message: (do notice the difference between this one and the TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE)\n            // Error Message: ERR_PNPM_NO_MATCHING_VERSION  No matching version found for @babel/types@^7.22.5\n            // The latest release of @babel/types is \"7.22.4\".\n            // Other releases are:\n            // * esm: 7.21.4-esm.4\n            return str.includes('No matching version found for') && str.includes('The latest release of');\n        }\n    },\n    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE]: {\n        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_PEER_DEP_ISSUES]: {\n        tipId: CustomTipId.TIP_PNPM_PEER_DEP_ISSUES,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_PEER_DEP_ISSUES');\n        }\n    },\n    [CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE]: {\n        tipId: CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_OUTDATED_LOCKFILE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_TARBALL_INTEGRITY]: {\n        tipId: CustomTipId.TIP_PNPM_TARBALL_INTEGRITY,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_TARBALL_INTEGRITY');\n        }\n    },\n    [CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL]: {\n        tipId: CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_MISMATCHED_RELEASE_CHANNEL');\n        }\n    },\n    [CustomTipId.TIP_PNPM_INVALID_NODE_VERSION]: {\n        tipId: CustomTipId.TIP_PNPM_INVALID_NODE_VERSION,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_INVALID_NODE_VERSION');\n        }\n    }\n};\n/**\n * Used to access the `common/config/rush/custom-tips.json` config file,\n * which allows repo maintainers to configure extra details to be printed alongside\n * certain Rush messages.\n * @beta\n */\nclass CustomTipsConfiguration {\n    constructor(configFilePath) {\n        const providedCustomTips = new Map();\n        let configuration;\n        try {\n            configuration = JsonFile.loadAndValidate(configFilePath, CustomTipsConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        const customTips = configuration === null || configuration === void 0 ? void 0 : configuration.customTips;\n        if (customTips) {\n            for (const tipItem of customTips) {\n                if (!(tipItem.tipId in CustomTipId)) {\n                    throw new Error(`The ${path.basename(configFilePath)} configuration` +\n                        ` references an unknown ID \"${tipItem.tipId}\"`);\n                }\n                if (providedCustomTips.has(tipItem.tipId)) {\n                    throw new Error(`The ${path.basename(configFilePath)} configuration` +\n                        ` specifies a duplicate definition for \"${tipItem.tipId}\"`);\n                }\n                else {\n                    providedCustomTips.set(tipItem.tipId, tipItem);\n                }\n            }\n        }\n        this.providedCustomTipsByTipId = providedCustomTips;\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId,\n     * display the tip on the terminal.\n     *\n     * @remarks\n     * The severity of the tip is defined in ${@link CustomTipsConfiguration.customTipRegistry}.\n     * If you want to change the severity specifically for this call, use other API like {@link CustomTipsConfiguration._showErrorTip}.\n     *\n     * @internal\n     */\n    _showTip(terminal, tipId) {\n        const severityOfOriginalMessage = CustomTipsConfiguration.customTipRegistry[tipId].severity;\n        this._writeMessageWithPipes(terminal, severityOfOriginalMessage, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId,\n     * display the tip on the terminal.\n     * @internal\n     */\n    _showInfoTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Info, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId,\n     * display the tip on the terminal.\n     * @internal\n     */\n    _showWarningTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Warning, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId,\n     * display the tip on the terminal.\n     * @internal\n     */\n    _showErrorTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Error, tipId);\n    }\n    _writeMessageWithPipes(terminal, severity, tipId) {\n        const customTipJsonItem = this.providedCustomTipsByTipId.get(tipId);\n        if (customTipJsonItem) {\n            let writeFunction;\n            switch (severity) {\n                case CustomTipSeverity.Error:\n                    writeFunction = terminal.writeErrorLine.bind(terminal);\n                    break;\n                case CustomTipSeverity.Warning:\n                    writeFunction = terminal.writeWarningLine.bind(terminal);\n                    break;\n                default:\n                    writeFunction = terminal.writeLine.bind(terminal);\n                    break;\n            }\n            writeFunction(`| Custom Tip (${tipId})`);\n            writeFunction('|');\n            const message = customTipJsonItem.message;\n            const wrappedAndIndentedMessage = PrintUtilities.wrapWords(message, undefined, '| ');\n            writeFunction(wrappedAndIndentedMessage);\n            terminal.writeLine();\n        }\n    }\n}\nCustomTipsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n/**\n * A registry mapping custom tip IDs to their corresponding metadata.\n *\n * @remarks\n * This registry is used to look up metadata for custom tips based on their IDs. The metadata includes\n * information such as the severity level, the type of tip, and an optional matching function.\n *\n * Each key in the registry corresponds to a `CustomTipIdEnum` value, and each value is an object\n * implementing the `ICustomTipInfo` interface.\n *\n * @example\n * ```typescript\n * const tipInfo = CustomTipsConfiguration.customTipRegistry[CustomTipIdEnum.TIP_RUSH_INCONSISTENT_VERSIONS];\n * console.log(tipInfo.severity);  // Output: CustomTipSeverity.Error\n * ```\n *\n * See {@link CustomTipId} for the list of custom tip IDs.\n * See {@link ICustomTipInfo} for the structure of the metadata.\n */\nCustomTipsConfiguration.customTipRegistry = Object.assign(Object.assign({}, RUSH_CUSTOM_TIPS), PNPM_CUSTOM_TIPS);\nexport { CustomTipsConfiguration };\n//# sourceMappingURL=CustomTipsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport { trueCasePathSync } from 'true-case-path';\n/**\n * Names of environment variables used by Rush.\n * @beta\n */\n// eslint-disable-next-line @typescript-eslint/typedef\nexport const EnvironmentVariableNames = {\n    /**\n     * This variable overrides the temporary folder used by Rush.\n     * The default value is \"common/temp\" under the repository root.\n     *\n     * @remarks This environment variable is not compatible with workspace installs. If attempting\n     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.\n     */\n    RUSH_TEMP_FOLDER: 'RUSH_TEMP_FOLDER',\n    /**\n     * This variable overrides the version of Rush that will be installed by\n     * the version selector.  The default value is determined by the \"rushVersion\"\n     * field from rush.json.\n     */\n    RUSH_PREVIEW_VERSION: 'RUSH_PREVIEW_VERSION',\n    /**\n     * If this variable is set to \"1\", Rush will not fail the build when running a version\n     * of Node that does not match the criteria specified in the \"nodeSupportedVersionRange\"\n     * field from rush.json.\n     */\n    RUSH_ALLOW_UNSUPPORTED_NODEJS: 'RUSH_ALLOW_UNSUPPORTED_NODEJS',\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: 'RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD',\n    /**\n     * This variable selects a specific installation variant for Rush to use when installing\n     * and linking package dependencies.\n     * For more information, see the command-line help for the `--variant` parameter\n     * and this article:  https://rushjs.io/pages/advanced/installation_variants/\n     */\n    RUSH_VARIANT: 'RUSH_VARIANT',\n    /**\n     * Specifies the maximum number of concurrent processes to launch during a build.\n     * For more information, see the command-line help for the `--parallelism` parameter for \"rush build\".\n     */\n    RUSH_PARALLELISM: 'RUSH_PARALLELISM',\n    /**\n     * If this variable is set to \"1\", Rush will create symlinks with absolute paths instead\n     * of relative paths. This can be necessary when a repository is moved during a build or\n     * if parts of a repository are moved into a sandbox.\n     */\n    RUSH_ABSOLUTE_SYMLINKS: 'RUSH_ABSOLUTE_SYMLINKS',\n    /**\n     * When using PNPM as the package manager, this variable can be used to configure the path that\n     * PNPM will use as the store directory.\n     *\n     * If a relative path is used, then the store path will be resolved relative to the process's\n     * current working directory.  An absolute path is recommended.\n     */\n    RUSH_PNPM_STORE_PATH: 'RUSH_PNPM_STORE_PATH',\n    /**\n     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM\n     * validates the integrity of the PNPM store during installation. The value of this environment variable must be\n     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.\n     */\n    RUSH_PNPM_VERIFY_STORE_INTEGRITY: 'RUSH_PNPM_VERIFY_STORE_INTEGRITY',\n    /**\n     * This environment variable can be used to specify the `--target-folder` parameter\n     * for the \"rush deploy\" command.\n     */\n    RUSH_DEPLOY_TARGET_FOLDER: 'RUSH_DEPLOY_TARGET_FOLDER',\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     *\n     * @remarks\n     *\n     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,\n     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set\n     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored\n     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like\n     * operating systems or `C:\\Users\\YourName` on Windows.\n     *\n     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows\n     * group policy forbids executing scripts installed in a user's home directory.\n     *\n     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n     */\n    RUSH_GLOBAL_FOLDER: 'RUSH_GLOBAL_FOLDER',\n    /**\n     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.\n     *\n     * @remarks\n     * Setting this environment variable overrides whatever credential has been saved in the\n     * local cloud cache credentials using `rush update-cloud-credentials`.\n     *\n     *\n     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query\n     * parameters.\n     *\n     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview\n     */\n    RUSH_BUILD_CACHE_CREDENTIAL: 'RUSH_BUILD_CACHE_CREDENTIAL',\n    /**\n     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`\n     * configuration file.\n     *\n     * @remarks\n     * Specify `1` to enable the build cache or `0` to disable it.\n     *\n     * If there is no build cache configured, then this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_ENABLED: 'RUSH_BUILD_CACHE_ENABLED',\n    /**\n     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this\n     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then\n     * this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_WRITE_ALLOWED: 'RUSH_BUILD_CACHE_WRITE_ALLOWED',\n    /**\n     * Setting this environment variable opts into running with cobuilds. The context id should be the same across\n     * multiple VMs, but changed when it is a new round of cobuilds.\n     *\n     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.\n     *\n     * @remarks\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_CONTEXT_ID: 'RUSH_COBUILD_CONTEXT_ID',\n    /**\n     * Explicitly specifies a name for each participating cobuild runner.\n     *\n     * Setting this environment variable opts into running with cobuilds.\n     *\n     * @remarks\n     * This environment variable is optional, if it is not provided, a random id is used.\n     *\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_RUNNER_ID: 'RUSH_COBUILD_RUNNER_ID',\n    /**\n     * If this variable is set to \"1\", When getting distributed builds, Rush will automatically handle the leaf project\n     * with build cache \"disabled\" by writing to the cache in a special \"log files only mode\". This is useful when you\n     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.\n     */\n    RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: 'RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED',\n    /**\n     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.\n     */\n    RUSH_GIT_BINARY_PATH: 'RUSH_GIT_BINARY_PATH',\n    /**\n     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.\n     */\n    RUSH_TAR_BINARY_PATH: 'RUSH_TAR_BINARY_PATH',\n    /**\n     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.\n     * Will be set upon loading Rush.\n     */\n    RUSH_LIB_PATH: '_RUSH_LIB_PATH',\n    /**\n     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or\n     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned\n     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.\n     *\n     * @remarks\n     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers\n     * assign when they execute lifecycle scripts.\n     */\n    RUSH_INVOKED_FOLDER: 'RUSH_INVOKED_FOLDER'\n};\n/**\n * Provides Rush-specific environment variable data. All Rush environment variables must start with \"RUSH_\". This class\n * is designed to be used by RushConfiguration.\n * @beta\n *\n * @remarks\n * Initialize will throw if any unknown parameters are present.\n */\nclass EnvironmentConfiguration {\n    /**\n     * An override for the common/temp folder path.\n     */\n    static get rushTempFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushTempFolderOverride;\n    }\n    /**\n     * If \"1\", create symlinks with absolute paths instead of relative paths.\n     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}\n     */\n    static get absoluteSymlinks() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._absoluteSymlinks;\n    }\n    /**\n     * If this environment variable is set to \"1\", the Node.js version check will print a warning\n     * instead of causing a hard error if the environment's Node.js version doesn't match the\n     * version specifier in `rush.json`'s \"nodeSupportedVersionRange\" property.\n     *\n     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.\n     */\n    static get allowUnsupportedNodeVersion() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowUnsupportedNodeVersion;\n    }\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    static get allowWarningsInSuccessfulBuild() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;\n    }\n    /**\n     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}\n     */\n    static get pnpmStorePathOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmStorePathOverride;\n    }\n    /**\n     * If specified, enables or disables integrity verification of the pnpm store during install.\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}\n     */\n    static get pnpmVerifyStoreIntegrity() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmVerifyStoreIntegrity;\n    }\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}\n     */\n    static get rushGlobalFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushGlobalFolderOverride;\n    }\n    /**\n     * Provides a credential for reading from and writing to a remote build cache, if configured.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}\n     */\n    static get buildCacheCredential() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheCredential;\n    }\n    /**\n     * If set, enables or disables the cloud build cache feature.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}\n     */\n    static get buildCacheEnabled() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheEnabled;\n    }\n    /**\n     * If set, enables or disables writing to the cloud build cache.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}\n     */\n    static get buildCacheWriteAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheWriteAllowed;\n    }\n    /**\n     * Provides a determined cobuild context id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}\n     */\n    static get cobuildContextId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildContextId;\n    }\n    /**\n     * Provides a determined cobuild runner id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}\n     */\n    static get cobuildRunnerId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildRunnerId;\n    }\n    /**\n     * If set, enables or disables the cobuild leaf project log only feature.\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}\n     */\n    static get cobuildLeafProjectLogOnlyAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed;\n    }\n    /**\n     * Allows the git binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}\n     */\n    static get gitBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._gitBinaryPath;\n    }\n    /**\n     * Allows the tar binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}\n     */\n    static get tarBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._tarBinaryPath;\n    }\n    /**\n     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before\n     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`\n     * is even installed). Thus we need to read this environment variable differently from all the others.\n     * @internal\n     */\n    static _getRushGlobalFolderOverride(processEnv) {\n        const value = processEnv[EnvironmentVariableNames.RUSH_GLOBAL_FOLDER];\n        if (value) {\n            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);\n            return normalizedValue;\n        }\n    }\n    /**\n     * Reads and validates environment variables. If any are invalid, this function will throw.\n     */\n    static validate(options = {}) {\n        var _a, _b, _c;\n        EnvironmentConfiguration.reset();\n        const unknownEnvVariables = [];\n        for (const envVarName in process.env) {\n            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {\n                const value = process.env[envVarName];\n                // Environment variables are only case-insensitive on Windows\n                const normalizedEnvVarName = os.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;\n                switch (normalizedEnvVarName) {\n                    case EnvironmentVariableNames.RUSH_TEMP_FOLDER: {\n                        EnvironmentConfiguration._rushTempFolderOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS: {\n                        EnvironmentConfiguration._absoluteSymlinks =\n                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS, value)) !== null && _a !== void 0 ? _a : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS: {\n                        if (value === 'true' || value === 'false') {\n                            // Small, undocumented acceptance of old \"true\" and \"false\" values for\n                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';\n                        }\n                        else {\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion =\n                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS, value)) !== null && _b !== void 0 ? _b : false;\n                        }\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: {\n                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =\n                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD, value)) !== null && _c !== void 0 ? _c : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_STORE_PATH: {\n                        EnvironmentConfiguration._pnpmStorePathOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY: {\n                        EnvironmentConfiguration._pnpmVerifyStoreIntegrity =\n                            value === '1' ? true : value === '0' ? false : undefined;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GLOBAL_FOLDER: {\n                        // Handled specially below\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL: {\n                        EnvironmentConfiguration._buildCacheCredential = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED: {\n                        EnvironmentConfiguration._buildCacheEnabled =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED: {\n                        EnvironmentConfiguration._buildCacheWriteAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID: {\n                        EnvironmentConfiguration._cobuildContextId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID: {\n                        EnvironmentConfiguration._cobuildRunnerId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: {\n                        EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GIT_BINARY_PATH: {\n                        EnvironmentConfiguration._gitBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_TAR_BINARY_PATH: {\n                        EnvironmentConfiguration._tarBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PARALLELISM:\n                    case EnvironmentVariableNames.RUSH_PREVIEW_VERSION:\n                    case EnvironmentVariableNames.RUSH_VARIANT:\n                    case EnvironmentVariableNames.RUSH_DEPLOY_TARGET_FOLDER:\n                        // Handled by @microsoft/rush front end\n                        break;\n                    case EnvironmentVariableNames.RUSH_INVOKED_FOLDER:\n                    case EnvironmentVariableNames.RUSH_LIB_PATH:\n                        // Assigned by Rush itself\n                        break;\n                    default:\n                        unknownEnvVariables.push(envVarName);\n                        break;\n                }\n            }\n        }\n        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.\n        if (unknownEnvVariables.length > 0) {\n            throw new Error('The following environment variables were found with the \"RUSH_\" prefix, but they are not ' +\n                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);\n        }\n        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().\n        EnvironmentConfiguration._rushGlobalFolderOverride =\n            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        EnvironmentConfiguration._hasBeenValidated = true;\n    }\n    /**\n     * Resets EnvironmentConfiguration into an un-initialized state.\n     */\n    static reset() {\n        EnvironmentConfiguration._rushTempFolderOverride = undefined;\n        EnvironmentConfiguration._hasBeenValidated = false;\n    }\n    static _ensureValidated() {\n        if (!EnvironmentConfiguration._hasBeenValidated) {\n            EnvironmentConfiguration.validate();\n        }\n    }\n    static parseBooleanEnvironmentVariable(name, value) {\n        if (value === '' || value === undefined) {\n            return undefined;\n        }\n        else if (value === '0') {\n            return false;\n        }\n        else if (value === '1') {\n            return true;\n        }\n        else {\n            throw new Error(`Invalid value \"${value}\" for the environment variable ${name}. Valid choices are 0 or 1.`);\n        }\n    }\n    /**\n     * Given a path to a folder (that may or may not exist), normalize the path, including casing,\n     * to the first existing parent folder in the path.\n     *\n     * If no existing path can be found (for example, if the root is a volume that doesn't exist),\n     * this function returns undefined.\n     *\n     * @example\n     * If the following path exists on disk: `C:\\Folder1\\folder2\\`\n     * _normalizeFirstExistingFolderPath('c:\\\\folder1\\\\folder2\\\\temp\\\\subfolder')\n     * returns 'C:\\\\Folder1\\\\folder2\\\\temp\\\\subfolder'\n     */\n    static _normalizeDeepestParentFolderPath(folderPath) {\n        folderPath = path.normalize(folderPath);\n        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path.sep;\n        const parsedPath = path.parse(folderPath);\n        const pathRoot = parsedPath.root;\n        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);\n        const pathParts = [...pathWithoutRoot.split(path.sep), parsedPath.name].filter((part) => !!part);\n        // Starting with all path sections, and eliminating one from the end during each loop iteration,\n        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset\n        // of the path that exists and we've now gotten the correct casing.\n        //\n        // Once we've found a parent folder that exists, append the path sections that didn't exist.\n        for (let i = pathParts.length; i >= 0; i--) {\n            const constructedPath = path.join(pathRoot, ...pathParts.slice(0, i));\n            try {\n                const normalizedConstructedPath = trueCasePathSync(constructedPath);\n                const result = path.join(normalizedConstructedPath, ...pathParts.slice(i));\n                if (endsWithSlash) {\n                    return `${result}${path.sep}`;\n                }\n                else {\n                    return result;\n                }\n            }\n            catch (e) {\n                // This path doesn't exist, continue to the next subpath\n            }\n        }\n        return undefined;\n    }\n}\nEnvironmentConfiguration._hasBeenValidated = false;\nEnvironmentConfiguration._absoluteSymlinks = false;\nEnvironmentConfiguration._allowUnsupportedNodeVersion = false;\nEnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;\nexport { EnvironmentConfiguration };\n//# sourceMappingURL=EnvironmentConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Enum } from '@rushstack/node-core-library';\n/**\n * Events happen during Rush runs.\n * @beta\n */\nexport var Event;\n(function (Event) {\n    /**\n     * Pre Rush install event\n     */\n    Event[Event[\"preRushInstall\"] = 1] = \"preRushInstall\";\n    /**\n     * Post Rush install event\n     */\n    Event[Event[\"postRushInstall\"] = 2] = \"postRushInstall\";\n    /**\n     * Pre Rush build event\n     */\n    Event[Event[\"preRushBuild\"] = 3] = \"preRushBuild\";\n    /**\n     * Post Rush build event\n     */\n    Event[Event[\"postRushBuild\"] = 4] = \"postRushBuild\";\n})(Event || (Event = {}));\n/**\n * This class represents Rush event hooks configured for this repo.\n * Hooks are customized script actions that Rush executes when specific events occur.\n * The actions are expressed as a command-line that is executed using the operating system shell.\n * @beta\n */\nexport class EventHooks {\n    /**\n     * @internal\n     */\n    constructor(eventHooksJson) {\n        this._hooks = new Map();\n        for (const [name, eventHooks] of Object.entries(eventHooksJson)) {\n            const eventName = Enum.tryGetValueByKey(Event, name);\n            if (eventName) {\n                this._hooks.set(eventName, [...eventHooks] || []);\n            }\n        }\n    }\n    /**\n     * Return all the scripts associated with the specified event.\n     * @param event - Rush event\n     */\n    get(event) {\n        return this._hooks.get(event) || [];\n    }\n}\n//# sourceMappingURL=EventHooks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/experiments.schema.json';\n/**\n * Use this class to load the \"common/config/rush/experiments.json\" config file.\n * This file allows repo maintainers to enable and disable experimental Rush features.\n * @public\n */\nclass ExperimentsConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFileName) {\n        this._jsonFileName = jsonFileName;\n        this.configuration = {};\n        if (!FileSystem.exists(this._jsonFileName)) {\n            this.configuration = {};\n        }\n        else {\n            this.configuration = JsonFile.loadAndValidate(this._jsonFileName, ExperimentsConfiguration._jsonSchema);\n        }\n    }\n}\nExperimentsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { ExperimentsConfiguration };\n//# sourceMappingURL=ExperimentsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, Path } from '@rushstack/node-core-library';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\nexport const LAST_INSTALL_FLAG_FILE_NAME = 'last-install.flag';\n/**\n * A helper class for managing last-install flags, which are persistent and\n * indicate that something installed in the folder was successfully completed.\n * It also compares state, so that if something like the Node.js version has changed,\n * it can invalidate the last install.\n * @internal\n */\nexport class LastInstallFlag {\n    /**\n     * Creates a new LastInstall flag\n     * @param folderPath - the folder that this flag is managing\n     * @param state - optional, the state that should be managed or compared\n     */\n    constructor(folderPath, state = {}) {\n        this.path = path.join(folderPath, this.flagName);\n        this._state = state;\n    }\n    /**\n     * Returns true if the file exists and the contents match the current state.\n     */\n    isValid(options) {\n        return this._isValid(false, options);\n    }\n    /**\n     * Same as isValid(), but with an additional check:  If the current state is not equal to the previous\n     * state, and an the current state causes an error, then throw an exception with a friendly message.\n     *\n     * @internal\n     */\n    checkValidAndReportStoreIssues(options) {\n        return this._isValid(true, options);\n    }\n    _isValid(checkValidAndReportStoreIssues, { rushVerb = 'update', statePropertiesToIgnore } = {}) {\n        let oldState;\n        try {\n            oldState = JsonFile.load(this.path);\n        }\n        catch (err) {\n            return false;\n        }\n        const newState = Object.assign({}, this._state);\n        if (statePropertiesToIgnore) {\n            for (const optionToIgnore of statePropertiesToIgnore) {\n                delete newState[optionToIgnore];\n                delete oldState[optionToIgnore];\n            }\n        }\n        if (!objectsAreDeepEqual(oldState, newState)) {\n            if (checkValidAndReportStoreIssues) {\n                const pkgManager = newState.packageManager;\n                if (pkgManager === 'pnpm') {\n                    if (\n                    // Only throw an error if the package manager hasn't changed from PNPM\n                    oldState.packageManager === pkgManager) {\n                        const normalizedOldStorePath = oldState.storePath\n                            ? Path.convertToPlatformDefault(oldState.storePath)\n                            : '<global>';\n                        const normalizedNewStorePath = newState.storePath\n                            ? Path.convertToPlatformDefault(newState.storePath)\n                            : '<global>';\n                        if (\n                        // Throw if the store path changed\n                        normalizedOldStorePath !== normalizedNewStorePath) {\n                            throw new Error('Current PNPM store path does not match the last one used. This may cause inconsistency in your builds.\\n\\n' +\n                                `If you wish to install with the new store path, please run \"rush ${rushVerb} --purge\"\\n\\n` +\n                                `Old Path: ${normalizedOldStorePath}\\n` +\n                                `New Path: ${normalizedNewStorePath}`);\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Writes the flag file to disk with the current state\n     */\n    create() {\n        JsonFile.save(this._state, this.path, {\n            ensureFolderExists: true\n        });\n    }\n    /**\n     * Removes the flag file\n     */\n    clear() {\n        FileSystem.deleteFile(this.path);\n    }\n    /**\n     * Returns the name of the flag file\n     */\n    get flagName() {\n        return LAST_INSTALL_FLAG_FILE_NAME;\n    }\n}\n/**\n * A helper class for LastInstallFlag\n *\n * @internal\n */\nexport class LastInstallFlagFactory {\n    /**\n     * Gets the LastInstall flag and sets the current state. This state is used to compare\n     * against the last-known-good state tracked by the LastInstall flag.\n     * @param rushConfiguration - the configuration of the Rush repo to get the install\n     * state from\n     *\n     * @internal\n     */\n    static getCommonTempFlag(rushConfiguration, extraState = {}) {\n        const currentState = Object.assign({ node: process.versions.node, packageManager: rushConfiguration.packageManager, packageManagerVersion: rushConfiguration.packageManagerToolVersion, rushJsonFolder: rushConfiguration.rushJsonFolder }, extraState);\n        if (currentState.packageManager === 'pnpm' && rushConfiguration.pnpmOptions) {\n            currentState.storePath = rushConfiguration.pnpmOptions.pnpmStorePath;\n            if (rushConfiguration.pnpmOptions.useWorkspaces) {\n                currentState.workspaces = rushConfiguration.pnpmOptions.useWorkspaces;\n            }\n        }\n        return new LastInstallFlag(rushConfiguration.commonTempFolder, currentState);\n    }\n}\n//# sourceMappingURL=LastInstallFlag.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { LastInstallFlag } from './LastInstallFlag';\nimport { JsonFile, InternalError } from '@rushstack/node-core-library';\nexport const LAST_LINK_FLAG_FILE_NAME = 'last-link.flag';\n/**\n * A helper class for managing the last-link flag, which is persistent and\n * indicates that linking was completed successfully.\n * @internal\n */\nexport class LastLinkFlag extends LastInstallFlag {\n    /**\n     * @override\n     */\n    isValid() {\n        let oldState;\n        try {\n            oldState = JsonFile.load(this.path);\n        }\n        catch (err) {\n            // Swallow error\n        }\n        return !!oldState;\n    }\n    /**\n     * @override\n     */\n    checkValidAndReportStoreIssues() {\n        throw new InternalError('Not implemented');\n    }\n    /**\n     * Returns the name of the flag file\n     *\n     * @override\n     */\n    get flagName() {\n        return LAST_LINK_FLAG_FILE_NAME;\n    }\n}\n/**\n * A helper class for LastLinkFlag\n *\n * @internal\n */\nexport class LastLinkFlagFactory {\n    /**\n     * Gets the LastLink flag and sets the current state. This state is used to compare\n     * against the last-known-good state tracked by the LastLink flag.\n     * @param rushConfiguration - the configuration of the Rush repo to get the install\n     * state from\n     *\n     * @internal\n     */\n    static getCommonTempFlag(rushConfiguration) {\n        return new LastLinkFlag(rushConfiguration.commonTempFolder, {});\n    }\n}\n//# sourceMappingURL=LastLinkFlag.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { InternalError, JsonFile, Sort } from '@rushstack/node-core-library';\nimport { cloneDeep } from '../utilities/objectUtilities';\n/**\n * @public\n */\nexport var DependencyType;\n(function (DependencyType) {\n    DependencyType[\"Regular\"] = \"dependencies\";\n    DependencyType[\"Dev\"] = \"devDependencies\";\n    DependencyType[\"Optional\"] = \"optionalDependencies\";\n    DependencyType[\"Peer\"] = \"peerDependencies\";\n    DependencyType[\"YarnResolutions\"] = \"resolutions\";\n})(DependencyType || (DependencyType = {}));\n/**\n * @public\n */\nexport class PackageJsonDependency {\n    constructor(name, version, type, onChange) {\n        this.name = name;\n        this._version = version;\n        this.dependencyType = type;\n        this._onChange = onChange;\n    }\n    get version() {\n        return this._version;\n    }\n    setVersion(newVersion) {\n        if (!semver.valid(newVersion) && !semver.validRange(newVersion)) {\n            throw new Error(`Cannot set version to invalid value: \"${newVersion}\"`);\n        }\n        this._version = newVersion;\n        this._onChange();\n    }\n}\n/**\n * @public\n */\nexport class PackageJsonEditor {\n    /**\n     * @internal\n     */\n    constructor(filepath, data) {\n        this.filePath = filepath;\n        this._sourceData = data;\n        this._modified = false;\n        this._dependencies = new Map();\n        this._devDependencies = new Map();\n        this._resolutions = new Map();\n        const dependencies = data.dependencies || {};\n        const optionalDependencies = data.optionalDependencies || {};\n        const peerDependencies = data.peerDependencies || {};\n        const devDependencies = data.devDependencies || {};\n        const resolutions = data.resolutions || {};\n        const _onChange = this._onChange.bind(this);\n        try {\n            Object.keys(dependencies || {}).forEach((packageName) => {\n                if (Object.prototype.hasOwnProperty.call(optionalDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both ` +\n                        `\"dependencies\" and \"optionalDependencies\"`);\n                }\n                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both \"dependencies\" and \"peerDependencies\"`);\n                }\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, dependencies[packageName], DependencyType.Regular, _onChange));\n            });\n            Object.keys(optionalDependencies || {}).forEach((packageName) => {\n                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both ` +\n                        `\"optionalDependencies\" and \"peerDependencies\"`);\n                }\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, optionalDependencies[packageName], DependencyType.Optional, _onChange));\n            });\n            Object.keys(peerDependencies || {}).forEach((packageName) => {\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, peerDependencies[packageName], DependencyType.Peer, _onChange));\n            });\n            Object.keys(devDependencies || {}).forEach((packageName) => {\n                this._devDependencies.set(packageName, new PackageJsonDependency(packageName, devDependencies[packageName], DependencyType.Dev, _onChange));\n            });\n            Object.keys(resolutions || {}).forEach((packageName) => {\n                this._resolutions.set(packageName, new PackageJsonDependency(packageName, resolutions[packageName], DependencyType.YarnResolutions, _onChange));\n            });\n            // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)\n            Sort.sortMapKeys(this._dependencies);\n            Sort.sortMapKeys(this._devDependencies);\n        }\n        catch (e) {\n            throw new Error(`Error loading \"${filepath}\": ${e.message}`);\n        }\n    }\n    static load(filePath) {\n        return new PackageJsonEditor(filePath, JsonFile.load(filePath));\n    }\n    static fromObject(object, filename) {\n        return new PackageJsonEditor(filename, object);\n    }\n    get name() {\n        return this._sourceData.name;\n    }\n    get version() {\n        return this._sourceData.version;\n    }\n    /**\n     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.\n     */\n    get dependencyList() {\n        return [...this._dependencies.values()];\n    }\n    /**\n     * The list of dependencies of type DependencyType.Dev.\n     */\n    get devDependencyList() {\n        return [...this._devDependencies.values()];\n    }\n    /**\n     * This field is a Yarn-specific feature that allows overriding of package resolution.\n     *\n     * @remarks\n     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md\n     * | 0000-selective-versions-resolutions.md RFC} for details.\n     */\n    get resolutionsList() {\n        return [...this._resolutions.values()];\n    }\n    tryGetDependency(packageName) {\n        return this._dependencies.get(packageName);\n    }\n    tryGetDevDependency(packageName) {\n        return this._devDependencies.get(packageName);\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        const dependency = new PackageJsonDependency(packageName, newVersion, dependencyType, this._onChange.bind(this));\n        // Rush collapses everything that isn't a devDependency into the dependencies\n        // field, so we need to set the value depending on dependency type\n        switch (dependencyType) {\n            case DependencyType.Regular:\n            case DependencyType.Optional:\n            case DependencyType.Peer:\n                this._dependencies.set(packageName, dependency);\n                break;\n            case DependencyType.Dev:\n                this._devDependencies.set(packageName, dependency);\n                break;\n            case DependencyType.YarnResolutions:\n                this._resolutions.set(packageName, dependency);\n                break;\n            default:\n                throw new InternalError('Unsupported DependencyType');\n        }\n        this._modified = true;\n    }\n    removeDependency(packageName, dependencyType) {\n        switch (dependencyType) {\n            case DependencyType.Regular:\n            case DependencyType.Optional:\n            case DependencyType.Peer:\n                this._dependencies.delete(packageName);\n                break;\n            case DependencyType.Dev:\n                this._devDependencies.delete(packageName);\n                break;\n            case DependencyType.YarnResolutions:\n                this._resolutions.delete(packageName);\n                break;\n            default:\n                throw new InternalError('Unsupported DependencyType');\n        }\n        this._modified = true;\n    }\n    saveIfModified() {\n        if (this._modified) {\n            this._modified = false;\n            this._sourceData = this._normalize(this._sourceData);\n            JsonFile.save(this._sourceData, this.filePath, { updateExistingFile: true });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get the normalized package.json that represents the current state of the\n     * PackageJsonEditor. This method does not save any changes that were made to the\n     * package.json, but instead returns the object representation of what would be saved\n     * if saveIfModified() is called.\n     */\n    saveToObject() {\n        // Only normalize if we need to\n        const sourceData = this._modified ? this._normalize(this._sourceData) : this._sourceData;\n        // Provide a clone to avoid reference back to the original data object\n        return cloneDeep(sourceData);\n    }\n    _onChange() {\n        this._modified = true;\n    }\n    /**\n     * Create a normalized shallow copy of the provided package.json without modifying the\n     * original. If the result of this method is being returned via a public facing method,\n     * it will still need to be deep-cloned to avoid propogating changes back to the\n     * original dataset.\n     */\n    _normalize(source) {\n        const normalizedData = Object.assign({}, source);\n        delete normalizedData.dependencies;\n        delete normalizedData.optionalDependencies;\n        delete normalizedData.peerDependencies;\n        delete normalizedData.devDependencies;\n        delete normalizedData.resolutions;\n        const keys = [...this._dependencies.keys()].sort();\n        for (const packageName of keys) {\n            const dependency = this._dependencies.get(packageName);\n            switch (dependency.dependencyType) {\n                case DependencyType.Regular:\n                    if (!normalizedData.dependencies) {\n                        normalizedData.dependencies = {};\n                    }\n                    normalizedData.dependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Optional:\n                    if (!normalizedData.optionalDependencies) {\n                        normalizedData.optionalDependencies = {};\n                    }\n                    normalizedData.optionalDependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Peer:\n                    if (!normalizedData.peerDependencies) {\n                        normalizedData.peerDependencies = {};\n                    }\n                    normalizedData.peerDependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Dev: // uses this._devDependencies instead\n                case DependencyType.YarnResolutions: // uses this._resolutions instead\n                default:\n                    throw new InternalError('Unsupported DependencyType');\n            }\n        }\n        const devDependenciesKeys = [...this._devDependencies.keys()].sort();\n        for (const packageName of devDependenciesKeys) {\n            const dependency = this._devDependencies.get(packageName);\n            if (!normalizedData.devDependencies) {\n                normalizedData.devDependencies = {};\n            }\n            normalizedData.devDependencies[dependency.name] = dependency.version;\n        }\n        // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)\n        for (const packageName of this._resolutions.keys()) {\n            const dependency = this._resolutions.get(packageName);\n            if (!normalizedData.resolutions) {\n                normalizedData.resolutions = {};\n            }\n            normalizedData.resolutions[dependency.name] = dependency.version;\n        }\n        return normalizedData;\n    }\n}\n//# sourceMappingURL=PackageJsonEditor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageNameParser } from '@rushstack/node-core-library';\nclass PackageNameParsers {\n}\n/**\n * This is the default for `RushConfiguration.packageNameParser`.\n */\nPackageNameParsers.rushDefault = new PackageNameParser({});\n/**\n * This is the `RushConfiguration.packageNameParser` used when `allowMostlyStandardPackageNames = true`\n * in rush.json.\n */\nPackageNameParsers.mostlyStandard = new PackageNameParser({\n    allowUpperCase: true\n});\n/**\n * Use this in contexts where we don't have easy access to `RushConfiguration.packageNameParser`\n * AND the package name was already validated at some earlier stage.\n */\nPackageNameParsers.permissive = PackageNameParsers.mostlyStandard;\nexport { PackageNameParsers };\n//# sourceMappingURL=PackageNameParsers.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { InternalError, PackageJsonLookup } from '@rushstack/node-core-library';\nimport '../utilities/SetRushLibPath';\nimport { RushCommandLineParser } from '../cli/RushCommandLineParser';\nimport { RushStartupBanner } from '../cli/RushStartupBanner';\nimport { RushXCommandLine } from '../cli/RushXCommandLine';\nimport { CommandLineMigrationAdvisor } from '../cli/CommandLineMigrationAdvisor';\nimport { EnvironmentVariableNames } from './EnvironmentConfiguration';\nimport { RushPnpmCommandLine } from '../cli/RushPnpmCommandLine';\n/**\n * General operations for the Rush engine.\n *\n * @public\n */\nclass Rush {\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rush\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rush\" binary\n     * and start a new Node.js process.\n     *\n     * @remarks\n     * Earlier versions of the rush frontend used a different API contract. In the old contract,\n     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.\n     *\n     * Even though this API isn't documented, it is still supported for legacy compatibility.\n     */\n    static launch(launcherVersion, arg) {\n        const options = Rush._normalizeLaunchOptions(arg);\n        if (!RushCommandLineParser.shouldRestrictConsoleOutput()) {\n            RushStartupBanner.logBanner(Rush.version, options.isManaged);\n        }\n        if (!CommandLineMigrationAdvisor.checkArgv(process.argv)) {\n            // The migration advisor recognized an obsolete command-line\n            process.exitCode = 1;\n            return;\n        }\n        Rush._assignRushInvokedFolder();\n        const parser = new RushCommandLineParser({\n            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError,\n            builtInPluginConfigurations: options.builtInPluginConfigurations\n        });\n        // eslint-disable-next-line no-console\n        parser.execute().catch(console.error); // CommandLineParser.execute() should never reject the promise\n    }\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rushx\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rushx\" binary\n     * and start a new Node.js process.\n     */\n    static launchRushX(launcherVersion, options) {\n        options = Rush._normalizeLaunchOptions(options);\n        Rush._assignRushInvokedFolder();\n        RushXCommandLine._launchRushXInternal(launcherVersion, Object.assign({}, options));\n    }\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rush-pnpm\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rush-pnpm\" binary\n     * and start a new Node.js process.\n     */\n    static launchRushPnpm(launcherVersion, options) {\n        Rush._assignRushInvokedFolder();\n        RushPnpmCommandLine.launch(launcherVersion, Object.assign({}, options));\n    }\n    /**\n     * The currently executing version of the \"rush-lib\" library.\n     * This is the same as the Rush tool version for that release.\n     */\n    static get version() {\n        return this._rushLibPackageJson.version;\n    }\n    /**\n     * @internal\n     */\n    static get _rushLibPackageJson() {\n        Rush._ensureOwnPackageJsonIsLoaded();\n        return Rush.__rushLibPackageJson;\n    }\n    static get _rushLibPackageFolder() {\n        Rush._ensureOwnPackageJsonIsLoaded();\n        return Rush.__rushLibPackageFolder;\n    }\n    static _ensureOwnPackageJsonIsLoaded() {\n        if (!Rush.__rushLibPackageJson) {\n            const packageJsonFilePath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(__dirname);\n            if (!packageJsonFilePath) {\n                throw new InternalError('Unable to locate the package.json file for this module');\n            }\n            Rush.__rushLibPackageFolder = path.dirname(packageJsonFilePath);\n            Rush.__rushLibPackageJson = PackageJsonLookup.instance.loadPackageJson(packageJsonFilePath);\n        }\n    }\n    /**\n     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when\n     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.\n     *\n     * @remarks\n     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate\n     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,\n     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.\n     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use\n     * `Executable.spawn()` or rushell.\n     */\n    static _assignRushInvokedFolder() {\n        process.env[EnvironmentVariableNames.RUSH_INVOKED_FOLDER] = process.cwd();\n    }\n    /**\n     * This function normalizes legacy options to the current {@link ILaunchOptions} object.\n     */\n    static _normalizeLaunchOptions(arg) {\n        return typeof arg === 'boolean'\n            ? { isManaged: arg } // In older versions of Rush, this the `launch` functions took a boolean arg for \"isManaged\"\n            : arg;\n    }\n}\nRush.__rushLibPackageJson = undefined;\nRush.__rushLibPackageFolder = undefined;\nexport { Rush };\n//# sourceMappingURL=Rush.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/* eslint max-lines: off */\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { JsonFile, JsonSchema, Path, FileSystem } from '@rushstack/node-core-library';\nimport { trueCasePathSync } from 'true-case-path';\nimport { Rush } from '../api/Rush';\nimport { RushConfigurationProject } from './RushConfigurationProject';\nimport { RushConstants } from '../logic/RushConstants';\nimport { ApprovedPackagesPolicy } from './ApprovedPackagesPolicy';\nimport { EventHooks } from './EventHooks';\nimport { VersionPolicyConfiguration } from './VersionPolicyConfiguration';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { CommonVersionsConfiguration } from './CommonVersionsConfiguration';\nimport { Utilities } from '../utilities/Utilities';\nimport { NpmPackageManager } from './packageManager/NpmPackageManager';\nimport { YarnPackageManager } from './packageManager/YarnPackageManager';\nimport { PnpmPackageManager } from './packageManager/PnpmPackageManager';\nimport { ExperimentsConfiguration } from './ExperimentsConfiguration';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { RepoStateFile } from '../logic/RepoStateFile';\nimport { LookupByPath } from '../logic/LookupByPath';\nimport { RushPluginsConfiguration } from './RushPluginsConfiguration';\nimport { PnpmOptionsConfiguration } from '../logic/pnpm/PnpmOptionsConfiguration';\nimport { NpmOptionsConfiguration } from '../logic/npm/NpmOptionsConfiguration';\nimport { YarnOptionsConfiguration } from '../logic/yarn/YarnOptionsConfiguration';\nimport schemaJson from '../schemas/rush.schema.json';\nimport { CustomTipsConfiguration } from './CustomTipsConfiguration';\nconst MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';\nconst DEFAULT_BRANCH = 'main';\nconst DEFAULT_REMOTE = 'origin';\n/**\n * A list of known config filenames that are expected to appear in the \"./common/config/rush\" folder.\n * To avoid confusion/mistakes, any extra files will be reported as an error.\n */\nconst knownRushConfigFilenames = [\n    '.npmrc-publish',\n    '.npmrc',\n    'deploy.json',\n    RushConstants.artifactoryFilename,\n    RushConstants.browserApprovedPackagesFilename,\n    RushConstants.buildCacheFilename,\n    RushConstants.cobuildFilename,\n    RushConstants.commandLineFilename,\n    RushConstants.commonVersionsFilename,\n    RushConstants.customTipsFilename,\n    RushConstants.experimentsFilename,\n    RushConstants.nonbrowserApprovedPackagesFilename,\n    RushConstants.pinnedVersionsFilename,\n    RushConstants.repoStateFilename,\n    RushConstants.versionPoliciesFilename,\n    RushConstants.rushPluginsConfigFilename,\n    RushConstants.pnpmConfigFilename\n];\n/**\n * This represents the Rush configuration for a repository, based on the \"rush.json\"\n * configuration file.\n * @public\n */\nclass RushConfiguration {\n    /**\n     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()\n     * instead.\n     */\n    constructor(rushConfigurationJson, rushJsonFilename) {\n        this.rushConfigurationJson = rushConfigurationJson;\n        EnvironmentConfiguration.validate();\n        if (rushConfigurationJson.nodeSupportedVersionRange) {\n            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {\n                throw new Error('Error parsing the node-semver expression in the \"nodeSupportedVersionRange\"' +\n                    ` field from rush.json: \"${rushConfigurationJson.nodeSupportedVersionRange}\"`);\n            }\n            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {\n                let message = `Your dev environment is running Node.js version ${process.version} which does` +\n                    ` not meet the requirements for building this repository.  (The rush.json configuration` +\n                    ` requires nodeSupportedVersionRange=\"${rushConfigurationJson.nodeSupportedVersionRange}\")`;\n                if (rushConfigurationJson.nodeSupportedVersionInstructions) {\n                    message += '\\n\\n' + rushConfigurationJson.nodeSupportedVersionInstructions;\n                }\n                if (EnvironmentConfiguration.allowUnsupportedNodeVersion) {\n                    // eslint-disable-next-line no-console\n                    console.warn(message);\n                }\n                else {\n                    throw new Error(message);\n                }\n            }\n        }\n        this.rushJsonFile = rushJsonFilename;\n        this.rushJsonFolder = path.dirname(rushJsonFilename);\n        this.commonFolder = path.resolve(path.join(this.rushJsonFolder, RushConstants.commonFolderName));\n        this.commonRushConfigFolder = path.join(this.commonFolder, 'config', 'rush');\n        this.commonTempFolder =\n            EnvironmentConfiguration.rushTempFolderOverride ||\n                path.join(this.commonFolder, RushConstants.rushTempFolderName);\n        this.commonScriptsFolder = path.join(this.commonFolder, 'scripts');\n        this.npmCacheFolder = path.resolve(path.join(this.commonTempFolder, 'npm-cache'));\n        this.npmTmpFolder = path.resolve(path.join(this.commonTempFolder, 'npm-tmp'));\n        this.yarnCacheFolder = path.resolve(path.join(this.commonTempFolder, 'yarn-cache'));\n        this.changesFolder = path.join(this.commonFolder, RushConstants.changeFilesFolderName);\n        this.currentVariantJsonFilename = path.join(this.commonTempFolder, 'current-variant.json');\n        this.suppressNodeLtsWarning = !!rushConfigurationJson.suppressNodeLtsWarning;\n        this.ensureConsistentVersions = !!rushConfigurationJson.ensureConsistentVersions;\n        const experimentsConfigFile = path.join(this.commonRushConfigFolder, RushConstants.experimentsFilename);\n        this.experimentsConfiguration = new ExperimentsConfiguration(experimentsConfigFile);\n        const rushPluginsConfigFilename = path.join(this.commonRushConfigFolder, RushConstants.rushPluginsConfigFilename);\n        this._rushPluginsConfiguration = new RushPluginsConfiguration(rushPluginsConfigFilename);\n        this.npmOptions = new NpmOptionsConfiguration(rushConfigurationJson.npmOptions || {});\n        this.yarnOptions = new YarnOptionsConfiguration(rushConfigurationJson.yarnOptions || {});\n        try {\n            this.pnpmOptions = PnpmOptionsConfiguration.loadFromJsonFileOrThrow(`${this.commonRushConfigFolder}/${RushConstants.pnpmConfigFilename}`, this.commonTempFolder);\n            if (rushConfigurationJson.pnpmOptions) {\n                throw new Error('Because the new config file \"common/config/rush/pnpm-config.json\" is being used, ' +\n                    'you must remove the old setting \"pnpmOptions\" from rush.json');\n            }\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                this.pnpmOptions = PnpmOptionsConfiguration.loadFromJsonObject(rushConfigurationJson.pnpmOptions || {}, this.commonTempFolder);\n            }\n            else {\n                throw error;\n            }\n        }\n        // TODO: Add an actual \"packageManager\" field in rush.json\n        const packageManagerFields = [];\n        if (rushConfigurationJson.npmVersion) {\n            this.packageManager = 'npm';\n            this.packageManagerOptions = this.npmOptions;\n            packageManagerFields.push('npmVersion');\n        }\n        if (rushConfigurationJson.pnpmVersion) {\n            this.packageManager = 'pnpm';\n            this.packageManagerOptions = this.pnpmOptions;\n            packageManagerFields.push('pnpmVersion');\n        }\n        if (rushConfigurationJson.yarnVersion) {\n            this.packageManager = 'yarn';\n            this.packageManagerOptions = this.yarnOptions;\n            packageManagerFields.push('yarnVersion');\n        }\n        if (packageManagerFields.length === 0) {\n            throw new Error(`The rush.json configuration must specify one of: npmVersion, pnpmVersion, or yarnVersion`);\n        }\n        if (packageManagerFields.length > 1) {\n            throw new Error(`The rush.json configuration cannot specify both ${packageManagerFields[0]}` +\n                ` and ${packageManagerFields[1]} `);\n        }\n        if (this.packageManager === 'npm') {\n            this.packageManagerToolVersion = rushConfigurationJson.npmVersion;\n            this.packageManagerWrapper = new NpmPackageManager(this.packageManagerToolVersion);\n        }\n        else if (this.packageManager === 'pnpm') {\n            this.packageManagerToolVersion = rushConfigurationJson.pnpmVersion;\n            this.packageManagerWrapper = new PnpmPackageManager(this.packageManagerToolVersion);\n        }\n        else {\n            this.packageManagerToolVersion = rushConfigurationJson.yarnVersion;\n            this.packageManagerWrapper = new YarnPackageManager(this.packageManagerToolVersion);\n        }\n        this.shrinkwrapFilename = this.packageManagerWrapper.shrinkwrapFilename;\n        this.tempShrinkwrapFilename = path.join(this.commonTempFolder, this.shrinkwrapFilename);\n        this.packageManagerToolFilename = path.resolve(path.join(this.commonTempFolder, `${this.packageManager}-local`, 'node_modules', '.bin', `${this.packageManager}`));\n        /// From \"C:\\repo\\common\\temp\\pnpm-lock.yaml\" --> \"C:\\repo\\common\\temp\\pnpm-lock-preinstall.yaml\"\n        const parsedPath = path.parse(this.tempShrinkwrapFilename);\n        this.tempShrinkwrapPreinstallFilename = path.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);\n        RushConfiguration._validateCommonRushConfigFolder(this.commonRushConfigFolder, this.packageManagerWrapper, this.experimentsConfiguration);\n        this.projectFolderMinDepth =\n            rushConfigurationJson.projectFolderMinDepth !== undefined\n                ? rushConfigurationJson.projectFolderMinDepth\n                : 1;\n        if (this.projectFolderMinDepth < 1) {\n            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');\n        }\n        this.projectFolderMaxDepth =\n            rushConfigurationJson.projectFolderMaxDepth !== undefined\n                ? rushConfigurationJson.projectFolderMaxDepth\n                : 2;\n        if (this.projectFolderMaxDepth < this.projectFolderMinDepth) {\n            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');\n        }\n        this.allowMostlyStandardPackageNames = !!rushConfigurationJson.allowMostlyStandardPackageNames;\n        this.packageNameParser = this.allowMostlyStandardPackageNames\n            ? PackageNameParsers.mostlyStandard\n            : PackageNameParsers.rushDefault;\n        this.approvedPackagesPolicy = new ApprovedPackagesPolicy(this, rushConfigurationJson);\n        this.gitAllowedEmailRegExps = [];\n        this.gitSampleEmail = '';\n        if (rushConfigurationJson.gitPolicy) {\n            if (rushConfigurationJson.gitPolicy.sampleEmail) {\n                this.gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;\n            }\n            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {\n                this.gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;\n                if (this.gitSampleEmail.trim().length < 1) {\n                    throw new Error('The rush.json file is missing the \"sampleEmail\" option, ' +\n                        'which is required when using \"allowedEmailRegExps\"');\n                }\n            }\n            if (rushConfigurationJson.gitPolicy.versionBumpCommitMessage) {\n                this.gitVersionBumpCommitMessage = rushConfigurationJson.gitPolicy.versionBumpCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage) {\n                this.gitChangeLogUpdateCommitMessage = rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.changefilesCommitMessage) {\n                this.gitChangefilesCommitMessage = rushConfigurationJson.gitPolicy.changefilesCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.tagSeparator) {\n                this.gitTagSeparator = rushConfigurationJson.gitPolicy.tagSeparator;\n            }\n        }\n        this.hotfixChangeEnabled = false;\n        if (rushConfigurationJson.hotfixChangeEnabled) {\n            this.hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;\n        }\n        if (!rushConfigurationJson.repository) {\n            rushConfigurationJson.repository = {};\n        }\n        this.repositoryDefaultBranch = rushConfigurationJson.repository.defaultBranch || DEFAULT_BRANCH;\n        this.repositoryDefaultRemote = rushConfigurationJson.repository.defaultRemote || DEFAULT_REMOTE;\n        const repositoryFieldWithMultipleUrls = rushConfigurationJson.repository;\n        const repositoryFieldWithSingleUrl = rushConfigurationJson.repository;\n        if (repositoryFieldWithMultipleUrls.urls) {\n            if (repositoryFieldWithSingleUrl.url) {\n                throw new Error(\"The 'repository.url' field cannot be used when 'repository.urls' is present\");\n            }\n            this.repositoryUrls = repositoryFieldWithMultipleUrls.urls;\n        }\n        else if (repositoryFieldWithSingleUrl.url) {\n            this.repositoryUrls = [repositoryFieldWithSingleUrl.url];\n        }\n        else {\n            this.repositoryUrls = [];\n        }\n        this.telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;\n        this.eventHooks = new EventHooks(rushConfigurationJson.eventHooks || {});\n        this.versionPolicyConfigurationFilePath = path.join(this.commonRushConfigFolder, RushConstants.versionPoliciesFilename);\n        this.versionPolicyConfiguration = new VersionPolicyConfiguration(this.versionPolicyConfigurationFilePath);\n        this.customTipsConfigurationFilePath = path.join(this.commonRushConfigFolder, RushConstants.customTipsFilename);\n        this.customTipsConfiguration = new CustomTipsConfiguration(this.customTipsConfigurationFilePath);\n        this._variants = new Set();\n        if (rushConfigurationJson.variants) {\n            for (const variantOptions of rushConfigurationJson.variants) {\n                const { variantName } = variantOptions;\n                if (this._variants.has(variantName)) {\n                    throw new Error(`Duplicate variant named '${variantName}' specified in configuration.`);\n                }\n                this._variants.add(variantName);\n            }\n        }\n        this._pathTrees = new Map();\n    }\n    _initializeAndValidateLocalProjects() {\n        this._projects = [];\n        this._projectsByName = new Map();\n        // We sort the projects array in alphabetical order.  This ensures that the packages\n        // are processed in a deterministic order by the various Rush algorithms.\n        const sortedProjectJsons = this.rushConfigurationJson.projects.slice(0);\n        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));\n        const allowedProjectTags = this.rushConfigurationJson.allowedProjectTags\n            ? new Set(this.rushConfigurationJson.allowedProjectTags)\n            : undefined;\n        const usedTempNames = new Set();\n        for (let i = 0, len = sortedProjectJsons.length; i < len; i++) {\n            const projectJson = sortedProjectJsons[i];\n            const tempProjectName = RushConfiguration._generateTempNameForProject(projectJson, usedTempNames);\n            const project = new RushConfigurationProject({\n                projectJson,\n                rushConfiguration: this,\n                tempProjectName,\n                allowedProjectTags\n            });\n            this._projects.push(project);\n            if (this._projectsByName.has(project.packageName)) {\n                throw new Error(`The project name \"${project.packageName}\" was specified more than once` +\n                    ` in the rush.json configuration file.`);\n            }\n            this._projectsByName.set(project.packageName, project);\n        }\n        for (const project of this._projects) {\n            project.decoupledLocalDependencies.forEach((decoupledLocalDependency) => {\n                if (!this.getProjectByName(decoupledLocalDependency)) {\n                    throw new Error(`In rush.json, the \"${decoupledLocalDependency}\" project does not exist,` +\n                        ` but was referenced by the decoupledLocalDependencies (previously cyclicDependencyProjects) for ${project.packageName}`);\n                }\n            });\n            this.versionPolicyConfiguration.validate(this.projectsByName);\n            // Consumer relationships will be established the first time one is requested\n        }\n    }\n    /**\n     * Loads the configuration data from an Rush.json configuration file and returns\n     * an RushConfiguration object.\n     */\n    static loadFromConfigurationFile(rushJsonFilename) {\n        let resolvedRushJsonFilename = path.resolve(rushJsonFilename);\n        // Load the rush.json before we fix the casing. If the case is wrong on a case-sensitive filesystem,\n        // the next line show throw.\n        const rushConfigurationJson = JsonFile.load(resolvedRushJsonFilename);\n        try {\n            resolvedRushJsonFilename = trueCasePathSync(resolvedRushJsonFilename);\n        }\n        catch (error) {\n            /* ignore errors from true-case-path */\n        }\n        // Check the Rush version *before* we validate the schema, since if the version is outdated\n        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,\n        // but we'll validate anyway.\n        const expectedRushVersion = rushConfigurationJson.rushVersion;\n        const rushJsonBaseName = path.basename(resolvedRushJsonFilename);\n        // If the version is missing or malformed, fall through and let the schema handle it.\n        if (expectedRushVersion && semver.valid(expectedRushVersion)) {\n            // Make sure the requested version isn't too old\n            if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {\n                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +\n                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);\n            }\n            // Make sure the requested version isn't too new.\n            //\n            // If the major/minor versions are the same, then we consider the file to be compatible.\n            // This is somewhat lax, e.g. \"5.0.2-dev.3\" will be assumed to be loadable by rush-lib 5.0.0.\n            //\n            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must\n            // increment the minor version number for Rush.\n            if (semver.major(Rush.version) !== semver.major(expectedRushVersion) ||\n                semver.minor(Rush.version) !== semver.minor(expectedRushVersion)) {\n                // If the major/minor are different, then make sure it's an older version.\n                if (semver.lt(Rush.version, expectedRushVersion)) {\n                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is` +\n                        ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${Rush.version}.` +\n                        ` Consider upgrading the library.`);\n                }\n            }\n        }\n        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, resolvedRushJsonFilename);\n        return new RushConfiguration(rushConfigurationJson, resolvedRushJsonFilename);\n    }\n    static tryLoadFromDefaultLocation(options) {\n        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation(options);\n        if (rushJsonLocation) {\n            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);\n        }\n    }\n    static loadFromDefaultLocation(options) {\n        const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation(options);\n        if (rushConfiguration) {\n            return rushConfiguration;\n        }\n        else {\n            throw Utilities.getRushConfigNotFoundError();\n        }\n    }\n    /**\n     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.\n     *\n     * @privateRemarks\n     * Keep this in sync with `findRushJsonLocation` in `rush-sdk/src/index.ts`.\n     */\n    static tryFindRushJsonLocation(options) {\n        const optionsIn = options || {};\n        const verbose = optionsIn.showVerbose || false;\n        let currentFolder = optionsIn.startingFolder || process.cwd();\n        // Look upwards at parent folders until we find a folder containing rush.json\n        for (let i = 0; i < 10; ++i) {\n            const rushJsonFilename = path.join(currentFolder, 'rush.json');\n            if (FileSystem.exists(rushJsonFilename)) {\n                if (i > 0 && verbose) {\n                    // eslint-disable-next-line no-console\n                    console.log('Found configuration in ' + rushJsonFilename);\n                }\n                if (verbose) {\n                    // eslint-disable-next-line no-console\n                    console.log('');\n                }\n                return rushJsonFilename;\n            }\n            const parentFolder = path.dirname(currentFolder);\n            if (parentFolder === currentFolder) {\n                break;\n            }\n            currentFolder = parentFolder;\n        }\n        return undefined;\n    }\n    /**\n     * This generates the unique names that are used to create temporary projects\n     * in the Rush common folder.\n     * NOTE: sortedProjectJsons is sorted by the caller.\n     */\n    static _generateTempNameForProject(projectJson, usedTempNames) {\n        // If the name is \"@ms/MyProject\", extract the \"MyProject\" part\n        const unscopedName = PackageNameParsers.permissive.getUnscopedName(projectJson.packageName);\n        // Generate a unique like name \"@rush-temp/MyProject\", or \"@rush-temp/MyProject-2\" if\n        // there is a naming conflict\n        let counter = 0;\n        let tempProjectName = `${RushConstants.rushTempNpmScope}/${unscopedName}`;\n        while (usedTempNames.has(tempProjectName)) {\n            ++counter;\n            tempProjectName = `${RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;\n        }\n        usedTempNames.add(tempProjectName);\n        return tempProjectName;\n    }\n    /**\n     * If someone adds a config file in the \"common/rush/config\" folder, it would be a bad\n     * experience for Rush to silently ignore their file simply because they misspelled the\n     * filename, or maybe it's an old format that's no longer supported.  The\n     * _validateCommonRushConfigFolder() function makes sure that this folder only contains\n     * recognized config files.\n     */\n    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManagerWrapper, experiments) {\n        if (!FileSystem.exists(commonRushConfigFolder)) {\n            // eslint-disable-next-line no-console\n            console.log(`Creating folder: ${commonRushConfigFolder}`);\n            FileSystem.ensureFolder(commonRushConfigFolder);\n            return;\n        }\n        for (const filename of FileSystem.readFolderItemNames(commonRushConfigFolder)) {\n            // Ignore things that aren't actual files\n            const stat = FileSystem.getLinkStatistics(path.join(commonRushConfigFolder, filename));\n            if (!stat.isFile() && !stat.isSymbolicLink()) {\n                continue;\n            }\n            // Ignore harmless file extensions\n            const fileExtension = path.extname(filename);\n            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {\n                continue;\n            }\n            // Ignore hidden files such as \".DS_Store\"\n            if (filename.startsWith('.')) {\n                continue;\n            }\n            if (filename.startsWith('deploy-') && fileExtension === '.json') {\n                // Ignore \"rush deploy\" files, which use the naming pattern \"deploy-<scenario-name>.json\".\n                continue;\n            }\n            const knownSet = new Set(knownRushConfigFilenames.map((x) => x.toUpperCase()));\n            // Add the shrinkwrap filename for the package manager to the known set.\n            knownSet.add(packageManagerWrapper.shrinkwrapFilename.toUpperCase());\n            // If the package manager is pnpm, then also add the pnpm file to the known set.\n            if (packageManagerWrapper.packageManager === 'pnpm') {\n                knownSet.add(packageManagerWrapper.pnpmfileFilename.toUpperCase());\n            }\n            // Is the filename something we know?  If not, report an error.\n            if (!knownSet.has(filename.toUpperCase())) {\n                throw new Error(`An unrecognized file \"${filename}\" was found in the Rush config folder:` +\n                    ` ${commonRushConfigFolder}`);\n            }\n        }\n        const pinnedVersionsFilename = path.join(commonRushConfigFolder, RushConstants.pinnedVersionsFilename);\n        if (FileSystem.exists(pinnedVersionsFilename)) {\n            throw new Error('The \"pinned-versions.json\" config file is no longer supported;' +\n                ' please move your settings to the \"preferredVersions\" field of a \"common-versions.json\" config file.' +\n                ` (See the ${RushConstants.rushWebSiteUrl} documentation for details.)\\n\\n` +\n                pinnedVersionsFilename);\n        }\n    }\n    /**\n     * The fully resolved path for the \"autoinstallers\" folder.\n     * Example: `C:\\MyRepo\\common\\autoinstallers`\n     */\n    get commonAutoinstallersFolder() {\n        return path.join(this.commonFolder, 'autoinstallers');\n    }\n    /**\n     * The folder where rush-plugin options json files are stored.\n     * Example: `C:\\MyRepo\\common\\config\\rush-plugins`\n     */\n    get rushPluginOptionsFolder() {\n        return path.join(this.commonFolder, 'config', 'rush-plugins');\n    }\n    /**\n     * The full path of the shrinkwrap file that is tracked by Git.  (The \"rush install\"\n     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)\n     * @remarks\n     * This property merely reports the filename; the file itself may not actually exist.\n     * Example: `C:\\MyRepo\\common\\npm-shrinkwrap.json` or `C:\\MyRepo\\common\\pnpm-lock.yaml`\n     *\n     * @deprecated Use `getCommittedShrinkwrapFilename` instead, which gets the correct common\n     * shrinkwrap file name for a given active variant.\n     */\n    get committedShrinkwrapFilename() {\n        return this.getCommittedShrinkwrapFilename();\n    }\n    /**\n     * Returns an English phrase such as \"shrinkwrap file\" that can be used in logging messages\n     * to refer to the shrinkwrap file using appropriate terminology for the currently selected\n     * package manager.\n     */\n    get shrinkwrapFilePhrase() {\n        if (this.packageManager === 'yarn') {\n            // Eventually we'd like to be consistent with Yarn's terminology of calling this a \"lock file\",\n            // but a lot of Rush documentation uses \"shrinkwrap\" file and would all need to be updated.\n            return 'shrinkwrap file (yarn.lock)';\n        }\n        else {\n            return 'shrinkwrap file';\n        }\n    }\n    /**\n     * The filename of the build dependency data file.  By default this is\n     * called 'rush-link.json' resides in the Rush common folder.\n     * Its data structure is defined by IRushLinkJson.\n     *\n     * Example: `C:\\MyRepo\\common\\temp\\rush-link.json`\n     *\n     * @deprecated The \"rush-link.json\" file was removed in Rush 5.30.0.\n     * Use `RushConfigurationProject.localDependencyProjects` instead.\n     */\n    get rushLinkJsonFilename() {\n        throw new Error('The \"rush-link.json\" file was removed in Rush 5.30.0. Use ' +\n            'RushConfigurationProject.localDependencyProjects instead.');\n    }\n    /**\n     * The default fully-qualified git remote branch of the repository. This helps \"rush change\" find the right branch to compare against.\n     */\n    get repositoryDefaultFullyQualifiedRemoteBranch() {\n        return `${this.repositoryDefaultRemote}/${this.repositoryDefaultBranch}`;\n    }\n    get projects() {\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        return this._projects;\n    }\n    get projectsByName() {\n        if (!this._projectsByName) {\n            this._initializeAndValidateLocalProjects();\n        }\n        return this._projectsByName;\n    }\n    /**\n     * Obtains the mapping from custom tags to projects.\n     * @beta\n     */\n    get projectsByTag() {\n        if (!this._projectsByTag) {\n            const projectsByTag = new Map();\n            for (const project of this.projects) {\n                for (const tag of project.tags) {\n                    let collection = projectsByTag.get(tag);\n                    if (!collection) {\n                        projectsByTag.set(tag, (collection = new Set()));\n                    }\n                    collection.add(project);\n                }\n            }\n            this._projectsByTag = projectsByTag;\n        }\n        return this._projectsByTag;\n    }\n    /**\n     * Settings from the common-versions.json config file.\n     * @remarks\n     * If the common-versions.json file is missing, this property will not be undefined.\n     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()\n     * will create the file.\n     *\n     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data\n     * for a given active variant.\n     */\n    get commonVersions() {\n        return this.getCommonVersions();\n    }\n    /**\n     * Gets the currently-installed variant, if an installation has occurred.\n     * For Rush operations which do not take a --variant parameter, this method\n     * determines which variant, if any, was last specified when performing \"rush install\"\n     * or \"rush update\".\n     */\n    get currentInstalledVariant() {\n        let variant;\n        if (FileSystem.exists(this.currentVariantJsonFilename)) {\n            const currentVariantJson = JsonFile.load(this.currentVariantJsonFilename);\n            variant = currentVariantJson.variant || undefined;\n        }\n        return variant;\n    }\n    /**\n     * Gets the path to the common-versions.json config file for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     */\n    getCommonVersionsFilePath(variant) {\n        const commonVersionsFilename = path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants.rushVariantsFolderName, variant] : []), RushConstants.commonVersionsFilename);\n        return commonVersionsFilename;\n    }\n    /**\n     * Gets the settings from the common-versions.json config file for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     */\n    getCommonVersions(variant) {\n        if (!this._commonVersionsConfigurationsByVariant) {\n            this._commonVersionsConfigurationsByVariant = new Map();\n        }\n        // Use an empty string as the key when no variant provided. Anything else would possibly conflict\n        // with a variant created by the user\n        const variantKey = variant || '';\n        let commonVersionsConfiguration = this._commonVersionsConfigurationsByVariant.get(variantKey);\n        if (!commonVersionsConfiguration) {\n            const commonVersionsFilename = this.getCommonVersionsFilePath(variant);\n            commonVersionsConfiguration = CommonVersionsConfiguration.loadFromFile(commonVersionsFilename);\n            this._commonVersionsConfigurationsByVariant.set(variantKey, commonVersionsConfiguration);\n        }\n        return commonVersionsConfiguration;\n    }\n    /**\n     * Returns a map of all direct dependencies that only have a single semantic version specifier.\n     * @param variant - The name of the current variant in use by the active command.\n     *\n     * @returns A map of dependency name --\\> version specifier for implicitly preferred versions.\n     */\n    getImplicitlyPreferredVersions(variant) {\n        // TODO: During the next major release of Rush, replace this `require` call with a dynamic import, and\n        // change this function to be async.\n        const DependencyAnalyzerModule = require('../logic/DependencyAnalyzer');\n        const dependencyAnalyzer = DependencyAnalyzerModule.DependencyAnalyzer.forRushConfiguration(this);\n        const dependencyAnalysis = dependencyAnalyzer.getAnalysis(variant);\n        return dependencyAnalysis.implicitlyPreferredVersionByPackageName;\n    }\n    /**\n     * Gets the path to the repo-state.json file for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     */\n    getRepoStateFilePath(variant) {\n        const repoStateFilename = path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants.rushVariantsFolderName, variant] : []), RushConstants.repoStateFilename);\n        return repoStateFilename;\n    }\n    /**\n     * Gets the contents from the repo-state.json file for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     */\n    getRepoState(variant) {\n        const repoStateFilename = this.getRepoStateFilePath(variant);\n        return RepoStateFile.loadFromFile(repoStateFilename, variant);\n    }\n    /**\n     * Gets the committed shrinkwrap file name for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     */\n    getCommittedShrinkwrapFilename(variant) {\n        if (variant) {\n            if (!this._variants.has(variant)) {\n                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +\n                    `one of the following from rush.json: ` +\n                    `${Array.from(this._variants.values())\n                        .map((name) => `\"${name}\"`)\n                        .join(', ')}.`);\n            }\n        }\n        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);\n        return path.join(variantConfigFolderPath, this.shrinkwrapFilename);\n    }\n    /**\n     * Gets the absolute path for \"pnpmfile.js\" for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     * @remarks\n     * The file path is returned even if PNPM is not configured as the package manager.\n     */\n    getPnpmfilePath(variant) {\n        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);\n        return path.join(variantConfigFolderPath, this.packageManagerWrapper.pnpmfileFilename);\n    }\n    /**\n     * Looks up a project in the projectsByName map.  If the project is not found,\n     * then undefined is returned.\n     */\n    getProjectByName(projectName) {\n        return this.projectsByName.get(projectName);\n    }\n    /**\n     * This is used e.g. by command-line interfaces such as \"rush build --to example\".\n     * If \"example\" is not a project name, then it also looks for a scoped name\n     * like `@something/example`.  If exactly one project matches this heuristic, it\n     * is returned.  Otherwise, undefined is returned.\n     */\n    findProjectByShorthandName(shorthandProjectName) {\n        // Is there an exact match?\n        let result = this.projectsByName.get(shorthandProjectName);\n        if (result) {\n            return result;\n        }\n        // Is there an approximate match?\n        for (const project of this.projects) {\n            if (this.packageNameParser.getUnscopedName(project.packageName) === shorthandProjectName) {\n                if (result) {\n                    // Ambiguous -- there is more than one match\n                    return undefined;\n                }\n                else {\n                    result = project;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Looks up a project by its RushConfigurationProject.tempProjectName field.\n     * @returns The found project, or undefined if no match was found.\n     */\n    findProjectByTempName(tempProjectName) {\n        // Is there an approximate match?\n        for (const project of this.projects) {\n            if (project.tempProjectName === tempProjectName) {\n                return project;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * @returns An optimized lookup engine to find a project by its path relative to the specified root.\n     * @beta\n     */\n    getProjectLookupForRoot(rootPath) {\n        let pathTree = this._pathTrees.get(rootPath);\n        if (!pathTree) {\n            this._pathTrees.set(rootPath, (pathTree = new LookupByPath()));\n            for (const project of this.projects) {\n                const relativePath = path.relative(rootPath, project.projectFolder);\n                pathTree.setItemFromSegments(LookupByPath.iteratePathSegments(relativePath, path.sep), project);\n            }\n        }\n        return pathTree;\n    }\n    /**\n     * Returns the project for which the specified path is underneath that project's folder.\n     * If the path is not under any project's folder, returns undefined.\n     */\n    tryGetProjectForPath(currentFolderPath) {\n        // TODO: Improve the method in which a package is found, perhaps without having to sort / loop though the entire package list\n        const resolvedPath = path.resolve(currentFolderPath);\n        const sortedProjects = this.projects.sort((a, b) => b.projectFolder.length - a.projectFolder.length);\n        for (const project of sortedProjects) {\n            if (Path.isUnderOrEqual(resolvedPath, project.projectFolder)) {\n                return project;\n            }\n        }\n        return undefined;\n    }\n    _getVariantConfigFolderPath(variant) {\n        if (variant) {\n            if (!this._variants.has(variant)) {\n                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +\n                    `one of the following from rush.json: ` +\n                    `${Array.from(this._variants.values())\n                        .map((name) => `\"${name}\"`)\n                        .join(', ')}.`);\n            }\n        }\n        return path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants.rushVariantsFolderName, variant] : []));\n    }\n}\nRushConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { RushConfiguration };\n//# sourceMappingURL=RushConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, FileConstants } from '@rushstack/node-core-library';\nimport { RushConstants } from '../logic/RushConstants';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { DependencySpecifier, DependencySpecifierType } from '../logic/DependencySpecifier';\nimport { SaveCallbackPackageJsonEditor } from './SaveCallbackPackageJsonEditor';\n/**\n * This represents the configuration of a project that is built by Rush, based on\n * the Rush.json configuration file.\n * @public\n */\nexport class RushConfigurationProject {\n    /**\n     * The parsed NPM \"package.json\" file from projectFolder.\n     */\n    get packageJson() {\n        return this._packageJson;\n    }\n    /** @internal */\n    constructor(options) {\n        this._versionPolicy = undefined;\n        this._dependencyProjects = undefined;\n        this._consumingProjects = undefined;\n        const { projectJson, rushConfiguration, tempProjectName, allowedProjectTags } = options;\n        this.rushConfiguration = rushConfiguration;\n        this.packageName = projectJson.packageName;\n        this.projectRelativeFolder = projectJson.projectFolder;\n        // For example, the depth of \"a/b/c\" would be 3.  The depth of \"a\" is 1.\n        const projectFolderDepth = projectJson.projectFolder.split('/').length;\n        if (projectFolderDepth < rushConfiguration.projectFolderMinDepth) {\n            throw new Error(`To keep things organized, this repository has a projectFolderMinDepth policy` +\n                ` requiring project folders to be at least ${rushConfiguration.projectFolderMinDepth} levels deep.` +\n                `  Problem folder: \"${projectJson.projectFolder}\"`);\n        }\n        if (projectFolderDepth > rushConfiguration.projectFolderMaxDepth) {\n            throw new Error(`To keep things organized, this repository has a projectFolderMaxDepth policy` +\n                ` preventing project folders from being deeper than ${rushConfiguration.projectFolderMaxDepth} levels.` +\n                `  Problem folder:  \"${projectJson.projectFolder}\"`);\n        }\n        this.projectFolder = path.join(rushConfiguration.rushJsonFolder, projectJson.projectFolder);\n        const packageJsonFilename = path.join(this.projectFolder, FileConstants.PackageJson);\n        try {\n            const packageJsonText = FileSystem.readFile(packageJsonFilename);\n            // JSON.parse is native and runs in less than 1/2 the time of jju.parse. package.json is required to be strict JSON by NodeJS.\n            this._packageJson = JSON.parse(packageJsonText);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                throw new Error(`Could not find package.json for ${projectJson.packageName} at ${packageJsonFilename}`);\n            }\n            throw error;\n        }\n        this.projectRushConfigFolder = path.join(this.projectFolder, 'config', 'rush');\n        this.projectRushTempFolder = path.join(this.projectFolder, RushConstants.projectRushFolderName, RushConstants.rushTempFolderName);\n        // Are we using a package review file?\n        if (rushConfiguration.approvedPackagesPolicy.enabled) {\n            // If so, then every project needs to have a reviewCategory that was defined\n            // by the reviewCategories array.\n            if (!projectJson.reviewCategory) {\n                throw new Error(`The \"approvedPackagesPolicy\" feature is enabled rush.json, but a reviewCategory` +\n                    ` was not specified for the project \"${projectJson.packageName}\".`);\n            }\n            if (!rushConfiguration.approvedPackagesPolicy.reviewCategories.has(projectJson.reviewCategory)) {\n                throw new Error(`The project \"${projectJson.packageName}\" specifies its reviewCategory as` +\n                    `\"${projectJson.reviewCategory}\" which is not one of the defined reviewCategories.`);\n            }\n            this.reviewCategory = projectJson.reviewCategory;\n        }\n        if (this.packageJson.name !== this.packageName) {\n            throw new Error(`The package name \"${this.packageName}\" specified in rush.json does not` +\n                ` match the name \"${this.packageJson.name}\" from package.json`);\n        }\n        if (!semver.valid(this.packageJson.version)) {\n            throw new Error(`The value \"${this.packageJson.version}\" is not valid SemVer syntax for the \\\"version\\\" field` +\n                ` in the file \"${packageJsonFilename}\"`);\n        }\n        this.packageJsonEditor = SaveCallbackPackageJsonEditor.fromObjectWithCallback({\n            object: this.packageJson,\n            filename: packageJsonFilename,\n            onSaved: (newObject) => {\n                // Just update the in-memory copy, don't bother doing the validation again\n                this._packageJson = newObject;\n                this._dependencyProjects = undefined; // Reset the cached dependency projects\n            }\n        });\n        this.tempProjectName = tempProjectName;\n        // The \"rushProject.tempProjectName\" is guaranteed to be unique name (e.g. by adding the \"-2\"\n        // suffix).  Even after we strip the NPM scope, it will still be unique.\n        // Example: \"my-project-2\"\n        this.unscopedTempProjectName = PackageNameParsers.permissive.getUnscopedName(tempProjectName);\n        this.decoupledLocalDependencies = new Set();\n        if (projectJson.cyclicDependencyProjects || projectJson.decoupledLocalDependencies) {\n            if (projectJson.cyclicDependencyProjects && projectJson.decoupledLocalDependencies) {\n                throw new Error('A project configuration cannot specify both \"decoupledLocalDependencies\" and \"cyclicDependencyProjects\". Please use \"decoupledLocalDependencies\" only -- the other name is deprecated.');\n            }\n            for (const cyclicDependencyProject of projectJson.cyclicDependencyProjects ||\n                projectJson.decoupledLocalDependencies) {\n                this.decoupledLocalDependencies.add(cyclicDependencyProject);\n            }\n        }\n        this._shouldPublish = !!projectJson.shouldPublish;\n        this.skipRushCheck = !!projectJson.skipRushCheck;\n        this.versionPolicyName = projectJson.versionPolicyName;\n        if (this._shouldPublish && this.packageJson.private) {\n            throw new Error(`The project \"${projectJson.packageName}\" specifies \"shouldPublish\": true, ` +\n                `but the package.json file specifies \"private\": true.`);\n        }\n        this.publishFolder = this.projectFolder;\n        if (projectJson.publishFolder) {\n            this.publishFolder = path.join(this.publishFolder, projectJson.publishFolder);\n        }\n        if (allowedProjectTags && projectJson.tags) {\n            this.tags = new Set();\n            for (const tag of projectJson.tags) {\n                if (!allowedProjectTags.has(tag)) {\n                    throw new Error(`The tag \"${tag}\" specified for project \"${this.packageName}\" is not listed in the ` +\n                        `allowedProjectTags field in rush.json.`);\n                }\n                else {\n                    this.tags.add(tag);\n                }\n            }\n        }\n        else {\n            this.tags = new Set(projectJson.tags);\n        }\n    }\n    /**\n     * A list of local projects that appear as devDependencies for this project, but cannot be\n     * locally linked because it would create a cyclic dependency; instead, the last published\n     * version will be installed in the Common folder.\n     *\n     * These are package names that would be found by RushConfiguration.getProjectByName().\n     *\n     * @deprecated Use `decoupledLocalDependencies` instead, as it better describes the purpose of the data.\n     */\n    get cyclicDependencyProjects() {\n        return this.decoupledLocalDependencies;\n    }\n    /**\n     * An array of projects within the Rush configuration which directly depend on this package.\n     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature\n     * of the data.\n     */\n    get downstreamDependencyProjects() {\n        return Array.from(this.consumingProjects, (project) => project.packageName);\n    }\n    /**\n     * An array of projects within the Rush configuration which this project declares as dependencies.\n     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature\n     * of the data.\n     */\n    get localDependencyProjects() {\n        return [...this.dependencyProjects];\n    }\n    /**\n     * The set of projects within the Rush configuration which this project declares as dependencies.\n     *\n     * @remarks\n     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly\n     * referenced from this project.\n     */\n    get dependencyProjects() {\n        let dependencyProjects = this._dependencyProjects;\n        if (!dependencyProjects) {\n            this._dependencyProjects = dependencyProjects = new Set();\n            const { packageJson } = this;\n            for (const dependencySet of [\n                packageJson.dependencies,\n                packageJson.devDependencies,\n                packageJson.optionalDependencies\n            ]) {\n                if (dependencySet) {\n                    for (const [dependency, version] of Object.entries(dependencySet)) {\n                        // Skip if we can't find the local project or it's a cyclic dependency\n                        const localProject = this.rushConfiguration.getProjectByName(dependency);\n                        if (localProject && !this.decoupledLocalDependencies.has(dependency)) {\n                            // Set the value if it's a workspace project, or if we have a local project and the semver is satisfied\n                            const dependencySpecifier = new DependencySpecifier(dependency, version);\n                            switch (dependencySpecifier.specifierType) {\n                                case DependencySpecifierType.Version:\n                                case DependencySpecifierType.Range:\n                                    if (semver.satisfies(localProject.packageJson.version, dependencySpecifier.versionSpecifier)) {\n                                        dependencyProjects.add(localProject);\n                                    }\n                                    break;\n                                case DependencySpecifierType.Workspace:\n                                    dependencyProjects.add(localProject);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dependencyProjects;\n    }\n    /**\n     * The set of projects within the Rush configuration which declare this project as a dependency.\n     * Excludes those that declare this project as a `cyclicDependencyProject`.\n     *\n     * @remarks\n     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency\n     * graph to find all projects which will be impacted by changes to this project.\n     */\n    get consumingProjects() {\n        if (!this._consumingProjects) {\n            // Force initialize all dependency relationships\n            // This needs to operate on every project in the set because the relationships are only specified\n            // in the consuming project\n            const { projects } = this.rushConfiguration;\n            for (const project of projects) {\n                project._consumingProjects = new Set();\n            }\n            for (const project of projects) {\n                for (const dependency of project.dependencyProjects) {\n                    dependency._consumingProjects.add(project);\n                }\n            }\n        }\n        return this._consumingProjects;\n    }\n    /**\n     * A flag which indicates whether changes to this project should be published. This controls\n     * whether or not the project would show up when running `rush change`, and whether or not it\n     * should be published during `rush publish`.\n     */\n    get shouldPublish() {\n        return this._shouldPublish || !!this.versionPolicyName;\n    }\n    /**\n     * Version policy of the project\n     * @beta\n     */\n    get versionPolicy() {\n        if (!this._versionPolicy) {\n            if (this.versionPolicyName && this.rushConfiguration.versionPolicyConfiguration) {\n                this._versionPolicy = this.rushConfiguration.versionPolicyConfiguration.getVersionPolicy(this.versionPolicyName);\n            }\n        }\n        return this._versionPolicy;\n    }\n    /**\n     * Indicate whether this project is the main project for the related version policy.\n     *\n     * False if the project is not for publishing.\n     * True if the project is individually versioned or if its lockstep version policy does not specify main project.\n     * False if the project is lockstepped and is not the main project for its version policy.\n     *\n     * @beta\n     */\n    get isMainProject() {\n        if (!this.shouldPublish) {\n            return false;\n        }\n        let isMain = true;\n        if (this.versionPolicy && this.versionPolicy.isLockstepped) {\n            const lockStepPolicy = this.versionPolicy;\n            if (lockStepPolicy.mainProject && lockStepPolicy.mainProject !== this.packageName) {\n                isMain = false;\n            }\n        }\n        return isMain;\n    }\n}\n//# sourceMappingURL=RushConfigurationProject.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Utilities } from '../utilities/Utilities';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\n/**\n * This class provides global folders that are used for rush's internal install locations.\n *\n * @internal\n */\nexport class RushGlobalFolder {\n    constructor() {\n        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration\n        // is initialized, we need to read it using a special internal API.\n        const rushGlobalFolderOverride = EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        if (rushGlobalFolderOverride !== undefined) {\n            this.path = rushGlobalFolderOverride;\n        }\n        else {\n            this.path = path.join(Utilities.getHomeFolder(), '.rush');\n        }\n        const normalizedNodeVersion = process.version.match(/^[a-z0-9\\-\\.]+$/i)\n            ? process.version\n            : 'unknown-version';\n        this.nodeSpecificPath = path.join(this.path, `node-${normalizedNodeVersion}`);\n    }\n}\n//# sourceMappingURL=RushGlobalFolder.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Rush } from './Rush';\n/**\n * Used by rush-sdk to access internals of rush-lib.\n * @internal\n */\nexport class RushInternals {\n    /**\n     * Used by rush-sdk to load an internal API specified by its module path.\n     *\n     * @param srcImportPath - The module path to load.  For example, to refer to `src/api/ChangeFile.ts`,\n     * the `srcImportPath` would be `\"api/ChangeFile\"`.\n     * @returns the module object as would be returned by `require()`\n     */\n    static loadModule(srcImportPath) {\n        const libPath = `${Rush._rushLibPackageFolder}/lib/${srcImportPath}`;\n        try {\n            return require(libPath);\n        }\n        catch (e) {\n            throw new Error(`The specified internal API \"src/${srcImportPath}\" is not implemented by Rush ${Rush.version}`);\n        }\n    }\n}\n//# sourceMappingURL=RushInternals.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/rush-plugins.schema.json';\nclass RushPluginsConfiguration {\n    constructor(jsonFilename) {\n        this._jsonFilename = jsonFilename;\n        this.configuration = {\n            plugins: []\n        };\n        if (FileSystem.exists(this._jsonFilename)) {\n            this.configuration = JsonFile.loadAndValidate(this._jsonFilename, RushPluginsConfiguration._jsonSchema);\n        }\n    }\n}\nRushPluginsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { RushPluginsConfiguration };\n//# sourceMappingURL=RushPluginsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, Async, Path } from '@rushstack/node-core-library';\nimport { ConfigurationFile, InheritanceType } from '@rushstack/heft-config-file';\nimport { RigConfig } from '@rushstack/rig-package';\nimport { RushConstants } from '../logic/RushConstants';\nimport { OverlappingPathAnalyzer } from '../utilities/OverlappingPathAnalyzer';\nimport schemaJson from '../schemas/rush-project.schema.json';\nimport anythingSchemaJson from '../schemas/rush-project.schema.json';\nconst RUSH_PROJECT_CONFIGURATION_FILE = new ConfigurationFile({\n    projectRelativeFilePath: `config/${RushConstants.rushProjectConfigFilename}`,\n    jsonSchemaObject: schemaJson,\n    propertyInheritance: {\n        operationSettings: {\n            inheritanceType: InheritanceType.custom,\n            inheritanceFunction: (child, parent) => {\n                if (!child) {\n                    return parent;\n                }\n                else if (!parent) {\n                    return child;\n                }\n                else {\n                    // Merge any properties that need to be merged\n                    const resultOperationSettingsByOperationName = new Map();\n                    for (const parentOperationSettings of parent) {\n                        resultOperationSettingsByOperationName.set(parentOperationSettings.operationName, parentOperationSettings);\n                    }\n                    const childEncounteredOperationNames = new Set();\n                    for (const childOperationSettings of child) {\n                        const operationName = childOperationSettings.operationName;\n                        if (childEncounteredOperationNames.has(operationName)) {\n                            // If the operation settings already exist, but didn't come from the parent, then\n                            // it shows up multiple times in the child.\n                            const childSourceFilePath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child);\n                            throw new Error(`The operation \"${operationName}\" occurs multiple times in the \"operationSettings\" array ` +\n                                `in \"${childSourceFilePath}\".`);\n                        }\n                        childEncounteredOperationNames.add(operationName);\n                        let mergedOperationSettings = resultOperationSettingsByOperationName.get(operationName);\n                        if (mergedOperationSettings) {\n                            // The parent operation settings object already exists\n                            const outputFolderNames = mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames\n                                ? [\n                                    ...mergedOperationSettings.outputFolderNames,\n                                    ...childOperationSettings.outputFolderNames\n                                ]\n                                : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;\n                            const dependsOnEnvVars = mergedOperationSettings.dependsOnEnvVars && childOperationSettings.dependsOnEnvVars\n                                ? [\n                                    ...mergedOperationSettings.dependsOnEnvVars,\n                                    ...childOperationSettings.dependsOnEnvVars\n                                ]\n                                : mergedOperationSettings.dependsOnEnvVars || childOperationSettings.dependsOnEnvVars;\n                            mergedOperationSettings = Object.assign(Object.assign(Object.assign(Object.assign({}, mergedOperationSettings), childOperationSettings), (outputFolderNames ? { outputFolderNames } : {})), (dependsOnEnvVars ? { dependsOnEnvVars } : {}));\n                            resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);\n                        }\n                        else {\n                            resultOperationSettingsByOperationName.set(operationName, childOperationSettings);\n                        }\n                    }\n                    return Array.from(resultOperationSettingsByOperationName.values());\n                }\n            }\n        },\n        incrementalBuildIgnoredGlobs: {\n            inheritanceType: InheritanceType.replace\n        }\n    }\n});\nconst OLD_RUSH_PROJECT_CONFIGURATION_FILE = new ConfigurationFile({\n    projectRelativeFilePath: RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,\n    jsonSchemaObject: anythingSchemaJson\n});\n/**\n * Use this class to load the \"config/rush-project.json\" config file.\n *\n * This file provides project-specific configuration options.\n * @alpha\n */\nclass RushProjectConfiguration {\n    constructor(project, rushProjectJson, operationSettingsByOperationName) {\n        this._validationCache = new WeakSet();\n        this.project = project;\n        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];\n        this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;\n        this.operationSettingsByOperationName = operationSettingsByOperationName;\n    }\n    /**\n     * Validates that the requested phases are compatible.\n     * Deferral of this logic to its own method means that Rush no longer eagerly validates\n     * all defined commands in command-line.json. As such, while validation will be run for a given\n     * command upon invoking that command, defining overlapping phases in \"rush custom-command\"\n     * that are not used by \"rush build\" will not cause \"rush build\" to exit with an error.\n     */\n    validatePhaseConfiguration(phases, terminal) {\n        // Don't repeatedly validate the same set of phases for the same project.\n        if (this._validationCache.has(phases)) {\n            return;\n        }\n        const overlappingPathAnalyzer = new OverlappingPathAnalyzer();\n        const { operationSettingsByOperationName, project } = this;\n        let hasErrors = false;\n        for (const phase of phases) {\n            const operationName = phase.name;\n            const operationSettings = operationSettingsByOperationName.get(operationName);\n            if (operationSettings) {\n                if (operationSettings.outputFolderNames) {\n                    for (const outputFolderName of operationSettings.outputFolderNames) {\n                        const otherOverlappingOperationNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);\n                        if (otherOverlappingOperationNames) {\n                            const overlapsWithOwnOperation = otherOverlappingOperationNames === null || otherOverlappingOperationNames === void 0 ? void 0 : otherOverlappingOperationNames.includes(operationName);\n                            if (overlapsWithOwnOperation) {\n                                terminal.writeErrorLine(`The project \"${project.packageName}\" has a ` +\n                                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines an ` +\n                                    `operation with overlapping paths in the \"outputFolderNames\" list. The operation is ` +\n                                    `\"${operationName}\", and the conflicting path is \"${outputFolderName}\".`);\n                            }\n                            else {\n                                terminal.writeErrorLine(`The project \"${project.packageName}\" has a ` +\n                                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines ` +\n                                    'two operations in the same command whose \"outputFolderNames\" would overlap. ' +\n                                    'Operations outputs in the same command must be disjoint so that they can be independently cached. ' +\n                                    `The \"${outputFolderName}\" path overlaps between these operations: ` +\n                                    `\"${operationName}\", \"${otherOverlappingOperationNames.join('\", \"')}\"`);\n                            }\n                            hasErrors = true;\n                        }\n                    }\n                }\n            }\n        }\n        this._validationCache.add(phases);\n        if (hasErrors) {\n            throw new AlreadyReportedError();\n        }\n    }\n    /**\n     * Examines the list of source files for the project and the target phase and returns a reason\n     * why the project cannot enable the build cache for that phase, or undefined if it is safe to so do.\n     */\n    getCacheDisabledReason(trackedFileNames, phaseName) {\n        if (this.disableBuildCacheForProject) {\n            return 'Caching has been disabled for this project.';\n        }\n        const normalizedProjectRelativeFolder = Path.convertToSlashes(this.project.projectRelativeFolder);\n        const operationSettings = this.operationSettingsByOperationName.get(phaseName);\n        if (!operationSettings) {\n            return `This project does not define the caching behavior of the \"${phaseName}\" command, so caching has been disabled.`;\n        }\n        if (operationSettings.disableBuildCacheForOperation) {\n            return `Caching has been disabled for this project's \"${phaseName}\" command.`;\n        }\n        const { outputFolderNames } = operationSettings;\n        if (!outputFolderNames) {\n            return;\n        }\n        const normalizedOutputFolders = outputFolderNames.map((outputFolderName) => `${normalizedProjectRelativeFolder}/${outputFolderName}/`);\n        const inputOutputFiles = [];\n        for (const file of trackedFileNames) {\n            for (const outputFolder of normalizedOutputFolders) {\n                if (file.startsWith(outputFolder)) {\n                    inputOutputFiles.push(file);\n                }\n            }\n        }\n        if (inputOutputFiles.length > 0) {\n            return ('The following files are used to calculate project state ' +\n                `and are considered project output: ${inputOutputFiles.join(', ')}`);\n        }\n    }\n    /**\n     * Loads the rush-project.json data for the specified project.\n     */\n    static async tryLoadForProjectAsync(project, terminal) {\n        // false is a signal that the project config does not exist\n        const cacheEntry = RushProjectConfiguration._configCache.get(project);\n        if (cacheEntry !== undefined) {\n            return cacheEntry || undefined;\n        }\n        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);\n        if (rushProjectJson) {\n            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, terminal);\n            RushProjectConfiguration._configCache.set(project, result);\n            return result;\n        }\n        else {\n            RushProjectConfiguration._configCache.set(project, false);\n            return undefined;\n        }\n    }\n    /**\n     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping\n     * validation of other parts of the config file.\n     *\n     * @remarks\n     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without\n     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.\n     */\n    static async tryLoadIgnoreGlobsForProjectAsync(project, terminal) {\n        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);\n        return rushProjectJson === null || rushProjectJson === void 0 ? void 0 : rushProjectJson.incrementalBuildIgnoredGlobs;\n    }\n    /**\n     * Load the rush-project.json data for all selected projects.\n     * Validate compatibility of output folders across all selected phases.\n     */\n    static async tryLoadForProjectsAsync(projects, terminal) {\n        const result = new Map();\n        await Async.forEachAsync(projects, async (project) => {\n            const projectConfig = await RushProjectConfiguration.tryLoadForProjectAsync(project, terminal);\n            if (projectConfig) {\n                result.set(project, projectConfig);\n            }\n        }, { concurrency: 50 });\n        return result;\n    }\n    static async _tryLoadJsonForProjectAsync(project, terminal) {\n        const rigConfig = await RigConfig.loadForProjectFolderAsync({\n            projectFolderPath: project.projectFolder\n        });\n        try {\n            return await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);\n        }\n        catch (e1) {\n            // Detect if the project is using the old rush-project.json schema\n            let oldRushProjectJson;\n            try {\n                oldRushProjectJson =\n                    await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);\n            }\n            catch (e2) {\n                // Ignore\n            }\n            if ((oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.projectOutputFolderNames) ||\n                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.phaseOptions) ||\n                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.buildCacheOptions)) {\n                throw new Error(`The ${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +\n                    'in an outdated format. Please see the UPGRADING.md notes for details. ' +\n                    'Quick link: https://rushjs.io/link/upgrading');\n            }\n            else {\n                throw e1;\n            }\n        }\n    }\n    static _getRushProjectConfiguration(project, rushProjectJson, terminal) {\n        const operationSettingsByOperationName = new Map();\n        let hasErrors = false;\n        if (rushProjectJson.operationSettings) {\n            for (const operationSettings of rushProjectJson.operationSettings) {\n                const operationName = operationSettings.operationName;\n                const existingOperationSettings = operationSettingsByOperationName.get(operationName);\n                if (existingOperationSettings) {\n                    const existingOperationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);\n                    const operationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);\n                    hasErrors = true;\n                    let errorMessage = `The operation \"${operationName}\" appears multiple times in the \"${project.packageName}\" project's ` +\n                        `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +\n                        'operationSettings property.';\n                    if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {\n                        if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {\n                            errorMessage +=\n                                ` It first appears in \"${existingOperationSettingsJsonPath}\" and again ` +\n                                    `in \"${operationSettingsJsonPath}\".`;\n                        }\n                        else if (!Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(Path.convertToSlashes(project.projectFolder))) {\n                            errorMessage += ` It appears multiple times in \"${operationSettingsJsonPath}\".`;\n                        }\n                    }\n                    terminal.writeErrorLine(errorMessage);\n                }\n                else {\n                    operationSettingsByOperationName.set(operationName, operationSettings);\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new AlreadyReportedError();\n        }\n        return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);\n    }\n}\nRushProjectConfiguration._configCache = new Map();\nexport { RushProjectConfiguration };\n//# sourceMappingURL=RushProjectConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport * as path from 'path';\nimport { Utilities } from '../utilities/Utilities';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/rush-user-settings.schema.json';\n/**\n * Rush per-user configuration data.\n *\n * @beta\n */\nclass RushUserConfiguration {\n    constructor(rushUserConfigurationJson) {\n        this.buildCacheFolder = rushUserConfigurationJson === null || rushUserConfigurationJson === void 0 ? void 0 : rushUserConfigurationJson.buildCacheFolder;\n        if (this.buildCacheFolder && !path.isAbsolute(this.buildCacheFolder)) {\n            throw new Error('buildCacheFolder must be an absolute path');\n        }\n    }\n    static async initializeAsync() {\n        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();\n        const rushUserSettingsFilePath = path.join(rushUserFolderPath, 'settings.json');\n        let rushUserSettingsJson;\n        try {\n            rushUserSettingsJson = await JsonFile.loadAndValidateAsync(rushUserSettingsFilePath, RushUserConfiguration._schema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        return new RushUserConfiguration(rushUserSettingsJson);\n    }\n    static getRushUserFolderPath() {\n        const homeFolderPath = Utilities.getHomeFolder();\n        const rushUserSettingsFilePath = path.join(homeFolderPath, RushConstants.rushUserConfigurationFolderName);\n        return rushUserSettingsFilePath;\n    }\n}\nRushUserConfiguration._schema = JsonSchema.fromLoadedObject(schemaJson);\nexport { RushUserConfiguration };\n//# sourceMappingURL=RushUserConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonEditor } from './PackageJsonEditor';\nexport class SaveCallbackPackageJsonEditor extends PackageJsonEditor {\n    constructor(options) {\n        super(options.filename, options.object);\n        this._onSaved = options.onSaved;\n    }\n    static fromObjectWithCallback(options) {\n        return new SaveCallbackPackageJsonEditor(options);\n    }\n    saveIfModified() {\n        const modified = super.saveIfModified();\n        if (this._onSaved) {\n            this._onSaved(this.saveToObject());\n        }\n        return modified;\n    }\n}\n//# sourceMappingURL=SaveCallbackPackageJsonEditor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Namespace for utilities relating to the Variants feature.\n */\nclass Variants {\n}\n/**\n * Provides the parameter configuration for '--variant'.\n */\nVariants.VARIANT_PARAMETER = {\n    parameterLongName: '--variant',\n    argumentName: 'VARIANT',\n    description: 'Run command using a variant installation configuration',\n    environmentVariable: 'RUSH_VARIANT'\n};\nexport { Variants };\n//# sourceMappingURL=Variants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { Enum } from '@rushstack/node-core-library';\nimport { VersionFormatForCommit, VersionFormatForPublish } from './VersionPolicyConfiguration';\nimport { cloneDeep } from '../utilities/objectUtilities';\n/**\n * Type of version bumps\n * @public\n */\nexport var BumpType;\n(function (BumpType) {\n    // No version bump\n    BumpType[BumpType[\"none\"] = 0] = \"none\";\n    // Prerelease version bump\n    BumpType[BumpType[\"prerelease\"] = 1] = \"prerelease\";\n    // Patch version bump\n    BumpType[BumpType[\"patch\"] = 2] = \"patch\";\n    // Minor version bump\n    BumpType[BumpType[\"minor\"] = 4] = \"minor\";\n    // Major version bump\n    BumpType[BumpType[\"major\"] = 5] = \"major\";\n})(BumpType || (BumpType = {}));\n/**\n * Version policy base type names\n * @public\n */\nexport var VersionPolicyDefinitionName;\n(function (VersionPolicyDefinitionName) {\n    VersionPolicyDefinitionName[VersionPolicyDefinitionName[\"lockStepVersion\"] = 0] = \"lockStepVersion\";\n    VersionPolicyDefinitionName[VersionPolicyDefinitionName[\"individualVersion\"] = 1] = \"individualVersion\";\n})(VersionPolicyDefinitionName || (VersionPolicyDefinitionName = {}));\n/**\n * This is the base class for version policy which controls how versions get bumped.\n * @public\n */\nexport class VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        this.policyName = versionPolicyJson.policyName;\n        this.definitionName = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);\n        this.exemptFromRushChange = versionPolicyJson.exemptFromRushChange || false;\n        this.includeEmailInChangeFile = versionPolicyJson.includeEmailInChangeFile || false;\n        const jsonDependencies = versionPolicyJson.dependencies || {};\n        this._versionFormatForCommit = jsonDependencies.versionFormatForCommit || VersionFormatForCommit.original;\n        this._versionFormatForPublish =\n            jsonDependencies.versionFormatForPublish || VersionFormatForPublish.original;\n    }\n    /**\n     * Loads from version policy json\n     *\n     * @param versionPolicyJson - version policy Json\n     *\n     * @internal\n     */\n    static load(versionPolicyJson) {\n        const definition = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);\n        if (definition === VersionPolicyDefinitionName.lockStepVersion) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new LockStepVersionPolicy(versionPolicyJson);\n        }\n        else if (definition === VersionPolicyDefinitionName.individualVersion) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new IndividualVersionPolicy(versionPolicyJson);\n        }\n        return undefined;\n    }\n    /**\n     * Whether it is a lockstepped version policy\n     */\n    get isLockstepped() {\n        return this.definitionName === VersionPolicyDefinitionName.lockStepVersion;\n    }\n    /**\n     * Tells the version policy to modify any dependencies in the target package\n     * to values used for publishing.\n     */\n    setDependenciesBeforePublish(packageName, configuration) {\n        if (this._versionFormatForPublish === VersionFormatForPublish.exact) {\n            const project = configuration.getProjectByName(packageName);\n            const packageJsonEditor = project.packageJsonEditor;\n            for (const dependency of packageJsonEditor.dependencyList) {\n                const rushDependencyProject = configuration.getProjectByName(dependency.name);\n                if (rushDependencyProject) {\n                    const dependencyVersion = rushDependencyProject.packageJson.version;\n                    dependency.setVersion(dependencyVersion);\n                }\n            }\n            packageJsonEditor.saveIfModified();\n        }\n    }\n    /**\n     * Tells the version policy to modify any dependencies in the target package\n     * to values used for checked-in source.\n     */\n    setDependenciesBeforeCommit(packageName, configuration) {\n        if (this._versionFormatForCommit === VersionFormatForCommit.wildcard) {\n            const project = configuration.getProjectByName(packageName);\n            const packageJsonEditor = project.packageJsonEditor;\n            for (const dependency of packageJsonEditor.dependencyList) {\n                const rushDependencyProject = configuration.getProjectByName(dependency.name);\n                if (rushDependencyProject) {\n                    dependency.setVersion('*');\n                }\n            }\n            packageJsonEditor.saveIfModified();\n        }\n    }\n}\n/**\n * This policy indicates all related projects should use the same version.\n * @public\n */\nexport class LockStepVersionPolicy extends VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        super(versionPolicyJson);\n        this._version = new semver.SemVer(versionPolicyJson.version);\n        this.nextBump =\n            versionPolicyJson.nextBump !== undefined\n                ? Enum.getValueByKey(BumpType, versionPolicyJson.nextBump)\n                : undefined;\n        this.mainProject = versionPolicyJson.mainProject;\n    }\n    /**\n     * The value of the lockstep version\n     */\n    get version() {\n        return this._version.format();\n    }\n    /**\n     * Serialized json for this policy\n     *\n     * @internal\n     */\n    get _json() {\n        const json = {\n            policyName: this.policyName,\n            definitionName: VersionPolicyDefinitionName[this.definitionName],\n            version: this.version\n        };\n        if (this.nextBump !== undefined) {\n            json.nextBump = BumpType[this.nextBump];\n        }\n        if (this.mainProject !== undefined) {\n            json.mainProject = this.mainProject;\n        }\n        return json;\n    }\n    /**\n     * Returns an updated package json that satisfies the version policy.\n     *\n     * @param project - input package json\n     * @param force - force update even when the project version is higher than the policy version.\n     */\n    ensure(project, force) {\n        const packageVersion = new semver.SemVer(project.version);\n        const compareResult = packageVersion.compare(this._version);\n        if (compareResult === 0) {\n            return undefined;\n        }\n        else if (compareResult > 0 && !force) {\n            const errorMessage = `Version ${project.version} in package ${project.name}` +\n                ` is higher than locked version ${this._version.format()}.`;\n            throw new Error(errorMessage);\n        }\n        return this._updatePackageVersion(project, this._version);\n    }\n    /**\n     * Bumps the version of the lockstep policy\n     *\n     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.\n     * @param identifier - Prerelease identifier if bump type is prerelease.\n     */\n    bump(bumpType, identifier) {\n        const nextBump = bumpType !== null && bumpType !== void 0 ? bumpType : this.nextBump;\n        if (nextBump === undefined) {\n            // let change files drive version bump.\n            return;\n        }\n        this._version.inc(this._getReleaseType(nextBump), identifier);\n    }\n    /**\n     * Updates the version of the policy directly with a new value\n     * @param newVersionString - New version\n     */\n    update(newVersionString) {\n        const newVersion = new semver.SemVer(newVersionString);\n        if (!newVersion || this._version === newVersion) {\n            return false;\n        }\n        this._version = newVersion;\n        return true;\n    }\n    /**\n     * Validates the specified version and throws if the version does not satisfy lockstep version.\n     *\n     * @param versionString - version string\n     * @param packageName - package name\n     */\n    validate(versionString, packageName) {\n        const versionToTest = new semver.SemVer(versionString, false);\n        if (this._version.compare(versionToTest) !== 0) {\n            throw new Error(`Invalid version ${versionString} in ${packageName}`);\n        }\n    }\n    _updatePackageVersion(project, newVersion) {\n        const updatedProject = cloneDeep(project);\n        updatedProject.version = newVersion.format();\n        return updatedProject;\n    }\n    _getReleaseType(bumpType) {\n        // Eventually we should just use ReleaseType and get rid of bump type.\n        return BumpType[bumpType];\n    }\n}\n/**\n * This policy indicates all related projects get version bump driven by their own changes.\n * @public\n */\nexport class IndividualVersionPolicy extends VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        super(versionPolicyJson);\n        this.lockedMajor = versionPolicyJson.lockedMajor;\n    }\n    /**\n     * Serialized json for this policy\n     *\n     * @internal\n     */\n    get _json() {\n        const json = {\n            policyName: this.policyName,\n            definitionName: VersionPolicyDefinitionName[this.definitionName]\n        };\n        if (this.lockedMajor !== undefined) {\n            json.lockedMajor = this.lockedMajor;\n        }\n        return json;\n    }\n    /**\n     * Returns an updated package json that satisfies the version policy.\n     *\n     * @param project - input package json\n     * @param force - force update even when the project version is higher than the policy version.\n     */\n    ensure(project, force) {\n        if (this.lockedMajor) {\n            const version = new semver.SemVer(project.version);\n            if (version.major < this.lockedMajor) {\n                const updatedProject = cloneDeep(project);\n                updatedProject.version = `${this.lockedMajor}.0.0`;\n                return updatedProject;\n            }\n            else if (version.major > this.lockedMajor) {\n                const errorMessage = `Version ${project.version} in package ${project.name}` +\n                    ` is higher than locked major version ${this.lockedMajor}.`;\n                throw new Error(errorMessage);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Bumps version.\n     * Individual version policy lets change files drive version bump. This method currently does not do anything.\n     *\n     * @param bumpType - bump type\n     * @param identifier - prerelease id\n     */\n    bump(bumpType, identifier) {\n        // individual version policy lets change files drive version bump.\n    }\n    /**\n     * Validates the specified version and throws if the version does not satisfy the policy.\n     *\n     * @param versionString - version string\n     * @param packageName - package name\n     */\n    validate(versionString, packageName) {\n        const versionToTest = new semver.SemVer(versionString, false);\n        if (this.lockedMajor !== undefined) {\n            if (this.lockedMajor !== versionToTest.major) {\n                throw new Error(`Invalid major version ${versionString} in ${packageName}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=VersionPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport { VersionPolicy } from './VersionPolicy';\nimport schemaJson from '../schemas/version-policies.schema.json';\nexport var VersionFormatForPublish;\n(function (VersionFormatForPublish) {\n    VersionFormatForPublish[\"original\"] = \"original\";\n    VersionFormatForPublish[\"exact\"] = \"exact\";\n})(VersionFormatForPublish || (VersionFormatForPublish = {}));\nexport var VersionFormatForCommit;\n(function (VersionFormatForCommit) {\n    VersionFormatForCommit[\"wildcard\"] = \"wildcard\";\n    VersionFormatForCommit[\"original\"] = \"original\";\n})(VersionFormatForCommit || (VersionFormatForCommit = {}));\n/**\n * Use this class to load and save the \"common/config/rush/version-policies.json\" config file.\n * This config file configures how different groups of projects will be published by Rush,\n * and how their version numbers will be determined.\n * @public\n */\nclass VersionPolicyConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFileName) {\n        this._jsonFileName = jsonFileName;\n        this.versionPolicies = new Map();\n        this._loadFile();\n    }\n    /**\n     * Validate the version policy configuration against the rush config\n     */\n    validate(projectsByName) {\n        if (!this.versionPolicies) {\n            return;\n        }\n        this.versionPolicies.forEach((policy) => {\n            const lockStepPolicy = policy;\n            if (lockStepPolicy.mainProject && !projectsByName.get(lockStepPolicy.mainProject)) {\n                throw new Error(`Version policy \\\"${policy.policyName}\\\" has a non-existing mainProject:` +\n                    ` ${lockStepPolicy.mainProject}.`);\n            }\n        });\n    }\n    /**\n     * Gets the version policy by its name.\n     * Throws error if the version policy is not found.\n     * @param policyName - Name of the version policy\n     */\n    getVersionPolicy(policyName) {\n        const policy = this.versionPolicies.get(policyName);\n        if (!policy) {\n            throw new Error(`Failed to find version policy by name \\'${policyName}\\'`);\n        }\n        return policy;\n    }\n    /**\n     * Bumps up versions for the specified version policy or all version policies\n     *\n     * @param versionPolicyName - version policy name\n     * @param bumpType - bump type to override what policy has defined.\n     * @param identifier - prerelease identifier to override what policy has defined.\n     * @param shouldCommit - should save to disk\n     */\n    bump(versionPolicyName, bumpType, identifier, shouldCommit) {\n        if (versionPolicyName) {\n            const policy = this.versionPolicies.get(versionPolicyName);\n            if (policy) {\n                policy.bump(bumpType, identifier);\n            }\n        }\n        else {\n            this.versionPolicies.forEach((versionPolicy) => {\n                if (versionPolicy) {\n                    versionPolicy.bump(bumpType, identifier);\n                }\n            });\n        }\n        this._saveFile(!!shouldCommit);\n    }\n    /**\n     * Updates the version directly for the specified version policy\n     * @param versionPolicyName - version policy name\n     * @param newVersion - new version\n     */\n    update(versionPolicyName, newVersion, shouldCommit) {\n        const policy = this.versionPolicies.get(versionPolicyName);\n        if (!policy || !policy.isLockstepped) {\n            throw new Error(`Lockstep Version policy with name \"${versionPolicyName}\" cannot be found`);\n        }\n        const lockStepVersionPolicy = policy;\n        const previousVersion = lockStepVersionPolicy.version;\n        if (lockStepVersionPolicy.update(newVersion)) {\n            // eslint-disable-next-line no-console\n            console.log(`\\nUpdate version policy ${versionPolicyName} from ${previousVersion} to ${newVersion}`);\n            this._saveFile(!!shouldCommit);\n        }\n    }\n    _loadFile() {\n        if (!FileSystem.exists(this._jsonFileName)) {\n            return;\n        }\n        const versionPolicyJson = JsonFile.loadAndValidate(this._jsonFileName, VersionPolicyConfiguration._jsonSchema);\n        versionPolicyJson.forEach((policyJson) => {\n            const policy = VersionPolicy.load(policyJson);\n            if (policy) {\n                this.versionPolicies.set(policy.policyName, policy);\n            }\n        });\n    }\n    _saveFile(shouldCommit) {\n        const versionPolicyJson = [];\n        this.versionPolicies.forEach((versionPolicy) => {\n            versionPolicyJson.push(versionPolicy._json);\n        });\n        if (shouldCommit) {\n            JsonFile.save(versionPolicyJson, this._jsonFileName, { updateExistingFile: true });\n        }\n    }\n}\nVersionPolicyConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { VersionPolicyConfiguration };\n//# sourceMappingURL=VersionPolicyConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the NPM package manager.\n */\nexport class NpmPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'npm', RushConstants.npmShrinkwrapFilename);\n    }\n}\n//# sourceMappingURL=NpmPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.\n * @public\n */\nexport class PackageManager {\n    /** @internal */\n    constructor(version, packageManager, shrinkwrapFilename) {\n        this.version = version;\n        this.packageManager = packageManager;\n        this.shrinkwrapFilename = shrinkwrapFilename;\n    }\n}\n//# sourceMappingURL=PackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport * as path from 'path';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the PNPM package manager.\n */\nexport class PnpmPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'pnpm', RushConstants.pnpmV3ShrinkwrapFilename);\n        const parsedVersion = new semver.SemVer(version);\n        if (parsedVersion.major >= 6) {\n            // Introduced in version 6.0.0\n            this.pnpmfileFilename = RushConstants.pnpmfileV6Filename;\n        }\n        else {\n            this.pnpmfileFilename = RushConstants.pnpmfileV1Filename;\n        }\n        // node_modules/.pnpm/lock.yaml\n        // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0 for more details.\n        this.internalShrinkwrapRelativePath = path.join('node_modules', '.pnpm', 'lock.yaml');\n    }\n}\n//# sourceMappingURL=PnpmPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the Yarn package manager.\n */\nexport class YarnPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'yarn', RushConstants.yarnShrinkwrapFilename);\n    }\n}\n//# sourceMappingURL=YarnPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\nexport class CommandLineMigrationAdvisor {\n    // NOTE: THIS RUNS BEFORE THE REAL COMMAND-LINE PARSING.\n    // TAKE EXTREME CARE THAT THE HEURISTICS CANNOT FALSELY MATCH A VALID COMMAND LINE.\n    static checkArgv(argv) {\n        // 0=node.exe, 1=script name\n        const args = process.argv.slice(2);\n        if (args.length > 0) {\n            if (args[0] === 'generate') {\n                CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush generate\", use \"rush update\" or \"rush update --full\".');\n                return false;\n            }\n            if (args[0] === 'install') {\n                if (args.indexOf('--full-clean') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install --full-clean\", use \"rush purge --unsafe\".');\n                    return false;\n                }\n                if (args.indexOf('-C') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install -C\", use \"rush purge --unsafe\".');\n                    return false;\n                }\n                if (args.indexOf('--clean') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install --clean\", use \"rush install --purge\".');\n                    return false;\n                }\n                if (args.indexOf('-c') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install -c\", use \"rush install --purge\".');\n                    return false;\n                }\n            }\n        }\n        // Everything is okay\n        return true;\n    }\n    static _reportDeprecated(message) {\n        // eslint-disable-next-line no-console\n        console.error(colors.red(PrintUtilities.wrapWords('ERROR: You specified an outdated command-line that is no longer supported by this version of Rush:')));\n        // eslint-disable-next-line no-console\n        console.error(colors.yellow(PrintUtilities.wrapWords(message)));\n        // eslint-disable-next-line no-console\n        console.error();\n        // eslint-disable-next-line no-console\n        console.error(PrintUtilities.wrapWords(`For command-line help, type \"rush -h\".  For migration instructions,` +\n            ` please visit ${RushConstants.rushWebSiteUrl}`));\n    }\n}\n//# sourceMappingURL=CommandLineMigrationAdvisor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { CommandLineParser, CommandLineHelper } from '@rushstack/ts-command-line';\nimport { InternalError, AlreadyReportedError, ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport { CommandLineConfiguration } from '../api/CommandLineConfiguration';\nimport { AddAction } from './actions/AddAction';\nimport { ChangeAction } from './actions/ChangeAction';\nimport { CheckAction } from './actions/CheckAction';\nimport { DeployAction } from './actions/DeployAction';\nimport { InitAction } from './actions/InitAction';\nimport { InitAutoinstallerAction } from './actions/InitAutoinstallerAction';\nimport { InitDeployAction } from './actions/InitDeployAction';\nimport { InstallAction } from './actions/InstallAction';\nimport { LinkAction } from './actions/LinkAction';\nimport { ListAction } from './actions/ListAction';\nimport { PublishAction } from './actions/PublishAction';\nimport { PurgeAction } from './actions/PurgeAction';\nimport { RemoveAction } from './actions/RemoveAction';\nimport { ScanAction } from './actions/ScanAction';\nimport { UnlinkAction } from './actions/UnlinkAction';\nimport { UpdateAction } from './actions/UpdateAction';\nimport { UpdateAutoinstallerAction } from './actions/UpdateAutoinstallerAction';\nimport { VersionAction } from './actions/VersionAction';\nimport { UpdateCloudCredentialsAction } from './actions/UpdateCloudCredentialsAction';\nimport { UpgradeInteractiveAction } from './actions/UpgradeInteractiveAction';\nimport { GlobalScriptAction } from './scriptActions/GlobalScriptAction';\nimport { Telemetry } from '../logic/Telemetry';\nimport { RushGlobalFolder } from '../api/RushGlobalFolder';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { SetupAction } from './actions/SetupAction';\nimport { PluginManager } from '../pluginFramework/PluginManager';\nimport { RushSession } from '../pluginFramework/RushSession';\nimport { PhasedScriptAction } from './scriptActions/PhasedScriptAction';\nexport class RushCommandLineParser extends CommandLineParser {\n    constructor(options) {\n        super({\n            toolFilename: 'rush',\n            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish' +\n                ' many packages from a central Git repo.  It is designed to handle very large repositories' +\n                ' supporting many projects and people.  Rush provides policies, protections, and customizations' +\n                ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs' +\n                ' and automates package publishing.  It can manage decoupled subsets of projects with different' +\n                ' release and versioning strategies.  A full API is included to facilitate integration with other' +\n                ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,' +\n                ' Rush is for you.',\n            enableTabCompletionAction: true\n        });\n        this._restrictConsoleOutput = RushCommandLineParser.shouldRestrictConsoleOutput();\n        this._debugParameter = this.defineFlagParameter({\n            parameterLongName: '--debug',\n            parameterShortName: '-d',\n            description: 'Show the full call stack if an error occurs while executing the tool'\n        });\n        this._quietParameter = this.defineFlagParameter({\n            parameterLongName: '--quiet',\n            parameterShortName: '-q',\n            description: 'Hide rush startup information'\n        });\n        this._terminalProvider = new ConsoleTerminalProvider();\n        this._terminal = new Terminal(this._terminalProvider);\n        this._rushOptions = this._normalizeOptions(options || {});\n        try {\n            const rushJsonFilename = RushConfiguration.tryFindRushJsonLocation({\n                startingFolder: this._rushOptions.cwd,\n                showVerbose: !this._restrictConsoleOutput\n            });\n            if (rushJsonFilename) {\n                this.rushConfiguration = RushConfiguration.loadFromConfigurationFile(rushJsonFilename);\n            }\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n        NodeJsCompatibility.warnAboutCompatibilityIssues({\n            isRushLib: true,\n            alreadyReportedNodeTooNewError: this._rushOptions.alreadyReportedNodeTooNewError,\n            rushConfiguration: this.rushConfiguration\n        });\n        this.rushGlobalFolder = new RushGlobalFolder();\n        this.rushSession = new RushSession({\n            getIsDebugMode: () => this.isDebug,\n            terminalProvider: this._terminalProvider\n        });\n        this.pluginManager = new PluginManager({\n            rushSession: this.rushSession,\n            rushConfiguration: this.rushConfiguration,\n            terminal: this._terminal,\n            builtInPluginConfigurations: this._rushOptions.builtInPluginConfigurations,\n            restrictConsoleOutput: this._restrictConsoleOutput,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        this._populateActions();\n        const pluginCommandLineConfigurations = this.pluginManager.tryGetCustomCommandLineConfigurationInfos();\n        for (const { commandLineConfiguration, pluginLoader } of pluginCommandLineConfigurations) {\n            try {\n                this._addCommandLineConfigActions(commandLineConfiguration);\n            }\n            catch (e) {\n                this._terminal.writeErrorLine(`Error from plugin ${pluginLoader.pluginName} by ${pluginLoader.packageName}: ${e.toString()}`);\n            }\n        }\n    }\n    get isDebug() {\n        return this._debugParameter.value;\n    }\n    get isQuiet() {\n        return this._quietParameter.value;\n    }\n    /**\n     * Utility to determine if the app should restrict writing to the console.\n     */\n    static shouldRestrictConsoleOutput() {\n        if (CommandLineHelper.isTabCompletionActionRequest(process.argv)) {\n            return true;\n        }\n        for (let i = 2; i < process.argv.length; i++) {\n            const arg = process.argv[i];\n            if (arg === '-q' || arg === '--quiet' || arg === '--json') {\n                return true;\n            }\n        }\n        return false;\n    }\n    flushTelemetry() {\n        var _a;\n        (_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.flush();\n    }\n    async execute(args) {\n        // debugParameter will be correctly parsed during super.execute(), so manually parse here.\n        this._terminalProvider.verboseEnabled = this._terminalProvider.debugEnabled =\n            process.argv.indexOf('--debug') >= 0;\n        await this.pluginManager.tryInitializeUnassociatedPluginsAsync();\n        return await super.execute(args);\n    }\n    async onExecute() {\n        var _a;\n        // Defensively set the exit code to 1 so if Rush crashes for whatever reason, we'll have a nonzero exit code.\n        // For example, Node.js currently has the inexcusable design of terminating with zero exit code when\n        // there is an uncaught promise exception.  This will supposedly be fixed in Node.js 9.\n        // Ideally we should do this for all the Rush actions, but \"rush build\" is the most critical one\n        // -- if it falsely appears to succeed, we could merge bad PRs, publish empty packages, etc.\n        process.exitCode = 1;\n        if (this._debugParameter.value) {\n            InternalError.breakInDebugger = true;\n        }\n        try {\n            await this._wrapOnExecuteAsync();\n            // If we make it here, everything went fine, so reset the exit code back to 0\n            process.exitCode = 0;\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n        await ((_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.ensureFlushedAsync());\n    }\n    _normalizeOptions(options) {\n        return {\n            cwd: options.cwd || process.cwd(),\n            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false,\n            builtInPluginConfigurations: options.builtInPluginConfigurations || []\n        };\n    }\n    async _wrapOnExecuteAsync() {\n        if (this.rushConfiguration) {\n            this.telemetry = new Telemetry(this.rushConfiguration, this.rushSession);\n        }\n        await super.onExecute();\n        if (this.telemetry) {\n            this.flushTelemetry();\n        }\n    }\n    _populateActions() {\n        try {\n            // Alphabetical order\n            this.addAction(new AddAction(this));\n            this.addAction(new ChangeAction(this));\n            this.addAction(new CheckAction(this));\n            this.addAction(new DeployAction(this));\n            this.addAction(new InitAction(this));\n            this.addAction(new InitAutoinstallerAction(this));\n            this.addAction(new InitDeployAction(this));\n            this.addAction(new InstallAction(this));\n            this.addAction(new LinkAction(this));\n            this.addAction(new ListAction(this));\n            this.addAction(new PublishAction(this));\n            this.addAction(new PurgeAction(this));\n            this.addAction(new RemoveAction(this));\n            this.addAction(new ScanAction(this));\n            this.addAction(new SetupAction(this));\n            this.addAction(new UnlinkAction(this));\n            this.addAction(new UpdateAction(this));\n            this.addAction(new UpdateAutoinstallerAction(this));\n            this.addAction(new UpdateCloudCredentialsAction(this));\n            this.addAction(new UpgradeInteractiveAction(this));\n            this.addAction(new VersionAction(this));\n            this._populateScriptActions();\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n    }\n    _populateScriptActions() {\n        // If there is not a rush.json file, we still want \"build\" and \"rebuild\" to appear in the\n        // command-line help\n        let commandLineConfigFilePath;\n        if (this.rushConfiguration) {\n            commandLineConfigFilePath = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants.commandLineFilename);\n        }\n        const commandLineConfiguration = CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFilePath);\n        this._addCommandLineConfigActions(commandLineConfiguration);\n    }\n    _addCommandLineConfigActions(commandLineConfiguration) {\n        // Register each custom command\n        for (const command of commandLineConfiguration.commands.values()) {\n            this._addCommandLineConfigAction(commandLineConfiguration, command);\n        }\n    }\n    _addCommandLineConfigAction(commandLineConfiguration, command) {\n        if (this.tryGetAction(command.name)) {\n            throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\"` +\n                ` using a name that already exists`);\n        }\n        switch (command.commandKind) {\n            case RushConstants.globalCommandKind: {\n                this._addGlobalScriptAction(commandLineConfiguration, command);\n                break;\n            }\n            case RushConstants.phasedCommandKind: {\n                if (!command.isSynthetic && // synthetic commands come from bulk commands\n                    !this.rushConfiguration.experimentsConfiguration.configuration.phasedCommands) {\n                    throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\" ` +\n                        `that uses the \"${RushConstants.phasedCommandKind}\" command kind. To use this command kind, ` +\n                        'the \"phasedCommands\" experiment must be enabled. Note that this feature is not complete ' +\n                        'and will not work as expected.');\n                }\n                this._addPhasedCommandLineConfigAction(commandLineConfiguration, command);\n                break;\n            }\n            default:\n                throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\"` +\n                    ` using an unsupported command kind \"${command.commandKind}\"`);\n        }\n    }\n    _getSharedCommandActionOptions(commandLineConfiguration, command) {\n        return {\n            actionName: command.name,\n            summary: command.summary,\n            documentation: command.description || command.summary,\n            safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,\n            command,\n            parser: this,\n            commandLineConfiguration: commandLineConfiguration\n        };\n    }\n    _addGlobalScriptAction(commandLineConfiguration, command) {\n        if (command.name === RushConstants.buildCommandName ||\n            command.name === RushConstants.rebuildCommandName) {\n            throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\" using ` +\n                `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`);\n        }\n        const sharedCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);\n        this.addAction(new GlobalScriptAction(Object.assign(Object.assign({}, sharedCommandOptions), { shellCommand: command.shellCommand, autoinstallerName: command.autoinstallerName })));\n    }\n    _addPhasedCommandLineConfigAction(commandLineConfiguration, command) {\n        var _a;\n        const baseCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);\n        this.addAction(new PhasedScriptAction(Object.assign(Object.assign({}, baseCommandOptions), { enableParallelism: command.enableParallelism, incremental: command.incremental || false, disableBuildCache: command.disableBuildCache || false, initialPhases: command.phases, originalPhases: command.originalPhases, watchPhases: command.watchPhases, watchDebounceMs: (_a = command.watchDebounceMs) !== null && _a !== void 0 ? _a : RushConstants.defaultWatchDebounceMs, phases: commandLineConfiguration.phases, alwaysWatch: command.alwaysWatch, alwaysInstall: command.alwaysInstall })));\n    }\n    _reportErrorAndSetExitCode(error) {\n        if (!(error instanceof AlreadyReportedError)) {\n            const prefix = 'ERROR: ';\n            // The colors package will eat multi-newlines, which could break formatting\n            // in user-specified messages and instructions, so we prefer to color each\n            // line individually.\n            const message = PrintUtilities.wrapWords(prefix + error.message)\n                .split(/\\r?\\n/)\n                .map((line) => colors.red(line))\n                .join('\\n');\n            // eslint-disable-next-line no-console\n            console.error(`\\n${message}`);\n        }\n        if (this._debugParameter.value) {\n            // If catchSyncErrors() called this, then show a call stack similar to what Node.js\n            // would show for an uncaught error\n            // eslint-disable-next-line no-console\n            console.error(`\\n${error.stack}`);\n        }\n        this.flushTelemetry();\n        // Ideally we want to eliminate all calls to process.exit() from our code, and replace them\n        // with normal control flow that properly cleans up its data structures.\n        // For this particular call, we have a problem that the RushCommandLineParser constructor\n        // performs nontrivial work that can throw an exception.  Either the Rush class would need\n        // to handle reporting for those exceptions, or else _populateActions() should be moved\n        // to a RushCommandLineParser lifecycle stage that can handle it.\n        if (process.exitCode !== undefined) {\n            process.exit(process.exitCode);\n        }\n        else {\n            process.exit(1);\n        }\n    }\n}\n//# sourceMappingURL=RushCommandLineParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushPnpmCommandLineParser } from './RushPnpmCommandLineParser';\nexport class RushPnpmCommandLine {\n    static launch(launcherVersion, options) {\n        RushPnpmCommandLineParser.initializeAsync(options)\n            // RushPnpmCommandLineParser.executeAsync should never reject the promise\n            .then((rushPnpmCommandLineParser) => rushPnpmCommandLineParser.executeAsync())\n            // eslint-disable-next-line no-console\n            .catch(console.error);\n    }\n}\n//# sourceMappingURL=RushPnpmCommandLine.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { AlreadyReportedError, Colors, ConsoleTerminalProvider, EnvironmentMap, Executable, FileConstants, FileSystem, JsonFile, Terminal } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\nimport { RushGlobalFolder } from '../api/RushGlobalFolder';\nimport { PurgeManager } from '../logic/PurgeManager';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\nconst RUSH_SKIP_CHECKS_PARAMETER = '--rush-skip-checks';\nfunction _reportErrorAndSetExitCode(error, terminal, debugEnabled) {\n    var _a;\n    if (!(error instanceof AlreadyReportedError)) {\n        const prefix = 'ERROR: ';\n        terminal.writeErrorLine('\\n' + PrintUtilities.wrapWords(prefix + error.message));\n    }\n    if (debugEnabled) {\n        // If catchSyncErrors() called this, then show a call stack similar to what Node.js\n        // would show for an uncaught error\n        terminal.writeErrorLine('\\n' + error.stack);\n    }\n    process.exit((_a = process.exitCode) !== null && _a !== void 0 ? _a : 1);\n}\nexport class RushPnpmCommandLineParser {\n    constructor(options, terminal, debugEnabled) {\n        this._debugEnabled = debugEnabled;\n        this._terminal = terminal;\n        // Are we in a Rush repo?\n        const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation({\n            // showVerbose is false because the logging message may break JSON output\n            showVerbose: false\n        });\n        NodeJsCompatibility.warnAboutCompatibilityIssues({\n            isRushLib: true,\n            alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,\n            rushConfiguration\n        });\n        if (!rushConfiguration) {\n            throw new Error('The \"rush-pnpm\" command must be executed in a folder that is under a Rush workspace folder');\n        }\n        this._rushConfiguration = rushConfiguration;\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error('The \"rush-pnpm\" command requires your rush.json to be configured to use the PNPM package manager');\n        }\n        if (!rushConfiguration.pnpmOptions.useWorkspaces) {\n            const pnpmConfigFilename = rushConfiguration.pnpmOptions.jsonFilename || 'rush.json';\n            throw new Error(`The \"rush-pnpm\" command requires the \"useWorkspaces\" setting to be enabled in ${pnpmConfigFilename}`);\n        }\n        const workspaceFolder = rushConfiguration.commonTempFolder;\n        const workspaceFilePath = path.join(workspaceFolder, 'pnpm-workspace.yaml');\n        if (!FileSystem.exists(workspaceFilePath)) {\n            this._terminal.writeErrorLine('Error: The PNPM workspace file has not been generated:');\n            this._terminal.writeErrorLine(`  ${workspaceFilePath}\\n`);\n            this._terminal.writeLine(Colors.cyan(`Do you need to run \"rush install\" or \"rush update\"?`));\n            throw new AlreadyReportedError();\n        }\n        if (!FileSystem.exists(rushConfiguration.packageManagerToolFilename)) {\n            this._terminal.writeErrorLine('Error: The PNPM local binary has not been installed yet.');\n            this._terminal.writeLine('\\n' + Colors.cyan(`Do you need to run \"rush install\" or \"rush update\"?`));\n            throw new AlreadyReportedError();\n        }\n        // 0 = node.exe\n        // 1 = rush-pnpm\n        const pnpmArgs = process.argv.slice(2);\n        this._pnpmArgs = pnpmArgs;\n    }\n    static async initializeAsync(options) {\n        var _a;\n        const debugEnabled = process.argv.indexOf('--debug') >= 0;\n        const verboseEnabled = process.argv.indexOf('--verbose') >= 0;\n        const localTerminalProvider = (_a = options.terminalProvider) !== null && _a !== void 0 ? _a : new ConsoleTerminalProvider({\n            debugEnabled,\n            verboseEnabled\n        });\n        const terminal = new Terminal(localTerminalProvider);\n        try {\n            const rushPnpmCommandLineParser = new RushPnpmCommandLineParser(options, terminal, debugEnabled);\n            await rushPnpmCommandLineParser._validatePnpmUsageAsync(rushPnpmCommandLineParser._pnpmArgs);\n            return rushPnpmCommandLineParser;\n        }\n        catch (error) {\n            _reportErrorAndSetExitCode(error, terminal, debugEnabled);\n        }\n    }\n    async executeAsync() {\n        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught\n        // promise exception), so we start with the assumption that the exit code is 1\n        // and set it to 0 only on success.\n        process.exitCode = 1;\n        this._execute();\n        if (process.exitCode === 0) {\n            await this._postExecuteAsync();\n        }\n    }\n    async _validatePnpmUsageAsync(pnpmArgs) {\n        if (pnpmArgs[0] === RUSH_SKIP_CHECKS_PARAMETER) {\n            pnpmArgs.shift();\n            // Ignore other checks\n            return;\n        }\n        if (pnpmArgs.length === 0) {\n            return;\n        }\n        const firstArg = pnpmArgs[0];\n        // Detect common safe invocations\n        if (pnpmArgs.includes('-h') || pnpmArgs.includes('--help') || pnpmArgs.includes('-?')) {\n            return;\n        }\n        if (pnpmArgs.length === 1) {\n            if (firstArg === '-v' || firstArg === '--version') {\n                return;\n            }\n        }\n        const BYPASS_NOTICE = `To bypass this check, add \"${RUSH_SKIP_CHECKS_PARAMETER}\" as the very first command line option.`;\n        if (!/^[a-z]+([a-z0-9\\-])*$/.test(firstArg)) {\n            // We can't parse this CLI syntax\n            this._terminal.writeErrorLine(`Warning: The \"rush-pnpm\" wrapper expects a command verb before \"${firstArg}\"\\n`);\n            this._terminal.writeLine(Colors.cyan(BYPASS_NOTICE));\n            throw new AlreadyReportedError();\n        }\n        else {\n            const commandName = firstArg;\n            // Also accept SKIP_RUSH_CHECKS_PARAMETER immediately after the command verb\n            if (pnpmArgs[1] === RUSH_SKIP_CHECKS_PARAMETER) {\n                pnpmArgs.splice(1, 1);\n                return;\n            }\n            if (pnpmArgs.indexOf(RUSH_SKIP_CHECKS_PARAMETER) >= 0) {\n                // We do not attempt to parse PNPM's complete CLI syntax, so we cannot be sure how to interpret\n                // strings that appear outside of the specific patterns that this parser recognizes\n                this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"${RUSH_SKIP_CHECKS_PARAMETER}\" option must be the first parameter for the \"rush-pnpm\" command.`));\n                throw new AlreadyReportedError();\n            }\n            this._commandName = commandName;\n            // Warn about commands known not to work\n            /* eslint-disable no-fallthrough */\n            switch (commandName) {\n                // Blocked\n                case 'import': {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command is known to be incompatible with Rush's environment.`) + '\\n');\n                    this._terminal.writeLine(Colors.cyan(BYPASS_NOTICE));\n                    throw new AlreadyReportedError();\n                }\n                // Show warning for install commands\n                case 'add':\n                case 'install':\n                /* synonym */\n                case 'i':\n                case 'install-test':\n                /* synonym */\n                case 'it': {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command is incompatible with Rush's environment.` +\n                        ` Use the \"rush install\" or \"rush update\" commands instead.`) + '\\n');\n                    this._terminal.writeLine(Colors.cyan(BYPASS_NOTICE));\n                    throw new AlreadyReportedError();\n                }\n                // Show warning\n                case 'link':\n                /* synonym */\n                case 'ln':\n                case 'remove':\n                /* synonym */\n                case 'rm':\n                case 'unlink':\n                case 'update':\n                /* synonym */\n                case 'up': {\n                    this._terminal.writeWarningLine(PrintUtilities.wrapWords(`Warning: The \"pnpm ${commandName}\" command makes changes that may invalidate Rush's workspace state.`) + '\\n');\n                    this._terminal.writeWarningLine(`==> Consider running \"rush install\" or \"rush update\" afterwards.\\n`);\n                    break;\n                }\n                // Know safe after validation\n                case 'patch': {\n                    const semver = await import('semver');\n                    /**\n                     * If you were to accidentally attempt to use rush-pnpm patch with a pnpmVersion < 7.4.0, pnpm patch may fallback to the system patch command.\n                     * For instance, /usr/bin/patch which may just hangs forever\n                     * So, erroring out the command if the pnpm version is < 7.4.0\n                     */\n                    if (semver.lt(this._rushConfiguration.packageManagerToolVersion, '7.4.0')) {\n                        this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm patch\" command is added after pnpm@7.4.0.` +\n                            ` Please update \"pnpmVersion\" >= 7.4.0 in rush.json file and run \"rush update\" to use this command.`) + '\\n');\n                        throw new AlreadyReportedError();\n                    }\n                    break;\n                }\n                case 'patch-commit': {\n                    const pnpmOptionsJsonFilename = path.join(this._rushConfiguration.commonRushConfigFolder, RushConstants.pnpmConfigFilename);\n                    if (this._rushConfiguration.rushConfigurationJson.pnpmOptions) {\n                        this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm patch-commit\" command is incompatible with specifying \"pnpmOptions\" in rush.json file.` +\n                            ` Please move the content of \"pnpmOptions\" in rush.json file to ${pnpmOptionsJsonFilename}`) + '\\n');\n                        throw new AlreadyReportedError();\n                    }\n                    break;\n                }\n                // Known safe\n                case 'audit':\n                case 'exec':\n                case 'list':\n                /* synonym */\n                case 'ls':\n                case 'outdated':\n                case 'pack':\n                case 'prune':\n                case 'publish':\n                case 'rebuild':\n                /* synonym */\n                case 'rb':\n                case 'root':\n                case 'run':\n                case 'start':\n                case 'store':\n                case 'test':\n                /* synonym */\n                case 't':\n                case 'why': {\n                    break;\n                }\n                // Unknown\n                default: {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command has not been tested with Rush's environment. It may be incompatible.`) + '\\n');\n                    this._terminal.writeLine(Colors.cyan(BYPASS_NOTICE));\n                }\n            }\n            /* eslint-enable no-fallthrough */\n        }\n    }\n    _execute() {\n        const rushConfiguration = this._rushConfiguration;\n        const workspaceFolder = rushConfiguration.commonTempFolder;\n        const pnpmEnvironmentMap = new EnvironmentMap(process.env);\n        pnpmEnvironmentMap.set('NPM_CONFIG_WORKSPACE_DIR', workspaceFolder);\n        if (rushConfiguration.pnpmOptions.pnpmStorePath) {\n            pnpmEnvironmentMap.set('NPM_CONFIG_STORE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n            pnpmEnvironmentMap.set('NPM_CONFIG_CACHE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n            pnpmEnvironmentMap.set('NPM_CONFIG_STATE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n        }\n        if (rushConfiguration.pnpmOptions.environmentVariables) {\n            for (const [envKey, { value: envValue, override }] of Object.entries(rushConfiguration.pnpmOptions.environmentVariables)) {\n                if (override) {\n                    pnpmEnvironmentMap.set(envKey, envValue);\n                }\n                else {\n                    if (undefined === pnpmEnvironmentMap.get(envKey)) {\n                        pnpmEnvironmentMap.set(envKey, envValue);\n                    }\n                }\n            }\n        }\n        const result = Executable.spawnSync(rushConfiguration.packageManagerToolFilename, this._pnpmArgs, {\n            environmentMap: pnpmEnvironmentMap,\n            stdio: 'inherit'\n        });\n        if (result.error) {\n            throw new Error('Failed to invoke PNPM: ' + result.error);\n        }\n        if (result.status === null) {\n            throw new Error('Failed to invoke PNPM: Spawn completed without an exit code');\n        }\n        process.exitCode = result.status;\n    }\n    async _postExecuteAsync() {\n        var _a;\n        const commandName = this._commandName;\n        if (!commandName) {\n            return;\n        }\n        switch (commandName) {\n            case 'patch-commit': {\n                // Example: \"C:\\MyRepo\\common\\temp\\package.json\"\n                const commonPackageJsonFilename = `${this._rushConfiguration.commonTempFolder}/${FileConstants.PackageJson}`;\n                const commonPackageJson = JsonFile.load(commonPackageJsonFilename);\n                const newGlobalPatchedDependencies = (_a = commonPackageJson === null || commonPackageJson === void 0 ? void 0 : commonPackageJson.pnpm) === null || _a === void 0 ? void 0 : _a.patchedDependencies;\n                const currentGlobalPatchedDependencies = this._rushConfiguration.pnpmOptions.globalPatchedDependencies;\n                if (!objectsAreDeepEqual(currentGlobalPatchedDependencies, newGlobalPatchedDependencies)) {\n                    const commonTempPnpmPatchesFolder = `${this._rushConfiguration.commonTempFolder}/${RushConstants.pnpmPatchesFolderName}`;\n                    const rushPnpmPatchesFolder = `${this._rushConfiguration.commonFolder}/pnpm-${RushConstants.pnpmPatchesFolderName}`;\n                    // Copy (or delete) common\\temp\\patches\\ --> common\\pnpm-patches\\\n                    if (FileSystem.exists(commonTempPnpmPatchesFolder)) {\n                        FileSystem.ensureEmptyFolder(rushPnpmPatchesFolder);\n                        // eslint-disable-next-line no-console\n                        console.log(`Copying ${commonTempPnpmPatchesFolder}`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  --> ${rushPnpmPatchesFolder}`);\n                        FileSystem.copyFiles({\n                            sourcePath: commonTempPnpmPatchesFolder,\n                            destinationPath: rushPnpmPatchesFolder\n                        });\n                    }\n                    else {\n                        if (FileSystem.exists(rushPnpmPatchesFolder)) {\n                            // eslint-disable-next-line no-console\n                            console.log(`Deleting ${rushPnpmPatchesFolder}`);\n                            FileSystem.deleteFolder(rushPnpmPatchesFolder);\n                        }\n                    }\n                    // Update patchedDependencies to pnpm configuration file\n                    this._rushConfiguration.pnpmOptions.updateGlobalPatchedDependencies(newGlobalPatchedDependencies);\n                    // Rerun installation to update\n                    await this._doRushUpdateAsync();\n                    this._terminal.writeWarningLine(`Rush refreshed the ${RushConstants.pnpmConfigFilename}, shrinkwrap file and patch files under the \"common/pnpm/patches\" folder.\\n` +\n                        '  Please commit this change to Git.');\n                }\n                break;\n            }\n        }\n    }\n    async _doRushUpdateAsync() {\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colors.green('Running \"rush update\"'));\n        this._terminal.writeLine();\n        const rushGlobalFolder = new RushGlobalFolder();\n        const purgeManager = new PurgeManager(this._rushConfiguration, rushGlobalFolder);\n        const installManagerOptions = {\n            debug: this._debugEnabled,\n            allowShrinkwrapUpdates: true,\n            bypassPolicy: false,\n            noLink: false,\n            fullUpgrade: false,\n            recheckShrinkwrap: true,\n            networkConcurrency: undefined,\n            collectLogFile: false,\n            variant: undefined,\n            maxInstallAttempts: RushConstants.defaultMaxInstallAttempts,\n            pnpmFilterArguments: [],\n            checkOnly: false\n        };\n        const installManagerFactoryModule = await import(\n        /* webpackChunkName: 'InstallManagerFactory' */\n        '../logic/InstallManagerFactory');\n        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this._rushConfiguration, rushGlobalFolder, purgeManager, installManagerOptions);\n        try {\n            await installManager.doInstallAsync();\n        }\n        finally {\n            purgeManager.deleteAll();\n        }\n    }\n}\n//# sourceMappingURL=RushPnpmCommandLineParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { RushConstants } from '../logic/RushConstants';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nexport class RushStartupBanner {\n    static logBanner(rushVersion, isManaged) {\n        const nodeVersion = this._formatNodeVersion();\n        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';\n        // eslint-disable-next-line no-console\n        console.log('\\n' +\n            colors.bold(`Rush Multi-Project Build Tool${versionSuffix}`) +\n            colors.cyan(` - ${RushConstants.rushWebSiteUrl}`) +\n            `\\nNode.js version is ${nodeVersion}\\n`);\n    }\n    static logStreamlinedBanner(rushVersion, isManaged) {\n        const nodeVersion = this._formatNodeVersion();\n        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';\n        // eslint-disable-next-line no-console\n        console.log(colors.bold(`Rush Multi-Project Build Tool${versionSuffix}`) + ` - Node.js ${nodeVersion}`);\n    }\n    static _formatNodeVersion() {\n        const nodeVersion = process.versions.node;\n        const nodeReleaseLabel = NodeJsCompatibility.isOddNumberedVersion\n            ? 'unstable'\n            : NodeJsCompatibility.isLtsVersion\n                ? 'LTS'\n                : 'pre-LTS';\n        return `${nodeVersion} (${nodeReleaseLabel})`;\n    }\n    static _formatRushVersion(rushVersion, isManaged) {\n        return rushVersion + colors.yellow(isManaged ? '' : ' (unmanaged)');\n    }\n}\n//# sourceMappingURL=RushStartupBanner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { PackageJsonLookup, Text } from '@rushstack/node-core-library';\nimport { DEFAULT_CONSOLE_WIDTH, PrintUtilities } from '@rushstack/terminal';\nimport { Utilities } from '../utilities/Utilities';\nimport { ProjectCommandSet } from '../logic/ProjectCommandSet';\nimport { Rush } from '../api/Rush';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { RushStartupBanner } from './RushStartupBanner';\nexport class RushXCommandLine {\n    static launchRushX(launcherVersion, isManaged) {\n        RushXCommandLine._launchRushXInternal(launcherVersion, { isManaged });\n    }\n    /**\n     * @internal\n     */\n    static _launchRushXInternal(launcherVersion, options) {\n        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught\n        // promise exception), so we start with the assumption that the exit code is 1\n        // and set it to 0 only on success.\n        process.exitCode = 1;\n        const args = this._getCommandLineArguments();\n        if (!args.quiet) {\n            RushStartupBanner.logStreamlinedBanner(Rush.version, options.isManaged);\n        }\n        try {\n            // Are we in a Rush repo?\n            const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation({\n                showVerbose: false\n            });\n            NodeJsCompatibility.warnAboutCompatibilityIssues({\n                isRushLib: true,\n                alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,\n                rushConfiguration\n            });\n            // Find the governing package.json for this folder:\n            const packageJsonLookup = new PackageJsonLookup();\n            const packageJsonFilePath = packageJsonLookup.tryGetPackageJsonFilePathFor(process.cwd());\n            if (!packageJsonFilePath) {\n                // eslint-disable-next-line no-console\n                console.log(colors.red('This command should be used inside a project folder.'));\n                // eslint-disable-next-line no-console\n                console.log(`Unable to find a package.json file in the current working directory or any of its parents.`);\n                return;\n            }\n            if (rushConfiguration && !rushConfiguration.tryGetProjectForPath(process.cwd())) {\n                // GitHub #2713: Users reported confusion resulting from a situation where \"rush install\"\n                // did not install the project's dependencies, because the project was not registered.\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Warning: You are invoking \"rushx\" inside a Rush repository, but this project is not registered in rush.json.'));\n            }\n            const packageJson = packageJsonLookup.loadPackageJson(packageJsonFilePath);\n            const projectCommandSet = new ProjectCommandSet(packageJson);\n            if (args.help) {\n                RushXCommandLine._showUsage(packageJson, projectCommandSet);\n                return;\n            }\n            const scriptBody = projectCommandSet.tryGetScriptBody(args.commandName);\n            if (scriptBody === undefined) {\n                // eslint-disable-next-line no-console\n                console.log(colors.red(`Error: The command \"${args.commandName}\" is not defined in the` +\n                    ` package.json file for this project.`));\n                if (projectCommandSet.commandNames.length > 0) {\n                    // eslint-disable-next-line no-console\n                    console.log('\\nAvailable commands for this project are: ' +\n                        projectCommandSet.commandNames.map((x) => `\"${x}\"`).join(', '));\n                }\n                // eslint-disable-next-line no-console\n                console.log(`Use ${colors.yellow('\"rushx --help\"')} for more information.`);\n                return;\n            }\n            let commandWithArgs = scriptBody;\n            let commandWithArgsForDisplay = scriptBody;\n            if (args.commandArgs.length > 0) {\n                // This approach is based on what NPM 7 now does:\n                // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34\n                const escapedRemainingArgs = args.commandArgs.map((x) => Utilities.escapeShellParameter(x));\n                commandWithArgs += ' ' + escapedRemainingArgs.join(' ');\n                // Display it nicely without the extra quotes\n                commandWithArgsForDisplay += ' ' + args.commandArgs.join(' ');\n            }\n            if (!args.quiet) {\n                // eslint-disable-next-line no-console\n                console.log(`> ${JSON.stringify(commandWithArgsForDisplay)}\\n`);\n            }\n            const packageFolder = path.dirname(packageJsonFilePath);\n            const exitCode = Utilities.executeLifecycleCommand(commandWithArgs, {\n                rushConfiguration,\n                workingDirectory: packageFolder,\n                // If there is a rush.json then use its .npmrc from the temp folder.\n                // Otherwise look for npmrc in the project folder.\n                initCwd: rushConfiguration ? rushConfiguration.commonTempFolder : packageFolder,\n                handleOutput: false,\n                environmentPathOptions: {\n                    includeProjectBin: true\n                }\n            });\n            if (exitCode > 0) {\n                // eslint-disable-next-line no-console\n                console.log(colors.red(`The script failed with exit code ${exitCode}`));\n            }\n            process.exitCode = exitCode;\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.log(colors.red('Error: ' + error.message));\n        }\n    }\n    static _getCommandLineArguments() {\n        // 0 = node.exe\n        // 1 = rushx\n        const args = process.argv.slice(2);\n        const unknownArgs = [];\n        let help = false;\n        let quiet = false;\n        let commandName = '';\n        const commandArgs = [];\n        for (let index = 0; index < args.length; index++) {\n            const argValue = args[index];\n            if (!commandName) {\n                if (argValue === '-q' || argValue === '--quiet') {\n                    quiet = true;\n                }\n                else if (argValue === '-h' || argValue === '--help') {\n                    help = true;\n                }\n                else if (argValue.startsWith('-')) {\n                    unknownArgs.push(args[index]);\n                }\n                else {\n                    commandName = args[index];\n                }\n            }\n            else {\n                commandArgs.push(args[index]);\n            }\n        }\n        if (!commandName) {\n            help = true;\n        }\n        if (unknownArgs.length > 0) {\n            // Future TODO: Instead of just displaying usage info, we could display a\n            // specific error about the unknown flag the user tried to pass to rushx.\n            help = true;\n        }\n        return {\n            help,\n            quiet,\n            commandName,\n            commandArgs\n        };\n    }\n    static _showUsage(packageJson, projectCommandSet) {\n        // eslint-disable-next-line no-console\n        console.log('usage: rushx [-h]');\n        // eslint-disable-next-line no-console\n        console.log('       rushx [-q/--quiet] <command> ...\\n');\n        // eslint-disable-next-line no-console\n        console.log('Optional arguments:');\n        // eslint-disable-next-line no-console\n        console.log('  -h, --help            Show this help message and exit.');\n        // eslint-disable-next-line no-console\n        console.log('  -q, --quiet           Hide rushx startup information.\\n');\n        if (projectCommandSet.commandNames.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log(`Project commands for ${colors.cyan(packageJson.name)}:`);\n            // Calculate the length of the longest script name, for formatting\n            let maxLength = 0;\n            for (const commandName of projectCommandSet.commandNames) {\n                maxLength = Math.max(maxLength, commandName.length);\n            }\n            for (const commandName of projectCommandSet.commandNames) {\n                const escapedScriptBody = JSON.stringify(projectCommandSet.getScriptBody(commandName));\n                // The length of the string e.g. \"  command: \"\n                const firstPartLength = 2 + maxLength + 2;\n                // The length for truncating the escaped escapedScriptBody so it doesn't wrap\n                // to the next line\n                const consoleWidth = PrintUtilities.getConsoleWidth() || DEFAULT_CONSOLE_WIDTH;\n                const truncateLength = Math.max(0, consoleWidth - firstPartLength) - 1;\n                // eslint-disable-next-line no-console\n                console.log(\n                // Example: \"  command: \"\n                '  ' +\n                    colors.cyan(Text.padEnd(commandName + ':', maxLength + 2)) +\n                    // Example: \"do some thin...\"\n                    Text.truncateWithEllipsis(escapedScriptBody, truncateLength));\n            }\n            if (projectCommandSet.malformedScriptNames.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    colors.yellow('Warning: Some \"scripts\" entries in the package.json file' +\n                        ' have malformed names: ' +\n                        projectCommandSet.malformedScriptNames.map((x) => `\"${x}\"`).join(', ')));\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow('Warning: No commands are defined yet for this project.'));\n            // eslint-disable-next-line no-console\n            console.log('You can define a command by adding a \"scripts\" table to the project\\'s package.json file.');\n        }\n    }\n}\n//# sourceMappingURL=RushXCommandLine.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { BaseAddAndRemoveAction } from './BaseAddAndRemoveAction';\nimport { DependencySpecifier } from '../../logic/DependencySpecifier';\nexport class AddAction extends BaseAddAndRemoveAction {\n    constructor(parser) {\n        const documentation = [\n            'Adds specified package(s) to the dependencies of the current project (as determined by the current working directory)' +\n                ' and then runs \"rush update\". If no version is specified, a version will be automatically detected (typically' +\n                ' either the latest version or a version that won\\'t break the \"ensureConsistentVersions\" policy). If a version' +\n                ' range (or a workspace range) is specified, the latest version in the range will be used. The version will be' +\n                ' automatically prepended with a tilde, unless the \"--exact\" or \"--caret\" flags are used. The \"--make-consistent\"' +\n                ' flag can be used to update all packages with the dependency.'\n        ].join('\\n');\n        super({\n            actionName: 'add',\n            summary: 'Adds one or more dependencies to the package.json and runs rush update.',\n            documentation,\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._packageNameList = this.defineStringListParameter({\n            parameterLongName: '--package',\n            parameterShortName: '-p',\n            required: true,\n            argumentName: 'PACKAGE',\n            description: 'The name of the package which should be added as a dependency.' +\n                ' A SemVer version specifier can be appended after an \"@\" sign.  WARNING: Symbol characters' +\n                \" are usually interpreted by your shell, so it's recommended to use quotes.\" +\n                ' For example, write \"rush add --package \"example@^1.2.3\"\" instead of \"rush add --package example@^1.2.3\".' +\n                ' To add multiple packages, write \"rush add --package foo --package bar\".'\n        });\n        this._exactFlag = this.defineFlagParameter({\n            parameterLongName: '--exact',\n            description: 'If specified, the SemVer specifier added to the' +\n                ' package.json will be an exact version (e.g. without tilde or caret).'\n        });\n        this._caretFlag = this.defineFlagParameter({\n            parameterLongName: '--caret',\n            description: 'If specified, the SemVer specifier added to the' +\n                ' package.json will be a prepended with a \"caret\" specifier (\"^\").'\n        });\n        this._devDependencyFlag = this.defineFlagParameter({\n            parameterLongName: '--dev',\n            description: 'If specified, the package will be added to the \"devDependencies\" section of the package.json'\n        });\n        this._peerDependencyFlag = this.defineFlagParameter({\n            parameterLongName: '--peer',\n            description: 'If specified, the package will be added to the \"peerDependencies\" section of the package.json'\n        });\n        this._makeConsistentFlag = this.defineFlagParameter({\n            parameterLongName: '--make-consistent',\n            parameterShortName: '-m',\n            description: 'If specified, other packages with this dependency will have their package.json' +\n                ' files updated to use the same version of the dependency.'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If specified, the dependency will be added to all projects.'\n        });\n    }\n    getUpdateOptions() {\n        const projects = super.getProjects();\n        if (this._caretFlag.value && this._exactFlag.value) {\n            throw new Error(`Only one of \"${this._caretFlag.longName}\" and \"${this._exactFlag.longName}\" should be specified`);\n        }\n        const packagesToAdd = [];\n        for (const specifiedPackageName of this.specifiedPackageNameList) {\n            /**\n             * Name & Version\n             */\n            let packageName = specifiedPackageName;\n            let version = undefined;\n            const parts = packageName.split('@');\n            if (parts[0] === '') {\n                // this is a scoped package\n                packageName = '@' + parts[1];\n                version = parts[2];\n            }\n            else {\n                packageName = parts[0];\n                version = parts[1];\n            }\n            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {\n                throw new Error(`The package name \"${packageName}\" is not valid.`);\n            }\n            if (version && version !== 'latest') {\n                const specifier = new DependencySpecifier(packageName, version);\n                if (!semver.validRange(specifier.versionSpecifier) && !semver.valid(specifier.versionSpecifier)) {\n                    throw new Error(`The SemVer specifier \"${version}\" is not valid.`);\n                }\n            }\n            /**\n             * RangeStyle\n             */\n            let rangeStyle;\n            if (version && version !== 'latest') {\n                if (this._exactFlag.value || this._caretFlag.value) {\n                    throw new Error(`The \"${this._caretFlag.longName}\" and \"${this._exactFlag.longName}\" flags may not be specified if a ` +\n                        `version is provided in the ${this._packageNameList.longName} specifier. In this case \"${version}\" was provided.`);\n                }\n                rangeStyle = \"passthrough\" /* SemVerStyle.Passthrough */;\n            }\n            else {\n                rangeStyle = this._caretFlag.value\n                    ? \"caret\" /* SemVerStyle.Caret */\n                    : this._exactFlag.value\n                        ? \"exact\" /* SemVerStyle.Exact */\n                        : \"tilde\" /* SemVerStyle.Tilde */;\n            }\n            packagesToAdd.push({ packageName, version, rangeStyle });\n        }\n        return {\n            projects: projects,\n            packagesToUpdate: packagesToAdd,\n            devDependency: this._devDependencyFlag.value,\n            peerDependency: this._peerDependencyFlag.value,\n            updateOtherPackages: this._makeConsistentFlag.value,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug,\n            actionName: this.actionName\n        };\n    }\n}\n//# sourceMappingURL=AddAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\n/**\n * This is the common base class for AddAction and RemoveAction.\n */\nexport class BaseAddAndRemoveAction extends BaseRushAction {\n    get specifiedPackageNameList() {\n        return this._packageNameList.values;\n    }\n    constructor(options) {\n        super(options);\n        this._skipUpdateFlag = this.defineFlagParameter({\n            parameterLongName: '--skip-update',\n            parameterShortName: '-s',\n            description: 'If specified, the \"rush update\" command will not be run after updating the package.json files.'\n        });\n    }\n    getProjects() {\n        if (this._allFlag.value) {\n            return this.rushConfiguration.projects;\n        }\n        else {\n            const currentProject = this.rushConfiguration.tryGetProjectForPath(process.cwd());\n            if (!currentProject) {\n                throw new Error(`The rush \"${this.actionName}\" command must be invoked under a project` +\n                    ` folder that is registered in rush.json unless the ${this._allFlag.longName} is used.`);\n            }\n            return [currentProject];\n        }\n    }\n    async runAsync() {\n        const packageJsonUpdater = await import(\n        /* webpackChunkName: 'PackageJsonUpdater' */ '../../logic/PackageJsonUpdater');\n        const updater = new packageJsonUpdater.PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);\n        await updater.doRushUpdateAsync(this.getUpdateOptions());\n    }\n}\n//# sourceMappingURL=BaseAddAndRemoveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Event } from '../../api/EventHooks';\nimport { PurgeManager } from '../../logic/PurgeManager';\nimport { SetupChecks } from '../../logic/SetupChecks';\nimport { StandardScriptUpdater } from '../../logic/StandardScriptUpdater';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport { Variants } from '../../api/Variants';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\n/**\n * This is the common base class for InstallAction and UpdateAction.\n */\nexport class BaseInstallAction extends BaseRushAction {\n    constructor(options) {\n        super(options);\n        this._terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: options.parser.isDebug }));\n        this._purgeParameter = this.defineFlagParameter({\n            parameterLongName: '--purge',\n            parameterShortName: '-p',\n            description: 'Perform \"rush purge\" before starting the installation'\n        });\n        this._bypassPolicyParameter = this.defineFlagParameter({\n            parameterLongName: RushConstants.bypassPolicyFlagLongName,\n            description: 'Overrides enforcement of the \"gitPolicy\" rules from rush.json (use honorably!)'\n        });\n        this._noLinkParameter = this.defineFlagParameter({\n            parameterLongName: '--no-link',\n            description: 'If \"--no-link\" is specified, then project symlinks will NOT be created' +\n                ' after the installation completes.  You will need to run \"rush link\" manually.' +\n                ' This flag is useful for automated builds that want to report stages individually' +\n                ' or perform extra operations in between the two stages. This flag is not supported' +\n                ' when using workspaces.'\n        });\n        this._networkConcurrencyParameter = this.defineIntegerParameter({\n            parameterLongName: '--network-concurrency',\n            argumentName: 'COUNT',\n            description: 'If specified, limits the maximum number of concurrent network requests.' +\n                '  This is useful when troubleshooting network failures.'\n        });\n        this._debugPackageManagerParameter = this.defineFlagParameter({\n            parameterLongName: '--debug-package-manager',\n            description: 'Activates verbose logging for the package manager. You will probably want to pipe' +\n                ' the output of Rush to a file when using this command.'\n        });\n        this._maxInstallAttempts = this.defineIntegerParameter({\n            parameterLongName: '--max-install-attempts',\n            argumentName: 'NUMBER',\n            description: `Overrides the default maximum number of install attempts.`,\n            defaultValue: RushConstants.defaultMaxInstallAttempts\n        });\n        this._ignoreHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-hooks',\n            description: `Skips execution of the \"eventHooks\" scripts defined in rush.json. Make sure you know what you are skipping.`\n        });\n        this._variant = this.defineStringParameter(Variants.VARIANT_PARAMETER);\n    }\n    async runAsync() {\n        VersionMismatchFinder.ensureConsistentVersions(this.rushConfiguration, this._terminal, {\n            variant: this._variant.value\n        });\n        const stopwatch = Stopwatch.start();\n        SetupChecks.validate(this.rushConfiguration);\n        let warnAboutScriptUpdate = false;\n        if (this.actionName === 'update') {\n            warnAboutScriptUpdate = await StandardScriptUpdater.updateAsync(this.rushConfiguration);\n        }\n        else {\n            await StandardScriptUpdater.validateAsync(this.rushConfiguration);\n        }\n        this.eventHooksManager.handle(Event.preRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);\n        const purgeManager = new PurgeManager(this.rushConfiguration, this.rushGlobalFolder);\n        if (this._purgeParameter.value) {\n            // eslint-disable-next-line no-console\n            console.log('The --purge flag was specified, so performing \"rush purge\"');\n            purgeManager.purgeNormal();\n            // eslint-disable-next-line no-console\n            console.log('');\n        }\n        if (this._networkConcurrencyParameter.value) {\n            if (this.rushConfiguration.packageManager !== 'pnpm') {\n                throw new Error(`The \"${this._networkConcurrencyParameter.longName}\" parameter is` +\n                    ` only supported when using the PNPM package manager.`);\n            }\n        }\n        // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,\n        // it is safe to assume that the value is not null\n        if (this._maxInstallAttempts.value < 1) {\n            throw new Error(`The value of \"${this._maxInstallAttempts.longName}\" must be positive and nonzero.`);\n        }\n        const installManagerOptions = await this.buildInstallOptionsAsync();\n        const installManagerFactoryModule = await import(\n        /* webpackChunkName: 'InstallManagerFactory' */\n        '../../logic/InstallManagerFactory');\n        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this.rushConfiguration, this.rushGlobalFolder, purgeManager, installManagerOptions);\n        let installSuccessful = true;\n        try {\n            await installManager.doInstallAsync();\n            if (warnAboutScriptUpdate) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    colors.yellow('Rush refreshed some files in the \"common/scripts\" folder.' +\n                        '  Please commit this change to Git.'));\n            }\n            // eslint-disable-next-line no-console\n            console.log('\\n' + colors.green(`Rush ${this.actionName} finished successfully. (${stopwatch.toString()})`));\n        }\n        catch (error) {\n            installSuccessful = false;\n            throw error;\n        }\n        finally {\n            purgeManager.deleteAll();\n            stopwatch.stop();\n            this._collectTelemetry(stopwatch, installManagerOptions, installSuccessful);\n            this.parser.flushTelemetry();\n            this.eventHooksManager.handle(Event.postRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);\n        }\n    }\n    _collectTelemetry(stopwatch, installManagerOptions, success) {\n        var _a;\n        if (this.parser.telemetry) {\n            const extraData = Object.assign(Object.assign({ mode: this.actionName, clean: (!!this._purgeParameter.value).toString(), debug: installManagerOptions.debug.toString(), full: installManagerOptions.fullUpgrade.toString() }, this.getParameterStringMap()), (_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getTelemetry());\n            this.parser.telemetry.log({\n                name: 'install',\n                durationInSeconds: stopwatch.duration,\n                result: success ? 'Succeeded' : 'Failed',\n                extraData\n            });\n        }\n    }\n}\n//# sourceMappingURL=BaseInstallAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { CommandLineAction } from '@rushstack/ts-command-line';\nimport { LockFile } from '@rushstack/node-core-library';\nimport { EventHooksManager } from '../../logic/EventHooksManager';\nimport { RushCommandLineParser } from './../RushCommandLineParser';\nimport { Utilities } from '../../utilities/Utilities';\n/**\n * The base class for a few specialized Rush command-line actions that\n * can be used without a rush.json configuration.\n */\nexport class BaseConfiglessRushAction extends CommandLineAction {\n    get rushConfiguration() {\n        return this.parser.rushConfiguration;\n    }\n    get rushSession() {\n        return this.parser.rushSession;\n    }\n    get rushGlobalFolder() {\n        return this.parser.rushGlobalFolder;\n    }\n    constructor(options) {\n        super(options);\n        this.parser = options.parser;\n        this._safeForSimultaneousRushProcesses = !!options.safeForSimultaneousRushProcesses;\n    }\n    onExecute() {\n        this._ensureEnvironment();\n        if (this.rushConfiguration) {\n            if (!this._safeForSimultaneousRushProcesses) {\n                if (!LockFile.tryAcquire(this.rushConfiguration.commonTempFolder, 'rush')) {\n                    // eslint-disable-next-line no-console\n                    console.log(colors.red(`Another Rush command is already running in this repository.`));\n                    process.exit(1);\n                }\n            }\n        }\n        if (!RushCommandLineParser.shouldRestrictConsoleOutput()) {\n            // eslint-disable-next-line no-console\n            console.log(`Starting \"rush ${this.actionName}\"\\n`);\n        }\n        return this.runAsync();\n    }\n    _ensureEnvironment() {\n        if (this.rushConfiguration) {\n            // eslint-disable-next-line dot-notation\n            let environmentPath = process.env['PATH'];\n            environmentPath =\n                path.join(this.rushConfiguration.commonTempFolder, 'node_modules', '.bin') +\n                    path.delimiter +\n                    environmentPath;\n            // eslint-disable-next-line dot-notation\n            process.env['PATH'] = environmentPath;\n        }\n    }\n}\n/**\n * The base class that most Rush command-line actions should extend.\n */\nexport class BaseRushAction extends BaseConfiglessRushAction {\n    get eventHooksManager() {\n        if (!this._eventHooksManager) {\n            this._eventHooksManager = new EventHooksManager(this.rushConfiguration);\n        }\n        return this._eventHooksManager;\n    }\n    get rushConfiguration() {\n        return super.rushConfiguration;\n    }\n    async onExecute() {\n        if (!this.rushConfiguration) {\n            throw Utilities.getRushConfigNotFoundError();\n        }\n        this._throwPluginErrorIfNeed();\n        await this.parser.pluginManager.tryInitializeAssociatedCommandPluginsAsync(this.actionName);\n        this._throwPluginErrorIfNeed();\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.initialize.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.initialize.promise(this);\n        }\n        return super.onExecute();\n    }\n    /**\n     * If an error is encountered while trying to load plugins, it is saved in the `PluginManager.error`\n     * property, so we can defer throwing it until when `_throwPluginErrorIfNeed()` is called.\n     */\n    _throwPluginErrorIfNeed() {\n        // If the plugin configuration is broken, these three commands are used to fix the problem:\n        //\n        //   \"rush update\"\n        //   \"rush init-autoinstaller\"\n        //   \"rush update-autoinstaller\"\n        //\n        // In addition, the \"rush setup\" command is designed to help new users configure their access\n        // to a private NPM registry, which means it can't rely on plugins that might live in that\n        // registry.\n        //\n        // Thus we do not report plugin errors when invoking these commands.\n        if (!['update', 'init-autoinstaller', 'update-autoinstaller', 'setup'].includes(this.actionName)) {\n            const pluginError = this.parser.pluginManager.error;\n            if (pluginError) {\n                throw pluginError;\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseRushAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as child_process from 'child_process';\nimport colors from 'colors/safe';\nimport { FileSystem, AlreadyReportedError, Terminal, ConsoleTerminalProvider } from '@rushstack/node-core-library';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { ChangeType } from '../../api/ChangeManagement';\nimport { ChangeFile } from '../../api/ChangeFile';\nimport { BaseRushAction } from './BaseRushAction';\nimport { ChangeFiles } from '../../logic/ChangeFiles';\nimport { VersionPolicyDefinitionName } from '../../api/VersionPolicy';\nimport { ProjectChangeAnalyzer } from '../../logic/ProjectChangeAnalyzer';\nimport { Git } from '../../logic/Git';\nimport { Utilities } from '../../utilities/Utilities';\nconst BULK_LONG_NAME = '--bulk';\nconst BULK_MESSAGE_LONG_NAME = '--message';\nconst BULK_BUMP_TYPE_LONG_NAME = '--bump-type';\nexport class ChangeAction extends BaseRushAction {\n    constructor(parser) {\n        const documentation = [\n            'Asks a series of questions and then generates a <branchname>-<timestamp>.json file ' +\n                'in the common folder. The `publish` command will consume these files and perform the proper ' +\n                'version bumps. Note these changes will eventually be published in a changelog.md file in each package.',\n            '',\n            'The possible types of changes are: ',\n            '',\n            'MAJOR - these are breaking changes that are not backwards compatible. ' +\n                'Examples are: renaming a public class, adding/removing a non-optional ' +\n                'parameter from a public API, or renaming an variable or function that ' +\n                'is exported.',\n            '',\n            'MINOR - these are changes that are backwards compatible (but not ' +\n                'forwards compatible). Examples are: adding a new public API or adding an ' +\n                'optional parameter to a public API',\n            '',\n            'PATCH - these are changes that are backwards and forwards compatible. ' +\n                'Examples are: Modifying a private API or fixing a bug in the logic ' +\n                'of how an existing API works.',\n            '',\n            \"NONE - these are changes that are backwards and forwards compatible and don't require an immediate release. \" +\n                'Examples are: Modifying dev tooling configuration like eslint.',\n            '',\n            'HOTFIX (EXPERIMENTAL) - these are changes that are hotfixes targeting a ' +\n                'specific older version of the package. When a hotfix change is added, ' +\n                'other changes will not be able to increment the version number. ' +\n                \"Enable this feature by setting 'hotfixChangeEnabled' in your rush.json.\",\n            ''\n        ].join('\\n');\n        super({\n            actionName: 'change',\n            summary: 'Records changes made to projects, indicating how the package version number should be bumped ' +\n                'for the next publish.',\n            documentation,\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._git = new Git(this.rushConfiguration);\n        this._terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));\n        this._verifyParameter = this.defineFlagParameter({\n            parameterLongName: '--verify',\n            parameterShortName: '-v',\n            description: 'Verify the change file has been generated and that it is a valid JSON file'\n        });\n        this._noFetchParameter = this.defineFlagParameter({\n            parameterLongName: '--no-fetch',\n            description: 'Skips fetching the baseline branch before running \"git diff\" to detect changes.'\n        });\n        this._targetBranchParameter = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this parameter is specified, compare the checked out branch with the specified branch to ' +\n                'determine which projects were changed. If this parameter is not specified, the checked out branch ' +\n                'is compared against the \"main\" branch.'\n        });\n        this._overwriteFlagParameter = this.defineFlagParameter({\n            parameterLongName: '--overwrite',\n            description: `If a changefile already exists, overwrite without prompting ` +\n                `(or erroring in ${BULK_LONG_NAME} mode).`\n        });\n        this._commitChangesFlagParameter = this.defineFlagParameter({\n            parameterLongName: '--commit',\n            parameterShortName: '-c',\n            description: `If this flag is specified generated changefiles will be commited automatically.`\n        });\n        this._commitChangesMessageStringParameter = this.defineStringParameter({\n            parameterLongName: '--commit-message',\n            argumentName: 'COMMIT_MESSAGE',\n            description: `If this parameter is specified generated changefiles will be commited automatically with the specified commit message.`\n        });\n        this._changeEmailParameter = this.defineStringParameter({\n            parameterLongName: '--email',\n            argumentName: 'EMAIL',\n            description: 'The email address to use in changefiles. If this parameter is not provided, the email address ' +\n                'will be detected or prompted for in interactive mode.'\n        });\n        this._bulkChangeParameter = this.defineFlagParameter({\n            parameterLongName: BULK_LONG_NAME,\n            description: 'If this flag is specified, apply the same change message and bump type to all changed projects. ' +\n                `The ${BULK_MESSAGE_LONG_NAME} and the ${BULK_BUMP_TYPE_LONG_NAME} parameters must be specified if the ` +\n                `${BULK_LONG_NAME} parameter is specified`\n        });\n        this._bulkChangeMessageParameter = this.defineStringParameter({\n            parameterLongName: BULK_MESSAGE_LONG_NAME,\n            argumentName: 'MESSAGE',\n            description: `The message to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`\n        });\n        this._bulkChangeBumpTypeParameter = this.defineChoiceParameter({\n            parameterLongName: BULK_BUMP_TYPE_LONG_NAME,\n            alternatives: [...Object.keys(this._getBumpOptions())],\n            description: `The bump type to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`\n        });\n    }\n    async runAsync() {\n        // eslint-disable-next-line no-console\n        console.log(`The target branch is ${this._targetBranch}`);\n        if (this._verifyParameter.value) {\n            const errors = [\n                this._bulkChangeParameter,\n                this._bulkChangeMessageParameter,\n                this._bulkChangeBumpTypeParameter,\n                this._overwriteFlagParameter,\n                this._commitChangesFlagParameter\n            ]\n                .map((parameter) => {\n                return parameter.value\n                    ? `The {${this._bulkChangeParameter.longName} parameter cannot be provided with the ` +\n                        `${this._verifyParameter.longName} parameter`\n                    : '';\n            })\n                .filter((error) => error !== '');\n            if (errors.length > 0) {\n                errors.forEach((error) => {\n                    // eslint-disable-next-line no-console\n                    console.error(error);\n                });\n                throw new AlreadyReportedError();\n            }\n            await this._verifyAsync();\n            return;\n        }\n        const sortedProjectList = (await this._getChangedProjectNamesAsync()).sort();\n        if (sortedProjectList.length === 0) {\n            this._logNoChangeFileRequired();\n            this._warnUnstagedChanges();\n            return;\n        }\n        this._warnUnstagedChanges();\n        const inquirer = await import('inquirer');\n        const promptModule = inquirer.createPromptModule();\n        let changeFileData = new Map();\n        let interactiveMode = false;\n        if (this._bulkChangeParameter.value) {\n            if (!this._bulkChangeBumpTypeParameter.value ||\n                (!this._bulkChangeMessageParameter.value &&\n                    this._bulkChangeBumpTypeParameter.value !== ChangeType[ChangeType.none])) {\n                throw new Error(`The ${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} ` +\n                    `parameters must provided if the ${this._bulkChangeParameter.longName} flag is provided. If the value ` +\n                    `\"${ChangeType[ChangeType.none]}\" is provided to the ${this._bulkChangeBumpTypeParameter.longName} ` +\n                    `parameter, the ${this._bulkChangeMessageParameter.longName} parameter may be omitted.`);\n            }\n            const email = this._changeEmailParameter.value || this._detectEmail();\n            if (!email) {\n                throw new Error(\"Unable to detect Git email and an email address wasn't provided using the \" +\n                    `${this._changeEmailParameter.longName} parameter.`);\n            }\n            const errors = [];\n            const comment = this._bulkChangeMessageParameter.value || '';\n            const changeType = this._bulkChangeBumpTypeParameter.value;\n            for (const packageName of sortedProjectList) {\n                const allowedBumpTypes = Object.keys(this._getBumpOptions(packageName));\n                let projectChangeType = changeType;\n                if (allowedBumpTypes.length === 0) {\n                    projectChangeType = ChangeType[ChangeType.none];\n                }\n                else if (projectChangeType !== ChangeType[ChangeType.none] &&\n                    allowedBumpTypes.indexOf(projectChangeType) === -1) {\n                    errors.push(`The \"${projectChangeType}\" change type is not allowed for package \"${packageName}\".`);\n                }\n                changeFileData.set(packageName, {\n                    changes: [\n                        {\n                            comment,\n                            type: projectChangeType,\n                            packageName\n                        }\n                    ],\n                    packageName,\n                    email\n                });\n            }\n            if (errors.length > 0) {\n                for (const error of errors) {\n                    // eslint-disable-next-line no-console\n                    console.error(error);\n                }\n                throw new AlreadyReportedError();\n            }\n        }\n        else if (this._bulkChangeBumpTypeParameter.value || this._bulkChangeMessageParameter.value) {\n            throw new Error(`The ${this._bulkChangeParameter.longName} flag must be provided with the ` +\n                `${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} parameters.`);\n        }\n        else {\n            interactiveMode = true;\n            const existingChangeComments = ChangeFiles.getChangeComments(this._getChangeFiles());\n            changeFileData = await this._promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments);\n            if (this._isEmailRequired(changeFileData)) {\n                const email = this._changeEmailParameter.value\n                    ? this._changeEmailParameter.value\n                    : await this._detectOrAskForEmail(promptModule);\n                changeFileData.forEach((changeFile) => {\n                    var _a, _b;\n                    changeFile.email = ((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile)\n                        ? email\n                        : '';\n                });\n            }\n        }\n        let changefiles;\n        try {\n            changefiles = await this._writeChangeFiles(promptModule, changeFileData, this._overwriteFlagParameter.value, interactiveMode);\n        }\n        catch (error) {\n            throw new Error(`There was an error creating a change file: ${error.toString()}`);\n        }\n        if (this._commitChangesFlagParameter.value || this._commitChangesMessageStringParameter.value) {\n            if (changefiles && changefiles.length !== 0) {\n                this._stageAndCommitGitChanges(changefiles, this._commitChangesMessageStringParameter.value ||\n                    this.rushConfiguration.gitChangefilesCommitMessage ||\n                    'Rush change');\n            }\n            else {\n                this._terminal.writeWarningLine('Warning: No change files generated, nothing to commit.');\n            }\n        }\n    }\n    _generateHostMap() {\n        var _a;\n        const hostMap = new Map();\n        for (const project of this.rushConfiguration.projects) {\n            let hostProjectName = project.packageName;\n            if ((_a = project.versionPolicy) === null || _a === void 0 ? void 0 : _a.isLockstepped) {\n                const lockstepPolicy = project.versionPolicy;\n                hostProjectName = lockstepPolicy.mainProject || project.packageName;\n            }\n            hostMap.set(project, hostProjectName);\n        }\n        return hostMap;\n    }\n    async _verifyAsync() {\n        const changedPackages = await this._getChangedProjectNamesAsync();\n        if (changedPackages.length > 0) {\n            this._validateChangeFile(changedPackages);\n        }\n        else {\n            this._logNoChangeFileRequired();\n        }\n    }\n    get _targetBranch() {\n        if (!this._targetBranchName) {\n            this._targetBranchName = this._targetBranchParameter.value || this._git.getRemoteDefaultBranch();\n        }\n        return this._targetBranchName;\n    }\n    async _getChangedProjectNamesAsync() {\n        var _a;\n        const projectChangeAnalyzer = new ProjectChangeAnalyzer(this.rushConfiguration);\n        const changedProjects = await projectChangeAnalyzer.getChangedProjectsAsync({\n            targetBranchName: this._targetBranch,\n            terminal: this._terminal,\n            shouldFetch: !this._noFetchParameter.value,\n            // Lockfile evaluation will expand the set of projects that request change files\n            // Not enabling, since this would be a breaking change\n            includeExternalDependencies: false,\n            // Since install may not have happened, cannot read rush-project.json\n            enableFiltering: false\n        });\n        const projectHostMap = this._generateHostMap();\n        const changedProjectNames = new Set();\n        for (const changedProject of changedProjects) {\n            if (changedProject.shouldPublish && !((_a = changedProject.versionPolicy) === null || _a === void 0 ? void 0 : _a.exemptFromRushChange)) {\n                const hostName = projectHostMap.get(changedProject);\n                if (hostName) {\n                    changedProjectNames.add(hostName);\n                }\n            }\n        }\n        return Array.from(changedProjectNames);\n    }\n    _validateChangeFile(changedPackages) {\n        const files = this._getChangeFiles();\n        ChangeFiles.validate(files, changedPackages, this.rushConfiguration);\n    }\n    _getChangeFiles() {\n        const repoRoot = getRepoRoot(this.rushConfiguration.rushJsonFolder);\n        const relativeChangesFolder = path.relative(repoRoot, this.rushConfiguration.changesFolder);\n        return this._git\n            .getChangedFiles(this._targetBranch, this._terminal, true, relativeChangesFolder)\n            .map((relativePath) => {\n            return path.join(repoRoot, relativePath);\n        });\n    }\n    /**\n     * The main loop which prompts the user for information on changed projects.\n     */\n    async _promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments) {\n        const changedFileData = new Map();\n        for (const projectName of sortedProjectList) {\n            const changeInfo = await this._askQuestions(promptModule, projectName, existingChangeComments);\n            if (changeInfo) {\n                // Save the info into the change file\n                let changeFile = changedFileData.get(changeInfo.packageName);\n                if (!changeFile) {\n                    changeFile = {\n                        changes: [],\n                        packageName: changeInfo.packageName,\n                        email: undefined\n                    };\n                    changedFileData.set(changeInfo.packageName, changeFile);\n                }\n                changeFile.changes.push(changeInfo);\n            }\n        }\n        return changedFileData;\n    }\n    /**\n     * Asks all questions which are needed to generate changelist for a project.\n     */\n    async _askQuestions(promptModule, packageName, existingChangeComments) {\n        // eslint-disable-next-line no-console\n        console.log(`\\n${packageName}`);\n        const comments = existingChangeComments.get(packageName);\n        if (comments) {\n            // eslint-disable-next-line no-console\n            console.log(`Found existing comments:`);\n            comments.forEach((comment) => {\n                // eslint-disable-next-line no-console\n                console.log(`    > ${comment}`);\n            });\n            const { appendComment } = await promptModule({\n                name: 'appendComment',\n                type: 'list',\n                default: 'skip',\n                message: 'Append to existing comments or skip?',\n                choices: [\n                    {\n                        name: 'Skip',\n                        value: 'skip'\n                    },\n                    {\n                        name: 'Append',\n                        value: 'append'\n                    }\n                ]\n            });\n            if (appendComment === 'skip') {\n                return undefined;\n            }\n            else {\n                return await this._promptForComments(promptModule, packageName);\n            }\n        }\n        else {\n            return await this._promptForComments(promptModule, packageName);\n        }\n    }\n    async _promptForComments(promptModule, packageName) {\n        const bumpOptions = this._getBumpOptions(packageName);\n        const { comment } = await promptModule({\n            name: 'comment',\n            type: 'input',\n            message: `Describe changes, or ENTER if no changes:`\n        });\n        if (Object.keys(bumpOptions).length === 0 || !comment) {\n            return {\n                packageName: packageName,\n                comment: comment || '',\n                type: ChangeType[ChangeType.none]\n            };\n        }\n        else {\n            const { bumpType } = await promptModule({\n                choices: Object.keys(bumpOptions).map((option) => {\n                    return {\n                        value: option,\n                        name: bumpOptions[option]\n                    };\n                }),\n                default: 'patch',\n                message: 'Select the type of change:',\n                name: 'bumpType',\n                type: 'list'\n            });\n            return {\n                packageName: packageName,\n                comment: comment,\n                type: bumpType\n            };\n        }\n    }\n    _getBumpOptions(packageName) {\n        let bumpOptions = this.rushConfiguration && this.rushConfiguration.hotfixChangeEnabled\n            ? {\n                [ChangeType[ChangeType.hotfix]]: 'hotfix - for changes that need to be published in a separate hotfix package'\n            }\n            : {\n                [ChangeType[ChangeType.major]]: 'major - for changes that break compatibility, e.g. removing an API',\n                [ChangeType[ChangeType.minor]]: 'minor - for backwards compatible changes, e.g. adding a new API',\n                [ChangeType[ChangeType.patch]]: 'patch - for changes that do not affect compatibility, e.g. fixing a bug',\n                [ChangeType[ChangeType.none]]: 'none - for changes that do not need an immediate release, e.g. eslint config change'\n            };\n        if (packageName) {\n            const project = this.rushConfiguration.getProjectByName(packageName);\n            const versionPolicy = project.versionPolicy;\n            if (versionPolicy) {\n                if (versionPolicy.definitionName === VersionPolicyDefinitionName.lockStepVersion) {\n                    const lockStepPolicy = versionPolicy;\n                    // No need to ask for bump types if project is lockstep versioned with an explicit nextBump\n                    if (lockStepPolicy.nextBump !== undefined) {\n                        bumpOptions = {};\n                    }\n                }\n                else if (versionPolicy.definitionName === VersionPolicyDefinitionName.individualVersion) {\n                    const individualPolicy = versionPolicy;\n                    if (individualPolicy.lockedMajor !== undefined) {\n                        delete bumpOptions[ChangeType[ChangeType.major]];\n                    }\n                }\n            }\n        }\n        return bumpOptions;\n    }\n    _isEmailRequired(changeFileData) {\n        return [...changeFileData.values()].some((changeFile) => {\n            var _a, _b;\n            return !!((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile);\n        });\n    }\n    /**\n     * Will determine a user's email by first detecting it from their Git config,\n     * or will ask for it if it is not found or the Git config is wrong.\n     */\n    async _detectOrAskForEmail(promptModule) {\n        return (await this._detectAndConfirmEmail(promptModule)) || (await this._promptForEmail(promptModule));\n    }\n    _detectEmail() {\n        try {\n            return child_process\n                .execSync('git config user.email')\n                .toString()\n                .replace(/(\\r\\n|\\n|\\r)/gm, '');\n        }\n        catch (err) {\n            // eslint-disable-next-line no-console\n            console.log('There was an issue detecting your Git email...');\n            return undefined;\n        }\n    }\n    /**\n     * Detects the user's email address from their Git configuration, prompts the user to approve the\n     * detected email. It returns undefined if it cannot be detected.\n     */\n    async _detectAndConfirmEmail(promptModule) {\n        const email = this._detectEmail();\n        if (email) {\n            const { isCorrectEmail } = await promptModule([\n                {\n                    type: 'confirm',\n                    name: 'isCorrectEmail',\n                    default: 'Y',\n                    message: `Is your email address ${email}?`\n                }\n            ]);\n            return isCorrectEmail ? email : undefined;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Asks the user for their email address\n     */\n    async _promptForEmail(promptModule) {\n        const { email } = await promptModule([\n            {\n                type: 'input',\n                name: 'email',\n                message: 'What is your email address?',\n                validate: (input) => {\n                    return true; // @todo should be an email\n                }\n            }\n        ]);\n        return email;\n    }\n    _warnUnstagedChanges() {\n        try {\n            if (this._git.hasUnstagedChanges()) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    colors.yellow('Warning: You have unstaged changes, which do not trigger prompting for change ' +\n                        'descriptions.'));\n            }\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.log(`An error occurred when detecting unstaged changes: ${error}`);\n        }\n    }\n    /**\n     * Writes change files to the common/changes folder. Will prompt for overwrite if file already exists.\n     */\n    async _writeChangeFiles(promptModule, changeFileData, overwrite, interactiveMode) {\n        const writtenFiles = [];\n        await changeFileData.forEach(async (changeFile) => {\n            const writtenFile = await this._writeChangeFile(promptModule, changeFile, overwrite, interactiveMode);\n            if (writtenFile) {\n                writtenFiles.push(writtenFile);\n            }\n        });\n        return writtenFiles;\n    }\n    async _writeChangeFile(promptModule, changeFileData, overwrite, interactiveMode) {\n        const output = JSON.stringify(changeFileData, undefined, 2);\n        const changeFile = new ChangeFile(changeFileData, this.rushConfiguration);\n        const filePath = changeFile.generatePath();\n        const fileExists = FileSystem.exists(filePath);\n        const shouldWrite = !fileExists ||\n            overwrite ||\n            (interactiveMode ? await this._promptForOverwrite(promptModule, filePath) : false);\n        if (!interactiveMode && fileExists && !overwrite) {\n            throw new Error(`Changefile ${filePath} already exists`);\n        }\n        if (shouldWrite) {\n            this._writeFile(filePath, output, shouldWrite && fileExists);\n            return filePath;\n        }\n    }\n    async _promptForOverwrite(promptModule, filePath) {\n        const overwrite = await promptModule([\n            {\n                name: 'overwrite',\n                type: 'confirm',\n                message: `Overwrite ${filePath}?`\n            }\n        ]);\n        if (overwrite) {\n            return true;\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`Not overwriting ${filePath}`);\n            return false;\n        }\n    }\n    /**\n     * Writes a file to disk, ensuring the directory structure up to that point exists\n     */\n    _writeFile(fileName, output, isOverwrite) {\n        FileSystem.writeFile(fileName, output, { ensureFolderExists: true });\n        if (isOverwrite) {\n            // eslint-disable-next-line no-console\n            console.log(`Overwrote file: ${fileName}`);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`Created file: ${fileName}`);\n        }\n    }\n    _logNoChangeFileRequired() {\n        // eslint-disable-next-line no-console\n        console.log('No changes were detected to relevant packages on this branch. Nothing to do.');\n    }\n    _stageAndCommitGitChanges(pattern, message) {\n        try {\n            Utilities.executeCommand({\n                command: 'git',\n                args: ['add', ...pattern],\n                workingDirectory: this.rushConfiguration.changesFolder\n            });\n            Utilities.executeCommand({\n                command: 'git',\n                args: ['commit', ...pattern, '-m', message],\n                workingDirectory: this.rushConfiguration.changesFolder\n            });\n        }\n        catch (error) {\n            this._terminal.writeErrorLine(`ERROR: Cannot stage and commit git changes ${error.message}`);\n        }\n    }\n}\n//# sourceMappingURL=ChangeAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { BaseRushAction } from './BaseRushAction';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport { Variants } from '../../api/Variants';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\nexport class CheckAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'check',\n            summary: \"Checks each project's package.json files and ensures that all dependencies are of the same \" +\n                'version throughout the repository.',\n            documentation: \"Checks each project's package.json files and ensures that all dependencies are of the \" +\n                'same version throughout the repository.',\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));\n        this._variant = this.defineStringParameter(Variants.VARIANT_PARAMETER);\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._verboseFlag = this.defineFlagParameter({\n            parameterLongName: '--verbose',\n            description: 'If this flag is specified, long lists of package names will not be truncated. ' +\n                `This has no effect if the ${this._jsonFlag.longName} flag is also specified.`\n        });\n    }\n    async runAsync() {\n        const variant = this.rushConfiguration.currentInstalledVariant;\n        if (!this._variant.value && variant) {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow(`Variant '${variant}' has been installed, but 'rush check' is currently checking the default variant. ` +\n                `Use 'rush check --variant '${variant}' to check the current installation.`));\n        }\n        VersionMismatchFinder.rushCheck(this.rushConfiguration, this._terminal, {\n            variant: this._variant.value,\n            printAsJson: this._jsonFlag.value,\n            truncateLongPackageNameLists: !this._verboseFlag.value\n        });\n    }\n}\n//# sourceMappingURL=CheckAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PnpmfileConfiguration } from '../../logic/pnpm/PnpmfileConfiguration';\nexport class DeployAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'deploy',\n            summary: 'Prepares a deployment by copying a subset of Rush projects and their dependencies' +\n                ' to a target folder',\n            documentation: 'After building the repo, \"rush deploy\" can be used to prepare a deployment by copying' +\n                ' a subset of Rush projects and their dependencies to a target folder, which can then be uploaded to' +\n                ' a production server.  The \"rush deploy\" behavior is specified by a scenario config file that must' +\n                ' be created first, using the \"rush init-deploy\" command.',\n            parser,\n            // It is okay to invoke multiple instances of \"rush deploy\" simultaneously, if they are writing\n            // to different target folders.\n            safeForSimultaneousRushProcesses: true\n        });\n        this._logger = this.rushSession.getLogger('deploy');\n        this._project = this.defineStringParameter({\n            parameterLongName: '--project',\n            parameterShortName: '-p',\n            argumentName: 'PROJECT_NAME',\n            description: 'Specifies the name of the main Rush project to be deployed. It must appear in the' +\n                ' \"deploymentProjectNames\" setting in the deployment config file.'\n        });\n        this._scenario = this.defineStringParameter({\n            parameterLongName: '--scenario',\n            parameterShortName: '-s',\n            argumentName: 'SCENARIO_NAME',\n            description: 'By default, the deployment configuration is specified in \"common/config/rush/deploy.json\".' +\n                ' You can use \"--scenario\" to specify an alternate name. The name must be lowercase and separated by dashes.' +\n                ' For example, if SCENARIO_NAME is \"web\", then the config file would be \"common/config/rush/deploy-web.json\".'\n        });\n        this._overwrite = this.defineFlagParameter({\n            parameterLongName: '--overwrite',\n            description: 'By default, deployment will fail if the target folder is not empty.  SPECIFYING THIS FLAG' +\n                ' WILL RECURSIVELY DELETE EXISTING CONTENTS OF THE TARGET FOLDER.'\n        });\n        this._targetFolder = this.defineStringParameter({\n            parameterLongName: '--target-folder',\n            parameterShortName: '-t',\n            argumentName: 'PATH',\n            environmentVariable: 'RUSH_DEPLOY_TARGET_FOLDER',\n            description: 'By default, files are deployed to the \"common/deploy\" folder inside the Rush repo.' +\n                ' Use this parameter to specify a different location. ' +\n                ' WARNING: USE CAUTION WHEN COMBINING WITH \"--overwrite\"'\n        });\n        this._createArchivePath = this.defineStringParameter({\n            parameterLongName: '--create-archive',\n            argumentName: 'ARCHIVE_PATH',\n            description: 'If specified, after the deployment has been prepared, \"rush deploy\"' +\n                ' will create an archive containing the contents of the target folder.' +\n                ' The newly created archive file will be placed according to the designated path, relative' +\n                ' to the target folder. Supported file extensions: .zip'\n        });\n        this._createArchiveOnly = this.defineFlagParameter({\n            parameterLongName: '--create-archive-only',\n            description: 'If specified, \"rush deploy\" will only create an archive containing the contents of the target folder.' +\n                ' The target folder will not be modified other than to create the archive file.'\n        });\n    }\n    async runAsync() {\n        const scenarioName = this._scenario.value;\n        const { DeployScenarioConfiguration } = await import('../../logic/deploy/DeployScenarioConfiguration');\n        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(scenarioName, this.rushConfiguration);\n        const scenarioConfiguration = DeployScenarioConfiguration.loadFromFile(this._logger.terminal, scenarioFilePath, this.rushConfiguration);\n        let mainProjectName = this._project.value;\n        if (!mainProjectName) {\n            if (scenarioConfiguration.json.deploymentProjectNames.length === 1) {\n                // If there is only one project, then \"--project\" is optional\n                mainProjectName = scenarioConfiguration.json.deploymentProjectNames[0];\n            }\n            else {\n                throw new Error(`The ${path.basename(scenarioFilePath)} configuration specifies multiple items for` +\n                    ` \"deploymentProjectNames\". Use the \"--project\" parameter to indicate the project to be deployed.`);\n            }\n        }\n        else {\n            if (scenarioConfiguration.json.deploymentProjectNames.indexOf(mainProjectName) < 0) {\n                throw new Error(`The project \"${mainProjectName}\" does not appear in the list of \"deploymentProjectNames\"` +\n                    ` from ${path.basename(scenarioFilePath)}.`);\n            }\n        }\n        const targetRootFolder = this._targetFolder.value\n            ? path.resolve(this._targetFolder.value)\n            : path.join(this.rushConfiguration.commonFolder, 'deploy');\n        const createArchiveFilePath = this._createArchivePath.value\n            ? path.resolve(targetRootFolder, this._createArchivePath.value)\n            : undefined;\n        const createArchiveOnly = this._createArchiveOnly.value;\n        let transformPackageJson;\n        let pnpmInstallFolder;\n        if (this.rushConfiguration.packageManager === 'pnpm') {\n            const pnpmfileConfiguration = await PnpmfileConfiguration.initializeAsync(this.rushConfiguration);\n            transformPackageJson = pnpmfileConfiguration.transform.bind(pnpmfileConfiguration);\n            if (!scenarioConfiguration.json.omitPnpmWorkaroundLinks) {\n                pnpmInstallFolder = this.rushConfiguration.commonTempFolder;\n            }\n        }\n        // Construct the project list for the deployer\n        const projectConfigurations = [];\n        for (const project of this.rushConfiguration.projects) {\n            const scenarioProjectJson = scenarioConfiguration.projectJsonsByName.get(project.packageName);\n            projectConfigurations.push({\n                projectName: project.packageName,\n                projectFolder: project.projectFolder,\n                additionalProjectsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalProjectsToInclude,\n                additionalDependenciesToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalDependenciesToInclude,\n                dependenciesToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.dependenciesToExclude,\n                patternsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToInclude,\n                patternsToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToExclude\n            });\n        }\n        // Call the deploy manager\n        const { PackageExtractor } = await import(\n        /* webpackChunkName: 'PackageExtractor' */\n        '@rushstack/package-extractor');\n        const deployManager = new PackageExtractor();\n        await deployManager.extractAsync({\n            terminal: this._logger.terminal,\n            overwriteExisting: !!this._overwrite.value,\n            includeDevDependencies: scenarioConfiguration.json.includeDevDependencies,\n            includeNpmIgnoreFiles: scenarioConfiguration.json.includeNpmIgnoreFiles,\n            folderToCopy: scenarioConfiguration.json.folderToCopy,\n            linkCreation: scenarioConfiguration.json.linkCreation,\n            sourceRootFolder: this.rushConfiguration.rushJsonFolder,\n            targetRootFolder,\n            mainProjectName,\n            projectConfigurations,\n            dependencyConfigurations: scenarioConfiguration.json.dependencySettings,\n            createArchiveFilePath,\n            createArchiveOnly,\n            pnpmInstallFolder,\n            transformPackageJson\n        });\n    }\n}\n//# sourceMappingURL=DeployAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { FileSystem, NewlineKind, InternalError, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { BaseConfiglessRushAction } from './BaseRushAction';\nimport { Rush } from '../../api/Rush';\nimport { assetsFolderPath } from '../../utilities/PathConstants';\n// Matches a well-formed BEGIN macro starting a block section.\n// Example:  /*[BEGIN \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst BEGIN_MARCO_REGEXP = /^(\\s*)\\/\\*\\[BEGIN \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n// Matches a well-formed END macro ending a block section.\n// Example:  /*[END \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst END_MACRO_REGEXP = /^(\\s*)\\/\\*\\[END \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n// Matches a well-formed single-line section, including the space character after it\n// if present.\n// Example:  /*[LINE \"HYPOTHETICAL\"]*/\n//\n// Group #1 is the section name\nconst LINE_MACRO_REGEXP = /\\/\\*\\[LINE \"([A-Z]+)\"\\]\\s*\\*\\/\\s?/;\n// Matches a variable expansion.\n// Example:  [%RUSH_VERSION%]\n//\n// Group #1 is the variable name including the dollar sign\nconst VARIABLE_MACRO_REGEXP = /\\[(%[A-Z0-9_]+%)\\]/;\n// Matches anything that starts with \"/*[\" and ends with \"]*/\"\n// Used to catch malformed macro expressions\nconst ANY_MACRO_REGEXP = /\\/\\*\\s*\\[.*\\]\\s*\\*\\//;\nexport class InitAction extends BaseConfiglessRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init',\n            summary: 'Initializes a new repository to be managed by Rush',\n            documentation: 'When invoked in an empty folder, this command provisions a standard' +\n                ' set of config file templates to start managing projects using Rush.',\n            parser\n        });\n        // template section name --> whether it should be commented out\n        this._commentedBySectionName = new Map();\n        this._overwriteParameter = this.defineFlagParameter({\n            parameterLongName: '--overwrite-existing',\n            description: 'By default \"rush init\" will not overwrite existing config files.' +\n                ' Specify this switch to override that. This can be useful when upgrading' +\n                ' your repo to a newer release of Rush. WARNING: USE WITH CARE!'\n        });\n        this._rushExampleParameter = this.defineFlagParameter({\n            parameterLongName: '--rush-example-repo',\n            description: 'When copying the template config files, this uncomments fragments that are used' +\n                ' by the \"rush-example\" GitHub repo, which is a sample monorepo that illustrates many Rush' +\n                ' features. This option is primarily intended for maintaining that example.'\n        });\n    }\n    async runAsync() {\n        const initFolder = process.cwd();\n        if (!this._overwriteParameter.value) {\n            if (!this._validateFolderIsEmpty(initFolder)) {\n                throw new AlreadyReportedError();\n            }\n        }\n        this._defineMacroSections();\n        this._copyTemplateFiles(initFolder);\n    }\n    _defineMacroSections() {\n        this._commentedBySectionName.clear();\n        // The \"HYPOTHETICAL\" sections are always commented out by \"rush init\".\n        // They are uncommented in the \"assets\" source folder so that we can easily validate\n        // that they conform to their JSON schema.\n        this._commentedBySectionName.set('HYPOTHETICAL', true);\n        // The \"DEMO\" sections are uncommented only when \"--rush-example-repo\" is specified.\n        this._commentedBySectionName.set('DEMO', !this._rushExampleParameter.value);\n    }\n    // Check whether it's safe to run \"rush init\" in the current working directory.\n    _validateFolderIsEmpty(initFolder) {\n        if (this.rushConfiguration !== undefined) {\n            // eslint-disable-next-line no-console\n            console.error(colors.red('ERROR: Found an existing configuration in: ' + this.rushConfiguration.rushJsonFile));\n            // eslint-disable-next-line no-console\n            console.log('\\nThe \"rush init\" command must be run in a new folder without an existing Rush configuration.');\n            return false;\n        }\n        for (const itemName of FileSystem.readFolderItemNames(initFolder)) {\n            if (itemName.substr(0, 1) === '.') {\n                // Ignore any items that start with \".\", for example \".git\"\n                continue;\n            }\n            const itemPath = path.join(initFolder, itemName);\n            const stats = FileSystem.getStatistics(itemPath);\n            // Ignore any loose files in the current folder, e.g. \"README.md\"\n            // or \"CONTRIBUTING.md\"\n            if (stats.isDirectory()) {\n                // eslint-disable-next-line no-console\n                console.error(colors.red(`ERROR: Found a subdirectory: \"${itemName}\"`));\n                // eslint-disable-next-line no-console\n                console.log('\\nThe \"rush init\" command must be run in a new folder with no projects added yet.');\n                return false;\n            }\n            else {\n                if (itemName.toLowerCase() === 'package.json') {\n                    // eslint-disable-next-line no-console\n                    console.error(colors.red(`ERROR: Found a package.json file in this folder`));\n                    // eslint-disable-next-line no-console\n                    console.log('\\nThe \"rush init\" command must be run in a new folder with no projects added yet.');\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    _copyTemplateFiles(initFolder) {\n        // The \"[dot]\" base name is used for hidden files to prevent various tools from interpreting them.\n        // For example, \"npm publish\" will always exclude the filename \".gitignore\"\n        const templateFilePaths = [\n            '[dot]github/workflows/ci.yml',\n            'common/config/rush/.pnpmfile.cjs',\n            'common/config/rush/[dot]npmrc',\n            'common/config/rush/[dot]npmrc-publish',\n            'common/config/rush/artifactory.json',\n            'common/config/rush/build-cache.json',\n            'common/config/rush/cobuild.json',\n            'common/config/rush/command-line.json',\n            'common/config/rush/common-versions.json',\n            'common/config/rush/custom-tips.json',\n            'common/config/rush/experiments.json',\n            'common/config/rush/pnpm-config.json',\n            'common/config/rush/rush-plugins.json',\n            'common/config/rush/version-policies.json',\n            'common/git-hooks/commit-msg.sample',\n            '[dot]gitattributes',\n            '[dot]gitignore',\n            'rush.json'\n        ];\n        const assetsSubfolder = `${assetsFolderPath}/rush-init`;\n        for (const templateFilePath of templateFilePaths) {\n            const sourcePath = path.join(assetsSubfolder, templateFilePath);\n            if (!FileSystem.exists(sourcePath)) {\n                // If this happens, please report a Rush bug\n                throw new InternalError('Unable to find template input file: ' + sourcePath);\n            }\n            const destinationPath = path.join(initFolder, templateFilePath).replace('[dot]', '.');\n            this._copyTemplateFile(sourcePath, destinationPath);\n        }\n    }\n    // Copy the template from sourcePath, transform any macros, and write the output to destinationPath.\n    //\n    // We implement a simple template engine.  \"Single-line section\" macros have this form:\n    //\n    //     /*[LINE \"NAME\"]*/ (content goes here)\n    //\n    // ...and when commented out will look like this:\n    //\n    //     // (content goes here)\n    //\n    // \"Block section\" macros have this form:\n    //\n    //     /*[BEGIN \"NAME\"]*/\n    //     (content goes\n    //     here)\n    //     /*[END \"NAME\"]*/\n    //\n    // ...and when commented out will look like this:\n    //\n    //     // (content goes\n    //     // here)\n    //\n    // Lastly, a variable expansion has this form:\n    //\n    //     // The value is [%NAME%].\n    //\n    // ...and when expanded with e.g. \"123\" will look like this:\n    //\n    //     // The value is 123.\n    //\n    // The section names must be one of the predefined names used by \"rush init\".\n    // A single-line section may appear inside a block section, in which case it will get\n    // commented twice.\n    _copyTemplateFile(sourcePath, destinationPath) {\n        const destinationFileExists = FileSystem.exists(destinationPath);\n        if (!this._overwriteParameter.value) {\n            if (destinationFileExists) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Not overwriting already existing file: ') + destinationPath);\n                return;\n            }\n        }\n        if (destinationFileExists) {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow(`Overwriting: ${destinationPath}`));\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`Generating: ${destinationPath}`);\n        }\n        const outputLines = [];\n        const lines = FileSystem.readFile(sourcePath, { convertLineEndings: NewlineKind.Lf }).split('\\n');\n        let activeBlockSectionName = undefined;\n        let activeBlockIndent = '';\n        for (const line of lines) {\n            let match;\n            // Check for a block section start\n            // Example:  /*[BEGIN \"DEMO\"]*/\n            match = line.match(BEGIN_MARCO_REGEXP);\n            if (match) {\n                if (activeBlockSectionName) {\n                    // If this happens, please report a Rush bug\n                    throw new InternalError(`The template contains an unmatched BEGIN macro for \"${activeBlockSectionName}\"`);\n                }\n                activeBlockSectionName = match[2];\n                activeBlockIndent = match[1];\n                // Remove the entire line containing the macro\n                continue;\n            }\n            // Check for a block section end\n            // Example:  /*[END \"DEMO\"]*/\n            match = line.match(END_MACRO_REGEXP);\n            if (match) {\n                if (activeBlockSectionName === undefined) {\n                    // If this happens, please report a Rush bug\n                    throw new InternalError(`The template contains an unmatched END macro for \"${activeBlockSectionName}\"`);\n                }\n                if (activeBlockSectionName !== match[2]) {\n                    // If this happens, please report a Rush bug\n                    throw new InternalError(`The template contains an mismatched END macro for \"${activeBlockSectionName}\"`);\n                }\n                if (activeBlockIndent !== match[1]) {\n                    // If this happens, please report a Rush bug\n                    throw new InternalError(`The template contains an inconsistently indented section \"${activeBlockSectionName}\"`);\n                }\n                activeBlockSectionName = undefined;\n                // Remove the entire line containing the macro\n                continue;\n            }\n            let transformedLine = line;\n            // Check for a single-line section\n            // Example:  /*[LINE \"HYPOTHETICAL\"]*/\n            match = transformedLine.match(LINE_MACRO_REGEXP);\n            if (match) {\n                const sectionName = match[1];\n                const replacement = this._isSectionCommented(sectionName) ? '// ' : '';\n                transformedLine = transformedLine.replace(LINE_MACRO_REGEXP, replacement);\n            }\n            // Check for variable expansions\n            // Example:  [%RUSH_VERSION%]\n            while ((match = transformedLine.match(VARIABLE_MACRO_REGEXP))) {\n                const variableName = match[1];\n                const replacement = this._expandMacroVariable(variableName);\n                transformedLine = transformedLine.replace(VARIABLE_MACRO_REGEXP, replacement);\n            }\n            // Verify that all macros were handled\n            match = transformedLine.match(ANY_MACRO_REGEXP);\n            if (match) {\n                // If this happens, please report a Rush bug\n                throw new InternalError('The template contains a malformed macro expression: ' + JSON.stringify(match[0]));\n            }\n            // If we are inside a block section that is commented out, then insert the \"//\" after indentation\n            if (activeBlockSectionName !== undefined) {\n                if (this._isSectionCommented(activeBlockSectionName)) {\n                    // Is the line indented properly?\n                    if (transformedLine.substr(0, activeBlockIndent.length).trim().length > 0) {\n                        // If this happens, please report a Rush bug\n                        throw new InternalError(`The template contains inconsistently indented lines inside` +\n                            ` the \"${activeBlockSectionName}\" section`);\n                    }\n                    // Insert comment characters after the indentation\n                    const contentAfterIndent = transformedLine.substr(activeBlockIndent.length);\n                    transformedLine = activeBlockIndent + '// ' + contentAfterIndent;\n                }\n            }\n            outputLines.push(transformedLine);\n        }\n        // Write the output\n        FileSystem.writeFile(destinationPath, outputLines.join('\\n'), {\n            ensureFolderExists: true\n        });\n    }\n    _isSectionCommented(sectionName) {\n        const value = this._commentedBySectionName.get(sectionName);\n        if (value === undefined) {\n            // If this happens, please report a Rush bug\n            throw new InternalError(`The template references an undefined section name ${sectionName}`);\n        }\n        return value;\n    }\n    _expandMacroVariable(variableName) {\n        switch (variableName) {\n            case '%RUSH_VERSION%':\n                return Rush.version;\n            default:\n                throw new InternalError(`The template references an undefined variable \"${variableName}\"`);\n        }\n    }\n}\n//# sourceMappingURL=InitAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { FileSystem, NewlineKind, JsonFile } from '@rushstack/node-core-library';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nexport class InitAutoinstallerAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init-autoinstaller',\n            summary: 'Initializes a new autoinstaller',\n            documentation: 'Use this command to initialize a new autoinstaller folder.  Autoinstallers provide a way to' +\n                ' manage a set of related dependencies that are used for scripting scenarios outside of the usual' +\n                ' \"rush install\" context.  See the command-line.json documentation for an example.',\n            parser\n        });\n        this._name = this.defineStringParameter({\n            parameterLongName: '--name',\n            argumentName: 'AUTOINSTALLER_NAME',\n            required: true,\n            description: 'Specifies the name of the autoinstaller folder, which must conform to the naming rules for NPM packages.'\n        });\n    }\n    async runAsync() {\n        const autoinstallerName = this._name.value;\n        const autoinstaller = new Autoinstaller({\n            autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        if (FileSystem.exists(autoinstaller.folderFullPath)) {\n            // It's okay if the folder is empty\n            if (FileSystem.readFolderItemNames(autoinstaller.folderFullPath).length > 0) {\n                throw new Error('The target folder already exists: ' + autoinstaller.folderFullPath);\n            }\n        }\n        const packageJson = {\n            name: autoinstallerName,\n            version: '1.0.0',\n            private: true,\n            dependencies: {}\n        };\n        // eslint-disable-next-line no-console\n        console.log(colors.green('Creating package: ') + autoinstaller.packageJsonPath);\n        JsonFile.save(packageJson, autoinstaller.packageJsonPath, {\n            ensureFolderExists: true,\n            newlineConversion: NewlineKind.OsDefault\n        });\n        // eslint-disable-next-line no-console\n        console.log('\\nFile successfully written. Add your dependencies before committing.');\n    }\n}\n//# sourceMappingURL=InitAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { BaseRushAction } from './BaseRushAction';\nimport { FileSystem, NewlineKind } from '@rushstack/node-core-library';\nimport { DeployScenarioConfiguration } from '../../logic/deploy/DeployScenarioConfiguration';\nimport { assetsFolderPath } from '../../utilities/PathConstants';\nconst CONFIG_TEMPLATE_PATH = `${assetsFolderPath}/rush-init-deploy/scenario-template.json`;\nexport class InitDeployAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init-deploy',\n            summary: 'Creates a deployment scenario config file for use with \"rush deploy\".',\n            documentation: 'Use this command to initialize a new scenario config file for use with \"rush deploy\".' +\n                ' The default filename is common/config/rush/deploy.json. However, if you need to manage multiple' +\n                ' deployments with different settings, you can use use \"--scenario\" to create additional config files.',\n            parser\n        });\n        this._project = this.defineStringParameter({\n            parameterLongName: '--project',\n            parameterShortName: '-p',\n            argumentName: 'PROJECT_NAME',\n            required: true,\n            description: 'Specifies the name of the main Rush project to be deployed in this scenario.' +\n                ' It will be added to the \"deploymentProjectNames\" setting.'\n        });\n        this._scenario = this.defineStringParameter({\n            parameterLongName: '--scenario',\n            parameterShortName: '-s',\n            argumentName: 'SCENARIO',\n            description: 'By default, the deployment configuration will be written to \"common/config/rush/deploy.json\".' +\n                ' You can use \"--scenario\" to specify an alternate name. The name must be lowercase and separated by dashes.' +\n                ' For example, if the name is \"web\", then the config file would be \"common/config/rush/deploy-web.json\".'\n        });\n    }\n    async runAsync() {\n        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(this._scenario.value, this.rushConfiguration);\n        if (FileSystem.exists(scenarioFilePath)) {\n            throw new Error('The target file already exists:\\n' +\n                scenarioFilePath +\n                '\\nIf you intend to replace it, please delete the old file first.');\n        }\n        // eslint-disable-next-line no-console\n        console.log(colors.green('Creating scenario file: ') + scenarioFilePath);\n        const shortProjectName = this._project.value;\n        const rushProject = this.rushConfiguration.findProjectByShorthandName(shortProjectName);\n        if (!rushProject) {\n            throw new Error(`The specified project was not found in rush.json: \"${shortProjectName}\"`);\n        }\n        const templateContent = FileSystem.readFile(CONFIG_TEMPLATE_PATH);\n        const expandedContent = templateContent.replace('[%PROJECT_NAME_TO_DEPLOY%]', rushProject.packageName);\n        FileSystem.writeFile(scenarioFilePath, expandedContent, {\n            ensureFolderExists: true,\n            convertLineEndings: NewlineKind.OsDefault\n        });\n        // eslint-disable-next-line no-console\n        console.log('\\nFile successfully written. Please review the file contents before committing.');\n    }\n}\n//# sourceMappingURL=InitDeployAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\nimport { BaseInstallAction } from './BaseInstallAction';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nexport class InstallAction extends BaseInstallAction {\n    constructor(parser) {\n        super({\n            actionName: 'install',\n            summary: 'Install package dependencies for all projects in the repo according to the shrinkwrap file',\n            documentation: 'The \"rush install\" command installs package dependencies for all your projects,' +\n                ' based on the shrinkwrap file that is created/updated using \"rush update\".' +\n                ' (This \"shrinkwrap\" file stores a central inventory of all dependencies and versions' +\n                ' for projects in your repo. It is found in the \"common/config/rush\" folder.)' +\n                ' If the shrinkwrap file is missing or outdated (e.g. because project package.json files have' +\n                ' changed), \"rush install\" will fail and tell you to run \"rush update\" instead.' +\n                ' This read-only nature is the main feature:  Continuous integration builds should use' +\n                ' \"rush install\" instead of \"rush update\" to catch developers who forgot to commit their' +\n                ' shrinkwrap changes.  Cautious people can also use \"rush install\" if they want to avoid' +\n                ' accidentally updating their shrinkwrap file.',\n            parser\n        });\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            // Include lockfile processing since this expands the selection, and we need to select\n            // at least the same projects selected with the same query to \"rush build\"\n            includeExternalDependencies: true,\n            // Disable filtering because rush-project.json is riggable and therefore may not be available\n            enableFiltering: false\n        });\n        this._checkOnlyParameter = this.defineFlagParameter({\n            parameterLongName: '--check-only',\n            description: `Only check the validity of the shrinkwrap file without performing an install.`\n        });\n    }\n    async buildInstallOptionsAsync() {\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        return {\n            debug: this.parser.isDebug,\n            allowShrinkwrapUpdates: false,\n            bypassPolicyAllowed: true,\n            bypassPolicy: this._bypassPolicyParameter.value,\n            noLink: this._noLinkParameter.value,\n            fullUpgrade: false,\n            recheckShrinkwrap: false,\n            networkConcurrency: this._networkConcurrencyParameter.value,\n            collectLogFile: this._debugPackageManagerParameter.value,\n            variant: this._variant.value,\n            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,\n            // it is safe to assume that the value is not null\n            maxInstallAttempts: this._maxInstallAttempts.value,\n            // These are derived independently of the selection for command line brevity\n            pnpmFilterArguments: await this._selectionParameters.getPnpmFilterArgumentsAsync(terminal),\n            checkOnly: this._checkOnlyParameter.value,\n            beforeInstallAsync: () => this.rushSession.hooks.beforeInstall.promise(this)\n        };\n    }\n}\n//# sourceMappingURL=InstallAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nexport class LinkAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'link',\n            summary: 'Create node_modules symlinks for all projects',\n            documentation: 'Create node_modules symlinks for all projects.  This operation is normally performed' +\n                ' automatically as part of \"rush install\" or \"rush update\".  You should only need to use \"rush link\"' +\n                ' if you performed \"rush unlink\" for some reason, or if you specified the \"--no-link\" option' +\n                ' for \"rush install\" or \"rush update\".',\n            parser\n        });\n        this._force = this.defineFlagParameter({\n            parameterLongName: '--force',\n            parameterShortName: '-f',\n            description: 'Deletes and recreates all links, even if the filesystem state seems to indicate that this is ' +\n                'unnecessary.'\n        });\n    }\n    async runAsync() {\n        const linkManagerFactoryModule = await import(\n        /* webpackChunkName: 'LinkManagerFactory' */\n        '../../logic/LinkManagerFactory');\n        const linkManager = linkManagerFactoryModule.LinkManagerFactory.getLinkManager(this.rushConfiguration);\n        await linkManager.createSymlinksForProjects(this._force.value);\n    }\n}\n//# sourceMappingURL=LinkAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ConsoleTerminalProvider, Sort, Terminal } from '@rushstack/node-core-library';\nimport { BaseRushAction } from './BaseRushAction';\nimport { VersionPolicyDefinitionName } from '../../api/VersionPolicy';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nexport class ListAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'list',\n            summary: 'List package information for all projects in the repo',\n            documentation: 'List package names, and optionally version (--version) and ' +\n                'path (--path) or full path (--full-path), for projects in the ' +\n                'current rush config.',\n            parser,\n            safeForSimultaneousRushProcesses: true\n        });\n        this._version = this.defineFlagParameter({\n            parameterLongName: '--version',\n            parameterShortName: '-v',\n            description: 'If this flag is specified, the project version will be ' +\n                'displayed in a column along with the package name.'\n        });\n        this._path = this.defineFlagParameter({\n            parameterLongName: '--path',\n            parameterShortName: '-p',\n            description: 'If this flag is specified, the project path will be ' +\n                'displayed in a column along with the package name.'\n        });\n        this._fullPath = this.defineFlagParameter({\n            parameterLongName: '--full-path',\n            description: 'If this flag is specified, the project full path will ' +\n                'be displayed in a column along with the package name.'\n        });\n        this._detailedFlag = this.defineFlagParameter({\n            parameterLongName: '--detailed',\n            description: 'For the non --json view, if this flag is specified, ' +\n                'include path (-p), version (-v) columns along with ' +\n                \"the project's applicable: versionPolicy, versionPolicyName, \" +\n                'shouldPublish, reviewPolicy, and tags fields.'\n        });\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            // Include lockfile processing since this expands the selection, and we need to select\n            // at least the same projects selected with the same query to \"rush build\"\n            includeExternalDependencies: true,\n            // Disable filtering because rush-project.json is riggable and therefore may not be available\n            enableFiltering: false\n        });\n    }\n    async runAsync() {\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        const selection = await this._selectionParameters.getSelectedProjectsAsync(terminal);\n        Sort.sortSetBy(selection, (x) => x.packageName);\n        if (this._jsonFlag.value && this._detailedFlag.value) {\n            throw new Error(`The parameters \"--json\" and \"--detailed\" cannot be used together.`);\n        }\n        if (this._jsonFlag.value) {\n            this._printJson(selection);\n        }\n        else if (this._version.value || this._path.value || this._fullPath.value || this._detailedFlag.value) {\n            await this._printListTableAsync(selection);\n        }\n        else {\n            this._printList(selection);\n        }\n    }\n    _printJson(selection) {\n        const projects = Array.from(selection, (config) => {\n            let reviewCategory;\n            let shouldPublish;\n            let versionPolicy;\n            let versionPolicyName;\n            if (config.versionPolicy !== undefined) {\n                const definitionName = VersionPolicyDefinitionName[config.versionPolicy.definitionName];\n                versionPolicy = `${definitionName}`;\n                versionPolicyName = config.versionPolicy.policyName;\n            }\n            else {\n                shouldPublish = config.shouldPublish;\n            }\n            if (config.reviewCategory) {\n                reviewCategory = config.reviewCategory;\n            }\n            return {\n                name: config.packageName,\n                version: config.packageJson.version,\n                path: config.projectRelativeFolder,\n                fullPath: config.projectFolder,\n                versionPolicy,\n                versionPolicyName,\n                shouldPublish,\n                reviewCategory,\n                tags: Array.from(config.tags)\n            };\n        });\n        const output = {\n            projects\n        };\n        // eslint-disable-next-line no-console\n        console.log(JSON.stringify(output, undefined, 2));\n    }\n    _printList(selection) {\n        for (const project of selection) {\n            // eslint-disable-next-line no-console\n            console.log(project.packageName);\n        }\n    }\n    async _printListTableAsync(selection) {\n        const tableHeader = ['Project'];\n        if (this._version.value || this._detailedFlag.value) {\n            tableHeader.push('Version');\n        }\n        if (this._path.value || this._detailedFlag.value) {\n            tableHeader.push('Path');\n        }\n        if (this._fullPath.value) {\n            tableHeader.push('Full Path');\n        }\n        if (this._detailedFlag.value) {\n            tableHeader.push('Version policy');\n            tableHeader.push('Version policy name');\n            tableHeader.push('Should publish');\n            tableHeader.push('Review category');\n            tableHeader.push('Tags');\n        }\n        const { default: CliTable } = await import('cli-table');\n        const table = new CliTable({\n            head: tableHeader\n        });\n        for (const project of selection) {\n            const packageRow = [];\n            function appendToPackageRow(value) {\n                packageRow.push(value === undefined ? 'UNDEFINED' : value);\n            }\n            appendToPackageRow(project.packageName);\n            if (this._version.value || this._detailedFlag.value) {\n                appendToPackageRow(project.packageJson.version);\n            }\n            if (this._path.value || this._detailedFlag.value) {\n                appendToPackageRow(project.projectRelativeFolder);\n            }\n            if (this._fullPath.value) {\n                appendToPackageRow(project.projectFolder);\n            }\n            if (this._detailedFlag.value) {\n                // When we HAVE a version policy\n                let versionPolicyDefinitionName = '';\n                let versionPolicyName = '';\n                // When we DO NOT have version policy, fallback to shouldPublish boolean\n                let shouldPublish = '';\n                let reviewCategory = '';\n                if (project.versionPolicy !== undefined) {\n                    const definitionName = VersionPolicyDefinitionName[project.versionPolicy.definitionName];\n                    versionPolicyDefinitionName = definitionName;\n                    versionPolicyName = project.versionPolicy.policyName;\n                }\n                else {\n                    shouldPublish = `${project.shouldPublish}`;\n                }\n                if (project.reviewCategory) {\n                    reviewCategory = project.reviewCategory;\n                }\n                appendToPackageRow(versionPolicyDefinitionName);\n                appendToPackageRow(versionPolicyName);\n                appendToPackageRow(shouldPublish);\n                appendToPackageRow(reviewCategory);\n                appendToPackageRow(Array.from(project.tags).join(', '));\n            }\n            table.push(packageRow);\n        }\n        // eslint-disable-next-line no-console\n        console.log(table.toString());\n    }\n}\n//# sourceMappingURL=ListAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { ChangeType } from '../../api/ChangeManagement';\nimport { Npm } from '../../utilities/Npm';\nimport { PublishUtilities } from '../../logic/PublishUtilities';\nimport { ChangelogGenerator } from '../../logic/ChangelogGenerator';\nimport { PrereleaseToken } from '../../logic/PrereleaseToken';\nimport { ChangeManager } from '../../logic/ChangeManager';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PublishGit } from '../../logic/PublishGit';\nimport * as PolicyValidator from '../../logic/policy/PolicyValidator';\nimport { DEFAULT_PACKAGE_UPDATE_MESSAGE } from './VersionAction';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Git } from '../../logic/Git';\nexport class PublishAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'publish',\n            summary: 'Reads and processes package publishing change requests generated by \"rush change\".',\n            documentation: 'Reads and processes package publishing change requests generated by \"rush change\". This will perform a ' +\n                // eslint-disable-next-line no-console\n                'read-only operation by default, printing operations executed to the console. To commit ' +\n                'changes and publish packages, you must use the --commit flag and/or the --publish flag.',\n            parser\n        });\n        this._apply = this.defineFlagParameter({\n            parameterLongName: '--apply',\n            parameterShortName: '-a',\n            description: 'If this flag is specified, the change requests will be applied to package.json files.'\n        });\n        this._targetBranch = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this flag is specified, applied changes and deleted change requests will be ' +\n                'committed and merged into the target branch.'\n        });\n        this._publish = this.defineFlagParameter({\n            parameterLongName: '--publish',\n            parameterShortName: '-p',\n            description: 'If this flag is specified, applied changes will be published to the NPM registry.'\n        });\n        this._addCommitDetails = this.defineFlagParameter({\n            parameterLongName: '--add-commit-details',\n            parameterShortName: undefined,\n            description: 'Adds commit author and hash to the changelog.json files for each change.'\n        });\n        this._regenerateChangelogs = this.defineFlagParameter({\n            parameterLongName: '--regenerate-changelogs',\n            parameterShortName: undefined,\n            description: 'Regenerates all changelog files based on the current JSON content.'\n        });\n        // NPM registry related parameters\n        this._registryUrl = this.defineStringParameter({\n            parameterLongName: '--registry',\n            parameterShortName: '-r',\n            argumentName: 'REGISTRY',\n            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +\n                'tagged.'\n        });\n        this._npmAuthToken = this.defineStringParameter({\n            parameterLongName: '--npm-auth-token',\n            parameterShortName: '-n',\n            argumentName: 'TOKEN',\n            description: '(DEPRECATED) Specifies the authentication token to use during publishing. This parameter is deprecated' +\n                ' because command line parameters may be readable by unrelated processes on a lab machine. Instead, a' +\n                ' safer practice is to pass the token via an environment variable and reference it from your ' +\n                ' common/config/rush/.npmrc-publish file.'\n        });\n        this._npmTag = this.defineStringParameter({\n            parameterLongName: '--tag',\n            parameterShortName: '-t',\n            argumentName: 'TAG',\n            description: `The tag option to pass to npm publish. By default NPM will publish using the 'latest' tag, even if ` +\n                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +\n                `a tag is important. When hotfix changes are made, this parameter defaults to 'hotfix'.`\n        });\n        this._npmAccessLevel = this.defineChoiceParameter({\n            alternatives: ['public', 'restricted'],\n            parameterLongName: '--set-access-level',\n            parameterShortName: undefined,\n            description: `By default, when Rush invokes \"npm publish\" it will publish scoped packages with an access level ` +\n                `of \"restricted\". Scoped packages can be published with an access level of \"public\" by specifying ` +\n                `that value for this flag with the initial publication. NPM always publishes unscoped packages with ` +\n                `an access level of \"public\". For more information, see the NPM documentation for the \"--access\" ` +\n                `option of \"npm publish\".`\n        });\n        // NPM pack tarball related parameters\n        this._pack = this.defineFlagParameter({\n            parameterLongName: '--pack',\n            description: `Packs projects into tarballs instead of publishing to npm repository. It can only be used when ` +\n                `--include-all is specified. If this flag is specified, NPM registry related parameters will be ignored.`\n        });\n        this._releaseFolder = this.defineStringParameter({\n            parameterLongName: '--release-folder',\n            argumentName: 'FOLDER',\n            description: `This parameter is used with --pack parameter to provide customized location for the tarballs instead of ` +\n                `the default value. `\n        });\n        // End of NPM pack tarball related parameters\n        this._includeAll = this.defineFlagParameter({\n            parameterLongName: '--include-all',\n            parameterShortName: undefined,\n            description: 'If this flag is specified, all packages with shouldPublish=true in rush.json ' +\n                'or with a specified version policy ' +\n                'will be published if their version is newer than published version.'\n        });\n        this._versionPolicy = this.defineStringParameter({\n            parameterLongName: '--version-policy',\n            argumentName: 'POLICY',\n            description: 'Version policy name. Only projects with this version policy will be published if used ' +\n                'with --include-all.'\n        });\n        this._prereleaseName = this.defineStringParameter({\n            parameterLongName: '--prerelease-name',\n            argumentName: 'NAME',\n            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'\n        });\n        this._partialPrerelease = this.defineFlagParameter({\n            parameterLongName: '--partial-prerelease',\n            parameterShortName: undefined,\n            description: 'Used with --prerelease-name. Only bump packages to a prerelease version if they have changes.'\n        });\n        this._suffix = this.defineStringParameter({\n            parameterLongName: '--suffix',\n            argumentName: 'SUFFIX',\n            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'\n        });\n        this._force = this.defineFlagParameter({\n            parameterLongName: '--force',\n            parameterShortName: undefined,\n            description: 'If this flag is specified with --publish, packages will be published with --force on npm'\n        });\n        this._applyGitTagsOnPack = this.defineFlagParameter({\n            parameterLongName: '--apply-git-tags-on-pack',\n            description: `If specified with --publish and --pack, git tags will be applied for packages` +\n                ` as if a publish was being run without --pack.`\n        });\n        this._commitId = this.defineStringParameter({\n            parameterLongName: '--commit',\n            parameterShortName: '-c',\n            argumentName: 'COMMIT_ID',\n            description: `Used in conjunction with git tagging -- apply git tags at the commit hash` +\n                ` specified. If not provided, the current HEAD will be tagged.`\n        });\n        this._ignoreGitHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-git-hooks',\n            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`\n        });\n    }\n    /**\n     * Executes the publish action, which will read change request files, apply changes to package.jsons,\n     */\n    async runAsync() {\n        await PolicyValidator.validatePolicyAsync(this.rushConfiguration, { bypassPolicy: false });\n        // Example: \"common\\temp\\publish-home\"\n        this._targetNpmrcPublishFolder = path.join(this.rushConfiguration.commonTempFolder, 'publish-home');\n        // Example: \"common\\temp\\publish-home\\.npmrc\"\n        this._targetNpmrcPublishPath = path.join(this._targetNpmrcPublishFolder, '.npmrc');\n        const allPackages = this.rushConfiguration.projectsByName;\n        if (this._regenerateChangelogs.value) {\n            // eslint-disable-next-line no-console\n            console.log('Regenerating changelogs');\n            ChangelogGenerator.regenerateChangelogs(allPackages, this.rushConfiguration);\n            return;\n        }\n        this._validate();\n        this._addNpmPublishHome();\n        const git = new Git(this.rushConfiguration);\n        const publishGit = new PublishGit(git, this._targetBranch.value);\n        if (this._includeAll.value) {\n            this._publishAll(publishGit, allPackages);\n        }\n        else {\n            this._prereleaseToken = new PrereleaseToken(this._prereleaseName.value, this._suffix.value, this._partialPrerelease.value);\n            await this._publishChangesAsync(git, publishGit, allPackages);\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + colors.green('Rush publish finished successfully.'));\n    }\n    /**\n     * Validate some input parameters\n     */\n    _validate() {\n        if (this._pack.value && !this._includeAll.value) {\n            throw new Error('--pack can only be used with --include-all');\n        }\n        if (this._releaseFolder.value && !this._pack.value) {\n            throw new Error(`--release-folder can only be used with --pack`);\n        }\n        if (this._applyGitTagsOnPack.value && !this._pack.value) {\n            throw new Error(`${this._applyGitTagsOnPack.longName} must be used with ${this._pack.longName}`);\n        }\n    }\n    async _publishChangesAsync(git, publishGit, allPackages) {\n        const changeManager = new ChangeManager(this.rushConfiguration);\n        await changeManager.loadAsync(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);\n        if (changeManager.hasChanges()) {\n            const orderedChanges = changeManager.packageChanges;\n            const tempBranchName = `publish-${Date.now()}`;\n            // Make changes in temp branch.\n            publishGit.checkout(tempBranchName, true);\n            this._setDependenciesBeforePublish();\n            // Make changes to package.json and change logs.\n            changeManager.apply(this._apply.value);\n            await changeManager.updateChangelogAsync(this._apply.value);\n            this._setDependenciesBeforeCommit();\n            if (git.hasUncommittedChanges()) {\n                // Stage, commit, and push the changes to remote temp branch.\n                publishGit.addChanges(':/*');\n                publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);\n                this._setDependenciesBeforePublish();\n                // Override tag parameter if there is a hotfix change.\n                for (const change of orderedChanges) {\n                    if (change.changeType === ChangeType.hotfix) {\n                        this._hotfixTagOverride = 'hotfix';\n                        break;\n                    }\n                }\n                // npm publish the things that need publishing.\n                for (const change of orderedChanges) {\n                    if (change.changeType && change.changeType > ChangeType.dependency) {\n                        const project = allPackages.get(change.packageName);\n                        if (project) {\n                            if (!this._packageExists(project)) {\n                                this._npmPublish(change.packageName, project.publishFolder);\n                            }\n                            else {\n                                // eslint-disable-next-line no-console\n                                console.log(`Skip ${change.packageName}. Package exists.`);\n                            }\n                        }\n                        else {\n                            // eslint-disable-next-line no-console\n                            console.log(`Skip ${change.packageName}. Failed to find its project.`);\n                        }\n                    }\n                }\n                this._setDependenciesBeforeCommit();\n                // Create and push appropriate Git tags.\n                this._gitAddTags(publishGit, orderedChanges);\n                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);\n                // Now merge to target branch.\n                publishGit.checkout(this._targetBranch.value);\n                publishGit.pull(!this._ignoreGitHooksParameter.value);\n                publishGit.merge(tempBranchName, !this._ignoreGitHooksParameter.value);\n                publishGit.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);\n                publishGit.deleteBranch(tempBranchName, true, !this._ignoreGitHooksParameter.value);\n            }\n            else {\n                publishGit.checkout(this._targetBranch.value);\n                publishGit.deleteBranch(tempBranchName, false, !this._ignoreGitHooksParameter.value);\n            }\n        }\n    }\n    _publishAll(git, allPackages) {\n        // eslint-disable-next-line no-console\n        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);\n        let updated = false;\n        allPackages.forEach((packageConfig, packageName) => {\n            if (packageConfig.shouldPublish &&\n                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {\n                const applyTag = (apply) => {\n                    if (!apply) {\n                        return;\n                    }\n                    const packageVersion = packageConfig.packageJson.version;\n                    // Do not create a new tag if one already exists, this will result in a fatal error\n                    if (git.hasTag(packageConfig)) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Not tagging ${packageName}@${packageVersion}. A tag already exists for this version.`);\n                        return;\n                    }\n                    git.addTag(!!this._publish.value, packageName, packageVersion, this._commitId.value, this._prereleaseName.value);\n                    updated = true;\n                };\n                if (this._pack.value) {\n                    // packs to tarball instead of publishing to NPM repository\n                    this._npmPack(packageName, packageConfig);\n                    applyTag(this._applyGitTagsOnPack.value);\n                }\n                else if (this._force.value || !this._packageExists(packageConfig)) {\n                    // Publish to npm repository\n                    this._npmPublish(packageName, packageConfig.publishFolder);\n                    applyTag(true);\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.log(`Skip ${packageName}. Not updated.`);\n                }\n            }\n        });\n        if (updated) {\n            git.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);\n        }\n    }\n    _gitAddTags(git, orderedChanges) {\n        for (const change of orderedChanges) {\n            if (change.changeType &&\n                change.changeType > ChangeType.dependency &&\n                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {\n                git.addTag(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion, this._commitId.value, this._prereleaseName.value);\n            }\n        }\n    }\n    _npmPublish(packageName, packagePath) {\n        const env = PublishUtilities.getEnvArgs();\n        const args = ['publish'];\n        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {\n            this._addSharedNpmConfig(env, args);\n            if (this._npmTag.value) {\n                args.push(`--tag`, this._npmTag.value);\n            }\n            else if (this._hotfixTagOverride) {\n                args.push(`--tag`, this._hotfixTagOverride);\n            }\n            if (this._force.value) {\n                args.push(`--force`);\n            }\n            if (this._npmAccessLevel.value) {\n                args.push(`--access`, this._npmAccessLevel.value);\n            }\n            if (this.rushConfiguration.packageManager === 'pnpm') {\n                // PNPM 4.11.0 introduced a feature that may interrupt publishing and prompt the user for input.\n                // See this issue for details: https://github.com/microsoft/rushstack/issues/1940\n                args.push('--no-git-checks');\n            }\n            // TODO: Yarn's \"publish\" command line is fairly different from NPM and PNPM.  The right thing to do here\n            // would be to remap our options to the Yarn equivalents.  But until we get around to that, we'll simply invoke\n            // whatever NPM binary happens to be installed in the global path.\n            const packageManagerToolFilename = this.rushConfiguration.packageManager === 'yarn'\n                ? 'npm'\n                : this.rushConfiguration.packageManagerToolFilename;\n            // If the auth token was specified via the command line, avoid printing it on the console\n            const secretSubstring = this._npmAuthToken.value;\n            PublishUtilities.execCommand(!!this._publish.value, packageManagerToolFilename, args, packagePath, env, secretSubstring);\n        }\n    }\n    _packageExists(packageConfig) {\n        const env = PublishUtilities.getEnvArgs();\n        const args = [];\n        this._addSharedNpmConfig(env, args);\n        const publishedVersions = Npm.publishedVersions(packageConfig.packageName, packageConfig.publishFolder, env, args);\n        const packageVersion = packageConfig.packageJsonEditor.version;\n        // SemVer supports an obscure (and generally deprecated) feature where \"build metadata\" can be\n        // appended to a version.  For example if our version is \"1.2.3-beta.4+extra567\", then \"+extra567\" is the\n        // build metadata part.  The suffix has no effect on version comparisons and is mostly ignored by\n        // the NPM registry.  Importantly, the queried version number will not include it, so we need to discard\n        // it before comparing against the list of already published versions.\n        const parsedVersion = semver.parse(packageVersion);\n        if (!parsedVersion) {\n            throw new Error(`The package \"${packageConfig.packageName}\" has an invalid \"version\" value`);\n        }\n        // For example, normalize \"1.2.3-beta.4+extra567\" -->\"1.2.3-beta.4\".\n        //\n        // This is redundant in the current API, but might change in the future:\n        // https://github.com/npm/node-semver/issues/264\n        parsedVersion.build = [];\n        const normalizedVersion = parsedVersion.format();\n        return publishedVersions.indexOf(normalizedVersion) >= 0;\n    }\n    _npmPack(packageName, project) {\n        const args = ['pack'];\n        const env = PublishUtilities.getEnvArgs();\n        PublishUtilities.execCommand(!!this._publish.value, this.rushConfiguration.packageManagerToolFilename, args, project.publishFolder, env);\n        if (this._publish.value) {\n            // Copy the tarball the release folder\n            const tarballName = this._calculateTarballName(project);\n            const tarballPath = path.join(project.publishFolder, tarballName);\n            const destFolder = this._releaseFolder.value\n                ? this._releaseFolder.value\n                : path.join(this.rushConfiguration.commonTempFolder, 'artifacts', 'packages');\n            FileSystem.move({\n                sourcePath: tarballPath,\n                destinationPath: path.join(destFolder, tarballName),\n                overwrite: true\n            });\n        }\n    }\n    _calculateTarballName(project) {\n        // Same logic as how npm forms the tarball name\n        const packageName = project.packageName;\n        const name = packageName[0] === '@' ? packageName.substr(1).replace(/\\//g, '-') : packageName;\n        if (this.rushConfiguration.packageManager === 'yarn') {\n            // yarn tarballs have a \"v\" before the version number\n            return `${name}-v${project.packageJson.version}.tgz`;\n        }\n        else {\n            return `${name}-${project.packageJson.version}.tgz`;\n        }\n    }\n    _setDependenciesBeforePublish() {\n        for (const project of this.rushConfiguration.projects) {\n            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {\n                const versionPolicy = project.versionPolicy;\n                if (versionPolicy) {\n                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);\n                }\n            }\n        }\n    }\n    _setDependenciesBeforeCommit() {\n        for (const project of this.rushConfiguration.projects) {\n            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {\n                const versionPolicy = project.versionPolicy;\n                if (versionPolicy) {\n                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);\n                }\n            }\n        }\n    }\n    _addNpmPublishHome() {\n        // Create \"common\\temp\\publish-home\" folder, if it doesn't exist\n        Utilities.createFolderWithRetry(this._targetNpmrcPublishFolder);\n        // Copy down the committed \"common\\config\\rush\\.npmrc-publish\" file, if there is one\n        Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this._targetNpmrcPublishFolder, true);\n    }\n    _addSharedNpmConfig(env, args) {\n        const userHomeEnvVariable = process.platform === 'win32' ? 'USERPROFILE' : 'HOME';\n        let registry = '//registry.npmjs.org/';\n        // Check if .npmrc file exists in \"common\\temp\\publish-home\"\n        if (FileSystem.exists(this._targetNpmrcPublishPath)) {\n            // Redirect userHomeEnvVariable, NPM will use config in \"common\\temp\\publish-home\\.npmrc\"\n            env[userHomeEnvVariable] = this._targetNpmrcPublishFolder;\n        }\n        // Check if registryUrl and token are specified via command-line\n        if (this._registryUrl.value) {\n            const registryUrl = this._registryUrl.value;\n            env['npm_config_registry'] = registryUrl; // eslint-disable-line dot-notation\n            registry = registryUrl.substring(registryUrl.indexOf('//'));\n        }\n        if (this._npmAuthToken.value) {\n            args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);\n        }\n    }\n}\n//# sourceMappingURL=PublishAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { PurgeManager } from '../../logic/PurgeManager';\nimport { UnlinkManager } from '../../logic/UnlinkManager';\nexport class PurgeAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'purge',\n            summary: 'For diagnostic purposes, use this command to delete caches and other temporary files used by Rush',\n            documentation: 'The \"rush purge\" command is used to delete temporary files created by Rush.  This is' +\n                ' useful if you are having problems and suspect that cache files may be corrupt.',\n            parser\n        });\n        this._unsafeParameter = this.defineFlagParameter({\n            parameterLongName: '--unsafe',\n            description: '(UNSAFE!) Also delete shared files such as the package manager instances stored in' +\n                ' the \".rush\" folder in the user\\'s home directory.  This is a more aggressive fix that is' +\n                ' NOT SAFE to run in a live environment because it will cause other concurrent Rush processes to fail.'\n        });\n    }\n    async runAsync() {\n        const stopwatch = Stopwatch.start();\n        const unlinkManager = new UnlinkManager(this.rushConfiguration);\n        const purgeManager = new PurgeManager(this.rushConfiguration, this.rushGlobalFolder);\n        unlinkManager.unlink(/*force:*/ true);\n        if (this._unsafeParameter.value) {\n            purgeManager.purgeUnsafe();\n        }\n        else {\n            purgeManager.purgeNormal();\n        }\n        purgeManager.deleteAll();\n        // eslint-disable-next-line no-console\n        console.log('\\n' +\n            colors.green(`Rush purge started successfully and will complete asynchronously. (${stopwatch.toString()})`));\n    }\n}\n//# sourceMappingURL=PurgeAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\nimport { BaseAddAndRemoveAction } from './BaseAddAndRemoveAction';\nexport class RemoveAction extends BaseAddAndRemoveAction {\n    constructor(parser) {\n        const documentation = [\n            'Removes specified package(s) from the dependencies of the current project (as determined by the current working directory)' +\n                ' and then runs \"rush update\".'\n        ].join('\\n');\n        super({\n            actionName: 'remove',\n            summary: 'Removes one or more dependencies from the package.json and runs rush update.',\n            documentation,\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._terminalProvider = new ConsoleTerminalProvider();\n        this._terminal = new Terminal(this._terminalProvider);\n        this._packageNameList = this.defineStringListParameter({\n            parameterLongName: '--package',\n            parameterShortName: '-p',\n            required: true,\n            argumentName: 'PACKAGE',\n            description: 'The name of the package which should be removed.' +\n                ' To remove multiple packages, run \"rush remove --package foo --package bar\".'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If specified, the dependency will be removed from all projects that declare it.'\n        });\n    }\n    getUpdateOptions() {\n        const projects = super.getProjects();\n        const packagesToRemove = [];\n        for (const specifiedPackageName of this.specifiedPackageNameList) {\n            /**\n             * Name\n             */\n            const packageName = specifiedPackageName;\n            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {\n                throw new Error(`The package name \"${packageName}\" is not valid.`);\n            }\n            for (const project of projects) {\n                if (!project.packageJsonEditor.tryGetDependency(packageName) &&\n                    !project.packageJsonEditor.tryGetDevDependency(packageName)) {\n                    this._terminal.writeLine(`The project \"${project.packageName}\" do not have ${packageName} in package.json.`);\n                }\n            }\n            packagesToRemove.push({ packageName });\n        }\n        return {\n            projects: projects,\n            packagesToUpdate: packagesToRemove,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug,\n            actionName: this.actionName\n        };\n    }\n}\n//# sourceMappingURL=RemoveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport builtinPackageNames from 'builtin-modules';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { BaseConfiglessRushAction } from './BaseRushAction';\nexport class ScanAction extends BaseConfiglessRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'scan',\n            summary: 'When migrating projects into a Rush repo, this command is helpful for detecting' +\n                ' undeclared dependencies.',\n            documentation: `The Node.js module system allows a project to import NPM packages without explicitly` +\n                ` declaring them as dependencies in the package.json file.  Such \"phantom dependencies\"` +\n                ` can cause problems.  Rush and PNPM use symlinks specifically to protect against phantom dependencies.` +\n                ` These protections may cause runtime errors for existing projects when they are first migrated into` +\n                ` a Rush monorepo.  The \"rush scan\" command is a handy tool for fixing these errors. It scans the \"./src\"` +\n                ` and \"./lib\" folders for import syntaxes such as \"import __ from '__'\", \"require('__')\",` +\n                ` and \"System.import('__').  It prints a report of the referenced packages.  This heuristic is` +\n                ` not perfect, but it can save a lot of time when migrating projects.`,\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If this flag is specified, output will list all detected dependencies.'\n        });\n    }\n    async runAsync() {\n        const packageJsonFilename = path.resolve('./package.json');\n        if (!FileSystem.exists(packageJsonFilename)) {\n            throw new Error('You must run \"rush scan\" in a project folder containing a package.json file.');\n        }\n        const requireRegExps = [\n            // Example: require('something')\n            /\\brequire\\s*\\(\\s*[']([^']+\\s*)[']\\)/,\n            /\\brequire\\s*\\(\\s*[\"]([^\"]+)[\"]\\s*\\)/,\n            // Example: require.ensure('something')\n            /\\brequire.ensure\\s*\\(\\s*[']([^']+\\s*)[']\\)/,\n            /\\brequire.ensure\\s*\\(\\s*[\"]([^\"]+)[\"]\\s*\\)/,\n            // Example: require.resolve('something')\n            /\\brequire.resolve\\s*\\(\\s*[']([^']+\\s*)[']\\)/,\n            /\\brequire.resolve\\s*\\(\\s*[\"]([^\"]+)[\"]\\s*\\)/,\n            // Example: System.import('something')\n            /\\bSystem.import\\s*\\(\\s*[']([^']+\\s*)[']\\)/,\n            /\\bSystem.import\\s*\\(\\s*[\"]([^\"]+)[\"]\\s*\\)/,\n            // Example:\n            //\n            // import {\n            //   A, B\n            // } from 'something';\n            /\\bfrom\\s*[']([^']+)[']/,\n            /\\bfrom\\s*[\"]([^\"]+)[\"]/,\n            // Example:  import 'something';\n            /\\bimport\\s*[']([^']+)[']\\s*\\;/,\n            /\\bimport\\s*[\"]([^\"]+)[\"]\\s*\\;/,\n            // Example:\n            // /// <reference types=\"something\" />\n            /\\/\\/\\/\\s*<\\s*reference\\s+types\\s*=\\s*[\"]([^\"]+)[\"]\\s*\\/>/\n        ];\n        // Example: \"my-package/lad/dee/dah\" --> \"my-package\"\n        // Example: \"@ms/my-package\" --> \"@ms/my-package\"\n        // Example: \"lodash.get\" --> \"lodash.get\"\n        const packageRegExp = /^((@[a-z\\-0-9!_]+\\/)?[a-z\\-0-9!_][a-z\\-0-9!_.]*)\\/?/;\n        const requireMatches = new Set();\n        const { default: glob } = await import('fast-glob');\n        const scanResults = await glob(['./*.{ts,js,tsx,jsx}', './{src,lib}/**/*.{ts,js,tsx,jsx}']);\n        for (const filename of scanResults) {\n            try {\n                const contents = FileSystem.readFile(filename);\n                const lines = contents.split('\\n');\n                for (const line of lines) {\n                    for (const requireRegExp of requireRegExps) {\n                        const requireRegExpResult = requireRegExp.exec(line);\n                        if (requireRegExpResult) {\n                            requireMatches.add(requireRegExpResult[1]);\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log(colors.bold('Skipping file due to error: ' + filename));\n            }\n        }\n        const packageMatches = new Set();\n        requireMatches.forEach((requireMatch) => {\n            const packageRegExpResult = packageRegExp.exec(requireMatch);\n            if (packageRegExpResult) {\n                packageMatches.add(packageRegExpResult[1]);\n            }\n        });\n        const detectedPackageNames = [];\n        packageMatches.forEach((packageName) => {\n            if (builtinPackageNames.indexOf(packageName) < 0) {\n                detectedPackageNames.push(packageName);\n            }\n        });\n        detectedPackageNames.sort();\n        const declaredDependencies = new Set();\n        const declaredDevDependencies = new Set();\n        const missingDependencies = [];\n        const unusedDependencies = [];\n        const packageJsonContent = FileSystem.readFile(packageJsonFilename);\n        try {\n            const manifest = JSON.parse(packageJsonContent);\n            if (manifest.dependencies) {\n                for (const depName of Object.keys(manifest.dependencies)) {\n                    declaredDependencies.add(depName);\n                }\n            }\n            if (manifest.devDependencies) {\n                for (const depName of Object.keys(manifest.devDependencies)) {\n                    declaredDevDependencies.add(depName);\n                }\n            }\n        }\n        catch (e) {\n            // eslint-disable-next-line no-console\n            console.error(`JSON.parse ${packageJsonFilename} error`);\n        }\n        for (const detectedPkgName of detectedPackageNames) {\n            /**\n             * Missing(phantom) dependencies are\n             * - used in source code\n             * - not decalred in dependencies and devDependencies in package.json\n             */\n            if (!declaredDependencies.has(detectedPkgName) && !declaredDevDependencies.has(detectedPkgName)) {\n                missingDependencies.push(detectedPkgName);\n            }\n        }\n        for (const declaredPkgName of declaredDependencies) {\n            /**\n             * Unused dependencies are\n             * - declared in dependencies in package.json (devDependencies not included)\n             * - not used in source code\n             */\n            if (!detectedPackageNames.includes(declaredPkgName) && !declaredPkgName.startsWith('@types/')) {\n                unusedDependencies.push(declaredPkgName);\n            }\n        }\n        const output = {\n            detectedDependencies: detectedPackageNames,\n            missingDependencies: missingDependencies,\n            unusedDependencies: unusedDependencies\n        };\n        if (this._jsonFlag.value) {\n            // eslint-disable-next-line no-console\n            console.log(JSON.stringify(output, undefined, 2));\n        }\n        else if (this._allFlag.value) {\n            if (detectedPackageNames.length !== 0) {\n                // eslint-disable-next-line no-console\n                console.log('Dependencies that seem to be imported by this project:');\n                for (const packageName of detectedPackageNames) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log('This project does not seem to import any NPM packages.');\n            }\n        }\n        else {\n            let wroteAnything = false;\n            if (missingDependencies.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Possible phantom dependencies') +\n                    \" - these seem to be imported but aren't listed in package.json:\");\n                for (const packageName of missingDependencies) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n                wroteAnything = true;\n            }\n            if (unusedDependencies.length > 0) {\n                if (wroteAnything) {\n                    // eslint-disable-next-line no-console\n                    console.log('');\n                }\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow('Possible unused dependencies') +\n                    \" - these are listed in package.json but don't seem to be imported:\");\n                for (const packageName of unusedDependencies) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n                wroteAnything = true;\n            }\n            if (!wroteAnything) {\n                // eslint-disable-next-line no-console\n                console.log(colors.green('Everything looks good.') + '  No missing or unused dependencies were found.');\n            }\n        }\n    }\n}\n//# sourceMappingURL=ScanAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { SetupPackageRegistry } from '../../logic/setup/SetupPackageRegistry';\nimport { BaseRushAction } from './BaseRushAction';\nexport class SetupAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'setup',\n            summary: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +\n                ' prerequisites are installed and permissions are configured.',\n            documentation: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +\n                ' prerequisites are installed and permissions are configured.  The initial implementation' +\n                ' configures the NPM registry credentials.  More features will be added later.',\n            parser\n        });\n    }\n    async runAsync() {\n        const setupPackageRegistry = new SetupPackageRegistry({\n            rushConfiguration: this.rushConfiguration,\n            isDebug: this.parser.isDebug,\n            syncNpmrcAlreadyCalled: false\n        });\n        await setupPackageRegistry.checkAndSetup();\n    }\n}\n//# sourceMappingURL=SetupAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { UnlinkManager } from '../../logic/UnlinkManager';\nexport class UnlinkAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'unlink',\n            summary: 'Delete node_modules symlinks for all projects in the repo',\n            documentation: 'This removes the symlinks created by the \"rush link\" command. This is useful for' +\n                ' cleaning a repo using \"git clean\" without accidentally deleting source files, or for using standard NPM' +\n                ' commands on a project.',\n            parser\n        });\n    }\n    async runAsync() {\n        const unlinkManager = new UnlinkManager(this.rushConfiguration);\n        if (!unlinkManager.unlink()) {\n            // eslint-disable-next-line no-console\n            console.log('Nothing to do.');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log('\\nDone.');\n        }\n    }\n}\n//# sourceMappingURL=UnlinkAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseInstallAction } from './BaseInstallAction';\nexport class UpdateAction extends BaseInstallAction {\n    constructor(parser) {\n        super({\n            actionName: 'update',\n            summary: 'Install package dependencies for all projects in the repo,' +\n                ' and create or update the shrinkwrap file as needed',\n            documentation: 'The \"rush update\" command installs the dependencies described in your' +\n                ' package.json files, and updates the shrinkwrap file as needed.' +\n                ' (This \"shrinkwrap\" file stores a central inventory of all dependencies and versions' +\n                ' for projects in your repo. It is found in the \"common/config/rush\" folder.)' +\n                ' Note that Rush always performs a single install for all projects in your repo.' +\n                ' You should run \"rush update\" whenever you start working in a Rush repo,' +\n                ' after you pull from Git, and after you modify a package.json file.' +\n                ' If there is nothing to do, \"rush update\" is instantaneous.' +\n                ' NOTE: In certain cases \"rush install\" should be used instead of \"rush update\"' +\n                ' -- for details, see the command help for \"rush install\".',\n            parser\n        });\n        this._fullParameter = this.defineFlagParameter({\n            parameterLongName: '--full',\n            description: 'Normally \"rush update\" tries to preserve your existing installed versions' +\n                ' and only makes the minimum updates needed to satisfy the package.json files.' +\n                ' This conservative approach prevents your PR from getting involved with package updates that' +\n                ' are unrelated to your work. Use \"--full\" when you really want to update all dependencies' +\n                ' to the latest SemVer-compatible version.  This should be done periodically by a person' +\n                ' or robot whose role is to deal with potential upgrade regressions.'\n        });\n        this._recheckParameter = this.defineFlagParameter({\n            parameterLongName: '--recheck',\n            description: 'If the shrinkwrap file appears to already satisfy the package.json files,' +\n                ' then \"rush update\" will skip invoking the package manager at all.  In certain situations' +\n                ' this heuristic may be inaccurate.  Use the \"--recheck\" flag to force the package manager' +\n                \" to process the shrinkwrap file.  This will also update your shrinkwrap file with Rush's fixups.\" +\n                ' (To minimize shrinkwrap churn, these fixups are normally performed only in the temporary folder.)'\n        });\n    }\n    async runAsync() {\n        await this.parser.pluginManager.updateAsync();\n        if (this.parser.pluginManager.error) {\n            await this.parser.pluginManager.reinitializeAllPluginsForCommandAsync(this.actionName);\n        }\n        return super.runAsync();\n    }\n    async buildInstallOptionsAsync() {\n        return {\n            debug: this.parser.isDebug,\n            allowShrinkwrapUpdates: true,\n            bypassPolicyAllowed: true,\n            bypassPolicy: this._bypassPolicyParameter.value,\n            noLink: this._noLinkParameter.value,\n            fullUpgrade: this._fullParameter.value,\n            recheckShrinkwrap: this._recheckParameter.value,\n            networkConcurrency: this._networkConcurrencyParameter.value,\n            collectLogFile: this._debugPackageManagerParameter.value,\n            variant: this._variant.value,\n            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,\n            // it is safe to assume that the value is not null\n            maxInstallAttempts: this._maxInstallAttempts.value,\n            pnpmFilterArguments: [],\n            checkOnly: false,\n            beforeInstallAsync: () => this.rushSession.hooks.beforeInstall.promise(this)\n        };\n    }\n}\n//# sourceMappingURL=UpdateAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nexport class UpdateAutoinstallerAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'update-autoinstaller',\n            summary: 'Updates autoinstaller package dependencies',\n            documentation: 'Use this command to regenerate the shrinkwrap file for an autoinstaller folder.',\n            parser\n        });\n        this._name = this.defineStringParameter({\n            parameterLongName: '--name',\n            argumentName: 'AUTOINSTALLER_NAME',\n            required: true,\n            description: 'Specifies the name of the autoinstaller, which must be one of the folders under common/autoinstallers.'\n        });\n    }\n    async runAsync() {\n        const autoinstallerName = this._name.value;\n        const autoinstaller = new Autoinstaller({\n            autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        // Do not run `autoinstaller.prepareAsync` here. It tries to install the autoinstaller with\n        // --frozen-lockfile or equivalent, which will fail if the autoinstaller's dependencies\n        // have been changed.\n        await autoinstaller.updateAsync();\n        // eslint-disable-next-line no-console\n        console.log('\\nSuccess.');\n    }\n}\n//# sourceMappingURL=UpdateAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, ConsoleTerminalProvider, Terminal } from '@rushstack/node-core-library';\nimport { BaseRushAction } from './BaseRushAction';\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport { RushConstants } from '../../logic/RushConstants';\nexport class UpdateCloudCredentialsAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: RushConstants.updateCloudCredentialsCommandName,\n            summary: '(EXPERIMENTAL) Update the credentials used by the build cache provider.',\n            documentation: '(EXPERIMENTAL) If the build caching feature is configured, this command facilitates ' +\n                'updating the credentials used by a cloud-based provider.',\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._interactiveModeFlag = this.defineFlagParameter({\n            parameterLongName: '--interactive',\n            parameterShortName: '-i',\n            description: 'Run the credential update operation in interactive mode, if supported by the provider.'\n        });\n        this._credentialParameter = this.defineStringParameter({\n            parameterLongName: '--credential',\n            argumentName: 'CREDENTIAL_STRING',\n            description: 'A static credential, to be cached.'\n        });\n        this._deleteFlag = this.defineFlagParameter({\n            parameterLongName: '--delete',\n            parameterShortName: '-d',\n            description: 'If specified, delete stored credentials.'\n        });\n    }\n    async runAsync() {\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        const buildCacheConfiguration = await BuildCacheConfiguration.loadAndRequireEnabledAsync(terminal, this.rushConfiguration, this.rushSession);\n        if (this._deleteFlag.value) {\n            if (this._interactiveModeFlag.value || this._credentialParameter.value !== undefined) {\n                terminal.writeErrorLine(`If the ${this._deleteFlag.longName} is provided, no other parameters may be provided.`);\n                throw new AlreadyReportedError();\n            }\n            else if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.deleteCachedCredentialsAsync(terminal);\n            }\n            else {\n                terminal.writeLine('A cloud build cache is not configured; there is nothing to delete.');\n            }\n        }\n        else if (this._interactiveModeFlag.value && this._credentialParameter.value !== undefined) {\n            terminal.writeErrorLine(`Both the ${this._interactiveModeFlag.longName} and the ` +\n                `${this._credentialParameter.longName} parameters were provided. Only one ` +\n                'or the other may be used at a time.');\n            throw new AlreadyReportedError();\n        }\n        else if (this._interactiveModeFlag.value) {\n            if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialInteractiveAsync(terminal);\n            }\n            else {\n                terminal.writeLine('A cloud build cache is not configured. Credentials are not required.');\n            }\n        }\n        else if (this._credentialParameter.value !== undefined) {\n            if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialAsync(terminal, this._credentialParameter.value);\n            }\n            else {\n                terminal.writeErrorLine('A cloud build cache is not configured. Credentials are not supported.');\n                throw new AlreadyReportedError();\n            }\n        }\n        else {\n            terminal.writeErrorLine(`One of the ${this._interactiveModeFlag.longName} parameter, the ` +\n                `${this._credentialParameter.longName} parameter, or the ` +\n                `${this._deleteFlag.longName} parameter must be provided.`);\n            throw new AlreadyReportedError();\n        }\n    }\n}\n//# sourceMappingURL=UpdateCloudCredentialsAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nexport class UpgradeInteractiveAction extends BaseRushAction {\n    constructor(parser) {\n        const documentation = [\n            'Provide an interactive way to upgrade your dependencies. Running the command will open an interactive prompt' +\n                ' that will ask you which projects and which dependencies you would like to upgrade.' +\n                ' It will then update your package.json files, and run \"rush update\" for you.' +\n                ' If you are using ensureConsistentVersions policy, upgrade-interactive will update all packages which use the' +\n                ' dependencies that you are upgrading and match their SemVer range if provided. If ensureConsistentVersions' +\n                ' is not enabled, upgrade-interactive will only update the dependency in the package you specify.' +\n                ' This can be overriden by using the --make-consistent flag.'\n        ];\n        super({\n            actionName: 'upgrade-interactive',\n            summary: 'Provides interactive prompt for upgrading package dependencies per project',\n            safeForSimultaneousRushProcesses: false,\n            documentation: documentation.join(''),\n            parser\n        });\n        this._makeConsistentFlag = this.defineFlagParameter({\n            parameterLongName: '--make-consistent',\n            description: 'When upgrading dependencies from a single project, also upgrade dependencies from other projects.'\n        });\n        this._skipUpdateFlag = this.defineFlagParameter({\n            parameterLongName: '--skip-update',\n            parameterShortName: '-s',\n            description: 'If specified, the \"rush update\" command will not be run after updating the package.json files.'\n        });\n    }\n    async runAsync() {\n        const [{ PackageJsonUpdater }, { InteractiveUpgrader }] = await Promise.all([\n            import(/* webpackChunkName: 'PackageJsonUpdater' */ '../../logic/PackageJsonUpdater'),\n            import(/* webpackChunkName: 'InteractiveUpgrader' */ '../../logic/InteractiveUpgrader')\n        ]);\n        const packageJsonUpdater = new PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);\n        const interactiveUpgrader = new InteractiveUpgrader(this.rushConfiguration);\n        const shouldMakeConsistent = this.rushConfiguration.ensureConsistentVersions || this._makeConsistentFlag.value;\n        const { projects, depsToUpgrade } = await interactiveUpgrader.upgrade();\n        await packageJsonUpdater.doRushUpgradeAsync({\n            projects: projects,\n            packagesToAdd: depsToUpgrade.packages,\n            updateOtherPackages: shouldMakeConsistent,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug\n        });\n    }\n}\n//# sourceMappingURL=UpgradeInteractiveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { FileConstants, Enum } from '@rushstack/node-core-library';\nimport { BumpType } from '../../api/VersionPolicy';\nimport { RushConfiguration } from '../../api/RushConfiguration';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport * as PolicyValidator from '../../logic/policy/PolicyValidator';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PublishGit } from '../../logic/PublishGit';\nimport { Git } from '../../logic/Git';\nimport { RushConstants } from '../../logic/RushConstants';\nexport const DEFAULT_PACKAGE_UPDATE_MESSAGE = 'Bump versions [skip ci]';\nexport const DEFAULT_CHANGELOG_UPDATE_MESSAGE = 'Update changelogs [skip ci]';\nexport class VersionAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'version',\n            summary: 'Manage package versions in the repo.',\n            documentation: 'use this \"rush version\" command to ensure version policies and bump versions.',\n            parser\n        });\n        this._targetBranch = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this flag is specified, changes will be committed and merged into the target branch.'\n        });\n        this._ensureVersionPolicy = this.defineFlagParameter({\n            parameterLongName: '--ensure-version-policy',\n            description: 'Updates package versions if needed to satisfy version policies.'\n        });\n        this._overrideVersion = this.defineStringParameter({\n            parameterLongName: '--override-version',\n            argumentName: 'NEW_VERSION',\n            description: 'Override the version in the specified --version-policy. ' +\n                'This setting only works for lock-step version policy and when --ensure-version-policy is specified.'\n        });\n        this._bumpVersion = this.defineFlagParameter({\n            parameterLongName: '--bump',\n            description: 'Bumps package version based on version policies.'\n        });\n        this._bypassPolicy = this.defineFlagParameter({\n            parameterLongName: RushConstants.bypassPolicyFlagLongName,\n            description: 'Overrides \"gitPolicy\" enforcement (use honorably!)'\n        });\n        this._versionPolicy = this.defineStringParameter({\n            parameterLongName: '--version-policy',\n            argumentName: 'POLICY',\n            description: 'The name of the version policy'\n        });\n        this._overwriteBump = this.defineStringParameter({\n            parameterLongName: '--override-bump',\n            argumentName: 'BUMPTYPE',\n            description: 'Overrides the bump type in the version-policy.json for the specified version policy. ' +\n                'Valid BUMPTYPE values include: prerelease, patch, minor, major. ' +\n                'This setting only works for lock-step version policy in bump action.'\n        });\n        this._prereleaseIdentifier = this.defineStringParameter({\n            parameterLongName: '--override-prerelease-id',\n            argumentName: 'ID',\n            description: 'Overrides the prerelease identifier in the version value of version-policy.json ' +\n                'for the specified version policy. ' +\n                'This setting only works for lock-step version policy. ' +\n                'This setting increases to new prerelease id when \"--bump\" is provided but only replaces the ' +\n                'prerelease name when \"--ensure-version-policy\" is provided.'\n        });\n        this._ignoreGitHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-git-hooks',\n            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`\n        });\n    }\n    async runAsync() {\n        await PolicyValidator.validatePolicyAsync(this.rushConfiguration, {\n            bypassPolicyAllowed: true,\n            bypassPolicy: this._bypassPolicy.value\n        });\n        const git = new Git(this.rushConfiguration);\n        const userEmail = git.getGitEmail();\n        this._validateInput();\n        const versionManagerModule = await import(\n        /* webpackChunkName: 'VersionManager' */\n        '../../logic/VersionManager');\n        const versionManager = new versionManagerModule.VersionManager(this.rushConfiguration, userEmail, this.rushConfiguration.versionPolicyConfiguration);\n        if (this._ensureVersionPolicy.value) {\n            this._overwritePolicyVersionIfNeeded();\n            const tempBranch = 'version/ensure-' + new Date().getTime();\n            versionManager.ensure(this._versionPolicy.value, true, !!this._overrideVersion.value || !!this._prereleaseIdentifier.value);\n            const updatedPackages = versionManager.updatedProjects;\n            if (updatedPackages.size > 0) {\n                // eslint-disable-next-line no-console\n                console.log(`${updatedPackages.size} packages are getting updated.`);\n                this._gitProcess(tempBranch, this._targetBranch.value);\n            }\n        }\n        else if (this._bumpVersion.value) {\n            const tempBranch = 'version/bump-' + new Date().getTime();\n            await versionManager.bumpAsync(this._versionPolicy.value, this._overwriteBump.value ? Enum.getValueByKey(BumpType, this._overwriteBump.value) : undefined, this._prereleaseIdentifier.value, true);\n            this._gitProcess(tempBranch, this._targetBranch.value);\n        }\n    }\n    _overwritePolicyVersionIfNeeded() {\n        if (!this._overrideVersion.value && !this._prereleaseIdentifier.value) {\n            // No need to overwrite policy version\n            return;\n        }\n        if (this._overrideVersion.value && this._prereleaseIdentifier.value) {\n            throw new Error(`The parameters \"--override-version\" and \"--override-prerelease-id\" cannot be used together.`);\n        }\n        if (this._versionPolicy.value) {\n            const versionConfig = this.rushConfiguration.versionPolicyConfiguration;\n            const policy = versionConfig.getVersionPolicy(this._versionPolicy.value);\n            if (!policy || !policy.isLockstepped) {\n                throw new Error(`The lockstep version policy \"${policy.policyName}\" is not found.`);\n            }\n            let newVersion = undefined;\n            if (this._overrideVersion.value) {\n                newVersion = this._overrideVersion.value;\n            }\n            else if (this._prereleaseIdentifier.value) {\n                const newPolicyVersion = new semver.SemVer(policy.version);\n                if (newPolicyVersion.prerelease.length) {\n                    // Update 1.5.0-alpha.10 to 1.5.0-beta.10\n                    // For example, if we are parsing \"1.5.0-alpha.10\" then the newPolicyVersion.prerelease array\n                    // would contain [ \"alpha\", 10 ], so we would replace \"alpha\" with \"beta\"\n                    newPolicyVersion.prerelease = [\n                        this._prereleaseIdentifier.value,\n                        ...newPolicyVersion.prerelease.slice(1)\n                    ];\n                }\n                else {\n                    // Update 1.5.0 to 1.5.0-beta\n                    // Since there is no length, we can just set to a new array\n                    newPolicyVersion.prerelease = [this._prereleaseIdentifier.value];\n                }\n                newVersion = newPolicyVersion.format();\n            }\n            if (newVersion) {\n                versionConfig.update(this._versionPolicy.value, newVersion, true);\n            }\n        }\n        else {\n            throw new Error('Missing --version-policy parameter to specify which version policy should be overwritten.');\n        }\n    }\n    _validateInput() {\n        if (this._bumpVersion.value && this._ensureVersionPolicy.value) {\n            throw new Error('Please choose --bump or --ensure-version-policy but not together.');\n        }\n        if (this._overwriteBump.value && !Enum.tryGetValueByKey(BumpType, this._overwriteBump.value)) {\n            throw new Error('The value of override-bump is not valid.  ' +\n                'Valid values include prerelease, patch, minor, and major');\n        }\n    }\n    _validateResult() {\n        // Load the config from file to avoid using inconsistent in-memory data.\n        const rushConfig = RushConfiguration.loadFromConfigurationFile(this.rushConfiguration.rushJsonFile);\n        // Respect the `ensureConsistentVersions` field in rush.json\n        if (!rushConfig.ensureConsistentVersions) {\n            return;\n        }\n        const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfig);\n        if (mismatchFinder.numberOfMismatches) {\n            throw new Error('Unable to finish version bump because inconsistencies were encountered. ' +\n                'Run \"rush check\" to find more details.');\n        }\n    }\n    _gitProcess(tempBranch, targetBranch) {\n        // Validate the result before commit.\n        this._validateResult();\n        const git = new Git(this.rushConfiguration);\n        const publishGit = new PublishGit(git, targetBranch);\n        // Make changes in temp branch.\n        publishGit.checkout(tempBranch, true);\n        const uncommittedChanges = git.getUncommittedChanges();\n        // Stage, commit, and push the changes to remote temp branch.\n        // Need to commit the change log updates in its own commit\n        const changeLogUpdated = uncommittedChanges.some((changePath) => {\n            return changePath.indexOf('CHANGELOG.json') > 0;\n        });\n        if (changeLogUpdated) {\n            publishGit.addChanges('.', this.rushConfiguration.changesFolder);\n            publishGit.addChanges(':/**/CHANGELOG.json');\n            publishGit.addChanges(':/**/CHANGELOG.md');\n            publishGit.commit(this.rushConfiguration.gitChangeLogUpdateCommitMessage || DEFAULT_CHANGELOG_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n        }\n        // Commit the package.json and change files updates.\n        const packageJsonUpdated = uncommittedChanges.some((changePath) => {\n            return changePath.indexOf(FileConstants.PackageJson) > 0;\n        });\n        if (packageJsonUpdated) {\n            publishGit.addChanges(this.rushConfiguration.versionPolicyConfigurationFilePath);\n            publishGit.addChanges(':/**/package.json');\n            publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n        }\n        if (changeLogUpdated || packageJsonUpdated) {\n            publishGit.push(tempBranch, !this._ignoreGitHooksParameter.value);\n            // Now merge to target branch.\n            publishGit.fetch();\n            publishGit.checkout(targetBranch);\n            publishGit.pull(!this._ignoreGitHooksParameter.value);\n            publishGit.merge(tempBranch, !this._ignoreGitHooksParameter.value);\n            publishGit.push(targetBranch, !this._ignoreGitHooksParameter.value);\n            publishGit.deleteBranch(tempBranch, true, !this._ignoreGitHooksParameter.value);\n        }\n        else {\n            // skip commits\n            publishGit.fetch();\n            publishGit.checkout(targetBranch);\n            publishGit.deleteBranch(tempBranch, false, !this._ignoreGitHooksParameter.value);\n        }\n    }\n}\n//# sourceMappingURL=VersionAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\n/**\n * Parses a command line specification for desired parallelism.\n * Factored out to enable unit tests\n */\nexport function parseParallelism(rawParallelism, numberOfCores = os.cpus().length) {\n    if (rawParallelism) {\n        if (rawParallelism === 'max') {\n            return numberOfCores;\n        }\n        else {\n            const parallelismAsNumber = Number(rawParallelism);\n            if (typeof rawParallelism === 'string' && rawParallelism.trim().endsWith('%')) {\n                const parsedPercentage = Number(rawParallelism.trim().replace(/\\%$/, ''));\n                if (parsedPercentage <= 0 || parsedPercentage > 100) {\n                    throw new Error(`Invalid percentage value of '${rawParallelism}', value cannot be less than '0%' or more than '100%'`);\n                }\n                const workers = Math.floor((parsedPercentage / 100) * numberOfCores);\n                return Math.max(workers, 1);\n            }\n            else if (!isNaN(parallelismAsNumber)) {\n                return Math.max(parallelismAsNumber, 1);\n            }\n            else {\n                throw new Error(`Invalid parallelism value of '${rawParallelism}', expected a number, a percentage, or 'max'`);\n            }\n        }\n    }\n    else {\n        // If an explicit parallelism number wasn't provided, then choose a sensible\n        // default.\n        if (os.platform() === 'win32') {\n            // On desktop Windows, some people have complained that their system becomes\n            // sluggish if Rush is using all the CPU cores.  Leave one thread for\n            // other operations. For CI environments, you can use the \"max\" argument to use all available cores.\n            return Math.max(numberOfCores - 1, 1);\n        }\n        else {\n            // Unix-like operating systems have more balanced scheduling, so default\n            // to the number of CPU cores\n            return numberOfCores;\n        }\n    }\n}\n//# sourceMappingURL=ParseParallelism.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, PackageJsonLookup } from '@rushstack/node-core-library';\nimport { Selection } from '../../logic/Selection';\nimport { GitChangedProjectSelectorParser } from '../../logic/selectors/GitChangedProjectSelectorParser';\nimport { NamedProjectSelectorParser } from '../../logic/selectors/NamedProjectSelectorParser';\nimport { TagProjectSelectorParser } from '../../logic/selectors/TagProjectSelectorParser';\nimport { VersionPolicyProjectSelectorParser } from '../../logic/selectors/VersionPolicyProjectSelectorParser';\n/**\n * This class is provides the set of command line parameters used to select projects\n * based on dependencies.\n *\n * It is a separate component such that unrelated actions can share the same parameters.\n */\nexport class SelectionParameterSet {\n    constructor(rushConfiguration, action, gitOptions) {\n        this._rushConfiguration = rushConfiguration;\n        const selectorParsers = new Map();\n        const nameSelectorParser = new NamedProjectSelectorParser(rushConfiguration);\n        selectorParsers.set('name', nameSelectorParser);\n        selectorParsers.set('git', new GitChangedProjectSelectorParser(rushConfiguration, gitOptions));\n        selectorParsers.set('tag', new TagProjectSelectorParser(rushConfiguration));\n        selectorParsers.set('version-policy', new VersionPolicyProjectSelectorParser(rushConfiguration));\n        this._selectorParserByScope = selectorParsers;\n        const getSpecifierCompletions = async () => {\n            const completions = ['.'];\n            for (const [prefix, selector] of selectorParsers) {\n                for (const completion of selector.getCompletions()) {\n                    completions.push(`${prefix}:${completion}`);\n                }\n            }\n            // Include completions from the name parser without a scope\n            for (const completion of nameSelectorParser.getCompletions()) {\n                completions.push(completion);\n            }\n            return completions;\n        };\n        this._toProject = action.defineStringListParameter({\n            parameterLongName: '--to',\n            parameterShortName: '-t',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--to\" parameter expands this selection to include PROJECT and all its dependencies.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._toExceptProject = action.defineStringListParameter({\n            parameterLongName: '--to-except',\n            parameterShortName: '-T',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--to-except\" parameter expands this selection to include all dependencies of PROJECT,' +\n                ' but not PROJECT itself.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._fromProject = action.defineStringListParameter({\n            parameterLongName: '--from',\n            parameterShortName: '-f',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--from\" parameter expands this selection to include PROJECT and all projects that depend on it,' +\n                ' plus all dependencies of this set.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._onlyProject = action.defineStringListParameter({\n            parameterLongName: '--only',\n            parameterShortName: '-o',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--only\" parameter expands this selection to include PROJECT; its dependencies are not added.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._impactedByProject = action.defineStringListParameter({\n            parameterLongName: '--impacted-by',\n            parameterShortName: '-i',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--impacted-by\" parameter expands this selection to include PROJECT and any projects that' +\n                ' depend on PROJECT (and thus might be broken by changes to PROJECT).' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._impactedByExceptProject = action.defineStringListParameter({\n            parameterLongName: '--impacted-by-except',\n            parameterShortName: '-I',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--impacted-by-except\" parameter works the same as \"--impacted-by\" except that PROJECT itself' +\n                ' is not added to the selection.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._toVersionPolicy = action.defineStringListParameter({\n            parameterLongName: '--to-version-policy',\n            argumentName: 'VERSION_POLICY_NAME',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' The \"--to-version-policy\" parameter is equivalent to specifying \"--to\" for each of the projects' +\n                ' belonging to VERSION_POLICY_NAME.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".'\n        });\n        this._fromVersionPolicy = action.defineStringListParameter({\n            parameterLongName: '--from-version-policy',\n            argumentName: 'VERSION_POLICY_NAME',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' The \"--from-version-policy\" parameter is equivalent to specifying \"--from\" for each of the projects' +\n                ' belonging to VERSION_POLICY_NAME.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".'\n        });\n    }\n    /**\n     * Computes the set of selected projects based on all parameter values.\n     *\n     * If no parameters are specified, returns all projects in the Rush config file.\n     */\n    async getSelectedProjectsAsync(terminal) {\n        // Hack out the old version-policy parameters\n        for (const value of this._fromVersionPolicy.values) {\n            this._fromProject.values.push(`version-policy:${value}`);\n        }\n        for (const value of this._toVersionPolicy.values) {\n            this._toProject.values.push(`version-policy:${value}`);\n        }\n        const selectors = [\n            this._onlyProject,\n            this._fromProject,\n            this._toProject,\n            this._toExceptProject,\n            this._impactedByProject,\n            this._impactedByExceptProject\n        ];\n        // Check if any of the selection parameters have a value specified on the command line\n        const isSelectionSpecified = selectors.some((param) => param.values.length > 0);\n        // If no selection parameters are specified, return everything\n        if (!isSelectionSpecified) {\n            return new Set(this._rushConfiguration.projects);\n        }\n        const [\n        // Include exactly these projects (--only)\n        onlyProjects, \n        // Include all projects that depend on these projects, and all dependencies thereof\n        fromProjects, \n        // --to\n        toRaw, \n        // --to-except\n        toExceptProjects, \n        // --impacted-by\n        impactedByProjects, \n        // --impacted-by-except\n        impactedByExceptProjects] = await Promise.all(selectors.map((param) => {\n            return this._evaluateProjectParameterAsync(param, terminal);\n        }));\n        const selection = Selection.union(\n        // Safe command line options\n        Selection.expandAllDependencies(Selection.union(toRaw, Selection.directDependenciesOf(toExceptProjects), \n        // --from / --from-version-policy\n        Selection.expandAllConsumers(fromProjects))), \n        // Unsafe command line option: --only\n        onlyProjects, \n        // Unsafe command line options: --impacted-by, --impacted-by-except\n        Selection.expandAllConsumers(Selection.union(impactedByProjects, Selection.directConsumersOf(impactedByExceptProjects))));\n        return selection;\n    }\n    /**\n     * Represents the selection as `--filter` parameters to pnpm.\n     *\n     * @remarks\n     * This is a separate from the selection to allow the filters to be represented more concisely.\n     *\n     * @see https://pnpm.js.org/en/filtering\n     */\n    async getPnpmFilterArgumentsAsync(terminal) {\n        const args = [];\n        // Include exactly these projects (--only)\n        for (const project of await this._evaluateProjectParameterAsync(this._onlyProject, terminal)) {\n            args.push('--filter', project.packageName);\n        }\n        // Include all projects that depend on these projects, and all dependencies thereof\n        const fromProjects = Selection.union(\n        // --from\n        await this._evaluateProjectParameterAsync(this._fromProject, terminal));\n        // All specified projects and all projects that they depend on\n        for (const project of Selection.union(\n        // --to\n        await this._evaluateProjectParameterAsync(this._toProject, terminal), \n        // --from / --from-version-policy\n        Selection.expandAllConsumers(fromProjects))) {\n            args.push('--filter', `${project.packageName}...`);\n        }\n        // --to-except\n        // All projects that the project directly or indirectly declares as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._toExceptProject, terminal)) {\n            args.push('--filter', `${project.packageName}^...`);\n        }\n        // --impacted-by\n        // The project and all projects directly or indirectly declare it as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._impactedByProject, terminal)) {\n            args.push('--filter', `...${project.packageName}`);\n        }\n        // --impacted-by-except\n        // All projects that directly or indirectly declare the specified project as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._impactedByExceptProject, terminal)) {\n            args.push('--filter', `...^${project.packageName}`);\n        }\n        return args;\n    }\n    /**\n     * Usage telemetry for selection parameters. Only saved locally, and if requested in the config.\n     */\n    getTelemetry() {\n        return {\n            command_from: `${this._fromProject.values.length > 0}`,\n            command_impactedBy: `${this._impactedByProject.values.length > 0}`,\n            command_impactedByExcept: `${this._impactedByExceptProject.values.length > 0}`,\n            command_only: `${this._onlyProject.values.length > 0}`,\n            command_to: `${this._toProject.values.length > 0}`,\n            command_toExcept: `${this._toExceptProject.values.length > 0}`,\n            command_fromVersionPolicy: `${this._fromVersionPolicy.values.length > 0}`,\n            command_toVersionPolicy: `${this._toVersionPolicy.values.length > 0}`\n        };\n    }\n    /**\n     * Computes the referents of parameters that accept a project identifier.\n     * Handles '.', unscoped names, and scoped names.\n     */\n    async _evaluateProjectParameterAsync(listParameter, terminal) {\n        const parameterName = listParameter.longName;\n        const selection = new Set();\n        for (const rawSelector of listParameter.values) {\n            // Handle the special case of \"current project\" without a scope\n            if (rawSelector === '.') {\n                const packageJsonLookup = PackageJsonLookup.instance;\n                const packageJson = packageJsonLookup.tryLoadPackageJsonFor(process.cwd());\n                if (packageJson) {\n                    const project = this._rushConfiguration.getProjectByName(packageJson.name);\n                    if (project) {\n                        selection.add(project);\n                    }\n                    else {\n                        terminal.writeErrorLine('Rush is not currently running in a project directory specified in rush.json. ' +\n                            `The \".\" value for the ${parameterName} parameter is not allowed.`);\n                        throw new AlreadyReportedError();\n                    }\n                }\n                else {\n                    terminal.writeErrorLine('Rush is not currently running in a project directory. ' +\n                        `The \".\" value for the ${parameterName} parameter is not allowed.`);\n                    throw new AlreadyReportedError();\n                }\n                continue;\n            }\n            const scopeIndex = rawSelector.indexOf(':');\n            const scope = scopeIndex < 0 ? 'name' : rawSelector.slice(0, scopeIndex);\n            const unscopedSelector = scopeIndex < 0 ? rawSelector : rawSelector.slice(scopeIndex + 1);\n            const handler = this._selectorParserByScope.get(scope);\n            if (!handler) {\n                terminal.writeErrorLine(`Unsupported selector prefix \"${scope}\" passed to \"${parameterName}\": \"${rawSelector}\".` +\n                    ` Supported prefixes: ${Array.from(this._selectorParserByScope.keys(), (selectorParserScope) => `\"${selectorParserScope}:\"`).join(', ')}`);\n                throw new AlreadyReportedError();\n            }\n            for (const project of await handler.evaluateSelectorAsync({\n                unscopedSelector,\n                terminal,\n                parameterName\n            })) {\n                selection.add(project);\n            }\n        }\n        return selection;\n    }\n}\n//# sourceMappingURL=SelectionParameterSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from '../actions/BaseRushAction';\nimport { RushConstants } from '../../logic/RushConstants';\n/**\n * Base class for command-line actions that are implemented using user-defined scripts.\n *\n * @remarks\n * Compared to the normal built-in actions, these actions are special because (1) they\n * can be discovered dynamically via common/config/command-line.json, and (2)\n * user-defined command-line parameters can be passed through to the script.\n *\n * The two subclasses are BulkScriptAction and GlobalScriptAction.\n */\nexport class BaseScriptAction extends BaseRushAction {\n    constructor(options) {\n        super(options);\n        this.customParameters = new Map();\n        this.commandLineConfiguration = options.commandLineConfiguration;\n        this.command = options.command;\n    }\n    defineScriptParameters() {\n        if (!this.commandLineConfiguration) {\n            return;\n        }\n        // Find any parameters that are associated with this command\n        for (const parameter of this.command.associatedParameters) {\n            let tsCommandLineParameter;\n            switch (parameter.parameterKind) {\n                case 'flag':\n                    tsCommandLineParameter = this.defineFlagParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required\n                    });\n                    break;\n                case 'choice':\n                    tsCommandLineParameter = this.defineChoiceParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        alternatives: parameter.alternatives.map((x) => x.name),\n                        defaultValue: parameter.defaultValue\n                    });\n                    break;\n                case 'string':\n                    tsCommandLineParameter = this.defineStringParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'integer':\n                    tsCommandLineParameter = this.defineIntegerParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'stringList':\n                    tsCommandLineParameter = this.defineStringListParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'integerList':\n                    tsCommandLineParameter = this.defineIntegerListParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'choiceList':\n                    tsCommandLineParameter = this.defineChoiceListParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        alternatives: parameter.alternatives.map((x) => x.name)\n                    });\n                    break;\n                default:\n                    throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${parameter.longName}\" using an unsupported parameter kind \"${parameter.parameterKind}\"`);\n            }\n            this.customParameters.set(parameter, tsCommandLineParameter);\n        }\n    }\n}\n//# sourceMappingURL=BaseScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport colors from 'colors/safe';\nimport { FileSystem, JsonFile, AlreadyReportedError, Text } from '@rushstack/node-core-library';\nimport { BaseScriptAction } from './BaseScriptAction';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\n/**\n * This class implements custom commands that are run once globally for the entire repo\n * (versus bulk commands, which run separately for each project).  The action executes\n * a user-defined script file.\n *\n * @remarks\n * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined \"build\"\n * and \"rebuild\" commands are also modeled as bulk commands, because they essentially just\n * invoke scripts from package.json in the same way as a custom command.\n */\nexport class GlobalScriptAction extends BaseScriptAction {\n    constructor(options) {\n        super(options);\n        this._shellCommand = options.shellCommand;\n        this._autoinstallerName = options.autoinstallerName || '';\n        if (this._autoinstallerName) {\n            Autoinstaller.validateName(this._autoinstallerName);\n            // Example: .../common/autoinstallers/my-task\n            this._autoinstallerFullPath = path.join(this.rushConfiguration.commonAutoinstallersFolder, this._autoinstallerName);\n            if (!FileSystem.exists(this._autoinstallerFullPath)) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting` +\n                    ' but the path does not exist: ' +\n                    this._autoinstallerFullPath);\n            }\n            // Example: .../common/autoinstallers/my-task/package.json\n            const packageJsonPath = path.join(this._autoinstallerFullPath, 'package.json');\n            if (!FileSystem.exists(packageJsonPath)) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting` +\n                    ` whose package.json file was not found: ` +\n                    packageJsonPath);\n            }\n            const packageJson = JsonFile.load(packageJsonPath);\n            if (packageJson.name !== this._autoinstallerName) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting,` +\n                    ` but the package.json file's \"name\" field is not \"${this._autoinstallerName}\": ` +\n                    packageJsonPath);\n            }\n        }\n        else {\n            this._autoinstallerFullPath = '';\n        }\n        this.defineScriptParameters();\n    }\n    async _prepareAutoinstallerName() {\n        const autoInstaller = new Autoinstaller({\n            autoinstallerName: this._autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        await autoInstaller.prepareAsync();\n    }\n    async runAsync() {\n        var _a, _b;\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.runAnyGlobalCustomCommand.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.runAnyGlobalCustomCommand.promise(this);\n        }\n        const hookForAction = sessionHooks.runGlobalCustomCommand.get(this.actionName);\n        if (hookForAction) {\n            // Run the more specific hook for a command with this name after the general hook\n            await hookForAction.promise(this);\n        }\n        const additionalPathFolders = ((_a = this.commandLineConfiguration) === null || _a === void 0 ? void 0 : _a.additionalPathFolders.slice()) || [];\n        if (this._autoinstallerName) {\n            await this._prepareAutoinstallerName();\n            const autoinstallerNameBinPath = path.join(this._autoinstallerFullPath, 'node_modules', '.bin');\n            additionalPathFolders.push(autoinstallerNameBinPath);\n        }\n        // Collect all custom parameter values\n        const customParameterValues = [];\n        for (const tsCommandLineParameter of this.customParameters.values()) {\n            tsCommandLineParameter.appendToArgList(customParameterValues);\n        }\n        for (let i = 0; i < customParameterValues.length; i++) {\n            let customParameterValue = customParameterValues[i];\n            customParameterValue = customParameterValue.replace(/\"/g, '\\\\\"');\n            if (customParameterValue.indexOf(' ') >= 0) {\n                customParameterValue = `\"${customParameterValue}\"`;\n            }\n            customParameterValues[i] = customParameterValue;\n        }\n        let shellCommand = this._shellCommand;\n        if (customParameterValues.length > 0) {\n            shellCommand += ' ' + customParameterValues.join(' ');\n        }\n        const shellCommandTokenContext = (_b = this.commandLineConfiguration) === null || _b === void 0 ? void 0 : _b.shellCommandTokenContext;\n        if (shellCommandTokenContext) {\n            shellCommand = this._expandShellCommandWithTokens(shellCommand, shellCommandTokenContext);\n        }\n        this._rejectAnyTokensInShellCommand(shellCommand, shellCommandTokenContext);\n        const stopwatch = Stopwatch.start();\n        const exitCode = Utilities.executeLifecycleCommand(shellCommand, {\n            rushConfiguration: this.rushConfiguration,\n            workingDirectory: this.rushConfiguration.rushJsonFolder,\n            initCwd: this.rushConfiguration.commonTempFolder,\n            handleOutput: false,\n            environmentPathOptions: {\n                includeRepoBin: true,\n                additionalPathFolders: additionalPathFolders\n            }\n        });\n        process.exitCode = exitCode;\n        stopwatch.stop();\n        if (this.parser.telemetry) {\n            this.parser.telemetry.log({\n                name: this.actionName,\n                durationInSeconds: stopwatch.duration,\n                result: exitCode > 0 ? 'Failed' : 'Succeeded',\n                extraData: {\n                    customParameterValue: customParameterValues.join(' ')\n                }\n            });\n            this.parser.flushTelemetry();\n        }\n        if (exitCode > 0) {\n            // eslint-disable-next-line no-console\n            console.log('\\n' + colors.red(`The script failed with exit code ${exitCode}`));\n            throw new AlreadyReportedError();\n        }\n    }\n    _expandShellCommandWithTokens(shellCommand, tokenContext) {\n        let expandedShellCommand = shellCommand;\n        for (const [token, tokenReplacement] of Object.entries(tokenContext)) {\n            expandedShellCommand = Text.replaceAll(expandedShellCommand, `<${token}>`, tokenReplacement);\n        }\n        return expandedShellCommand;\n    }\n    _rejectAnyTokensInShellCommand(shellCommand, tokenContext) {\n        if (shellCommand.indexOf('<') < 0 && shellCommand.indexOf('>') < 0) {\n            return;\n        }\n        const tokenRegExp = /(\\<[^<]*?\\>)/;\n        const match = tokenRegExp.exec(shellCommand);\n        if (match) {\n            throw new Error(`The \"shellCommand\" value contains an unrecognized token \"${match[1]}\".${tokenContext ? ` Available tokens are ${Object.keys(tokenContext).join(', ')}.` : ''}`);\n        }\n        throw new Error(`The \"shellCommand\" value contains extra token characters (\"<\" or \">\"): ${shellCommand}`);\n    }\n}\n//# sourceMappingURL=GlobalScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { AlreadyReportedError, InternalError, Terminal } from '@rushstack/node-core-library';\nimport { PhasedCommandHooks } from '../../pluginFramework/PhasedCommandHooks';\nimport { SetupChecks } from '../../logic/SetupChecks';\nimport { Stopwatch, StopwatchState } from '../../utilities/Stopwatch';\nimport { BaseScriptAction } from './BaseScriptAction';\nimport { OperationExecutionManager } from '../../logic/operations/OperationExecutionManager';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\nimport { LastLinkFlagFactory } from '../../api/LastLinkFlag';\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nimport { PhasedOperationPlugin } from '../../logic/operations/PhasedOperationPlugin';\nimport { ShellOperationRunnerPlugin } from '../../logic/operations/ShellOperationRunnerPlugin';\nimport { Event } from '../../api/EventHooks';\nimport { ProjectChangeAnalyzer } from '../../logic/ProjectChangeAnalyzer';\nimport { OperationStatus } from '../../logic/operations/OperationStatus';\nimport { OperationResultSummarizerPlugin } from '../../logic/operations/OperationResultSummarizerPlugin';\nimport { parseParallelism } from '../parsing/ParseParallelism';\nimport { CobuildConfiguration } from '../../api/CobuildConfiguration';\nimport { CacheableOperationPlugin } from '../../logic/operations/CacheableOperationPlugin';\nimport { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport { LegacySkipPlugin } from '../../logic/operations/LegacySkipPlugin';\nimport { ValidateOperationsPlugin } from '../../logic/operations/ValidateOperationsPlugin';\n/**\n * This class implements phased commands which are run individually for each project in the repo,\n * possibly in parallel, and which may define multiple phases.\n *\n * @remarks\n * Phased commands can be defined via common/config/command-line.json.  Rush's predefined \"build\"\n * and \"rebuild\" commands are also modeled as phased commands with a single phase that invokes the npm\n * \"build\" script for each project.\n */\nexport class PhasedScriptAction extends BaseScriptAction {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._enableParallelism = options.enableParallelism;\n        this._isIncrementalBuildAllowed = options.incremental;\n        this._disableBuildCache = options.disableBuildCache;\n        this._originalPhases = options.originalPhases;\n        this._initialPhases = options.initialPhases;\n        this._watchPhases = options.watchPhases;\n        this._watchDebounceMs = (_a = options.watchDebounceMs) !== null && _a !== void 0 ? _a : RushConstants.defaultWatchDebounceMs;\n        this._alwaysWatch = options.alwaysWatch;\n        this._alwaysInstall = options.alwaysInstall;\n        this._runsBeforeInstall = false;\n        this._knownPhases = options.phases;\n        this.hooks = new PhasedCommandHooks();\n        const terminal = new Terminal(this.rushSession.terminalProvider);\n        this._terminal = terminal;\n        // Generates the default operation graph\n        new PhasedOperationPlugin().apply(this.hooks);\n        // Applies the Shell Operation Runner to selected operations\n        new ShellOperationRunnerPlugin().apply(this.hooks);\n        new ValidateOperationsPlugin(terminal).apply(this.hooks);\n        if (this._enableParallelism) {\n            this._parallelismParameter = this.defineStringParameter({\n                parameterLongName: '--parallelism',\n                parameterShortName: '-p',\n                argumentName: 'COUNT',\n                environmentVariable: EnvironmentVariableNames.RUSH_PARALLELISM,\n                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +\n                    ' The COUNT should be a positive integer, a percentage value (eg. \"50%%\") or the word \"max\"' +\n                    ' to specify a count that is equal to the number of CPU cores. If this parameter is omitted,' +\n                    ' then the default value depends on the operating system and number of CPU cores.'\n            });\n            this._timelineParameter = this.defineFlagParameter({\n                parameterLongName: '--timeline',\n                description: 'After the build is complete, print additional statistics and CPU usage information,' +\n                    ' including an ASCII chart of the start and stop times for each operation.'\n            });\n        }\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            // Include lockfile processing since this expands the selection, and we need to select\n            // at least the same projects selected with the same query to \"rush build\"\n            includeExternalDependencies: true,\n            // Enable filtering to reduce evaluation cost\n            enableFiltering: true\n        });\n        this._verboseParameter = this.defineFlagParameter({\n            parameterLongName: '--verbose',\n            parameterShortName: '-v',\n            description: 'Display the logs during the build, rather than just displaying the build status summary'\n        });\n        if (this._isIncrementalBuildAllowed) {\n            this._changedProjectsOnly = this.defineFlagParameter({\n                parameterLongName: '--changed-projects-only',\n                parameterShortName: '-c',\n                description: 'Normally the incremental build logic will rebuild changed projects as well as' +\n                    ' any projects that directly or indirectly depend on a changed project. Specify \"--changed-projects-only\"' +\n                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +\n                    ' Note that this parameter is \"unsafe\"; it is up to the developer to ensure that the ignored projects' +\n                    ' are okay to ignore.'\n            });\n        }\n        this._ignoreHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-hooks',\n            description: `Skips execution of the \"eventHooks\" scripts defined in rush.json. Make sure you know what you are skipping.`\n        });\n        if (this._watchPhases.size > 0 && !this._alwaysWatch) {\n            // Only define the parameter if it has an effect.\n            this._watchParameter = this.defineFlagParameter({\n                parameterLongName: '--watch',\n                description: `Starts a file watcher after initial execution finishes. Will run the following phases on affected projects: ${Array.from(this._watchPhases, (phase) => phase.name).join(', ')}`\n            });\n        }\n        // If `this._alwaysInstall === undefined`, Rush does not define the parameter\n        // but a repository may still define a custom parameter with the same name.\n        if (this._alwaysInstall === false) {\n            this._installParameter = this.defineFlagParameter({\n                parameterLongName: '--install',\n                description: 'Normally a phased command expects \"rush install\" to have been manually run first. If this flag is specified, ' +\n                    'Rush will automatically perform an install before processing the current command.'\n            });\n        }\n        this.defineScriptParameters();\n        for (const [{ associatedPhases }, tsCommandLineParameter] of this.customParameters) {\n            if (associatedPhases) {\n                for (const phaseName of associatedPhases) {\n                    const phase = this._knownPhases.get(phaseName);\n                    if (!phase) {\n                        throw new InternalError(`Could not find a phase matching ${phaseName}.`);\n                    }\n                    phase.associatedParameters.add(tsCommandLineParameter);\n                }\n            }\n        }\n    }\n    async runAsync() {\n        var _a, _b, _c, _d;\n        if (this._alwaysInstall || ((_a = this._installParameter) === null || _a === void 0 ? void 0 : _a.value)) {\n            const { doBasicInstallAsync } = await import(\n            /* webpackChunkName: 'doBasicInstallAsync' */\n            '../../logic/installManager/doBasicInstallAsync');\n            await doBasicInstallAsync({\n                terminal: this._terminal,\n                rushConfiguration: this.rushConfiguration,\n                rushGlobalFolder: this.rushGlobalFolder,\n                isDebug: this.parser.isDebug\n            });\n        }\n        if (!this._runsBeforeInstall) {\n            // TODO: Replace with last-install.flag when \"rush link\" and \"rush unlink\" are removed\n            const lastLinkFlag = LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration);\n            if (!lastLinkFlag.isValid()) {\n                const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;\n                if (useWorkspaces) {\n                    throw new Error('Link flag invalid.\\nDid you run \"rush install\" or \"rush update\"?');\n                }\n                else {\n                    throw new Error('Link flag invalid.\\nDid you run \"rush link\"?');\n                }\n            }\n        }\n        this._doBeforeTask();\n        // if this is parallelizable, then use the value from the flag (undefined or a number),\n        // if parallelism is not enabled, then restrict to 1 core\n        const parallelism = this._enableParallelism\n            ? parseParallelism((_b = this._parallelismParameter) === null || _b === void 0 ? void 0 : _b.value)\n            : 1;\n        const terminal = this._terminal;\n        const stopwatch = Stopwatch.start();\n        const showTimeline = this._timelineParameter ? this._timelineParameter.value : false;\n        if (showTimeline) {\n            const { ConsoleTimelinePlugin } = await import(\n            /* webpackChunkName: 'ConsoleTimelinePlugin' */\n            '../../logic/operations/ConsoleTimelinePlugin');\n            new ConsoleTimelinePlugin(terminal).apply(this.hooks);\n        }\n        // Enable the standard summary\n        new OperationResultSummarizerPlugin(terminal).apply(this.hooks);\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.runAnyPhasedCommand.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.runAnyPhasedCommand.promise(this);\n        }\n        const hookForAction = sessionHooks.runPhasedCommand.get(this.actionName);\n        if (hookForAction) {\n            // Run the more specific hook for a command with this name after the general hook\n            await hookForAction.promise(this);\n        }\n        const isQuietMode = !this._verboseParameter.value;\n        const changedProjectsOnly = !!((_c = this._changedProjectsOnly) === null || _c === void 0 ? void 0 : _c.value);\n        let buildCacheConfiguration;\n        let cobuildConfiguration;\n        if (!this._disableBuildCache) {\n            buildCacheConfiguration = await BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);\n            cobuildConfiguration = await CobuildConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);\n            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.createLockProviderAsync(terminal));\n        }\n        try {\n            const projectSelection = await this._selectionParameters.getSelectedProjectsAsync(terminal);\n            if (!projectSelection.size) {\n                terminal.writeLine(colors.yellow(`The command line selection parameters did not match any projects.`));\n                return;\n            }\n            const isWatch = ((_d = this._watchParameter) === null || _d === void 0 ? void 0 : _d.value) || this._alwaysWatch;\n            const customParametersByName = new Map();\n            for (const [configParameter, parserParameter] of this.customParameters) {\n                customParametersByName.set(configParameter.longName, parserParameter);\n            }\n            if (buildCacheConfiguration) {\n                new CacheableOperationPlugin({\n                    allowWarningsInSuccessfulBuild: !!this.rushConfiguration.experimentsConfiguration.configuration\n                        .buildCacheWithAllowWarningsInSuccessfulBuild,\n                    buildCacheConfiguration,\n                    cobuildConfiguration,\n                    terminal\n                }).apply(this.hooks);\n            }\n            else if (!this._disableBuildCache) {\n                // Explicitly disabling the build cache also disables legacy skip detection.\n                new LegacySkipPlugin({\n                    terminal,\n                    changedProjectsOnly,\n                    isIncrementalBuildAllowed: this._isIncrementalBuildAllowed\n                }).apply(this.hooks);\n            }\n            const projectConfigurations = this\n                ._runsBeforeInstall\n                ? new Map()\n                : await RushProjectConfiguration.tryLoadForProjectsAsync(projectSelection, terminal);\n            const projectChangeAnalyzer = new ProjectChangeAnalyzer(this.rushConfiguration);\n            const initialCreateOperationsContext = {\n                buildCacheConfiguration,\n                cobuildConfiguration,\n                customParameters: customParametersByName,\n                isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,\n                isInitial: true,\n                isWatch,\n                rushConfiguration: this.rushConfiguration,\n                phaseOriginal: new Set(this._originalPhases),\n                phaseSelection: new Set(this._initialPhases),\n                projectChangeAnalyzer,\n                projectSelection,\n                projectConfigurations,\n                projectsInUnknownState: projectSelection\n            };\n            const executionManagerOptions = {\n                quietMode: isQuietMode,\n                debugMode: this.parser.isDebug,\n                parallelism,\n                changedProjectsOnly,\n                beforeExecuteOperation: async (record) => {\n                    return await this.hooks.beforeExecuteOperation.promise(record);\n                },\n                afterExecuteOperation: async (record) => {\n                    await this.hooks.afterExecuteOperation.promise(record);\n                },\n                beforeExecuteOperations: async (records) => {\n                    await this.hooks.beforeExecuteOperations.promise(records, initialCreateOperationsContext);\n                },\n                onOperationStatusChanged: (record) => {\n                    this.hooks.onOperationStatusChanged.call(record);\n                }\n            };\n            const internalOptions = {\n                initialCreateOperationsContext,\n                executionManagerOptions,\n                stopwatch,\n                terminal\n            };\n            terminal.write('Analyzing repo state... ');\n            const repoStateStopwatch = new Stopwatch();\n            repoStateStopwatch.start();\n            await projectChangeAnalyzer._ensureInitializedAsync(terminal);\n            repoStateStopwatch.stop();\n            terminal.writeLine(`DONE (${repoStateStopwatch.toString()})`);\n            terminal.writeLine();\n            await this._runInitialPhases(internalOptions);\n            if (isWatch) {\n                if (buildCacheConfiguration) {\n                    // Cache writes are not supported during watch mode, only reads.\n                    buildCacheConfiguration.cacheWriteEnabled = false;\n                }\n                await this._runWatchPhases(internalOptions);\n            }\n        }\n        finally {\n            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.destroyLockProviderAsync());\n        }\n    }\n    async _runInitialPhases(options) {\n        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;\n        const operations = await this.hooks.createOperations.promise(new Set(), initialCreateOperationsContext);\n        const initialOptions = {\n            createOperationsContext: initialCreateOperationsContext,\n            ignoreHooks: false,\n            operations,\n            stopwatch,\n            executionManagerOptions,\n            terminal\n        };\n        await this._executeOperations(initialOptions);\n    }\n    _registerWatchModeInterface(projectWatcher) {\n        const toggleWatcherKey = 'w';\n        const buildOnceKey = 'b';\n        const terminal = this._terminal;\n        process.stdin.setRawMode(true);\n        process.stdin.resume();\n        process.stdin.setEncoding('utf8');\n        process.stdin.on('data', (key) => {\n            switch (key) {\n                case toggleWatcherKey:\n                    if (projectWatcher.isPaused) {\n                        terminal.writeLine(`Resuming project watcher...`);\n                        projectWatcher.resume();\n                    }\n                    else {\n                        terminal.writeLine(`Pausing project watcher...`);\n                        projectWatcher.pause();\n                    }\n                    break;\n                case buildOnceKey:\n                    if (projectWatcher.isPaused) {\n                        terminal.writeLine(`Building once...`);\n                        projectWatcher.resume();\n                        projectWatcher.pause();\n                    }\n                    break;\n                case '\\u0003':\n                    process.kill(process.pid, 'SIGINT');\n                    break;\n            }\n        });\n    }\n    /**\n     * Runs the command in watch mode. Fundamentally is a simple loop:\n     * 1) Wait for a change to one or more projects in the selection\n     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects\n     *    Uses the same algorithm as --impacted-by\n     * 3) Goto (1)\n     */\n    async _runWatchPhases(options) {\n        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;\n        const phaseOriginal = new Set(this._watchPhases);\n        const phaseSelection = new Set(this._watchPhases);\n        const { projectChangeAnalyzer: initialState, projectSelection: projectsToWatch } = initialCreateOperationsContext;\n        // Use async import so that we don't pay the cost for sync builds\n        const { ProjectWatcher } = await import(\n        /* webpackChunkName: 'ProjectWatcher' */\n        '../../logic/ProjectWatcher');\n        const projectWatcher = new ProjectWatcher({\n            debounceMs: this._watchDebounceMs,\n            rushConfiguration: this.rushConfiguration,\n            projectsToWatch,\n            terminal,\n            initialState\n        });\n        this._registerWatchModeInterface(projectWatcher);\n        const onWaitingForChanges = () => {\n            // Allow plugins to display their own messages when waiting for changes.\n            this.hooks.waitingForChanges.call();\n            // Report so that the developer can always see that it is in watch mode as the latest console line.\n            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);\n        };\n        // Loop until Ctrl+C\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // On the initial invocation, this promise will return immediately with the full set of projects\n            const { changedProjects, state } = await projectWatcher.waitForChange(onWaitingForChanges);\n            if (stopwatch.state === StopwatchState.Stopped) {\n                // Clear and reset the stopwatch so that we only report time from a single execution at a time\n                stopwatch.reset();\n                stopwatch.start();\n            }\n            terminal.writeLine(`Detected changes in ${changedProjects.size} project${changedProjects.size === 1 ? '' : 's'}:`);\n            const names = [...changedProjects].map((x) => x.packageName).sort();\n            for (const name of names) {\n                terminal.writeLine(`    ${colors.cyan(name)}`);\n            }\n            // Account for consumer relationships\n            const createOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { isInitial: false, projectChangeAnalyzer: state, projectsInUnknownState: changedProjects, phaseOriginal,\n                phaseSelection });\n            const operations = await this.hooks.createOperations.promise(new Set(), createOperationsContext);\n            const executeOptions = {\n                createOperationsContext,\n                // For now, don't run pre-build or post-build in watch mode\n                ignoreHooks: true,\n                operations,\n                stopwatch,\n                executionManagerOptions: Object.assign(Object.assign({}, executionManagerOptions), { beforeExecuteOperations: async (records) => {\n                        await this.hooks.beforeExecuteOperations.promise(records, createOperationsContext);\n                    } }),\n                terminal\n            };\n            try {\n                // Delegate the the underlying command, for only the projects that need reprocessing\n                await this._executeOperations(executeOptions);\n            }\n            catch (err) {\n                // In watch mode, we want to rebuild even if the original build failed.\n                if (!(err instanceof AlreadyReportedError)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    /**\n     * Runs a set of operations and reports the results.\n     */\n    async _executeOperations(options) {\n        var _a;\n        const { executionManagerOptions, ignoreHooks, operations, stopwatch, terminal } = options;\n        const executionManager = new OperationExecutionManager(operations, executionManagerOptions);\n        const { isInitial, isWatch } = options.createOperationsContext;\n        let success = false;\n        let result;\n        try {\n            result = await executionManager.executeAsync();\n            success = result.status === OperationStatus.Success;\n            await this.hooks.afterExecuteOperations.promise(result, options.createOperationsContext);\n            stopwatch.stop();\n            const message = `rush ${this.actionName} (${stopwatch.toString()})`;\n            if (result.status === OperationStatus.Success) {\n                terminal.writeLine(colors.green(message));\n            }\n            else {\n                terminal.writeLine(message);\n            }\n        }\n        catch (error) {\n            success = false;\n            stopwatch.stop();\n            if (error instanceof AlreadyReportedError) {\n                terminal.writeLine(`rush ${this.actionName} (${stopwatch.toString()})`);\n            }\n            else {\n                if (error && error.message) {\n                    if (this.parser.isDebug) {\n                        terminal.writeErrorLine('Error: ' + error.stack);\n                    }\n                    else {\n                        terminal.writeErrorLine('Error: ' + error.message);\n                    }\n                }\n                terminal.writeErrorLine(colors.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));\n            }\n        }\n        if (!ignoreHooks) {\n            this._doAfterTask();\n        }\n        if (this.parser.telemetry) {\n            const operationResults = {};\n            const extraData = Object.assign(Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap()), { isWatch,\n                // Fields specific to the current operation set\n                isInitial, countAll: 0, countSuccess: 0, countSuccessWithWarnings: 0, countFailure: 0, countBlocked: 0, countFromCache: 0, countSkipped: 0, countNoOp: 0 });\n            if (result) {\n                const nonSilentDependenciesByOperation = new Map();\n                function getNonSilentDependencies(operation) {\n                    let realDependencies = nonSilentDependenciesByOperation.get(operation);\n                    if (!realDependencies) {\n                        realDependencies = new Set();\n                        nonSilentDependenciesByOperation.set(operation, realDependencies);\n                        for (const dependency of operation.dependencies) {\n                            if (dependency.runner.silent) {\n                                for (const deepDependency of getNonSilentDependencies(dependency)) {\n                                    realDependencies.add(deepDependency);\n                                }\n                            }\n                            else {\n                                realDependencies.add(dependency.name);\n                            }\n                        }\n                    }\n                    return realDependencies;\n                }\n                for (const [operation, operationResult] of result.operationResults) {\n                    if ((_a = operation.runner) === null || _a === void 0 ? void 0 : _a.silent) {\n                        // Architectural operation. Ignore.\n                        continue;\n                    }\n                    const { startTime, endTime } = operationResult.stopwatch;\n                    operationResults[operation.name] = {\n                        startTimestampMs: startTime,\n                        endTimestampMs: endTime,\n                        nonCachedDurationMs: operationResult.nonCachedDurationMs,\n                        result: operationResult.status,\n                        dependencies: Array.from(getNonSilentDependencies(operation)).sort()\n                    };\n                    extraData.countAll++;\n                    switch (operationResult.status) {\n                        case OperationStatus.Success:\n                            extraData.countSuccess++;\n                            break;\n                        case OperationStatus.SuccessWithWarning:\n                            extraData.countSuccessWithWarnings++;\n                            break;\n                        case OperationStatus.Failure:\n                            extraData.countFailure++;\n                            break;\n                        case OperationStatus.Blocked:\n                            extraData.countBlocked++;\n                            break;\n                        case OperationStatus.FromCache:\n                            extraData.countFromCache++;\n                            break;\n                        case OperationStatus.Skipped:\n                            extraData.countSkipped++;\n                            break;\n                        case OperationStatus.NoOp:\n                            extraData.countNoOp++;\n                            break;\n                        default:\n                            // Do nothing.\n                            break;\n                    }\n                }\n            }\n            const logEntry = {\n                name: this.actionName,\n                durationInSeconds: stopwatch.duration,\n                result: success ? 'Succeeded' : 'Failed',\n                extraData,\n                operationResults\n            };\n            this.hooks.beforeLog.call(logEntry);\n            this.parser.telemetry.log(logEntry);\n            this.parser.flushTelemetry();\n        }\n        if (!success && !isWatch) {\n            throw new AlreadyReportedError();\n        }\n    }\n    _doBeforeTask() {\n        if (this.actionName !== RushConstants.buildCommandName &&\n            this.actionName !== RushConstants.rebuildCommandName) {\n            // Only collects information for built-in commands like build or rebuild.\n            return;\n        }\n        SetupChecks.validate(this.rushConfiguration);\n        this.eventHooksManager.handle(Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);\n    }\n    _doAfterTask() {\n        if (this.actionName !== RushConstants.buildCommandName &&\n            this.actionName !== RushConstants.rebuildCommandName) {\n            // Only collects information for built-in commands like build or rebuild.\n            return;\n        }\n        this.eventHooksManager.handle(Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);\n    }\n}\n//# sourceMappingURL=PhasedScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.\n * @packageDocumentation\n */\nexport { ApprovedPackagesPolicy } from './api/ApprovedPackagesPolicy';\nexport { RushConfiguration } from './api/RushConfiguration';\nexport { PackageManagerOptionsConfigurationBase } from './logic/base/BasePackageManagerOptionsConfiguration';\nexport { NpmOptionsConfiguration } from './logic/npm/NpmOptionsConfiguration';\nexport { YarnOptionsConfiguration } from './logic/yarn/YarnOptionsConfiguration';\nexport { PnpmOptionsConfiguration } from './logic/pnpm/PnpmOptionsConfiguration';\nexport { BuildCacheConfiguration } from './api/BuildCacheConfiguration';\nexport { CobuildConfiguration } from './api/CobuildConfiguration';\nexport { FileSystemBuildCacheProvider } from './logic/buildCache/FileSystemBuildCacheProvider';\nexport { EnvironmentConfiguration, EnvironmentVariableNames } from './api/EnvironmentConfiguration';\nexport { RushConstants } from './logic/RushConstants';\nexport { PackageManager } from './api/packageManager/PackageManager';\nexport { RushConfigurationProject } from './api/RushConfigurationProject';\nexport { RushProjectConfiguration } from './api/RushProjectConfiguration';\nexport { RushUserConfiguration } from './api/RushUserConfiguration';\nexport { RushGlobalFolder as _RushGlobalFolder } from './api/RushGlobalFolder';\nexport { ApprovedPackagesItem, ApprovedPackagesConfiguration } from './api/ApprovedPackagesConfiguration';\nexport { CommonVersionsConfiguration } from './api/CommonVersionsConfiguration';\nexport { PackageJsonEditor, PackageJsonDependency, DependencyType } from './api/PackageJsonEditor';\nexport { RepoStateFile } from './logic/RepoStateFile';\nexport { LookupByPath } from './logic/LookupByPath';\nexport { EventHooks, Event } from './api/EventHooks';\nexport { ChangeManager } from './api/ChangeManager';\nexport { LastInstallFlag as _LastInstallFlag } from './api/LastInstallFlag';\nexport { VersionPolicyDefinitionName, BumpType, LockStepVersionPolicy, IndividualVersionPolicy, VersionPolicy } from './api/VersionPolicy';\nexport { VersionPolicyConfiguration } from './api/VersionPolicyConfiguration';\nexport { Rush } from './api/Rush';\nexport { RushInternals as _RushInternals } from './api/RushInternals';\nexport { ExperimentsConfiguration } from './api/ExperimentsConfiguration';\nexport { CustomTipsConfiguration, CustomTipId, CustomTipSeverity, CustomTipType } from './api/CustomTipsConfiguration';\nexport { ProjectChangeAnalyzer } from './logic/ProjectChangeAnalyzer';\nexport { Operation } from './logic/operations/Operation';\nexport { OperationStatus } from './logic/operations/OperationStatus';\nexport { RushSession } from './pluginFramework/RushSession';\nexport { RushLifecycleHooks } from './pluginFramework/RushLifeCycle';\nexport { PhasedCommandHooks } from './pluginFramework/PhasedCommandHooks';\nexport { CredentialCache } from './logic/CredentialCache';\nexport { OperationStateFile as _OperationStateFile } from './logic/operations/OperationStateFile';\nexport { OperationMetadataManager as _OperationMetadataManager } from './logic/operations/OperationMetadataManager';\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { FileSystem, JsonFile, LockFile, NewlineKind } from '@rushstack/node-core-library';\nimport { Utilities } from '../utilities/Utilities';\nimport { PackageName } from '@rushstack/node-core-library';\nimport { PackageJsonEditor } from '../api/PackageJsonEditor';\nimport { InstallHelpers } from './installManager/InstallHelpers';\nimport { RushConstants } from './RushConstants';\nimport { LastInstallFlag } from '../api/LastInstallFlag';\nimport { RushCommandLineParser } from '../cli/RushCommandLineParser';\nexport class Autoinstaller {\n    constructor(options) {\n        var _a;\n        this.name = options.autoinstallerName;\n        this._rushConfiguration = options.rushConfiguration;\n        this._rushGlobalFolder = options.rushGlobalFolder;\n        this._restrictConsoleOutput =\n            (_a = options.restrictConsoleOutput) !== null && _a !== void 0 ? _a : RushCommandLineParser.shouldRestrictConsoleOutput();\n        Autoinstaller.validateName(this.name);\n    }\n    // Example: .../common/autoinstallers/my-task\n    get folderFullPath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name);\n    }\n    // Example: .../common/autoinstallers/my-task/package-lock.yaml\n    get shrinkwrapFilePath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, this._rushConfiguration.shrinkwrapFilename);\n    }\n    // Example: .../common/autoinstallers/my-task/package.json\n    get packageJsonPath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, 'package.json');\n    }\n    static validateName(autoinstallerName) {\n        const nameOrError = PackageName.tryParse(autoinstallerName);\n        if (nameOrError.error) {\n            throw new Error(`The specified name \"${autoinstallerName}\" is invalid: ` + nameOrError.error);\n        }\n        if (nameOrError.scope) {\n            throw new Error(`The specified name \"${autoinstallerName}\" must not contain an NPM scope`);\n        }\n    }\n    async prepareAsync() {\n        const autoinstallerFullPath = this.folderFullPath;\n        if (!FileSystem.exists(autoinstallerFullPath)) {\n            throw new Error(`The autoinstaller ${this.name} does not exist, Please run\\nrush init-autoinstaller --name ${this.name}\\n`);\n        }\n        await InstallHelpers.ensureLocalPackageManager(this._rushConfiguration, this._rushGlobalFolder, RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);\n        // Example: common/autoinstallers/my-task/package.json\n        const relativePathForLogs = path.relative(this._rushConfiguration.rushJsonFolder, autoinstallerFullPath);\n        this._logIfConsoleOutputIsNotRestricted(`Acquiring lock for \"${relativePathForLogs}\" folder...`);\n        const lock = await LockFile.acquire(autoinstallerFullPath, 'autoinstaller');\n        try {\n            // Example: .../common/autoinstallers/my-task/.rush/temp\n            const lastInstallFlagPath = path.join(autoinstallerFullPath, RushConstants.projectRushFolderName, 'temp');\n            const packageJsonPath = path.join(autoinstallerFullPath, 'package.json');\n            const packageJson = JsonFile.load(packageJsonPath);\n            const lastInstallFlag = new LastInstallFlag(lastInstallFlagPath, {\n                node: process.versions.node,\n                packageManager: this._rushConfiguration.packageManager,\n                packageManagerVersion: this._rushConfiguration.packageManagerToolVersion,\n                packageJson: packageJson,\n                rushJsonFolder: this._rushConfiguration.rushJsonFolder\n            });\n            // Example: ../common/autoinstallers/my-task/node_modules\n            const nodeModulesFolder = `${autoinstallerFullPath}/${RushConstants.nodeModulesFolderName}`;\n            const flagPath = `${nodeModulesFolder}/rush-autoinstaller.flag`;\n            const isLastInstallFlagDirty = !lastInstallFlag.isValid() || !FileSystem.exists(flagPath);\n            if (isLastInstallFlagDirty || lock.dirtyWhenAcquired) {\n                if (FileSystem.exists(nodeModulesFolder)) {\n                    this._logIfConsoleOutputIsNotRestricted('Deleting old files from ' + nodeModulesFolder);\n                    FileSystem.ensureEmptyFolder(nodeModulesFolder);\n                }\n                // Copy: .../common/autoinstallers/my-task/.npmrc\n                Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, autoinstallerFullPath);\n                this._logIfConsoleOutputIsNotRestricted(`Installing dependencies under ${autoinstallerFullPath}...\\n`);\n                Utilities.executeCommand({\n                    command: this._rushConfiguration.packageManagerToolFilename,\n                    args: ['install', '--frozen-lockfile'],\n                    workingDirectory: autoinstallerFullPath,\n                    keepEnvironment: true\n                });\n                // Create file: ../common/autoinstallers/my-task/.rush/temp/last-install.flag\n                lastInstallFlag.create();\n                FileSystem.writeFile(flagPath, 'If this file is deleted, Rush will assume that the node_modules folder has been cleaned and will reinstall it.');\n                this._logIfConsoleOutputIsNotRestricted('Auto install completed successfully\\n');\n            }\n            else {\n                this._logIfConsoleOutputIsNotRestricted('Autoinstaller folder is already up to date\\n');\n            }\n        }\n        finally {\n            // Ensure the lockfile is released when we are finished.\n            lock.release();\n        }\n    }\n    async updateAsync() {\n        await InstallHelpers.ensureLocalPackageManager(this._rushConfiguration, this._rushGlobalFolder, RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);\n        const autoinstallerPackageJsonPath = path.join(this.folderFullPath, 'package.json');\n        if (!(await FileSystem.existsAsync(autoinstallerPackageJsonPath))) {\n            throw new Error(`The specified autoinstaller path does not exist: ` + autoinstallerPackageJsonPath);\n        }\n        this._logIfConsoleOutputIsNotRestricted(`Updating autoinstaller package: ${autoinstallerPackageJsonPath}`);\n        let oldFileContents = '';\n        if (await FileSystem.existsAsync(this.shrinkwrapFilePath)) {\n            oldFileContents = FileSystem.readFile(this.shrinkwrapFilePath, { convertLineEndings: NewlineKind.Lf });\n            this._logIfConsoleOutputIsNotRestricted('Deleting ' + this.shrinkwrapFilePath);\n            await FileSystem.deleteFileAsync(this.shrinkwrapFilePath);\n            if (this._rushConfiguration.packageManager === 'pnpm') {\n                // Workaround for https://github.com/pnpm/pnpm/issues/1890\n                //\n                // When \"rush update-autoinstaller\" is run, Rush deletes \"common/autoinstallers/my-task/pnpm-lock.yaml\"\n                // so that a new lockfile will be generated. However \"pnpm install\" by design will try to recover\n                // \"pnpm-lock.yaml\" from \"my-task/node_modules/.pnpm/lock.yaml\", which may prevent a full upgrade.\n                // Deleting both files ensures that a new lockfile will always be generated.\n                const pnpmPackageManager = this._rushConfiguration\n                    .packageManagerWrapper;\n                await FileSystem.deleteFileAsync(path.join(this.folderFullPath, pnpmPackageManager.internalShrinkwrapRelativePath));\n            }\n        }\n        // Detect a common mistake where PNPM prints \"Already up-to-date\" without creating a shrinkwrap file\n        const packageJsonEditor = PackageJsonEditor.load(this.packageJsonPath);\n        if (packageJsonEditor.dependencyList.length === 0) {\n            throw new Error('You must add at least one dependency to the autoinstaller package' +\n                ' before invoking this command:\\n' +\n                this.packageJsonPath);\n        }\n        this._logIfConsoleOutputIsNotRestricted();\n        Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, this.folderFullPath);\n        Utilities.executeCommand({\n            command: this._rushConfiguration.packageManagerToolFilename,\n            args: ['install'],\n            workingDirectory: this.folderFullPath,\n            keepEnvironment: true\n        });\n        this._logIfConsoleOutputIsNotRestricted();\n        if (this._rushConfiguration.packageManager === 'npm') {\n            this._logIfConsoleOutputIsNotRestricted(colors.bold('Running \"npm shrinkwrap\"...'));\n            Utilities.executeCommand({\n                command: this._rushConfiguration.packageManagerToolFilename,\n                args: ['shrinkwrap'],\n                workingDirectory: this.folderFullPath,\n                keepEnvironment: true\n            });\n            this._logIfConsoleOutputIsNotRestricted('\"npm shrinkwrap\" completed');\n            this._logIfConsoleOutputIsNotRestricted();\n        }\n        if (!(await FileSystem.existsAsync(this.shrinkwrapFilePath))) {\n            throw new Error('The package manager did not create the expected shrinkwrap file: ' + this.shrinkwrapFilePath);\n        }\n        const newFileContents = await FileSystem.readFileAsync(this.shrinkwrapFilePath, {\n            convertLineEndings: NewlineKind.Lf\n        });\n        if (oldFileContents !== newFileContents) {\n            this._logIfConsoleOutputIsNotRestricted(colors.green('The shrinkwrap file has been updated.') + '  Please commit the updated file:');\n            this._logIfConsoleOutputIsNotRestricted(`\\n  ${this.shrinkwrapFilePath}`);\n        }\n        else {\n            this._logIfConsoleOutputIsNotRestricted(colors.green('Already up to date.'));\n        }\n    }\n    _logIfConsoleOutputIsNotRestricted(message) {\n        if (!this._restrictConsoleOutput) {\n            // eslint-disable-next-line no-console\n            console.log(message !== null && message !== void 0 ? message : '');\n        }\n    }\n}\n//# sourceMappingURL=Autoinstaller.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Async, FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/change-file.schema.json';\n/**\n * This class represents the collection of change files existing in the repo and provides operations\n * for those change files.\n */\nexport class ChangeFiles {\n    constructor(changesPath) {\n        this._changesPath = changesPath;\n    }\n    /**\n     * Validate if the newly added change files match the changed packages.\n     */\n    static validate(newChangeFilePaths, changedPackages, rushConfiguration) {\n        const schema = JsonSchema.fromLoadedObject(schemaJson);\n        const projectsWithChangeDescriptions = new Set();\n        newChangeFilePaths.forEach((filePath) => {\n            // eslint-disable-next-line no-console\n            console.log(`Found change file: ${filePath}`);\n            const changeFile = JsonFile.loadAndValidate(filePath, schema);\n            if (rushConfiguration.hotfixChangeEnabled) {\n                if (changeFile && changeFile.changes) {\n                    for (const change of changeFile.changes) {\n                        if (change.type !== 'none' && change.type !== 'hotfix') {\n                            throw new Error(`Change file ${filePath} specifies a type of '${change.type}' ` +\n                                `but only 'hotfix' and 'none' change types may be used in a branch with 'hotfixChangeEnabled'.`);\n                        }\n                    }\n                }\n            }\n            if (changeFile && changeFile.changes) {\n                changeFile.changes.forEach((change) => projectsWithChangeDescriptions.add(change.packageName));\n            }\n            else {\n                throw new Error(`Invalid change file: ${filePath}`);\n            }\n        });\n        const projectsMissingChangeDescriptions = new Set(changedPackages);\n        projectsWithChangeDescriptions.forEach((name) => projectsMissingChangeDescriptions.delete(name));\n        if (projectsMissingChangeDescriptions.size > 0) {\n            const projectsMissingChangeDescriptionsArray = [];\n            projectsMissingChangeDescriptions.forEach((name) => projectsMissingChangeDescriptionsArray.push(name));\n            throw new Error([\n                'The following projects have been changed and require change descriptions, but change descriptions were not ' +\n                    'detected for them:',\n                ...projectsMissingChangeDescriptionsArray.map((projectName) => `- ${projectName}`),\n                'To resolve this error, run \"rush change\". This will generate change description files that must be ' +\n                    'committed to source control.'\n            ].join('\\n'));\n        }\n    }\n    static getChangeComments(newChangeFilePaths) {\n        const changes = new Map();\n        newChangeFilePaths.forEach((filePath) => {\n            // eslint-disable-next-line no-console\n            console.log(`Found change file: ${filePath}`);\n            const changeRequest = JsonFile.load(filePath);\n            if (changeRequest && changeRequest.changes) {\n                changeRequest.changes.forEach((change) => {\n                    if (!changes.get(change.packageName)) {\n                        changes.set(change.packageName, []);\n                    }\n                    if (change.comment && change.comment.length) {\n                        changes.get(change.packageName).push(change.comment);\n                    }\n                });\n            }\n            else {\n                throw new Error(`Invalid change file: ${filePath}`);\n            }\n        });\n        return changes;\n    }\n    /**\n     * Get the array of absolute paths of change files.\n     */\n    async getFilesAsync() {\n        if (!this._files) {\n            const { default: glob } = await import('fast-glob');\n            this._files = (await glob('**/*.json', { cwd: this._changesPath, absolute: true })) || [];\n        }\n        return this._files;\n    }\n    /**\n     * Get the path of changes folder.\n     */\n    getChangesPath() {\n        return this._changesPath;\n    }\n    /**\n     * Delete all change files\n     */\n    async deleteAllAsync(shouldDelete, updatedChangelogs) {\n        if (updatedChangelogs) {\n            // Skip changes files if the package's change log is not updated.\n            const packagesToInclude = new Set();\n            updatedChangelogs.forEach((changelog) => {\n                packagesToInclude.add(changelog.name);\n            });\n            const files = await this.getFilesAsync();\n            const filesToDelete = [];\n            await Async.forEachAsync(files, async (filePath) => {\n                const changeRequest = await JsonFile.loadAsync(filePath);\n                let shouldDeleteFile = true;\n                for (const changeInfo of changeRequest.changes) {\n                    if (!packagesToInclude.has(changeInfo.packageName)) {\n                        shouldDeleteFile = false;\n                        break;\n                    }\n                }\n                if (shouldDeleteFile) {\n                    filesToDelete.push(filePath);\n                }\n            }, { concurrency: 5 });\n            return await this._deleteFilesAsync(filesToDelete, shouldDelete);\n        }\n        else {\n            // Delete all change files.\n            const files = await this.getFilesAsync();\n            return await this._deleteFilesAsync(files, shouldDelete);\n        }\n    }\n    async _deleteFilesAsync(files, shouldDelete) {\n        if (files.length) {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldDelete ? 'DELETING:' : 'DRYRUN: Deleting'} ${files.length} change file(s).`);\n            await Async.forEachAsync(files, async (filePath) => {\n                // eslint-disable-next-line no-console\n                console.log(` - ${filePath}`);\n                if (shouldDelete) {\n                    await FileSystem.deleteFileAsync(filePath);\n                }\n            }, { concurrency: 5 });\n        }\n        return files.length;\n    }\n}\n//# sourceMappingURL=ChangeFiles.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PublishUtilities } from './PublishUtilities';\nimport { ChangeFiles } from './ChangeFiles';\nimport { PrereleaseToken } from './PrereleaseToken';\nimport { ChangelogGenerator } from './ChangelogGenerator';\n/**\n * The class manages change files and controls how changes logged by change files\n * can be applied to package.json and change logs.\n */\nexport class ChangeManager {\n    constructor(rushConfiguration, projectsToExclude) {\n        this._rushConfiguration = rushConfiguration;\n        this._projectsToExclude = projectsToExclude;\n    }\n    /**\n     * Load changes from change files\n     * @param changesPath - location of change files\n     * @param prereleaseToken - prerelease token\n     * @param includeCommitDetails - whether commit details need to be included in changes\n     */\n    async loadAsync(changesPath, prereleaseToken = new PrereleaseToken(), includeCommitDetails = false) {\n        this._allPackages = this._rushConfiguration.projectsByName;\n        this._prereleaseToken = prereleaseToken;\n        this._changeFiles = new ChangeFiles(changesPath);\n        this._allChanges = await PublishUtilities.findChangeRequestsAsync(this._allPackages, this._rushConfiguration, this._changeFiles, includeCommitDetails, this._prereleaseToken, this._projectsToExclude);\n        this._orderedChanges = PublishUtilities.sortChangeRequests(this._allChanges.packageChanges);\n    }\n    hasChanges() {\n        return ((this._orderedChanges && this._orderedChanges.length > 0) ||\n            (this._allChanges && this._allChanges.versionPolicyChanges.size > 0));\n    }\n    get packageChanges() {\n        return this._orderedChanges;\n    }\n    get allPackages() {\n        return this._allPackages;\n    }\n    validateChanges(versionConfig) {\n        this._allChanges.packageChanges.forEach((change, projectName) => {\n            const projectInfo = this._rushConfiguration.getProjectByName(projectName);\n            if (projectInfo) {\n                if (projectInfo.versionPolicy) {\n                    projectInfo.versionPolicy.validate(change.newVersion, projectName);\n                }\n            }\n        });\n    }\n    /**\n     * Apply changes to package.json\n     * @param shouldCommit - If the value is true, package.json will be updated.\n     * If the value is false, package.json and change logs will not be updated. It will only do a dry-run.\n     */\n    apply(shouldCommit) {\n        if (!this.hasChanges()) {\n            return;\n        }\n        // Update all the changed version policies\n        this._allChanges.versionPolicyChanges.forEach((versionPolicyChange, versionPolicyName) => {\n            this._rushConfiguration.versionPolicyConfiguration.update(versionPolicyName, versionPolicyChange.newVersion, shouldCommit);\n        });\n        // Apply all changes to package.json files.\n        const updatedPackages = PublishUtilities.updatePackages(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit, this._prereleaseToken, this._projectsToExclude);\n        return updatedPackages;\n    }\n    async updateChangelogAsync(shouldCommit) {\n        // Do not update changelog or delete the change files for prerelease.\n        // Save them for the official release.\n        if (!this._prereleaseToken.hasValue) {\n            // Update changelogs.\n            const updatedChangelogs = ChangelogGenerator.updateChangelogs(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit);\n            // Remove the change request files only if \"-a\" was provided.\n            await this._changeFiles.deleteAllAsync(shouldCommit, updatedChangelogs);\n        }\n    }\n}\n//# sourceMappingURL=ChangeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { PublishUtilities } from './PublishUtilities';\nimport { ChangeType } from '../api/ChangeManagement';\nimport schemaJson from '../schemas/changelog.schema.json';\nconst CHANGELOG_JSON = 'CHANGELOG.json';\nconst CHANGELOG_MD = 'CHANGELOG.md';\nconst EOL = '\\n';\nclass ChangelogGenerator {\n    /**\n     * Updates the appropriate changelogs with the given changes.\n     */\n    static updateChangelogs(allChanges, allProjects, rushConfiguration, shouldCommit) {\n        const updatedChangeLogs = [];\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const project = allProjects.get(packageName);\n            if (project && ChangelogGenerator._shouldUpdateChangeLog(project, allChanges)) {\n                const changeLog = ChangelogGenerator.updateIndividualChangelog(change, project.projectFolder, shouldCommit, rushConfiguration, project.versionPolicy && project.versionPolicy.isLockstepped, project.isMainProject);\n                if (changeLog) {\n                    updatedChangeLogs.push(changeLog);\n                }\n            }\n        });\n        return updatedChangeLogs;\n    }\n    /**\n     * Fully regenerate the markdown files based on the current json files.\n     */\n    static regenerateChangelogs(allProjects, rushConfiguration) {\n        allProjects.forEach((project) => {\n            const markdownPath = path.resolve(project.projectFolder, CHANGELOG_MD);\n            const markdownJSONPath = path.resolve(project.projectFolder, CHANGELOG_JSON);\n            if (FileSystem.exists(markdownPath)) {\n                // eslint-disable-next-line no-console\n                console.log('Found: ' + markdownPath);\n                if (!FileSystem.exists(markdownJSONPath)) {\n                    throw new Error('A CHANGELOG.md without json: ' + markdownPath);\n                }\n                const changelog = ChangelogGenerator._getChangelog(project.packageName, project.projectFolder);\n                const isLockstepped = !!project.versionPolicy && project.versionPolicy.isLockstepped;\n                FileSystem.writeFile(path.join(project.projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));\n            }\n        });\n    }\n    /**\n     * Updates an individual changelog for a single project.\n     */\n    static updateIndividualChangelog(change, projectFolder, shouldCommit, rushConfiguration, isLockstepped = false, isMain = true) {\n        if (isLockstepped && !isMain) {\n            // Early return if the project is lockstepped and does not host change logs\n            return undefined;\n        }\n        const changelog = ChangelogGenerator._getChangelog(change.packageName, projectFolder);\n        if (!changelog.entries.some((entry) => entry.version === change.newVersion)) {\n            const changelogEntry = {\n                version: change.newVersion,\n                tag: PublishUtilities.createTagname(change.packageName, change.newVersion, rushConfiguration.gitTagSeparator),\n                date: new Date().toUTCString(),\n                comments: {}\n            };\n            change.changes.forEach((individualChange) => {\n                if (individualChange.comment) {\n                    // Initialize the comments array only as necessary.\n                    const changeTypeString = ChangeType[individualChange.changeType];\n                    changelogEntry.comments[changeTypeString] = changelogEntry.comments[changeTypeString] || [];\n                    const comments = changelogEntry.comments[changeTypeString];\n                    const changeLogComment = {\n                        comment: individualChange.comment\n                    };\n                    if (individualChange.author) {\n                        changeLogComment.author = individualChange.author;\n                    }\n                    if (individualChange.commit) {\n                        changeLogComment.commit = individualChange.commit;\n                    }\n                    if (individualChange.customFields) {\n                        changeLogComment.customFields = individualChange.customFields;\n                    }\n                    comments.push(changeLogComment);\n                }\n            });\n            // Add the changelog entry to the start of the list.\n            changelog.entries.unshift(changelogEntry);\n            const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);\n            // eslint-disable-next-line no-console\n            console.log(`${EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ` +\n                `Changelog update for \"${change.packageName}@${change.newVersion}\".`);\n            if (shouldCommit) {\n                // Write markdown transform.\n                JsonFile.save(changelog, changelogFilename);\n                FileSystem.writeFile(path.join(projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));\n            }\n            return changelog;\n        }\n        // change log not updated.\n        return undefined;\n    }\n    /**\n     * Loads the changelog json from disk, or creates a new one if there isn't one.\n     */\n    static _getChangelog(packageName, projectFolder) {\n        const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);\n        let changelog = undefined;\n        // Try to read the existing changelog.\n        if (FileSystem.exists(changelogFilename)) {\n            changelog = JsonFile.loadAndValidate(changelogFilename, ChangelogGenerator.jsonSchema);\n        }\n        if (!changelog) {\n            changelog = {\n                name: packageName,\n                entries: []\n            };\n        }\n        else {\n            // Force the changelog name to be same as package name.\n            // In case the package has been renamed but change log name is not updated.\n            changelog.name = packageName;\n        }\n        return changelog;\n    }\n    /**\n     * Translates the given changelog json object into a markdown string.\n     */\n    static _translateToMarkdown(changelog, rushConfiguration, isLockstepped = false) {\n        let markdown = [\n            `# Change Log - ${changelog.name}`,\n            '',\n            `This log was last generated on ${new Date().toUTCString()} and should not be manually modified.`,\n            '',\n            ''\n        ].join(EOL);\n        changelog.entries.forEach((entry, index) => {\n            markdown += `## ${entry.version}${EOL}`;\n            if (entry.date) {\n                markdown += `${entry.date}${EOL}`;\n            }\n            markdown += EOL;\n            let comments = '';\n            comments += ChangelogGenerator._getChangeComments('Breaking changes', entry.comments.major);\n            comments += ChangelogGenerator._getChangeComments('Minor changes', entry.comments.minor);\n            comments += ChangelogGenerator._getChangeComments('Patches', entry.comments.patch);\n            if (isLockstepped) {\n                // In lockstepped projects, all changes are of type ChangeType.none.\n                comments += ChangelogGenerator._getChangeComments('Updates', entry.comments.none);\n            }\n            if (rushConfiguration.hotfixChangeEnabled) {\n                comments += ChangelogGenerator._getChangeComments('Hotfixes', entry.comments.hotfix);\n            }\n            if (!comments) {\n                markdown +=\n                    (changelog.entries.length === index + 1 ? '_Initial release_' : '_Version update only_') +\n                        EOL +\n                        EOL;\n            }\n            else {\n                markdown += comments;\n            }\n        });\n        return markdown;\n    }\n    /**\n     * Helper to return the comments string to be appends to the markdown content.\n     */\n    static _getChangeComments(title, commentsArray) {\n        let comments = '';\n        if (commentsArray) {\n            comments = `### ${title}${EOL + EOL}`;\n            commentsArray.forEach((comment) => {\n                comments += `- ${comment.comment}${EOL}`;\n            });\n            comments += EOL;\n        }\n        return comments;\n    }\n    /**\n     * Changelogs should only be generated for publishable projects.\n     * Do not update changelog or delete the change files for prerelease. Save them for the official release.\n     * Unless the package is a hotfix, in which case do delete the change files.\n     *\n     * @param project\n     * @param allChanges\n     */\n    static _shouldUpdateChangeLog(project, allChanges) {\n        var _a;\n        return (project.shouldPublish &&\n            (!semver.prerelease(project.packageJson.version) ||\n                ((_a = allChanges.packageChanges.get(project.packageName)) === null || _a === void 0 ? void 0 : _a.changeType) === ChangeType.hotfix));\n    }\n}\n/**\n * The JSON Schema for Changelog file (changelog.schema.json).\n */\nChangelogGenerator.jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { ChangelogGenerator };\n//# sourceMappingURL=ChangelogGenerator.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema, LockFile } from '@rushstack/node-core-library';\nimport { Utilities } from '../utilities/Utilities';\nimport { RushUserConfiguration } from '../api/RushUserConfiguration';\nimport schemaJson from '../schemas/credentials.schema.json';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\nconst CACHE_FILENAME = 'credentials.json';\nconst LATEST_CREDENTIALS_JSON_VERSION = '0.1.0';\n/**\n * @beta\n */\nexport class CredentialCache /* implements IDisposable */ {\n    constructor(cacheFilePath, loadedJson, lockfile) {\n        this._modified = false;\n        this._disposed = false;\n        if (loadedJson && loadedJson.version !== LATEST_CREDENTIALS_JSON_VERSION) {\n            throw new Error(`Unexpected credentials.json file version: ${loadedJson.version}`);\n        }\n        this._cacheFilePath = cacheFilePath;\n        this._cacheEntries = new Map(Object.entries((loadedJson === null || loadedJson === void 0 ? void 0 : loadedJson.cacheEntries) || {}));\n        this._supportsEditing = !!lockfile;\n        this._lockfile = lockfile;\n    }\n    static async initializeAsync(options) {\n        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();\n        const cacheFilePath = `${rushUserFolderPath}/${CACHE_FILENAME}`;\n        const jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n        let loadedJson;\n        try {\n            loadedJson = await JsonFile.loadAndValidateAsync(cacheFilePath, jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isErrnoException(e)) {\n                throw e;\n            }\n        }\n        let lockfile;\n        if (options.supportEditing) {\n            lockfile = await LockFile.acquire(rushUserFolderPath, `${CACHE_FILENAME}.lock`);\n        }\n        const credentialCache = new CredentialCache(cacheFilePath, loadedJson, lockfile);\n        return credentialCache;\n    }\n    static async usingAsync(options, doActionAsync) {\n        await Utilities.usingAsync(async () => await CredentialCache.initializeAsync(options), doActionAsync);\n    }\n    setCacheEntry(cacheId, entry) {\n        this._validate(true);\n        const { expires, credential, credentialMetadata } = entry;\n        const expiresMilliseconds = (expires === null || expires === void 0 ? void 0 : expires.getTime()) || 0;\n        const existingCacheEntry = this._cacheEntries.get(cacheId);\n        if ((existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credential) !== credential ||\n            (existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.expires) !== expiresMilliseconds ||\n            !objectsAreDeepEqual(existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credentialMetadata, credentialMetadata)) {\n            this._modified = true;\n            this._cacheEntries.set(cacheId, {\n                expires: expiresMilliseconds,\n                credential,\n                credentialMetadata\n            });\n        }\n    }\n    tryGetCacheEntry(cacheId) {\n        this._validate(false);\n        const cacheEntry = this._cacheEntries.get(cacheId);\n        if (cacheEntry) {\n            const result = {\n                expires: cacheEntry.expires ? new Date(cacheEntry.expires) : undefined,\n                credential: cacheEntry.credential,\n                credentialMetadata: cacheEntry.credentialMetadata\n            };\n            return result;\n        }\n        else {\n            return undefined;\n        }\n    }\n    deleteCacheEntry(cacheId) {\n        this._validate(true);\n        if (this._cacheEntries.has(cacheId)) {\n            this._modified = true;\n            this._cacheEntries.delete(cacheId);\n        }\n    }\n    trimExpiredEntries() {\n        this._validate(true);\n        const now = Date.now();\n        for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {\n            if (cacheEntry.expires < now) {\n                this._cacheEntries.delete(cacheId);\n                this._modified = true;\n            }\n        }\n    }\n    async saveIfModifiedAsync() {\n        this._validate(true);\n        if (this._modified) {\n            const cacheEntriesJson = {};\n            for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {\n                cacheEntriesJson[cacheId] = cacheEntry;\n            }\n            const newJson = {\n                version: LATEST_CREDENTIALS_JSON_VERSION,\n                cacheEntries: cacheEntriesJson\n            };\n            await JsonFile.saveAsync(newJson, this._cacheFilePath, {\n                ensureFolderExists: true,\n                updateExistingFile: true,\n                ignoreUndefinedValues: true\n            });\n            this._modified = false;\n        }\n    }\n    dispose() {\n        var _a;\n        (_a = this._lockfile) === null || _a === void 0 ? void 0 : _a.release();\n        this._disposed = true;\n    }\n    _validate(requiresEditing) {\n        if (!this._supportsEditing && requiresEditing) {\n            throw new Error(`This instance of ${CredentialCache.name} does not support editing.`);\n        }\n        if (this._disposed) {\n            throw new Error(`This instance of ${CredentialCache.name} has been disposed.`);\n        }\n    }\n}\n//# sourceMappingURL=CredentialCache.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { DependencyType } from '../api/PackageJsonEditor';\nexport class DependencyAnalyzer {\n    constructor(rushConfiguration) {\n        this._analysisByVariant = new Map();\n        this._rushConfiguration = rushConfiguration;\n    }\n    static forRushConfiguration(rushConfiguration) {\n        if (!DependencyAnalyzer._dependencyAnalyzerByRushConfiguration) {\n            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration = new WeakMap();\n        }\n        let analyzer = DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.get(rushConfiguration);\n        if (!analyzer) {\n            analyzer = new DependencyAnalyzer(rushConfiguration);\n            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.set(rushConfiguration, analyzer);\n        }\n        return analyzer;\n    }\n    getAnalysis(variant) {\n        // Use an empty string as the key when no variant provided. Anything else would possibly conflict\n        // with a variant created by the user\n        const variantKey = variant || '';\n        let analysis = this._analysisByVariant.get(variantKey);\n        if (!analysis) {\n            analysis = this._getAnalysisInternal(variant);\n            this._analysisByVariant.set(variantKey, analysis);\n        }\n        return analysis;\n    }\n    /**\n     * Generates the {@link IDependencyAnalysis} for a variant.\n     *\n     * @remarks\n     * The result of this function is not cached.\n     */\n    _getAnalysisInternal(variant) {\n        var _a;\n        const commonVersionsConfiguration = this._rushConfiguration.getCommonVersions(variant);\n        const allVersionsByPackageName = new Map();\n        const allowedAlternativeVersions = commonVersionsConfiguration.allowedAlternativeVersions;\n        for (const project of this._rushConfiguration.projects) {\n            const dependencies = [\n                ...project.packageJsonEditor.dependencyList,\n                ...project.packageJsonEditor.devDependencyList\n            ];\n            for (const { name: dependencyName, version: dependencyVersion, dependencyType } of dependencies) {\n                if (dependencyType === DependencyType.Peer) {\n                    // If this is a peer dependency, it isn't a real dependency in this context, so it shouldn't\n                    // be included in the list of dependency versions.\n                    continue;\n                }\n                // Is it a local project?\n                const localProject = this._rushConfiguration.getProjectByName(dependencyName);\n                if (localProject) {\n                    if (!project.decoupledLocalDependencies.has(dependencyName) &&\n                        semver.satisfies(localProject.packageJson.version, dependencyVersion)) {\n                        // For now, ignore local dependencies (that aren't cyclic dependencies).\n                        continue;\n                    }\n                }\n                let allVersionForDependency = allVersionsByPackageName.get(dependencyName);\n                if (!allVersionForDependency) {\n                    allVersionForDependency = new Set();\n                    allVersionsByPackageName.set(dependencyName, allVersionForDependency);\n                }\n                allVersionForDependency.add(dependencyVersion);\n            }\n        }\n        const implicitlyPreferredVersionByPackageName = new Map();\n        // Only generate implicitly preferred versions for variants that request it\n        const useImplicitlyPreferredVersions = (_a = commonVersionsConfiguration.implicitlyPreferredVersions) !== null && _a !== void 0 ? _a : true;\n        if (useImplicitlyPreferredVersions) {\n            for (const [dependencyName, versions] of allVersionsByPackageName) {\n                // For each dependency, we're collecting the set of all version specifiers that appear across the repo.\n                // If there is only one version specifier, then that's the \"preferred\" one.\n                const alternativesForThisDependency = new Set(allowedAlternativeVersions.get(dependencyName));\n                let implicitlyPreferredVersion = undefined;\n                for (const version of versions) {\n                    // Versions listed in the common-versions.json's \"allowedAlternativeVersions\" property\n                    // can be safely ignored in determining the set of implicitly preferred versions.\n                    // (Even if it's the only version specifier anywhere in the repo, we still ignore it, because\n                    // otherwise the rule would be difficult to explain.)\n                    if (!alternativesForThisDependency.has(version)) {\n                        if (implicitlyPreferredVersion === undefined) {\n                            // There isn't a candidate for an implicitly preferred version yet. Set this value as a candidate.\n                            implicitlyPreferredVersion = version;\n                        }\n                        else {\n                            // There was already another version that was a candidate. Clear that out and break.\n                            // This dependency does not have an implicitly preferred version because there are at least\n                            // two candidates.\n                            implicitlyPreferredVersion = undefined;\n                            break;\n                        }\n                    }\n                }\n                if (implicitlyPreferredVersion !== undefined) {\n                    implicitlyPreferredVersionByPackageName.set(dependencyName, implicitlyPreferredVersion);\n                }\n            }\n        }\n        return {\n            commonVersionsConfiguration,\n            implicitlyPreferredVersionByPackageName,\n            allVersionsByPackageName\n        };\n    }\n}\n//# sourceMappingURL=DependencyAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport npmPackageArg from 'npm-package-arg';\nimport { InternalError } from '@rushstack/node-core-library';\n/**\n * The parsed format of a provided version specifier.\n */\nexport var DependencySpecifierType;\n(function (DependencySpecifierType) {\n    /**\n     * A git repository\n     */\n    DependencySpecifierType[\"Git\"] = \"Git\";\n    /**\n     * A tagged version, e.g. \"example@latest\"\n     */\n    DependencySpecifierType[\"Tag\"] = \"Tag\";\n    /**\n     * A specific version number, e.g. \"example@1.2.3\"\n     */\n    DependencySpecifierType[\"Version\"] = \"Version\";\n    /**\n     * A version range, e.g. \"example@2.x\"\n     */\n    DependencySpecifierType[\"Range\"] = \"Range\";\n    /**\n     * A local .tar.gz, .tar or .tgz file\n     */\n    DependencySpecifierType[\"File\"] = \"File\";\n    /**\n     * A local directory\n     */\n    DependencySpecifierType[\"Directory\"] = \"Directory\";\n    /**\n     * An HTTP url to a .tar.gz, .tar or .tgz file\n     */\n    DependencySpecifierType[\"Remote\"] = \"Remote\";\n    /**\n     * A package alias, e.g. \"npm:other-package@^1.2.3\"\n     */\n    DependencySpecifierType[\"Alias\"] = \"Alias\";\n    /**\n     * A package specified using workspace protocol, e.g. \"workspace:^1.2.3\"\n     */\n    DependencySpecifierType[\"Workspace\"] = \"Workspace\";\n})(DependencySpecifierType || (DependencySpecifierType = {}));\n/**\n * An NPM \"version specifier\" is a string that can appear as a package.json \"dependencies\" value.\n * Example version specifiers: `^1.2.3`, `file:./blah.tgz`, `npm:other-package@~1.2.3`, and so forth.\n * A \"dependency specifier\" is the version specifier information, combined with the dependency package name.\n */\nexport class DependencySpecifier {\n    constructor(packageName, versionSpecifier) {\n        this.packageName = packageName;\n        this.versionSpecifier = versionSpecifier;\n        // Workspace ranges are a feature from PNPM and Yarn. Set the version specifier\n        // to the trimmed version range.\n        if (versionSpecifier.startsWith('workspace:')) {\n            this.specifierType = DependencySpecifierType.Workspace;\n            this.versionSpecifier = versionSpecifier.slice(this.specifierType.length + 1).trim();\n            this.aliasTarget = undefined;\n            return;\n        }\n        const result = npmPackageArg.resolve(packageName, versionSpecifier);\n        this.specifierType = DependencySpecifier.getDependencySpecifierType(result.type);\n        if (this.specifierType === DependencySpecifierType.Alias) {\n            const aliasResult = result;\n            if (!aliasResult.subSpec || !aliasResult.subSpec.name) {\n                throw new InternalError('Unexpected result from npm-package-arg');\n            }\n            this.aliasTarget = new DependencySpecifier(aliasResult.subSpec.name, aliasResult.subSpec.rawSpec);\n        }\n        else {\n            this.aliasTarget = undefined;\n        }\n    }\n    static getDependencySpecifierType(specifierType) {\n        switch (specifierType) {\n            case 'git':\n                return DependencySpecifierType.Git;\n            case 'tag':\n                return DependencySpecifierType.Tag;\n            case 'version':\n                return DependencySpecifierType.Version;\n            case 'range':\n                return DependencySpecifierType.Range;\n            case 'file':\n                return DependencySpecifierType.File;\n            case 'directory':\n                return DependencySpecifierType.Directory;\n            case 'remote':\n                return DependencySpecifierType.Remote;\n            case 'alias':\n                return DependencySpecifierType.Alias;\n            default:\n                throw new InternalError(`Unexpected npm-package-arg result type \"${specifierType}\"`);\n        }\n    }\n}\n//# sourceMappingURL=DependencySpecifier.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { Utilities } from '../utilities/Utilities';\nimport { Event } from '../api/EventHooks';\nimport { Stopwatch } from '../utilities/Stopwatch';\nexport class EventHooksManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._eventHooks = rushConfiguration.eventHooks;\n        this._commonTempFolder = rushConfiguration.commonTempFolder;\n    }\n    handle(event, isDebug, ignoreHooks) {\n        if (!this._eventHooks) {\n            return;\n        }\n        const scripts = this._eventHooks.get(event);\n        if (scripts.length > 0) {\n            if (ignoreHooks) {\n                // eslint-disable-next-line no-console\n                console.log(`Skipping event hooks for ${Event[event]} since --ignore-hooks was specified`);\n                return;\n            }\n            const stopwatch = Stopwatch.start();\n            // eslint-disable-next-line no-console\n            console.log('\\n' + colors.green(`Executing event hooks for ${Event[event]}`));\n            const printEventHooksOutputToConsole = isDebug ||\n                this._rushConfiguration.experimentsConfiguration.configuration.printEventHooksOutputToConsole;\n            scripts.forEach((script) => {\n                try {\n                    Utilities.executeLifecycleCommand(script, {\n                        rushConfiguration: this._rushConfiguration,\n                        workingDirectory: this._rushConfiguration.rushJsonFolder,\n                        initCwd: this._commonTempFolder,\n                        handleOutput: !printEventHooksOutputToConsole,\n                        environmentPathOptions: {\n                            includeRepoBin: true\n                        }\n                    });\n                }\n                catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.error('\\n' +\n                        colors.yellow(`Event hook \"${script}\" failed. Run \"rush\" with --debug` +\n                            ` to see detailed error information.`));\n                    if (isDebug) {\n                        // eslint-disable-next-line no-console\n                        console.error('\\n' + error.message);\n                    }\n                }\n            });\n            stopwatch.stop();\n            // eslint-disable-next-line no-console\n            console.log('\\n' + colors.green(`Event hooks finished. (${stopwatch.toString()})`));\n        }\n    }\n}\n//# sourceMappingURL=EventHooksManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport gitInfo from 'git-repo-info';\nimport * as path from 'path';\nimport * as url from 'url';\nimport colors from 'colors/safe';\nimport { trueCasePathSync } from 'true-case-path';\nimport { Executable, AlreadyReportedError, Path } from '@rushstack/node-core-library';\nimport { ensureGitMinimumVersion } from '@rushstack/package-deps-hash';\nimport { Utilities } from '../utilities/Utilities';\nimport * as GitEmailPolicy from './policy/GitEmailPolicy';\nimport { EnvironmentConfiguration } from '../api/EnvironmentConfiguration';\nimport { parseGitStatus } from './GitStatusParser';\nexport const DEFAULT_GIT_TAG_SEPARATOR = '_';\nexport class Git {\n    constructor(rushConfiguration) {\n        this._checkedGitPath = false;\n        this._checkedGitInfo = false;\n        this._gitEmailResult = undefined;\n        this._gitHooksPath = undefined;\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Returns the path to the Git binary if found. Otherwise, return undefined.\n     */\n    get gitPath() {\n        if (!this._checkedGitPath) {\n            this._gitPath = EnvironmentConfiguration.gitBinaryPath || Executable.tryResolve('git');\n            this._checkedGitPath = true;\n        }\n        return this._gitPath;\n    }\n    getGitPathOrThrow() {\n        const gitPath = this.gitPath;\n        if (!gitPath) {\n            throw new Error('Git is not present');\n        }\n        else {\n            return gitPath;\n        }\n    }\n    /**\n     * Returns true if the Git binary can be found.\n     */\n    isGitPresent() {\n        return !!this.gitPath;\n    }\n    /**\n     * Returns true if the Git binary was found and the current path is under a Git working tree.\n     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,\n     * the result of `this.getGitInfo()` is used.\n     */\n    isPathUnderGitWorkingTree(repoInfo) {\n        if (this.isGitPresent()) {\n            // Do we even have a Git binary?\n            if (!repoInfo) {\n                repoInfo = this.getGitInfo();\n            }\n            return !!(repoInfo && repoInfo.sha);\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * If a Git email address is configured and is nonempty, this returns it.\n     * Otherwise, undefined is returned.\n     */\n    tryGetGitEmail() {\n        const emailResult = this._tryGetGitEmail();\n        if (emailResult.result !== undefined && emailResult.result.length > 0) {\n            return emailResult.result;\n        }\n        return undefined;\n    }\n    /**\n     * If a Git email address is configured and is nonempty, this returns it.\n     * Otherwise, configuration instructions are printed to the console,\n     * and AlreadyReportedError is thrown.\n     */\n    getGitEmail() {\n        // Determine the user's account\n        // Ex: \"bob@example.com\"\n        const emailResult = this._tryGetGitEmail();\n        if (emailResult.error) {\n            // eslint-disable-next-line no-console\n            console.log([\n                `Error: ${emailResult.error.message}`,\n                'Unable to determine your Git configuration using this command:',\n                '',\n                '    git config user.email',\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n        if (emailResult.result === undefined || emailResult.result.length === 0) {\n            // eslint-disable-next-line no-console\n            console.log([\n                'This operation requires that a Git email be specified.',\n                '',\n                `If you didn't configure your email yet, try something like this:`,\n                '',\n                ...GitEmailPolicy.getEmailExampleLines(this._rushConfiguration),\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n        return emailResult.result;\n    }\n    /**\n     * Get the folder where Git hooks should go for the current working tree.\n     * Returns undefined if the current path is not under a Git working tree.\n     */\n    getHooksFolder() {\n        const repoInfo = this.getGitInfo();\n        if (repoInfo && repoInfo.worktreeGitDir) {\n            return path.join(repoInfo.worktreeGitDir, 'hooks');\n        }\n        return undefined;\n    }\n    isHooksPathDefault() {\n        const repoInfo = this.getGitInfo();\n        if (!(repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.commonGitDir)) {\n            // This should have never been called in a non-Git environment\n            return true;\n        }\n        let commonGitDir = repoInfo.commonGitDir;\n        try {\n            commonGitDir = trueCasePathSync(commonGitDir);\n        }\n        catch (error) {\n            /* ignore errors from true-case-path */\n        }\n        const defaultHooksPath = path.resolve(commonGitDir, 'hooks');\n        const hooksResult = this._tryGetGitHooksPath();\n        if (hooksResult.error) {\n            // eslint-disable-next-line no-console\n            console.log([\n                `Error: ${hooksResult.error.message}`,\n                'Unable to determine your Git configuration using this command:',\n                '',\n                '    git rev-parse --git-path hooks',\n                '',\n                'Assuming hooks can still be installed in the default location'\n            ].join('\\n'));\n            return true;\n        }\n        if (hooksResult.result) {\n            const absoluteHooksPath = path.resolve(this._rushConfiguration.rushJsonFolder, hooksResult.result);\n            return absoluteHooksPath === defaultHooksPath;\n        }\n        // No error, but also empty result? Not sure it's possible.\n        return true;\n    }\n    getConfigHooksPath() {\n        let configHooksPath = '';\n        const gitPath = this.getGitPathOrThrow();\n        try {\n            configHooksPath = this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'core.hooksPath']).trim();\n        }\n        catch (e) {\n            // git config returns error code 1 if core.hooksPath is not set.\n        }\n        return configHooksPath;\n    }\n    /**\n     * Get information about the current Git working tree.\n     * Returns undefined if rush.json is not under a Git working tree.\n     */\n    getGitInfo() {\n        if (!this._checkedGitInfo) {\n            let repoInfo;\n            try {\n                // gitInfo() shouldn't usually throw, but wrapping in a try/catch just in case\n                repoInfo = gitInfo(this._rushConfiguration.rushJsonFolder);\n            }\n            catch (ex) {\n                // if there's an error, assume we're not in a Git working tree\n            }\n            if (repoInfo && this.isPathUnderGitWorkingTree(repoInfo)) {\n                this._gitInfo = repoInfo;\n            }\n            this._checkedGitInfo = true;\n        }\n        return this._gitInfo;\n    }\n    getMergeBase(targetBranch, terminal, shouldFetch = false) {\n        if (shouldFetch) {\n            this._fetchRemoteBranch(targetBranch, terminal);\n        }\n        const gitPath = this.getGitPathOrThrow();\n        try {\n            const output = this._executeGitCommandAndCaptureOutput(gitPath, [\n                '--no-optional-locks',\n                'merge-base',\n                '--',\n                'HEAD',\n                targetBranch\n            ]);\n            const result = output.trim();\n            return result;\n        }\n        catch (e) {\n            terminal.writeErrorLine(`Unable to determine merge base for branch \"${targetBranch}\". ` +\n                'This can occur if the current clone is a shallow clone. If this clone is running in a CI ' +\n                'pipeline, check your pipeline settings to ensure that the clone depth includes ' +\n                'the expected merge base. If this clone is running locally, consider running \"git fetch --deepen=<depth>\".');\n            throw new AlreadyReportedError();\n        }\n    }\n    getBlobContent({ blobSpec, repositoryRoot }) {\n        const gitPath = this.getGitPathOrThrow();\n        const output = this._executeGitCommandAndCaptureOutput(gitPath, ['cat-file', 'blob', blobSpec, '--'], repositoryRoot);\n        return output;\n    }\n    /**\n     * @param pathPrefix - An optional path prefix \"git diff\"s should be filtered by.\n     * @returns\n     * An array of paths of repo-root-relative paths of files that are different from\n     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,\n     * this function only returns results under the that path.\n     */\n    getChangedFiles(targetBranch, terminal, skipFetch = false, pathPrefix) {\n        if (!skipFetch) {\n            this._fetchRemoteBranch(targetBranch, terminal);\n        }\n        const gitPath = this.getGitPathOrThrow();\n        const output = this._executeGitCommandAndCaptureOutput(gitPath, [\n            'diff',\n            `${targetBranch}...`,\n            '--name-only',\n            '--no-renames',\n            '--diff-filter=A'\n        ]);\n        return output\n            .split('\\n')\n            .map((line) => {\n            if (line) {\n                const trimmedLine = line.trim();\n                if (!pathPrefix || Path.isUnderOrEqual(trimmedLine, pathPrefix)) {\n                    return trimmedLine;\n                }\n            }\n            else {\n                return undefined;\n            }\n        })\n            .filter((line) => {\n            return line && line.length > 0;\n        });\n    }\n    /**\n     * Gets the remote default branch that maps to the provided repository url.\n     * This method is used by 'Rush change' to find the default remote branch to compare against.\n     * If repository url is not provided or if there is no match, returns the default remote's\n     * default branch 'origin/main'.\n     * If there are more than one matches, returns the first remote's default branch.\n     *\n     * @param rushConfiguration - rush configuration\n     */\n    getRemoteDefaultBranch() {\n        const repositoryUrls = this._rushConfiguration.repositoryUrls;\n        if (repositoryUrls.length > 0) {\n            const gitPath = this.getGitPathOrThrow();\n            const output = this._executeGitCommandAndCaptureOutput(gitPath, ['remote']).trim();\n            const normalizedRepositoryUrls = new Set();\n            for (const repositoryUrl of repositoryUrls) {\n                // Apply toUpperCase() for a case-insensitive comparison\n                normalizedRepositoryUrls.add(Git.normalizeGitUrlForComparison(repositoryUrl).toUpperCase());\n            }\n            const matchingRemotes = output.split('\\n').filter((remoteName) => {\n                if (remoteName) {\n                    const remoteUrl = this._executeGitCommandAndCaptureOutput(gitPath, [\n                        'remote',\n                        'get-url',\n                        '--',\n                        remoteName\n                    ]).trim();\n                    if (!remoteUrl) {\n                        return false;\n                    }\n                    // Also apply toUpperCase() for a case-insensitive comparison\n                    const normalizedRemoteUrl = Git.normalizeGitUrlForComparison(remoteUrl).toUpperCase();\n                    if (normalizedRepositoryUrls.has(normalizedRemoteUrl)) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n            if (matchingRemotes.length > 0) {\n                if (matchingRemotes.length > 1) {\n                    // eslint-disable-next-line no-console\n                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);\n                }\n                return `${matchingRemotes[0]}/${this._rushConfiguration.repositoryDefaultBranch}`;\n            }\n            else {\n                const errorMessage = repositoryUrls.length > 1\n                    ? `Unable to find a git remote matching one of the repository URLs (${repositoryUrls.join(', ')}). `\n                    : `Unable to find a git remote matching the repository URL (${repositoryUrls[0]}). `;\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow(errorMessage + 'Detected changes are likely to be incorrect.'));\n                return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow('A git remote URL has not been specified in rush.json. Setting the baseline remote URL is recommended.'));\n            return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;\n        }\n    }\n    hasUncommittedChanges() {\n        const gitStatusEntries = this.getGitStatus();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const gitStatusEntry of gitStatusEntries) {\n            // If there are any changes, return true. We only need to evaluate the first iterator entry\n            return true;\n        }\n        return false;\n    }\n    hasUnstagedChanges() {\n        const gitStatusEntries = this.getGitStatus();\n        for (const gitStatusEntry of gitStatusEntries) {\n            if (gitStatusEntry.kind === 'untracked' ||\n                gitStatusEntry.unstagedChangeType !== undefined) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * The list of files changed but not committed\n     */\n    getUncommittedChanges() {\n        const result = [];\n        const gitStatusEntries = this.getGitStatus();\n        for (const gitStatusEntry of gitStatusEntries) {\n            result.push(gitStatusEntry.path);\n        }\n        return result;\n    }\n    getTagSeparator() {\n        return this._rushConfiguration.gitTagSeparator || DEFAULT_GIT_TAG_SEPARATOR;\n    }\n    getGitStatus() {\n        const gitPath = this.getGitPathOrThrow();\n        // See Git.test.ts for example output\n        const output = this._executeGitCommandAndCaptureOutput(gitPath, [\n            'status',\n            '--porcelain=2',\n            '--null',\n            '--ignored=no'\n        ]);\n        return parseGitStatus(output);\n    }\n    /**\n     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS\n     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS\n     * NOT NECESSARILY A VALID GIT URL.\n     *\n     * @example\n     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`\n     */\n    static normalizeGitUrlForComparison(gitUrl) {\n        // Git URL formats are documented here: https://www.git-scm.com/docs/git-clone#_git_urls\n        let result = gitUrl.trim();\n        // [user@]host.xz:path/to/repo.git/\n        // \"This syntax is only recognized if there are no slashes before the first colon. This helps\n        // differentiate a local path that contains a colon.\"\n        //\n        // Match patterns like this:\n        //   user@host.ext:path/to/repo\n        //   host.ext:path/to/repo\n        //   localhost:/~user/path/to/repo\n        //\n        // But not:\n        //   http://blah\n        //   c:/windows/path.txt\n        //\n        const scpLikeSyntaxRegExp = /^(?:[^@:\\/]+\\@)?([^:\\/]{2,})\\:((?!\\/\\/).+)$/;\n        // Example: \"user@host.ext:path/to/repo\"\n        const scpLikeSyntaxMatch = scpLikeSyntaxRegExp.exec(gitUrl);\n        if (scpLikeSyntaxMatch) {\n            // Example: \"host.ext\"\n            const host = scpLikeSyntaxMatch[1];\n            // Example: \"path/to/repo\"\n            const urlPath = scpLikeSyntaxMatch[2];\n            if (urlPath.startsWith('/')) {\n                result = `https://${host}${urlPath}`;\n            }\n            else {\n                result = `https://${host}/${urlPath}`;\n            }\n        }\n        const parsedUrl = url.parse(result);\n        // Only convert recognized schemes\n        switch (parsedUrl.protocol) {\n            case 'http:':\n            case 'https:':\n            case 'ssh:':\n            case 'ftp:':\n            case 'ftps:':\n            case 'git:':\n            case 'git+http:':\n            case 'git+https:':\n            case 'git+ssh:':\n            case 'git+ftp:':\n            case 'git+ftps:':\n                // Assemble the parts we want:\n                result = `https://${parsedUrl.host}${parsedUrl.pathname}`;\n                break;\n        }\n        // Trim \".git\" or \".git/\" from the end\n        result = result.replace(/.git\\/?$/, '');\n        return result;\n    }\n    _tryGetGitEmail() {\n        if (this._gitEmailResult === undefined) {\n            const gitPath = this.getGitPathOrThrow();\n            try {\n                this._gitEmailResult = {\n                    result: this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'user.email']).trim()\n                };\n            }\n            catch (e) {\n                this._gitEmailResult = {\n                    error: e\n                };\n            }\n        }\n        return this._gitEmailResult;\n    }\n    _tryGetGitHooksPath() {\n        if (this._gitHooksPath === undefined) {\n            const gitPath = this.getGitPathOrThrow();\n            try {\n                this._gitHooksPath = {\n                    result: this._executeGitCommandAndCaptureOutput(gitPath, [\n                        'rev-parse',\n                        '--git-path',\n                        'hooks'\n                    ]).trim()\n                };\n            }\n            catch (e) {\n                this._gitHooksPath = {\n                    error: e\n                };\n            }\n        }\n        return this._gitHooksPath;\n    }\n    _tryFetchRemoteBranch(remoteBranchName) {\n        const firstSlashIndex = remoteBranchName.indexOf('/');\n        if (firstSlashIndex === -1) {\n            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +\n                'Expected branch to be in the <remote>/<branch name> format.');\n        }\n        const remoteName = remoteBranchName.substr(0, firstSlashIndex);\n        const branchName = remoteBranchName.substr(firstSlashIndex + 1);\n        const gitPath = this.getGitPathOrThrow();\n        const spawnResult = Executable.spawnSync(gitPath, ['fetch', '--', remoteName, branchName], {\n            stdio: 'ignore'\n        });\n        return spawnResult.status === 0;\n    }\n    _fetchRemoteBranch(remoteBranchName, terminal) {\n        // eslint-disable-next-line no-console\n        console.log(`Checking for updates to ${remoteBranchName}...`);\n        const fetchResult = this._tryFetchRemoteBranch(remoteBranchName);\n        if (!fetchResult) {\n            terminal.writeWarningLine(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`);\n        }\n    }\n    /**\n     * @internal\n     */\n    _executeGitCommandAndCaptureOutput(gitPath, args, repositoryRoot = this._rushConfiguration.rushJsonFolder) {\n        try {\n            return Utilities.executeCommandAndCaptureOutput(gitPath, args, repositoryRoot);\n        }\n        catch (e) {\n            ensureGitMinimumVersion(gitPath);\n            throw e;\n        }\n    }\n}\n//# sourceMappingURL=Git.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nfunction _parseGitStatusChangeType(str) {\n    switch (str) {\n        case 'M': {\n            return 'modified';\n        }\n        case 'T': {\n            return 'type-changed';\n        }\n        case 'A': {\n            return 'added';\n        }\n        case 'D': {\n            return 'deleted';\n        }\n        case 'R': {\n            return 'renamed';\n        }\n        case 'C': {\n            return 'copied';\n        }\n        case '.': {\n            return undefined;\n        }\n        default: {\n            throw new Error(`Unexpected git status change type: ${str}`);\n        }\n    }\n}\nfunction _parseIsInSubmodule(submoduleState) {\n    // This field is actually four characters long, but this parser only handles if the entry is in a\n    // submodule or not. That is represented by a \"N\" or an \"S\" in the first character.\n    const submoduleMode = submoduleState.charAt(0);\n    if (submoduleMode === 'N') {\n        return false;\n    }\n    else if (submoduleMode === 'S') {\n        return true;\n    }\n    else {\n        throw new Error(`Unexpected submodule state: ${submoduleState}`);\n    }\n}\nexport function* parseGitStatus(gitStatusOutput) {\n    // See reference https://git-scm.com/docs/git-status?msclkid=1cff552bcdce11ecadf77a086eded66c#_porcelain_format_version_2\n    let pos = 0;\n    function getFieldAndAdvancePos(delimiter) {\n        const newPos = gitStatusOutput.indexOf(delimiter, pos);\n        if (newPos === -1) {\n            throw new Error(`Unexpected end of git status output after position ${pos}`);\n        }\n        const field = gitStatusOutput.substring(pos, newPos);\n        pos = newPos + delimiter.length;\n        return field;\n    }\n    /**\n     * @example\n     * ```\n     * ? path/g.ts\n     * ```\n     */\n    function parseUntrackedEntry() {\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'untracked',\n            path\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 a171a25d2c978ba071959f39dbeaa339fe84f768 path/a.ts\\0\n     * 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n     * 1 .D N... 100644 100644 000000 3fcb58810c113c90c366dd81d16443425c7b95fa 3fcb58810c113c90c366dd81d16443425c7b95fa path/c.ts\\0\n     * 1 D. N... 100644 000000 000000 91b0203b85a7bb605e35f842d1d05d66a6275e10 0000000000000000000000000000000000000000 path/d.ts\\0\n     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 451de43c5cb012af55a79cc3463849ab3cfa0457 path/f.ts\\0\n     * 1 AM N... 000000 100644 100644 0000000000000000000000000000000000000000 9d9ab4adc79c591c0aa72f7fd29a008c80893e3e path/h.ts\\0\n     * ```\n     */\n    function parseAddModifyOrDeleteEntry() {\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //           ^\n        const headFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                  ^\n        const indexFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                         ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                ^\n        const headObjectName = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                                                         ^\n        const indexObjectName = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                                                                                                  ^\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'changed',\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            headFileMode,\n            indexFileMode,\n            worktreeFileMode,\n            headObjectName,\n            indexObjectName,\n            path\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n     * ```\n     */\n    function parseRenamedOrCopiedEntry() {\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //           ^\n        const headFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                  ^\n        const indexFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                         ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                ^\n        const headObjectName = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                         ^\n        const indexObjectName = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                  ^\n        const renameOrCopyScoreField = getFieldAndAdvancePos(' ');\n        const renameOrCopyMode = renameOrCopyScoreField.charAt(0);\n        const rawRenameOrCopyScore = renameOrCopyScoreField.substring(1);\n        const renameOrCopyScore = parseInt(rawRenameOrCopyScore, 10);\n        let kind;\n        if (renameOrCopyMode === 'R') {\n            kind = 'renamed';\n        }\n        else if (renameOrCopyMode === 'C') {\n            kind = 'copied';\n        }\n        else {\n            throw new Error(`Unexpected rename or copy mode: ${renameOrCopyMode}`);\n        }\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                       ^\n        const path = getFieldAndAdvancePos('\\0');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                                  ^\n        const originalPath = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind,\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            headFileMode,\n            indexFileMode,\n            worktreeFileMode,\n            headObjectName,\n            indexObjectName,\n            renameOrCopyScore,\n            path,\n            originalPath\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n     * ```\n     */\n    function parseUnmergedEntry() {\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //           ^\n        const stage1FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                  ^\n        const stage2FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                         ^\n        const stage3FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                       ^\n        const stage1ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                ^\n        const stage2ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                                                         ^\n        const stage3ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                                                                                                  ^\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'unmerged',\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            stage1FileMode,\n            stage2FileMode,\n            stage3FileMode,\n            worktreeFileMode,\n            stage1ObjectName,\n            stage2ObjectName,\n            stage3ObjectName,\n            path\n        };\n        return entry;\n    }\n    while (pos < gitStatusOutput.length) {\n        const modeField = getFieldAndAdvancePos(' ');\n        switch (modeField) {\n            case '?': {\n                // Untracked\n                yield parseUntrackedEntry();\n                break;\n            }\n            case '1': {\n                // Simple change\n                yield parseAddModifyOrDeleteEntry();\n                break;\n            }\n            case '2': {\n                // Renamed or copied\n                yield parseRenamedOrCopiedEntry();\n                break;\n            }\n            case 'u': {\n                // Unmerged\n                yield parseUnmergedEntry();\n                break;\n            }\n            default: {\n                throw new Error(`Unexpected git status mode: ${modeField}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=GitStatusParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * JSON schema URLs that Rush writes into config files.\n */\nclass JsonSchemaUrls {\n}\nJsonSchemaUrls.approvedPackages = 'https://developer.microsoft.com/json-schemas/rush/v5/approved-packages.schema.json';\nJsonSchemaUrls.commonVersions = 'https://developer.microsoft.com/json-schemas/rush/v5/common-versions.schema.json';\nexport { JsonSchemaUrls };\n//# sourceMappingURL=JsonSchemaUrls.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This class is used to associate POSIX relative paths, such as those returned by `git` commands,\n * with entities that correspond with ancestor folders, such as Rush Projects.\n *\n * It is optimized for efficiently locating the nearest ancestor path with an associated value.\n *\n * @example\n * ```ts\n * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);\n * tree.findChildPath('foo'); // returns 1\n * tree.findChildPath('foo/baz'); // returns 1\n * tree.findChildPath('baz'); // returns undefined\n * tree.findChildPath('foo/bar/baz'); returns 3\n * tree.findChildPath('bar/foo/bar'); returns 2\n * ```\n * @beta\n */\nexport class LookupByPath {\n    /**\n     * Constructs a new `LookupByPath`\n     *\n     * @param entries - Initial path-value pairs to populate the tree.\n     */\n    constructor(entries, delimiter) {\n        this._root = {\n            value: undefined,\n            children: undefined\n        };\n        this.delimiter = delimiter !== null && delimiter !== void 0 ? delimiter : '/';\n        if (entries) {\n            for (const [path, item] of entries) {\n                this.setItem(path, item);\n            }\n        }\n    }\n    /**\n     * Iterates over the segments of a serialized path.\n     *\n     * @example\n     *\n     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'\n     *\n     * `LookupByPath.iteratePathSegments('foo\\\\bar\\\\baz', '\\\\')` yields 'foo', 'bar', 'baz'\n     */\n    static *iteratePathSegments(serializedPath, delimiter = '/') {\n        for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {\n            yield prefixMatch.prefix;\n        }\n    }\n    static *_iteratePrefixes(input, delimiter = '/') {\n        if (!input) {\n            return;\n        }\n        let previousIndex = 0;\n        let nextIndex = input.indexOf(delimiter);\n        // Leading segments\n        while (nextIndex >= 0) {\n            yield {\n                prefix: input.slice(previousIndex, nextIndex),\n                index: nextIndex\n            };\n            previousIndex = nextIndex + 1;\n            nextIndex = input.indexOf(delimiter, previousIndex);\n        }\n        // Last segment\n        if (previousIndex < input.length) {\n            yield {\n                prefix: input.slice(previousIndex, input.length),\n                index: input.length\n            };\n        }\n    }\n    /**\n     * Associates the value with the specified serialized path.\n     * If a value is already associated, will overwrite.\n     *\n     * @returns this, for chained calls\n     */\n    setItem(serializedPath, value) {\n        return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);\n    }\n    /**\n     * Associates the value with the specified path.\n     * If a value is already associated, will overwrite.\n     *\n     * @returns this, for chained calls\n     */\n    setItemFromSegments(pathSegments, value) {\n        let node = this._root;\n        for (const segment of pathSegments) {\n            if (!node.children) {\n                node.children = new Map();\n            }\n            let child = node.children.get(segment);\n            if (!child) {\n                node.children.set(segment, (child = {\n                    value: undefined,\n                    children: undefined\n                }));\n            }\n            node = child;\n        }\n        node.value = value;\n        return this;\n    }\n    /**\n     * Searches for the item associated with `childPath`, or the nearest ancestor of that path that\n     * has an associated item.\n     *\n     * @returns the found item, or `undefined` if no item was found\n     *\n     * @example\n     * ```ts\n     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n     * tree.findChildPath('foo/baz'); // returns 1\n     * tree.findChildPath('foo/bar/baz'); // returns 2\n     * ```\n     */\n    findChildPath(childPath) {\n        return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));\n    }\n    /**\n     * Searches for the item for which the recorded prefix is the longest matching prefix of `query`.\n     * Obtains both the item and the length of the matched prefix, so that the remainder of the path can be\n     * extracted.\n     *\n     * @returns the found item and the length of the matched prefix, or `undefined` if no item was found\n     *\n     * @example\n     * ```ts\n     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n     * tree.findLongestPrefixMatch('foo/baz'); // returns { item: 1, index: 3 }\n     * tree.findLongestPrefixMatch('foo/bar/baz'); // returns { item: 2, index: 7 }\n     * ```\n     */\n    findLongestPrefixMatch(query) {\n        return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, this.delimiter));\n    }\n    /**\n     * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that\n     * has an associated item.\n     *\n     * @returns the found item, or `undefined` if no item was found\n     *\n     * @example\n     * ```ts\n     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n     * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1\n     * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2\n     * ```\n     */\n    findChildPathFromSegments(childPathSegments) {\n        var _a;\n        let node = this._root;\n        let best = node.value;\n        // Trivial cases\n        if (node.children) {\n            for (const segment of childPathSegments) {\n                const child = node.children.get(segment);\n                if (!child) {\n                    break;\n                }\n                node = child;\n                best = (_a = node.value) !== null && _a !== void 0 ? _a : best;\n                if (!node.children) {\n                    break;\n                }\n            }\n        }\n        return best;\n    }\n    /**\n     * Iterates through progressively longer prefixes of a given string and returns as soon\n     * as the number of candidate items that match the prefix are 1 or 0.\n     *\n     * If a match is present, returns the matched itme and the length of the matched prefix.\n     *\n     * @returns the found item, or `undefined` if no item was found\n     */\n    _findLongestPrefixMatch(prefixes) {\n        let node = this._root;\n        let best = node.value\n            ? {\n                value: node.value,\n                index: 0\n            }\n            : undefined;\n        // Trivial cases\n        if (node.children) {\n            for (const { prefix: hash, index } of prefixes) {\n                const child = node.children.get(hash);\n                if (!child) {\n                    break;\n                }\n                node = child;\n                if (node.value !== undefined) {\n                    best = {\n                        value: node.value,\n                        index\n                    };\n                }\n                if (!node.children) {\n                    break;\n                }\n            }\n        }\n        return best;\n    }\n}\n//# sourceMappingURL=LookupByPath.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as semver from 'semver';\n/**\n * This constant is the major version of the next LTS node Node.js release. This constant should be updated when\n * a new LTS version is added to Rush's support matrix.\n *\n * LTS schedule: https://nodejs.org/en/about/releases/\n * LTS versions: https://nodejs.org/en/download/releases/\n */\nconst UPCOMING_NODE_LTS_VERSION = 20;\nconst nodeVersion = process.versions.node;\nconst nodeMajorVersion = semver.major(nodeVersion);\n/**\n * This class provides useful functions for warning if the current Node.js runtime isn't supported.\n *\n * @internal\n */\nexport class NodeJsCompatibility {\n    /**\n     * This reports if the Node.js version is known to have serious incompatibilities.  In that situation, the user\n     * should downgrade Rush to an older release that supported their Node.js version.\n     */\n    static reportAncientIncompatibleVersion() {\n        // IMPORTANT: If this test fails, the Rush CLI front-end process will terminate with an error.\n        // Only increment it when our code base is known to use newer features (e.g. \"async\"/\"await\") that\n        // have no hope of working with older Node.js.\n        if (semver.satisfies(nodeVersion, '< 8.9.0')) {\n            // eslint-disable-next-line no-console\n            console.error(colors.red(`Your version of Node.js (${nodeVersion}) is very old and incompatible with Rush. ` +\n                `Please upgrade to the latest Long-Term Support (LTS) version.\\n`));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Detect whether the Node.js version is \"supported\" by the Rush maintainers.  We generally\n     * only support versions that were \"Long Term Support\" (LTS) at the time when Rush was published.\n     *\n     * This is a warning only -- the user is free to ignore it and use Rush anyway.\n     */\n    static warnAboutCompatibilityIssues(options) {\n        // Only show the first warning\n        return (NodeJsCompatibility.reportAncientIncompatibleVersion() ||\n            NodeJsCompatibility.warnAboutVersionTooNew(options) ||\n            NodeJsCompatibility._warnAboutOddNumberedVersion() ||\n            NodeJsCompatibility._warnAboutNonLtsVersion(options.rushConfiguration));\n    }\n    /**\n     * Warn about a Node.js version that has not been tested yet with Rush.\n     */\n    static warnAboutVersionTooNew(options) {\n        if (nodeMajorVersion >= UPCOMING_NODE_LTS_VERSION + 1) {\n            if (!options.alreadyReportedNodeTooNewError) {\n                // We are on a much newer release than we have tested and support\n                if (options.isRushLib) {\n                    // eslint-disable-next-line no-console\n                    console.warn(colors.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +\n                        `of the Rush engine. Please consider upgrading the \"rushVersion\" setting in rush.json, ` +\n                        `or downgrading Node.js.\\n`));\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.warn(colors.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +\n                        `of Rush. Please consider installing a newer version of the \"@microsoft/rush\" ` +\n                        `package, or downgrading Node.js.\\n`));\n                }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static _warnAboutNonLtsVersion(rushConfiguration) {\n        if (rushConfiguration && !rushConfiguration.suppressNodeLtsWarning && !NodeJsCompatibility.isLtsVersion) {\n            // eslint-disable-next-line no-console\n            console.warn(colors.yellow(`Your version of Node.js (${nodeVersion}) is not a Long-Term Support (LTS) release. ` +\n                'These versions frequently have bugs. Please consider installing a stable release.\\n'));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static _warnAboutOddNumberedVersion() {\n        if (NodeJsCompatibility.isOddNumberedVersion) {\n            // eslint-disable-next-line no-console\n            console.warn(colors.yellow(`Your version of Node.js (${nodeVersion}) is an odd-numbered release. ` +\n                `These releases frequently have bugs. Please consider installing a Long Term Support (LTS) ` +\n                `version instead.\\n`));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static get isLtsVersion() {\n        return !!process.release.lts;\n    }\n    static get isOddNumberedVersion() {\n        return nodeMajorVersion % 2 !== 0;\n    }\n}\n//# sourceMappingURL=NodeJsCompatibility.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class PrereleaseToken {\n    constructor(prereleaseName, suffixName, partialPrerelease = false) {\n        if (prereleaseName && suffixName) {\n            throw new Error('Pre-release name and suffix cannot be provided at the same time.');\n        }\n        this.name = prereleaseName || suffixName;\n        this._prereleaseName = prereleaseName;\n        this._suffixName = suffixName;\n        this._partialPrerelease = partialPrerelease;\n    }\n    get hasValue() {\n        return !!this._prereleaseName || !!this._suffixName;\n    }\n    get isPrerelease() {\n        return !!this._prereleaseName;\n    }\n    get isSuffix() {\n        return !!this._suffixName;\n    }\n    get isPartialPrerelease() {\n        return this.isPrerelease && this._partialPrerelease;\n    }\n}\n//# sourceMappingURL=PrereleaseToken.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport ignore from 'ignore';\nimport { getRepoChanges, getRepoRoot, getRepoStateAsync } from '@rushstack/package-deps-hash';\nimport { Path, FileSystem, Async } from '@rushstack/node-core-library';\nimport { RushProjectConfiguration } from '../api/RushProjectConfiguration';\nimport { Git } from './Git';\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\nimport { RushConstants } from './RushConstants';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport { UNINITIALIZED } from '../utilities/Utilities';\n/**\n * @beta\n */\nexport class ProjectChangeAnalyzer {\n    constructor(rushConfiguration) {\n        /**\n         * UNINITIALIZED === we haven't looked\n         * undefined === data isn't available (i.e. - git isn't present)\n         */\n        this._data = UNINITIALIZED;\n        this._filteredData = new Map();\n        this._projectStateCache = new Map();\n        this._rushConfiguration = rushConfiguration;\n        this._git = new Git(this._rushConfiguration);\n    }\n    /**\n     * Try to get a list of the specified project's dependencies and their hashes.\n     *\n     * @remarks\n     * If the data can't be generated (i.e. - if Git is not present) this returns undefined.\n     *\n     * @internal\n     */\n    async _tryGetProjectDependenciesAsync(project, terminal) {\n        // Check the cache for any existing data\n        let filteredProjectData = this._filteredData.get(project);\n        if (filteredProjectData) {\n            return filteredProjectData;\n        }\n        const data = await this._ensureInitializedAsync(terminal);\n        if (!data) {\n            return undefined;\n        }\n        const { projectState, rootDir } = data;\n        if (projectState === undefined) {\n            return undefined;\n        }\n        const unfilteredProjectData = projectState.get(project);\n        if (!unfilteredProjectData) {\n            throw new Error(`Project \"${project.packageName}\" does not exist in the current Rush configuration.`);\n        }\n        filteredProjectData = await this._filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal);\n        this._filteredData.set(project, filteredProjectData);\n        return filteredProjectData;\n    }\n    /**\n     * @internal\n     */\n    async _ensureInitializedAsync(terminal) {\n        if (this._data === UNINITIALIZED) {\n            this._data = await this._getDataAsync(terminal);\n        }\n        return this._data;\n    }\n    /**\n     * The project state hash is calculated in the following way:\n     * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)\n     *   - If project dependencies cannot be collected (i.e. - if Git isn't available),\n     *     this function returns `undefined`\n     * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted\n     * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its\n     *   Git SHA is fed into the hash\n     * - A hex digest of the hash is returned\n     *\n     * @internal\n     */\n    async _tryGetProjectStateHashAsync(project, terminal) {\n        let projectState = this._projectStateCache.get(project);\n        if (!projectState) {\n            const packageDeps = await this._tryGetProjectDependenciesAsync(project, terminal);\n            if (!packageDeps) {\n                return undefined;\n            }\n            else {\n                const sortedPackageDepsFiles = Array.from(packageDeps.keys()).sort();\n                const hash = crypto.createHash('sha1');\n                for (const packageDepsFile of sortedPackageDepsFiles) {\n                    hash.update(packageDepsFile);\n                    hash.update(RushConstants.hashDelimiter);\n                    hash.update(packageDeps.get(packageDepsFile));\n                    hash.update(RushConstants.hashDelimiter);\n                }\n                projectState = hash.digest('hex');\n                this._projectStateCache.set(project, projectState);\n            }\n        }\n        return projectState;\n    }\n    async _filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal) {\n        const ignoreMatcher = await this._getIgnoreMatcherForProjectAsync(project, terminal);\n        if (!ignoreMatcher) {\n            return unfilteredProjectData;\n        }\n        const projectKey = path.relative(rootDir, project.projectFolder);\n        const projectKeyLength = projectKey.length + 1;\n        // At this point, `filePath` is guaranteed to start with `projectKey`, so\n        // we can safely slice off the first N characters to get the file path relative to the\n        // root of the project.\n        const filteredProjectData = new Map();\n        for (const [filePath, value] of unfilteredProjectData) {\n            const relativePath = filePath.slice(projectKeyLength);\n            if (!ignoreMatcher.ignores(relativePath)) {\n                // Add the file path to the filtered data if it is not ignored\n                filteredProjectData.set(filePath, value);\n            }\n        }\n        return filteredProjectData;\n    }\n    /**\n     * Gets a list of projects that have changed in the current state of the repo\n     * when compared to the specified branch, optionally taking the shrinkwrap and settings in\n     * the rush-project.json file into consideration.\n     */\n    async getChangedProjectsAsync(options) {\n        const { _rushConfiguration: rushConfiguration } = this;\n        const { targetBranchName, terminal, includeExternalDependencies, enableFiltering, shouldFetch } = options;\n        const gitPath = this._git.getGitPathOrThrow();\n        const repoRoot = getRepoRoot(rushConfiguration.rushJsonFolder);\n        const mergeCommit = this._git.getMergeBase(targetBranchName, terminal, shouldFetch);\n        const repoChanges = getRepoChanges(repoRoot, mergeCommit, gitPath);\n        const changedProjects = new Set();\n        if (includeExternalDependencies) {\n            // Even though changing the installed version of a nested dependency merits a change file,\n            // ignore lockfile changes for `rush change` for the moment\n            // Determine the current variant from the link JSON.\n            const variant = rushConfiguration.currentInstalledVariant;\n            const fullShrinkwrapPath = rushConfiguration.getCommittedShrinkwrapFilename(variant);\n            const shrinkwrapFile = Path.convertToSlashes(path.relative(repoRoot, fullShrinkwrapPath));\n            const shrinkwrapStatus = repoChanges.get(shrinkwrapFile);\n            if (shrinkwrapStatus) {\n                if (shrinkwrapStatus.status !== 'M') {\n                    terminal.writeLine(`Lockfile was created or deleted. Assuming all projects are affected.`);\n                    return new Set(rushConfiguration.projects);\n                }\n                const { packageManager } = rushConfiguration;\n                if (packageManager === 'pnpm') {\n                    const currentShrinkwrap = PnpmShrinkwrapFile.loadFromFile(fullShrinkwrapPath);\n                    if (!currentShrinkwrap) {\n                        throw new Error(`Unable to obtain current shrinkwrap file.`);\n                    }\n                    const oldShrinkwrapText = this._git.getBlobContent({\n                        // <ref>:<path> syntax: https://git-scm.com/docs/gitrevisions\n                        blobSpec: `${mergeCommit}:${shrinkwrapFile}`,\n                        repositoryRoot: repoRoot\n                    });\n                    const oldShrinkWrap = PnpmShrinkwrapFile.loadFromString(oldShrinkwrapText);\n                    for (const project of rushConfiguration.projects) {\n                        if (currentShrinkwrap\n                            .getProjectShrinkwrap(project)\n                            .hasChanges(oldShrinkWrap.getProjectShrinkwrap(project))) {\n                            changedProjects.add(project);\n                        }\n                    }\n                }\n                else {\n                    terminal.writeLine(`Lockfile has changed and lockfile content comparison is only supported for pnpm. Assuming all projects are affected.`);\n                    return new Set(rushConfiguration.projects);\n                }\n            }\n        }\n        const changesByProject = new Map();\n        const lookup = rushConfiguration.getProjectLookupForRoot(repoRoot);\n        for (const [file, diffStatus] of repoChanges) {\n            const project = lookup.findChildPath(file);\n            if (project) {\n                if (changedProjects.has(project)) {\n                    // Lockfile changes cannot be ignored via rush-project.json\n                    continue;\n                }\n                if (enableFiltering) {\n                    let projectChanges = changesByProject.get(project);\n                    if (!projectChanges) {\n                        projectChanges = new Map();\n                        changesByProject.set(project, projectChanges);\n                    }\n                    projectChanges.set(file, diffStatus);\n                }\n                else {\n                    changedProjects.add(project);\n                }\n            }\n        }\n        if (enableFiltering) {\n            // Reading rush-project.json may be problematic if, e.g. rush install has not yet occurred and rigs are in use\n            await Async.forEachAsync(changesByProject, async ([project, projectChanges]) => {\n                const filteredChanges = await this._filterProjectDataAsync(project, projectChanges, repoRoot, terminal);\n                if (filteredChanges.size > 0) {\n                    changedProjects.add(project);\n                }\n            }, { concurrency: 10 });\n        }\n        return changedProjects;\n    }\n    async _getDataAsync(terminal) {\n        const repoState = await this._getRepoDepsAsync(terminal);\n        if (!repoState) {\n            // Mark as resolved, but no data\n            return {\n                projectState: undefined,\n                rootDir: this._rushConfiguration.rushJsonFolder,\n                rawHashes: new Map()\n            };\n        }\n        const lookup = this._rushConfiguration.getProjectLookupForRoot(repoState.rootDir);\n        const projectHashDeps = new Map();\n        for (const project of this._rushConfiguration.projects) {\n            projectHashDeps.set(project, new Map());\n        }\n        const { hashes: repoDeps, rootDir } = repoState;\n        // Currently, only pnpm handles project shrinkwraps\n        if (this._rushConfiguration.packageManager !== 'pnpm') {\n            // Determine the current variant from the link JSON.\n            const variant = this._rushConfiguration.currentInstalledVariant;\n            // Add the shrinkwrap file to every project's dependencies\n            const shrinkwrapFile = Path.convertToSlashes(path.relative(rootDir, this._rushConfiguration.getCommittedShrinkwrapFilename(variant)));\n            const shrinkwrapHash = repoDeps.get(shrinkwrapFile);\n            for (const projectDeps of projectHashDeps.values()) {\n                if (shrinkwrapHash) {\n                    projectDeps.set(shrinkwrapFile, shrinkwrapHash);\n                }\n            }\n        }\n        // Sort each project folder into its own package deps hash\n        for (const [filePath, fileHash] of repoDeps) {\n            // lookups in findChildPath are O(K)\n            // K being the maximum folder depth of any project in rush.json (usually on the order of 3)\n            const owningProject = lookup.findChildPath(filePath);\n            if (owningProject) {\n                const owningProjectHashDeps = projectHashDeps.get(owningProject);\n                owningProjectHashDeps.set(filePath, fileHash);\n            }\n        }\n        return {\n            projectState: projectHashDeps,\n            rootDir,\n            rawHashes: repoState.hashes\n        };\n    }\n    async _getIgnoreMatcherForProjectAsync(project, terminal) {\n        const incrementalBuildIgnoredGlobs = await RushProjectConfiguration.tryLoadIgnoreGlobsForProjectAsync(project, terminal);\n        if (incrementalBuildIgnoredGlobs && incrementalBuildIgnoredGlobs.length) {\n            const ignoreMatcher = ignore();\n            ignoreMatcher.add(incrementalBuildIgnoredGlobs);\n            return ignoreMatcher;\n        }\n    }\n    async _getRepoDepsAsync(terminal) {\n        try {\n            const gitPath = this._git.getGitPathOrThrow();\n            if (this._git.isPathUnderGitWorkingTree()) {\n                // Do not use getGitInfo().root; it is the root of the *primary* worktree, not the *current* one.\n                const rootDir = getRepoRoot(this._rushConfiguration.rushJsonFolder, gitPath);\n                // Load the package deps hash for the whole repository\n                // Include project shrinkwrap files as part of the computation\n                const additionalFilesToHash = [];\n                if (this._rushConfiguration.packageManager === 'pnpm') {\n                    const absoluteFilePathsToCheck = [];\n                    for (const project of this._rushConfiguration.projects) {\n                        const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);\n                        absoluteFilePathsToCheck.push(projectShrinkwrapFilePath);\n                        const relativeProjectShrinkwrapFilePath = Path.convertToSlashes(path.relative(rootDir, projectShrinkwrapFilePath));\n                        additionalFilesToHash.push(relativeProjectShrinkwrapFilePath);\n                    }\n                    await Async.forEachAsync(absoluteFilePathsToCheck, async (filePath) => {\n                        if (!(await FileSystem.existsAsync(filePath))) {\n                            throw new Error(`A project dependency file (${filePath}) is missing. You may need to run ` +\n                                '\"rush install\" or \"rush update\".');\n                        }\n                    });\n                }\n                const hashes = await getRepoStateAsync(rootDir, additionalFilesToHash, gitPath);\n                return {\n                    gitPath,\n                    hashes,\n                    rootDir\n                };\n            }\n            else {\n                return undefined;\n            }\n        }\n        catch (e) {\n            // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\n            // the state of the files in the repo. This can happen if the environment doesn't have Git.\n            terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`);\n            return undefined;\n        }\n    }\n}\n//# sourceMappingURL=ProjectChangeAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Parses the \"scripts\" section from package.json and provides support for executing scripts.\n */\nexport class ProjectCommandSet {\n    constructor(packageJson) {\n        this.malformedScriptNames = [];\n        this.commandNames = [];\n        this._scriptsByName = new Map();\n        const scripts = packageJson.scripts || {};\n        for (const scriptName of Object.keys(scripts)) {\n            if (scriptName[0] === '-' || scriptName.length === 0) {\n                this.malformedScriptNames.push(scriptName);\n            }\n            else {\n                this.commandNames.push(scriptName);\n                this._scriptsByName.set(scriptName, scripts[scriptName]);\n            }\n        }\n        this.commandNames.sort();\n    }\n    tryGetScriptBody(commandName) {\n        return this._scriptsByName.get(commandName);\n    }\n    getScriptBody(commandName) {\n        const result = this.tryGetScriptBody(commandName);\n        if (result === undefined) {\n            throw new Error(`The command \"${commandName}\" was not found`);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=ProjectCommandSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PublishUtilities } from './PublishUtilities';\nimport { Utilities } from '../utilities/Utilities';\nconst DUMMY_BRANCH_NAME = '-branch-name-';\nexport class PublishGit {\n    constructor(git, targetBranch) {\n        this._targetBranch = targetBranch;\n        this._gitPath = git.getGitPathOrThrow();\n        this._gitTagSeparator = git.getTagSeparator();\n    }\n    checkout(branchName, createBranch = false) {\n        const params = ['checkout'];\n        if (createBranch) {\n            params.push('-b');\n        }\n        params.push(branchName || DUMMY_BRANCH_NAME);\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);\n    }\n    merge(branchName, verify = false) {\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [\n            'merge',\n            branchName,\n            '--no-edit',\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n    deleteBranch(branchName, hasRemote = true, verify = false) {\n        if (!branchName) {\n            branchName = DUMMY_BRANCH_NAME;\n        }\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['branch', '-d', branchName]);\n        if (hasRemote) {\n            PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [\n                'push',\n                'origin',\n                '--delete',\n                branchName,\n                ...(verify ? [] : ['--no-verify'])\n            ]);\n        }\n    }\n    pull(verify = false) {\n        const params = ['pull', 'origin'];\n        if (this._targetBranch) {\n            params.push(this._targetBranch);\n        }\n        if (!verify) {\n            params.push('--no-verify');\n        }\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);\n    }\n    fetch() {\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['fetch', 'origin']);\n    }\n    addChanges(pathspec, workingDirectory) {\n        const files = pathspec ? pathspec : '.';\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['add', files], workingDirectory ? workingDirectory : process.cwd());\n    }\n    addTag(shouldExecute, packageName, packageVersion, commitId, preReleaseName) {\n        // Tagging only happens if we're publishing to real NPM and committing to git.\n        const tagName = PublishUtilities.createTagname(packageName, packageVersion, this._gitTagSeparator);\n        PublishUtilities.execCommand(!!this._targetBranch && shouldExecute, this._gitPath, [\n            'tag',\n            '-a',\n            preReleaseName ? `${tagName}-${preReleaseName}` : tagName,\n            '-m',\n            preReleaseName\n                ? `${packageName} v${packageVersion}-${preReleaseName}`\n                : `${packageName} v${packageVersion}`,\n            ...(commitId ? [commitId] : [])\n        ]);\n    }\n    hasTag(packageConfig) {\n        const tagName = PublishUtilities.createTagname(packageConfig.packageName, packageConfig.packageJson.version, this._gitTagSeparator);\n        const tagOutput = Utilities.executeCommandAndCaptureOutput(this._gitPath, ['tag', '-l', tagName], packageConfig.projectFolder, PublishUtilities.getEnvArgs(), true).replace(/(\\r\\n|\\n|\\r)/gm, '');\n        return tagOutput === tagName;\n    }\n    commit(commitMessage, verify = false) {\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [\n            'commit',\n            '-m',\n            commitMessage,\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n    push(branchName, verify = false) {\n        PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, \n        // We append \"--no-verify\" to prevent Git hooks from running.  For example, people may\n        // want to invoke \"rush change -v\" as a pre-push hook.\n        [\n            'push',\n            'origin',\n            `HEAD:${branchName || DUMMY_BRANCH_NAME}`,\n            '--follow-tags',\n            '--verbose',\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n}\n//# sourceMappingURL=PublishGit.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This file contains a set of helper functions that are unit tested and used with the PublishAction,\n * which itself is a thin wrapper around these helpers.\n */\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { execSync } from 'child_process';\nimport { JsonFile, FileConstants, Text, Enum, InternalError } from '@rushstack/node-core-library';\nimport { ChangeType } from '../api/ChangeManagement';\nimport { Utilities } from '../utilities/Utilities';\nimport { DependencySpecifier, DependencySpecifierType } from './DependencySpecifier';\nimport { Git, DEFAULT_GIT_TAG_SEPARATOR } from './Git';\nexport class PublishUtilities {\n    /**\n     * Finds change requests in the given folder.\n     * @param changesPath Path to the changes folder.\n     * @returns Dictionary of all change requests, keyed by package name.\n     */\n    static async findChangeRequestsAsync(allPackages, rushConfiguration, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {\n        const allChanges = {\n            packageChanges: new Map(),\n            versionPolicyChanges: new Map()\n        };\n        // eslint-disable-next-line no-console\n        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);\n        const files = await changeFiles.getFilesAsync();\n        // Add the minimum changes defined by the change descriptions.\n        for (const changeFilePath of files) {\n            const changeRequest = JsonFile.load(changeFilePath);\n            if (includeCommitDetails) {\n                const git = new Git(rushConfiguration);\n                PublishUtilities._updateCommitDetails(git, changeFilePath, changeRequest.changes);\n            }\n            for (const change of changeRequest.changes) {\n                PublishUtilities._addChange({\n                    change,\n                    changeFilePath,\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n            }\n        }\n        // keep resolving downstream dependency changes and version policy changes\n        // until no more changes are detected\n        let hasChanges;\n        do {\n            hasChanges = false;\n            // For each requested package change, ensure downstream dependencies are also updated.\n            allChanges.packageChanges.forEach((change, packageName) => {\n                hasChanges =\n                    PublishUtilities._updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n            });\n            // Bump projects affected by the version policy changes.\n            allPackages.forEach((project) => {\n                const versionPolicyChange = project.versionPolicyName !== undefined\n                    ? allChanges.versionPolicyChanges.get(project.versionPolicyName)\n                    : undefined;\n                if (versionPolicyChange === undefined) {\n                    return;\n                }\n                const projectHasChanged = this._addChange({\n                    change: {\n                        packageName: project.packageName,\n                        changeType: versionPolicyChange.changeType,\n                        newVersion: versionPolicyChange.newVersion // enforce the specific policy version\n                    },\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n                if (projectHasChanged) {\n                    // eslint-disable-next-line no-console\n                    console.log(`\\n* APPLYING: update ${project.packageName} to version ${versionPolicyChange.newVersion}`);\n                }\n                hasChanges = projectHasChanged || hasChanges;\n            });\n        } while (hasChanges);\n        // Update orders so that downstreams are marked to come after upstreams.\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const project = allPackages.get(packageName);\n            const packageJson = project.packageJson;\n            const deps = project.consumingProjects;\n            // Write the new version expected for the change.\n            const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);\n            if (skipVersionBump) {\n                change.newVersion = packageJson.version;\n            }\n            else {\n                // For hotfix changes, do not re-write new version\n                change.newVersion =\n                    change.changeType >= ChangeType.patch\n                        ? semver.inc(packageJson.version, PublishUtilities._getReleaseType(change.changeType))\n                        : change.changeType === ChangeType.hotfix\n                            ? change.newVersion\n                            : packageJson.version;\n            }\n            if (deps) {\n                for (const dep of deps) {\n                    const depChange = allChanges.packageChanges.get(dep.packageName);\n                    if (depChange) {\n                        depChange.order = Math.max(change.order + 1, depChange.order);\n                    }\n                }\n            }\n        });\n        return allChanges;\n    }\n    /**\n     * Given the changes hash, flattens them into a sorted array based on their dependency order.\n     * @params packageChanges - hash of change requests.\n     * @returns Sorted array of change requests.\n     */\n    static sortChangeRequests(packageChanges) {\n        return [...packageChanges.values()].sort((a, b) => a.order === b.order ? a.packageName.localeCompare(b.packageName) : a.order < b.order ? -1 : 1);\n    }\n    /**\n     * Given a single change request, updates the package json file with updated versions on disk.\n     */\n    static updatePackages(allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {\n        const updatedPackages = new Map();\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const updatedPackage = PublishUtilities._writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude);\n            updatedPackages.set(updatedPackage.name, updatedPackage);\n        });\n        return updatedPackages;\n    }\n    /**\n     * Returns the generated tagname to use for a published commit, given package name and version.\n     */\n    static createTagname(packageName, version, separator = DEFAULT_GIT_TAG_SEPARATOR) {\n        return packageName + `${separator}v` + version;\n    }\n    static isRangeDependency(version) {\n        const LOOSE_PKG_REGEX = />=?(?:\\d+\\.){2}\\d+(\\-[0-9A-Za-z-.]*)?\\s+<(?:\\d+\\.){2}\\d+/;\n        return LOOSE_PKG_REGEX.test(version);\n    }\n    static getEnvArgs() {\n        const env = {};\n        // Copy existing process.env values (for nodist)\n        Object.keys(process.env).forEach((key) => {\n            env[key] = process.env[key];\n        });\n        return env;\n    }\n    /**\n     * @param secretSubstring -- if specified, a substring to be replaced by `<<SECRET>>` to avoid printing secrets\n     * on the console\n     */\n    static execCommand(shouldExecute, command, args = [], workingDirectory = process.cwd(), environment, secretSubstring) {\n        let relativeDirectory = path.relative(process.cwd(), workingDirectory);\n        if (relativeDirectory) {\n            relativeDirectory = `(${relativeDirectory})`;\n        }\n        let commandArgs = args.join(' ');\n        if (secretSubstring && secretSubstring.length > 0) {\n            // Avoid printing the NPM publish token on the console when displaying the commandArgs\n            commandArgs = Text.replaceAll(commandArgs, secretSubstring, '<<SECRET>>');\n        }\n        // eslint-disable-next-line no-console\n        console.log(`\\n* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${commandArgs} ${relativeDirectory}`);\n        if (shouldExecute) {\n            Utilities.executeCommand({\n                command,\n                args,\n                workingDirectory,\n                environment,\n                suppressOutput: false,\n                keepEnvironment: true\n            });\n        }\n    }\n    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {\n        const currentDependencySpecifier = new DependencySpecifier(dependencyName, dependencies[dependencyName]);\n        const currentDependencyVersion = currentDependencySpecifier.versionSpecifier;\n        let newDependencyVersion;\n        if (currentDependencyVersion === '*') {\n            newDependencyVersion = '*';\n        }\n        else if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {\n            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);\n        }\n        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {\n            newDependencyVersion = '~' + newProjectVersion;\n        }\n        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {\n            newDependencyVersion = '^' + newProjectVersion;\n        }\n        else {\n            newDependencyVersion = newProjectVersion;\n        }\n        return currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace\n            ? `workspace:${newDependencyVersion}`\n            : newDependencyVersion;\n    }\n    static _getReleaseType(changeType) {\n        switch (changeType) {\n            case ChangeType.major:\n                return 'major';\n            case ChangeType.minor:\n                return 'minor';\n            case ChangeType.patch:\n                return 'patch';\n            case ChangeType.hotfix:\n                return 'prerelease';\n            default:\n                throw new Error(`Wrong change type ${changeType}`);\n        }\n    }\n    static _getChangeTypeForSemverReleaseType(releaseType) {\n        switch (releaseType) {\n            case 'major':\n                return ChangeType.major;\n            case 'minor':\n                return ChangeType.minor;\n            case 'patch':\n                return ChangeType.patch;\n            case 'premajor':\n            case 'prepatch':\n            case 'prerelease':\n                return ChangeType.hotfix;\n            default:\n                throw new Error(`Unsupported release type \"${releaseType}\"`);\n        }\n    }\n    static _getNewRangeDependency(newVersion) {\n        let upperLimit = newVersion;\n        if (semver.prerelease(newVersion)) {\n            // Remove the prerelease first, then bump major.\n            upperLimit = semver.inc(newVersion, 'patch');\n        }\n        upperLimit = semver.inc(upperLimit, 'major');\n        return `>=${newVersion} <${upperLimit}`;\n    }\n    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {\n        // Suffix does not bump up the version.\n        // Excluded projects do not bump up version.\n        return ((prereleaseToken && prereleaseToken.isSuffix) ||\n            (projectsToExclude && projectsToExclude.has(project.packageName)) ||\n            !project.shouldPublish);\n    }\n    static _updateCommitDetails(git, filename, changes) {\n        try {\n            const gitPath = git.getGitPathOrThrow();\n            const fileLog = execSync(`${gitPath} log -n 1 ${filename}`, {\n                cwd: path.dirname(filename)\n            }).toString();\n            const author = fileLog.match(/Author: (.*)/)[1];\n            const commit = fileLog.match(/commit (.*)/)[1];\n            changes.forEach((change) => {\n                change.author = author;\n                change.commit = commit;\n            });\n        }\n        catch (e) {\n            /* no-op, best effort. */\n        }\n    }\n    static _writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {\n        const project = allPackages.get(change.packageName);\n        const packageJson = project.packageJson;\n        const shouldSkipVersionBump = !project.shouldPublish || (!!projectsToExclude && projectsToExclude.has(change.packageName));\n        const newVersion = shouldSkipVersionBump\n            ? packageJson.version\n            : PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);\n        if (!shouldSkipVersionBump) {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${ChangeType[change.changeType]} update ` +\n                `for ${change.packageName} to ${newVersion}`);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update for ${change.packageName} at ${newVersion}`);\n        }\n        const packagePath = path.join(project.projectFolder, FileConstants.PackageJson);\n        packageJson.version = newVersion;\n        // Update the package's dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        // Update the package's dev dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.devDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        // Update the package's peer dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.peerDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        change.changes.forEach((subChange) => {\n            if (subChange.comment) {\n                // eslint-disable-next-line no-console\n                console.log(` - [${ChangeType[subChange.changeType]}] ${subChange.comment}`);\n            }\n        });\n        if (shouldCommit) {\n            JsonFile.save(packageJson, packagePath, { updateExistingFile: true });\n        }\n        return packageJson;\n    }\n    static _isCyclicDependency(allPackages, packageName, dependencyName) {\n        const packageConfig = allPackages.get(packageName);\n        return !!packageConfig && packageConfig.decoupledLocalDependencies.has(dependencyName);\n    }\n    static _updateDependencies(packageName, dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        if (dependencies) {\n            Object.keys(dependencies).forEach((depName) => {\n                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {\n                    const depChange = allChanges.packageChanges.get(depName);\n                    if (!depChange) {\n                        return;\n                    }\n                    const depProject = allPackages.get(depName);\n                    if (!depProject.shouldPublish || (projectsToExclude && projectsToExclude.has(depName))) {\n                        // No version change.\n                        return;\n                    }\n                    else if (prereleaseToken &&\n                        prereleaseToken.hasValue &&\n                        prereleaseToken.isPartialPrerelease &&\n                        depChange.changeType < ChangeType.hotfix) {\n                        // For partial prereleases, do not version bump dependencies with the `prereleaseToken`\n                        // value unless an actual change (hotfix, patch, minor, major) has occurred\n                        return;\n                    }\n                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {\n                        // TODO: treat prerelease version the same as non-prerelease version.\n                        // For prerelease, the newVersion needs to be appended with prerelease name.\n                        // And dependency should specify the specific prerelease version.\n                        const currentSpecifier = new DependencySpecifier(depName, dependencies[depName]);\n                        const newVersion = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);\n                        dependencies[depName] =\n                            currentSpecifier.specifierType === DependencySpecifierType.Workspace\n                                ? `workspace:${newVersion}`\n                                : newVersion;\n                    }\n                    else if (depChange && depChange.changeType >= ChangeType.hotfix) {\n                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages, rushConfiguration);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Gets the new version from the ChangeInfo.\n     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,\n     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why\n     * this function should return a pre-released patch for that case. The exception to this is when we're\n     * running a partial pre-release build. In this case, only user-changed packages should update.\n     */\n    static _getChangeInfoNewVersion(change, prereleaseToken) {\n        let newVersion = change.newVersion;\n        if (prereleaseToken && prereleaseToken.hasValue) {\n            if (prereleaseToken.isPartialPrerelease && change.changeType <= ChangeType.hotfix) {\n                return newVersion;\n            }\n            if (prereleaseToken.isPrerelease && change.changeType === ChangeType.dependency) {\n                newVersion = semver.inc(newVersion, 'patch');\n            }\n            return `${newVersion}-${prereleaseToken.name}`;\n        }\n        else {\n            return newVersion;\n        }\n    }\n    /**\n     * Adds the given change to the packageChanges map.\n     *\n     * @returns true if the change caused the dependency change type to increase.\n     */\n    static _addChange({ change, changeFilePath, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude }) {\n        var _a, _b, _c;\n        let hasChanged = false;\n        const packageName = change.packageName;\n        const project = allPackages.get(packageName);\n        if (!project) {\n            // eslint-disable-next-line no-console\n            console.log(`The package ${packageName} was requested for publishing but does not exist. Skip this change.`);\n            return false;\n        }\n        const packageJson = project.packageJson;\n        // If the given change does not have a changeType, derive it from the \"type\" string.\n        if (change.changeType === undefined) {\n            change.changeType = Enum.tryGetValueByKey(ChangeType, change.type);\n            if (change.changeType === undefined) {\n                if (changeFilePath) {\n                    throw new Error(`Invalid change type ${JSON.stringify(change.type)} in ${changeFilePath}`);\n                }\n                else {\n                    throw new InternalError(`Invalid change type ${JSON.stringify(change.type)}`);\n                }\n            }\n        }\n        let currentChange = allChanges.packageChanges.get(packageName);\n        if (currentChange === undefined) {\n            hasChanged = true;\n            currentChange = {\n                packageName,\n                changeType: change.changeType,\n                order: 0,\n                changes: [change]\n            };\n            allChanges.packageChanges.set(packageName, currentChange);\n        }\n        else {\n            const oldChangeType = currentChange.changeType;\n            if (oldChangeType === ChangeType.hotfix && change.changeType > oldChangeType) {\n                throw new Error(`Cannot apply ${this._getReleaseType(change.changeType)} change after hotfix on same package`);\n            }\n            if (change.changeType === ChangeType.hotfix && oldChangeType > change.changeType) {\n                throw new Error(`Cannot apply hotfix alongside ${this._getReleaseType(oldChangeType)} change on same package`);\n            }\n            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);\n            currentChange.changes.push(change);\n            hasChanged = hasChanged || oldChangeType !== currentChange.changeType;\n            hasChanged =\n                hasChanged ||\n                    (change.newVersion !== undefined &&\n                        currentChange.newVersion !== undefined &&\n                        semver.gt(change.newVersion, currentChange.newVersion));\n        }\n        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);\n        if (skipVersionBump) {\n            currentChange.newVersion = (_a = change.newVersion) !== null && _a !== void 0 ? _a : packageJson.version;\n            hasChanged = false;\n            currentChange.changeType = ChangeType.none;\n        }\n        else {\n            if (change.changeType === ChangeType.hotfix) {\n                const prereleaseComponents = semver.prerelease(packageJson.version);\n                if (!rushConfiguration.hotfixChangeEnabled) {\n                    throw new Error(`Cannot add hotfix change; hotfixChangeEnabled is false in configuration.`);\n                }\n                currentChange.newVersion = (_b = change.newVersion) !== null && _b !== void 0 ? _b : packageJson.version;\n                if (!prereleaseComponents) {\n                    currentChange.newVersion += '-hotfix';\n                }\n                currentChange.newVersion = semver.inc(currentChange.newVersion, 'prerelease');\n            }\n            else {\n                // When there are multiple changes of this package, the final value of new version\n                // should not depend on the order of the changes.\n                let packageVersion = (_c = change.newVersion) !== null && _c !== void 0 ? _c : packageJson.version;\n                if (currentChange.newVersion && semver.gt(currentChange.newVersion, packageVersion)) {\n                    packageVersion = currentChange.newVersion;\n                }\n                const shouldBump = change.newVersion === undefined && change.changeType >= ChangeType.hotfix;\n                currentChange.newVersion = shouldBump\n                    ? semver.inc(packageVersion, PublishUtilities._getReleaseType(currentChange.changeType))\n                    : packageVersion;\n                // set versionpolicy version to the current version\n                if (hasChanged &&\n                    project.versionPolicyName !== undefined &&\n                    project.versionPolicy !== undefined &&\n                    project.versionPolicy.isLockstepped) {\n                    const projectVersionPolicy = project.versionPolicy;\n                    const currentVersionPolicyChange = allChanges.versionPolicyChanges.get(project.versionPolicyName);\n                    if (projectVersionPolicy.nextBump === undefined &&\n                        (currentVersionPolicyChange === undefined ||\n                            semver.gt(currentChange.newVersion, currentVersionPolicyChange.newVersion))) {\n                        allChanges.versionPolicyChanges.set(project.versionPolicyName, {\n                            versionPolicyName: project.versionPolicyName,\n                            changeType: currentChange.changeType,\n                            newVersion: currentChange.newVersion\n                        });\n                    }\n                }\n            }\n            // If hotfix change, force new range dependency to be the exact new version\n            currentChange.newRangeDependency =\n                change.changeType === ChangeType.hotfix\n                    ? currentChange.newVersion\n                    : PublishUtilities._getNewRangeDependency(currentChange.newVersion);\n        }\n        return hasChanged;\n    }\n    static _updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        let hasChanges = false;\n        const packageName = change.packageName;\n        const downstream = allPackages.get(packageName).consumingProjects;\n        // Iterate through all downstream dependencies for the package.\n        if (downstream) {\n            if (change.changeType >= ChangeType.hotfix || (prereleaseToken && prereleaseToken.hasValue)) {\n                for (const dependency of downstream) {\n                    const packageJson = dependency.packageJson;\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.devDependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                }\n            }\n        }\n        return hasChanges;\n    }\n    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        let hasChanges = false;\n        if (dependencies &&\n            dependencies[change.packageName] &&\n            !PublishUtilities._isCyclicDependency(allPackages, parentPackageName, change.packageName)) {\n            const requiredVersion = new DependencySpecifier(change.packageName, dependencies[change.packageName]);\n            const isWorkspaceWildcardVersion = requiredVersion.specifierType === DependencySpecifierType.Workspace &&\n                requiredVersion.versionSpecifier === '*';\n            const isPrerelease = !!prereleaseToken && prereleaseToken.hasValue && !allChanges.packageChanges.has(parentPackageName);\n            // If the version range exists and has not yet been updated to this version, update it.\n            if (isPrerelease ||\n                isWorkspaceWildcardVersion ||\n                requiredVersion.versionSpecifier !== change.newRangeDependency) {\n                let changeType;\n                // Propagate hotfix changes to dependencies\n                if (change.changeType === ChangeType.hotfix) {\n                    changeType = ChangeType.hotfix;\n                }\n                else {\n                    // Either it already satisfies the new version, or doesn't.\n                    // If not, the downstream dep needs to be republished.\n                    // The downstream dep will also need to be republished if using `workspace:*` as this will publish\n                    // as the exact version.\n                    changeType =\n                        !isWorkspaceWildcardVersion &&\n                            semver.satisfies(change.newVersion, requiredVersion.versionSpecifier)\n                            ? ChangeType.dependency\n                            : ChangeType.patch;\n                }\n                hasChanges = PublishUtilities._addChange({\n                    change: {\n                        packageName: parentPackageName,\n                        changeType\n                    },\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n                if (hasChanges || isPrerelease) {\n                    // Only re-evaluate downstream dependencies if updating the parent package's dependency\n                    // caused a version bump.\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependencies(allChanges.packageChanges.get(parentPackageName), allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                }\n            }\n        }\n        return hasChanges;\n    }\n    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages, rushConfiguration) {\n        let currentDependencyVersion = dependencies[dependencyName];\n        let newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);\n        dependencies[dependencyName] = newDependencyVersion;\n        // \"*\" is a special case for workspace ranges, since it will publish using the exact\n        // version of the local dependency, so we need to modify what we write for our change\n        // comment\n        const currentDependencySpecifier = new DependencySpecifier(dependencyName, currentDependencyVersion);\n        currentDependencyVersion =\n            currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace &&\n                currentDependencySpecifier.versionSpecifier === '*'\n                ? undefined\n                : currentDependencySpecifier.versionSpecifier;\n        const newDependencySpecifier = new DependencySpecifier(dependencyName, newDependencyVersion);\n        newDependencyVersion =\n            newDependencySpecifier.specifierType === DependencySpecifierType.Workspace &&\n                newDependencySpecifier.versionSpecifier === '*'\n                ? dependencyChange.newVersion\n                : newDependencySpecifier.versionSpecifier;\n        // Add dependency version update comment.\n        PublishUtilities._addChange({\n            change: {\n                packageName: packageName,\n                changeType: ChangeType.dependency,\n                comment: `Updating dependency \"${dependencyName}\" ` +\n                    (currentDependencyVersion ? `from \\`${currentDependencyVersion}\\` ` : '') +\n                    `to \\`${newDependencyVersion}\\``\n            },\n            allChanges,\n            allPackages,\n            rushConfiguration\n        });\n    }\n}\n//# sourceMappingURL=PublishUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { AsyncRecycler } from '../utilities/AsyncRecycler';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * This class implements the logic for \"rush purge\"\n */\nexport class PurgeManager {\n    constructor(rushConfiguration, rushGlobalFolder) {\n        this._rushConfiguration = rushConfiguration;\n        this._rushGlobalFolder = rushGlobalFolder;\n        const commonAsyncRecyclerPath = path.join(this._rushConfiguration.commonTempFolder, RushConstants.rushRecyclerFolderName);\n        this.commonTempFolderRecycler = new AsyncRecycler(commonAsyncRecyclerPath);\n        const rushUserAsyncRecyclerPath = path.join(this._rushGlobalFolder.path, RushConstants.rushRecyclerFolderName);\n        this._rushUserFolderRecycler = new AsyncRecycler(rushUserAsyncRecyclerPath);\n    }\n    /**\n     * Performs the AsyncRecycler.deleteAll() operation.  This should be called before\n     * the PurgeManager instance is disposed.\n     */\n    deleteAll() {\n        this.commonTempFolderRecycler.deleteAll();\n        this._rushUserFolderRecycler.deleteAll();\n    }\n    /**\n     * Delete everything from the common/temp folder\n     */\n    purgeNormal() {\n        // Delete everything under common\\temp except for the recycler folder itself\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + this._rushConfiguration.commonTempFolder);\n        this.commonTempFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.commonTempFolder, this._getMembersToExclude(this._rushConfiguration.commonTempFolder, true));\n    }\n    /**\n     * In addition to performing the purgeNormal() operation, this method also cleans the\n     * .rush folder in the user's home directory.\n     */\n    purgeUnsafe() {\n        this.purgeNormal();\n        // We will delete everything under ~/.rush/ except for the recycler folder itself\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + this._rushGlobalFolder.path);\n        // If Rush itself is running under a folder such as  ~/.rush/node-v4.5.6/rush-1.2.3,\n        // we cannot delete that folder.\n        // First purge the node-specific folder, e.g. ~/.rush/node-v4.5.6/* except for rush-1.2.3:\n        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.nodeSpecificPath, this._getMembersToExclude(this._rushGlobalFolder.nodeSpecificPath, true));\n        // Then purge the the global folder, e.g. ~/.rush/* except for node-v4.5.6\n        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.path, this._getMembersToExclude(this._rushGlobalFolder.path, false));\n        if (this._rushConfiguration.packageManager === 'pnpm' &&\n            this._rushConfiguration.pnpmOptions.pnpmStore === 'global' &&\n            this._rushConfiguration.pnpmOptions.pnpmStorePath) {\n            // eslint-disable-next-line no-console\n            console.warn(colors.yellow(`Purging the global pnpm-store`));\n            this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.pnpmOptions.pnpmStorePath);\n        }\n    }\n    _getMembersToExclude(folderToRecycle, showWarning) {\n        // Don't recycle the recycler\n        const membersToExclude = [RushConstants.rushRecyclerFolderName];\n        // If the current process is running inside one of the folders, don't recycle that either\n        // Example: \"/home/user/.rush/rush-1.2.3/lib/example.js\"\n        const currentFolderPath = path.resolve(__dirname);\n        // Example:\n        // folderToRecycle = \"/home/user/.rush/node-v4.5.6\"\n        // relative =  \"rush-1.2.3/lib/example.js\"\n        const relative = path.relative(folderToRecycle, currentFolderPath);\n        // (The result can be an absolute path if the two folders are on different drive letters)\n        if (!path.isAbsolute(relative)) {\n            // Get the first path segment:\n            const firstPart = relative.split(/[\\\\\\/]/)[0];\n            if (firstPart.length > 0 && firstPart !== '..') {\n                membersToExclude.push(firstPart);\n                if (showWarning) {\n                    // Warn that we won't dispose this folder\n                    // eslint-disable-next-line no-console\n                    console.log(colors.yellow(\"The active process's folder will not be deleted: \" + path.join(folderToRecycle, firstPart)));\n                }\n            }\n        }\n        return membersToExclude;\n    }\n}\n//# sourceMappingURL=PurgeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema, NewlineKind } from '@rushstack/node-core-library';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport schemaJson from '../schemas/repo-state.schema.json';\n/**\n * This file is used to track the state of various Rush-related features. It is generated\n * and updated by Rush.\n *\n * @public\n */\nclass RepoStateFile {\n    constructor(repoStateJson, isValid, filePath, variant) {\n        this._modified = false;\n        this.filePath = filePath;\n        this._variant = variant;\n        this._isValid = isValid;\n        if (repoStateJson) {\n            this._pnpmShrinkwrapHash = repoStateJson.pnpmShrinkwrapHash;\n            this._preferredVersionsHash = repoStateJson.preferredVersionsHash;\n        }\n    }\n    /**\n     * The hash of the pnpm shrinkwrap file at the end of the last update.\n     */\n    get pnpmShrinkwrapHash() {\n        return this._pnpmShrinkwrapHash;\n    }\n    /**\n     * The hash of all preferred versions at the end of the last update.\n     */\n    get preferredVersionsHash() {\n        return this._preferredVersionsHash;\n    }\n    /**\n     * If false, the repo-state.json file is not valid and its values cannot be relied upon\n     */\n    get isValid() {\n        return this._isValid;\n    }\n    /**\n     * Loads the repo-state.json data from the specified file path.\n     * If the file has not been created yet, then an empty object is returned.\n     *\n     * @param jsonFilename - The path to the repo-state.json file.\n     * @param variant - The variant currently being used by Rush.\n     */\n    static loadFromFile(jsonFilename, variant) {\n        let fileContents;\n        try {\n            fileContents = FileSystem.readFile(jsonFilename);\n        }\n        catch (error) {\n            if (!FileSystem.isNotExistError(error)) {\n                throw error;\n            }\n        }\n        let foundMergeConflictMarker = false;\n        let repoStateJson = undefined;\n        if (fileContents) {\n            try {\n                repoStateJson = JsonFile.parseString(fileContents);\n            }\n            catch (error) {\n                // Look for a Git merge conflict marker. PNPM gracefully handles merge conflicts in pnpm-lock.yaml,\n                // so a user should be able to just run \"rush update\" if they get conflicts in pnpm-lock.yaml\n                // and repo-state.json and have Rush update both.\n                for (let nextNewlineIndex = 0; nextNewlineIndex > -1; nextNewlineIndex = fileContents.indexOf('\\n', nextNewlineIndex + 1)) {\n                    if (fileContents.substr(nextNewlineIndex + 1, 7) === '<<<<<<<') {\n                        foundMergeConflictMarker = true;\n                        repoStateJson = {\n                            preferredVersionsHash: 'INVALID',\n                            pnpmShrinkwrapHash: 'INVALID'\n                        };\n                        break;\n                    }\n                }\n            }\n            if (repoStateJson) {\n                this._jsonSchema.validateObject(repoStateJson, jsonFilename);\n            }\n        }\n        return new RepoStateFile(repoStateJson, !foundMergeConflictMarker, jsonFilename, variant);\n    }\n    /**\n     * Refresh the data contained in repo-state.json using the current state\n     * of the Rush repo, and save the file if changes were made.\n     *\n     * @param rushConfiguration - The Rush configuration for the repo.\n     *\n     * @returns true if the file was modified, otherwise false.\n     */\n    refreshState(rushConfiguration) {\n        // Only support saving the pnpm shrinkwrap hash if it was enabled\n        const preventShrinkwrapChanges = rushConfiguration.packageManager === 'pnpm' &&\n            rushConfiguration.pnpmOptions &&\n            rushConfiguration.pnpmOptions.preventManualShrinkwrapChanges;\n        if (preventShrinkwrapChanges) {\n            const pnpmShrinkwrapFile = PnpmShrinkwrapFile.loadFromFile(rushConfiguration.getCommittedShrinkwrapFilename(this._variant));\n            if (pnpmShrinkwrapFile) {\n                const shrinkwrapFileHash = pnpmShrinkwrapFile.getShrinkwrapHash(rushConfiguration.experimentsConfiguration.configuration);\n                if (this._pnpmShrinkwrapHash !== shrinkwrapFileHash) {\n                    this._pnpmShrinkwrapHash = shrinkwrapFileHash;\n                    this._modified = true;\n                }\n            }\n        }\n        else if (this._pnpmShrinkwrapHash !== undefined) {\n            this._pnpmShrinkwrapHash = undefined;\n            this._modified = true;\n        }\n        // Currently, only support saving the preferred versions hash if using workspaces\n        const useWorkspaces = rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.useWorkspaces;\n        if (useWorkspaces) {\n            const commonVersions = rushConfiguration.getCommonVersions(this._variant);\n            const preferredVersionsHash = commonVersions.getPreferredVersionsHash();\n            if (this._preferredVersionsHash !== preferredVersionsHash) {\n                this._preferredVersionsHash = preferredVersionsHash;\n                this._modified = true;\n            }\n        }\n        else if (this._preferredVersionsHash !== undefined) {\n            this._preferredVersionsHash = undefined;\n            this._modified = true;\n        }\n        // Now that the file has been refreshed, we know its contents are valid\n        this._isValid = true;\n        return this._saveIfModified();\n    }\n    /**\n     * Writes the \"repo-state.json\" file to disk, using the filename that was passed to loadFromFile().\n     */\n    _saveIfModified() {\n        if (this._modified) {\n            const content = '// DO NOT MODIFY THIS FILE MANUALLY BUT DO COMMIT IT. It is generated and used by Rush.' +\n                `${NewlineKind.Lf}${this._serialize()}`;\n            FileSystem.writeFile(this.filePath, content);\n            this._modified = false;\n            return true;\n        }\n        return false;\n    }\n    _serialize() {\n        // We need to set these one-by-one, since JsonFile.stringify does not like undefined values\n        const repoStateJson = {};\n        if (this._pnpmShrinkwrapHash) {\n            repoStateJson.pnpmShrinkwrapHash = this._pnpmShrinkwrapHash;\n        }\n        if (this._preferredVersionsHash) {\n            repoStateJson.preferredVersionsHash = this._preferredVersionsHash;\n        }\n        return JsonFile.stringify(repoStateJson, { newlineConversion: NewlineKind.Lf });\n    }\n}\nRepoStateFile._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { RepoStateFile };\n//# sourceMappingURL=RepoStateFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Constants used by the Rush tool.\n * @beta\n *\n * @remarks\n *\n * These are NOT part of the public API surface for rush-lib.\n * The rationale is that we don't want people implementing custom parsers for\n * the Rush config files; instead, they should rely on the official APIs from rush-lib.\n */\nclass RushConstants {\n}\n/**\n * The filename (\"browser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';\n/**\n * The folder name (\"changes\") where change files will be stored.\n */\nRushConstants.changeFilesFolderName = 'changes';\n/**\n * The filename (\"nonbrowser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';\n/**\n * The folder name (\"common\") where Rush's common data will be stored.\n */\nRushConstants.commonFolderName = 'common';\n/**\n * The NPM scope (\"\\@rush-temp\") that is used for Rush's temporary projects.\n */\nRushConstants.rushTempNpmScope = '@rush-temp';\n/**\n * The folder name (\"temp\") under the common folder, or under the .rush folder in each project's directory where\n * temporary files will be stored.\n * Example: `C:\\MyRepo\\common\\temp`\n */\nRushConstants.rushTempFolderName = 'temp';\n/**\n * The folder name (\"projects\") where temporary projects will be stored.\n * Example: `C:\\MyRepo\\common\\temp\\projects`\n */\nRushConstants.rushTempProjectsFolderName = 'projects';\n/**\n * The folder name (\"variants\") under which named variant configurations for\n * alternate dependency sets may be found.\n * Example: `C:\\MyRepo\\common\\config\\rush\\variants`\n */\nRushConstants.rushVariantsFolderName = 'variants';\n/**\n * The filename (\"npm-shrinkwrap.json\") used to store an installation plan for the NPM package manger.\n */\nRushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';\n/**\n * Number of installation attempts\n */\nRushConstants.defaultMaxInstallAttempts = 1;\n/**\n * The filename (\"pnpm-lock.yaml\") used to store an installation plan for the PNPM package manger\n * (PNPM version 3.x and later).\n */\nRushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';\n/**\n * The filename (\"pnpmfile.js\") used to add custom configuration to PNPM (PNPM version 1.x and later).\n */\nRushConstants.pnpmfileV1Filename = 'pnpmfile.js';\n/**\n * The filename (\".pnpmfile.cjs\") used to add custom configuration to PNPM (PNPM version 6.x and later).\n */\nRushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';\n/**\n * The folder name used to store patch files for pnpm\n * Example: `C:\\MyRepo\\common\\config\\pnpm-patches`\n * Example: `C:\\MyRepo\\common\\temp\\patches`\n */\nRushConstants.pnpmPatchesFolderName = 'patches';\n/**\n * The filename (\"shrinkwrap.yaml\") used to store state for pnpm\n */\nRushConstants.yarnShrinkwrapFilename = 'yarn.lock';\n/**\n * The folder name (\"node_modules\") where NPM installs its packages.\n */\nRushConstants.nodeModulesFolderName = 'node_modules';\n/**\n * The filename (\"pinned-versions.json\") for an old configuration file that\n * that is no longer supported.\n *\n * @deprecated This feature has been superseded by the \"preferredVersions\" setting\n * in common-versions.json\n */\n// NOTE: Although this is marked as \"deprecated\", we will probably never retire it,\n// since we always want to report the warning when someone upgrades an old repo.\nRushConstants.pinnedVersionsFilename = 'pinned-versions.json';\n/**\n * The filename (\"common-versions.json\") for an optional configuration file\n * that stores dependency version information that affects all projects in the repo.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.commonVersionsFilename = 'common-versions.json';\n/**\n * The filename (\"repo-state.json\") for a file used by Rush to\n * store the state of various features as they stand in the repo.\n */\nRushConstants.repoStateFilename = 'repo-state.json';\n/**\n * The filename (\"custom-tips.json\") for the file used by Rush to\n * print user-customized messages.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.customTipsFilename = 'custom-tips.json';\n/**\n * The name of the per-project folder where project-specific Rush files are stored. For example,\n * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.\n */\nRushConstants.projectRushFolderName = '.rush';\n/**\n * Custom command line configuration file, which is used by rush for implementing\n * custom command and options.\n */\nRushConstants.commandLineFilename = 'command-line.json';\nRushConstants.versionPoliciesFilename = 'version-policies.json';\n/**\n * Experiments configuration file.\n */\nRushConstants.experimentsFilename = 'experiments.json';\n/**\n * Pnpm configuration file\n */\nRushConstants.pnpmConfigFilename = 'pnpm-config.json';\n/**\n * Rush plugins configuration file name.\n */\nRushConstants.rushPluginsConfigFilename = 'rush-plugins.json';\n/**\n * Rush plugin manifest file name.\n */\nRushConstants.rushPluginManifestFilename = 'rush-plugin-manifest.json';\n/**\n * The artifactory.json configuration file name.\n */\nRushConstants.artifactoryFilename = 'artifactory.json';\n/**\n * Build cache configuration file.\n */\nRushConstants.buildCacheFilename = 'build-cache.json';\n/**\n * Build cache version number, incremented when the logic to create cache entries changes.\n * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.\n */\nRushConstants.buildCacheVersion = 1;\n/**\n * Cobuild configuration file.\n */\nRushConstants.cobuildFilename = 'cobuild.json';\n/**\n * Per-project configuration filename.\n */\nRushConstants.rushProjectConfigFilename = 'rush-project.json';\n/**\n * The URL (\"http://rushjs.io\") for the Rush web site.\n */\nRushConstants.rushWebSiteUrl = 'https://rushjs.io';\n/**\n * The name of the NPM package for the Rush tool (\"\\@microsoft/rush\").\n */\nRushConstants.rushPackageName = '@microsoft/rush';\n/**\n * The folder name (\"rush-recycler\") where Rush moves large folder trees\n * before asynchronously deleting them.\n */\nRushConstants.rushRecyclerFolderName = 'rush-recycler';\n/**\n * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct\n * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.\n */\nRushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';\n/**\n * The value of the \"commandKind\" property for a bulk command in command-line.json\n */\nRushConstants.bulkCommandKind = 'bulk';\n/**\n * The value of the \"commandKind\" property for a global command in command-line.json\n */\nRushConstants.globalCommandKind = 'global';\n/**\n * The value of the \"commandKind\" property for a phased command in command-line.json\n */\nRushConstants.phasedCommandKind = 'phased';\n/**\n * The name of the incremental build command.\n */\nRushConstants.buildCommandName = 'build';\n/**\n * The name of the non-incremental build command.\n */\nRushConstants.rebuildCommandName = 'rebuild';\nRushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';\n/**\n * When a hash generated that contains multiple input segments, this character may be used\n * to separate them to avoid issues like\n * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')\n */\nRushConstants.hashDelimiter = '|';\n/**\n * The name of the per-user Rush configuration data folder.\n */\nRushConstants.rushUserConfigurationFolderName = '.rush-user';\n/**\n * The name of the project `rush-logs` folder.\n */\nRushConstants.rushLogsFolderName = 'rush-logs';\n/**\n * The expected prefix for phase names in \"common/config/rush/command-line.json\"\n */\nRushConstants.phaseNamePrefix = '_phase:';\n/**\n * The default debounce value for Rush multi-project watch mode. When watching, controls\n * how long to wait after the last encountered file system event before execution. If another\n * file system event occurs in this interval, the timeout will reset.\n */\nRushConstants.defaultWatchDebounceMs = 1000;\n/**\n * The name of the parameter that can be used to bypass policies.\n */\nRushConstants.bypassPolicyFlagLongName = '--bypass-policy';\nexport { RushConstants };\n//# sourceMappingURL=RushConstants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This namespace contains functions for manipulating sets of projects\n */\nexport class Selection {\n    /**\n     * Computes the intersection of two or more sets.\n     */\n    static intersection(first, ...rest) {\n        return new Set(generateIntersection(first, ...rest));\n    }\n    /**\n     * Computes the union of two or more sets.\n     */\n    static union(...sets) {\n        return new Set(generateConcatenation(...sets));\n    }\n    /**\n     * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.\n     */\n    static expandAllDependencies(input) {\n        return expandAll(input, expandDependenciesStep);\n    }\n    /**\n     * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.\n     */\n    static expandAllConsumers(input) {\n        return expandAll(input, expandConsumers);\n    }\n    /**\n     * Iterates the direct dependencies of the listed projects. May contain duplicates.\n     */\n    static *directDependenciesOf(input) {\n        for (const item of input) {\n            yield* item.dependencyProjects;\n        }\n    }\n    /**\n     * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.\n     */\n    static *directConsumersOf(input) {\n        for (const item of input) {\n            yield* item.consumingProjects;\n        }\n    }\n}\nfunction* generateIntersection(first, ...rest) {\n    for (const item of first) {\n        if (rest.every((set) => set.has(item))) {\n            yield item;\n        }\n    }\n}\nfunction* generateConcatenation(...sets) {\n    for (const set of sets) {\n        yield* set;\n    }\n}\n/**\n * Adds all dependencies of the specified project to the target set.\n */\nfunction expandDependenciesStep(project, targetSet) {\n    for (const dep of project.dependencyProjects) {\n        targetSet.add(dep);\n    }\n}\n/**\n * Adds all projects that declare the specified project as a dependency to the target set.\n */\nfunction expandConsumers(project, targetSet) {\n    for (const dep of project.consumingProjects) {\n        targetSet.add(dep);\n    }\n}\n/**\n * Computes a set derived from the input by cloning it, then iterating over every member of the new set and\n * calling a step function that may add more elements to the set.\n */\nfunction expandAll(input, expandStep) {\n    const result = new Set(input);\n    for (const item of result) {\n        expandStep(item, result);\n    }\n    return result;\n}\n//# sourceMappingURL=Selection.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\n// Refuses to run at all if the PNPM version is older than this, because there\n// are known bugs or missing features in earlier releases.\nconst MINIMUM_SUPPORTED_NPM_VERSION = '4.5.0';\n// Refuses to run at all if the PNPM version is older than this, because there\n// are known bugs or missing features in earlier releases.\nconst MINIMUM_SUPPORTED_PNPM_VERSION = '5.0.0';\n/**\n * Validate that the developer's setup is good.\n *\n * These checks are invoked prior to the following commands:\n * - rush install\n * - rush update\n * - rush build\n * - rush rebuild\n */\nexport class SetupChecks {\n    static validate(rushConfiguration) {\n        // NOTE: The Node.js version is also checked in rush/src/start.ts\n        const errorMessage = SetupChecks._validate(rushConfiguration);\n        if (errorMessage) {\n            // eslint-disable-next-line no-console\n            console.error(colors.red(PrintUtilities.wrapWords(errorMessage)));\n            throw new AlreadyReportedError();\n        }\n    }\n    static _validate(rushConfiguration) {\n        // Check for outdated tools\n        if (rushConfiguration.packageManager === 'pnpm') {\n            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_PNPM_VERSION)) {\n                return (`The rush.json file requests PNPM version ` +\n                    rushConfiguration.packageManagerToolVersion +\n                    `, but PNPM ${MINIMUM_SUPPORTED_PNPM_VERSION} is the minimum supported by Rush.`);\n            }\n        }\n        else if (rushConfiguration.packageManager === 'npm') {\n            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_NPM_VERSION)) {\n                return (`The rush.json file requests NPM version ` +\n                    rushConfiguration.packageManagerToolVersion +\n                    `, but NPM ${MINIMUM_SUPPORTED_NPM_VERSION} is the minimum supported by Rush.`);\n            }\n        }\n        SetupChecks._checkForPhantomFolders(rushConfiguration);\n    }\n    static _checkForPhantomFolders(rushConfiguration) {\n        const phantomFolders = [];\n        const seenFolders = new Set();\n        // Check from the real parent of the common/temp folder\n        const commonTempParent = path.dirname(FileSystem.getRealPath(rushConfiguration.commonTempFolder));\n        SetupChecks._collectPhantomFoldersUpwards(commonTempParent, phantomFolders, seenFolders);\n        // Check from the real folder containing rush.json\n        const realRushJsonFolder = FileSystem.getRealPath(rushConfiguration.rushJsonFolder);\n        SetupChecks._collectPhantomFoldersUpwards(realRushJsonFolder, phantomFolders, seenFolders);\n        if (phantomFolders.length > 0) {\n            if (phantomFolders.length === 1) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow(PrintUtilities.wrapWords('Warning: A phantom \"node_modules\" folder was found. This defeats Rush\\'s protection against' +\n                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +\n                    ' delete this folder:')));\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow(PrintUtilities.wrapWords('Warning: Phantom \"node_modules\" folders were found. This defeats Rush\\'s protection against' +\n                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +\n                    ' delete these folders:')));\n            }\n            for (const folder of phantomFolders) {\n                // eslint-disable-next-line no-console\n                console.log(colors.yellow(`\"${folder}\"`));\n            }\n            // eslint-disable-next-line no-console\n            console.log(); // add a newline\n        }\n    }\n    /**\n     * Checks \"folder\" and each of its parents to see if it contains a node_modules folder.\n     * The bad folders will be added to phantomFolders.\n     * The seenFolders set is used to avoid duplicates.\n     */\n    static _collectPhantomFoldersUpwards(folder, phantomFolders, seenFolders) {\n        // Stop if we reached a folder that we already analyzed\n        while (!seenFolders.has(folder)) {\n            seenFolders.add(folder);\n            // If there is a node_modules folder under this folder, add it to the list of bad folders\n            const nodeModulesFolder = path.join(folder, RushConstants.nodeModulesFolderName);\n            if (FileSystem.exists(nodeModulesFolder)) {\n                // Collect the names of files/folders in that node_modules folder\n                const filenames = FileSystem.readFolderItemNames(nodeModulesFolder).filter((x) => !x.startsWith('.'));\n                let ignore = false;\n                if (filenames.length === 0) {\n                    // If the node_modules folder is completely empty, then it's not a concern\n                    ignore = true;\n                }\n                else if (filenames.length === 1 && filenames[0] === 'vso-task-lib') {\n                    // Special case:  The Azure DevOps build agent installs the \"vso-task-lib\" NPM package\n                    // in a top-level path such as:\n                    //\n                    //   /home/vsts/work/node_modules/vso-task-lib\n                    //\n                    // It is always the only package in that node_modules folder.  The \"vso-task-lib\" package\n                    // is now deprecated, so it is unlikely to be a real dependency of any modern project.\n                    // To avoid false alarms, we ignore this specific case.\n                    ignore = true;\n                }\n                if (!ignore) {\n                    phantomFolders.push(nodeModulesFolder);\n                }\n            }\n            // Walk upwards\n            const parentFolder = path.dirname(folder);\n            if (!parentFolder || parentFolder === folder) {\n                // If path.dirname() returns its own input, then means we reached the root\n                break;\n            }\n            folder = parentFolder;\n        }\n    }\n}\n//# sourceMappingURL=SetupChecks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { NpmShrinkwrapFile } from './npm/NpmShrinkwrapFile';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport { YarnShrinkwrapFile } from './yarn/YarnShrinkwrapFile';\nexport class ShrinkwrapFileFactory {\n    static getShrinkwrapFile(packageManager, packageManagerOptions, shrinkwrapFilename) {\n        switch (packageManager) {\n            case 'npm':\n                return NpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            case 'pnpm':\n                return PnpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            case 'yarn':\n                return YarnShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            default:\n                throw new Error(`Invalid package manager: ${packageManager}`);\n        }\n    }\n    static parseShrinkwrapFile(packageManager, packageManagerOptions, shrinkwrapContent) {\n        switch (packageManager) {\n            case 'npm':\n                return NpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n            case 'pnpm':\n                return PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n            case 'yarn':\n                return YarnShrinkwrapFile.loadFromString(shrinkwrapContent);\n            default:\n                throw new Error(`Invalid package manager: ${packageManager}`);\n        }\n    }\n}\n//# sourceMappingURL=ShrinkwrapFileFactory.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Async } from '@rushstack/node-core-library';\nimport { installRunRushScriptFilename, installRunRushxScriptFilename, installRunRushPnpmScriptFilename, installRunScriptFilename, scriptsFolderPath } from '../utilities/PathConstants';\nconst HEADER_LINES_PREFIX = [\n    '// THIS FILE WAS GENERATED BY A TOOL. ANY MANUAL MODIFICATIONS WILL GET OVERWRITTEN WHENEVER RUSH IS UPGRADED.',\n    '//'\n];\nconst HEADER_LINES_SUFFIX = [\n    '//',\n    '// For more information, see: https://rushjs.io/pages/maintainer/setup_new_repo/',\n    ''\n];\nconst _scripts = [\n    {\n        scriptName: installRunScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where a Node tool may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the specified',\n            '// version of the specified tool (if not already installed), and then pass a command-line to it.',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunScriptFilename} qrcode@1.2.2 qrcode https://rushjs.io`\n        ]\n    },\n    {\n        scriptName: installRunRushScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to it.',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushScriptFilename} install`\n        ]\n    },\n    {\n        scriptName: installRunRushxScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to the',\n            '// rushx command.',\n            '//',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushxScriptFilename} custom-command`\n        ]\n    }\n];\nconst _pnpmOnlyScripts = [\n    {\n        scriptName: installRunRushPnpmScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            '// specified in the rush.json configuration file (if not already installed), and then pass a command-line to the',\n            '// rush-pnpm command.',\n            '//',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushPnpmScriptFilename} pnpm-command`\n        ]\n    }\n];\nconst getScripts = (rushConfiguration) => {\n    if (rushConfiguration.packageManager === 'pnpm') {\n        return _scripts.concat(_pnpmOnlyScripts);\n    }\n    return _scripts;\n};\n/**\n * Checks whether the common/scripts files are up to date, and recopies them if needed.\n * This is used by the \"rush install\" and \"rush update\" commands.\n */\nexport class StandardScriptUpdater {\n    /**\n     * Recopy the scripts if the scripts are out of date.\n     * Used by \"rush update\".\n     */\n    static async updateAsync(rushConfiguration) {\n        await FileSystem.ensureFolderAsync(rushConfiguration.commonScriptsFolder);\n        let anyChanges = false;\n        await Async.forEachAsync(getScripts(rushConfiguration), async (script) => {\n            const changed = await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, false);\n            anyChanges || (anyChanges = changed);\n        }, { concurrency: 10 });\n        if (anyChanges) {\n            // eslint-disable-next-line no-console\n            console.log(); // print a newline after the notices\n        }\n        return anyChanges;\n    }\n    /**\n     * Throw an exception if the scripts are out of date.\n     * Used by \"rush install\".\n     */\n    static async validateAsync(rushConfiguration) {\n        await Async.forEachAsync(getScripts(rushConfiguration), async (script) => {\n            await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, true);\n        }, { concurrency: 10 });\n    }\n    /**\n     * Compares a single script in the common/script folder to see if it needs to be updated.\n     * If throwInsteadOfCopy=false, then an outdated or missing script will be recopied;\n     * otherwise, an exception is thrown.\n     */\n    static async _updateScriptOrThrowAsync(script, rushConfiguration, throwInsteadOfCopy) {\n        const targetFilePath = `${rushConfiguration.commonScriptsFolder}/${script.scriptName}`;\n        // Are the files the same?\n        let filesAreSame = false;\n        let targetContent;\n        try {\n            targetContent = await FileSystem.readFileAsync(targetFilePath);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        const targetNormalized = targetContent\n            ? StandardScriptUpdater._normalize(targetContent)\n            : undefined;\n        let sourceNormalized;\n        if (targetNormalized) {\n            sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script);\n            if (sourceNormalized === targetNormalized) {\n                filesAreSame = true;\n            }\n        }\n        if (!filesAreSame) {\n            if (throwInsteadOfCopy) {\n                throw new Error('The standard files in the \"common/scripts\" folders need to be updated' +\n                    ' for this Rush version.  Please run \"rush update\" and commit the changes.');\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Script is out of date; updating \"${targetFilePath}\"`);\n                sourceNormalized || (sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script));\n                await FileSystem.writeFileAsync(targetFilePath, sourceNormalized);\n            }\n        }\n        return !filesAreSame;\n    }\n    static _normalize(content) {\n        // Ignore newline differences from .gitattributes\n        return (content\n            .split('\\n')\n            // Ignore trailing whitespace\n            .map((x) => x.trimRight())\n            .join('\\n'));\n    }\n    static async _getExpectedFileDataAsync({ scriptName, headerLines }) {\n        const sourceFilePath = `${scriptsFolderPath}/${scriptName}`;\n        let sourceContent = await FileSystem.readFileAsync(sourceFilePath);\n        sourceContent = [...HEADER_LINES_PREFIX, ...headerLines, ...HEADER_LINES_SUFFIX, sourceContent].join('\\n');\n        const sourceNormalized = StandardScriptUpdater._normalize(sourceContent);\n        return sourceNormalized;\n    }\n}\n//# sourceMappingURL=StandardScriptUpdater.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { Rush } from '../api/Rush';\nconst MAX_FILE_COUNT = 100;\nconst ONE_MEGABYTE_IN_BYTES = 1048576;\nexport class Telemetry {\n    constructor(rushConfiguration, rushSession) {\n        this._flushAsyncTasks = new Set();\n        this._rushConfiguration = rushConfiguration;\n        this._rushSession = rushSession;\n        this._enabled = this._rushConfiguration.telemetryEnabled;\n        this._store = [];\n        const folderName = 'telemetry';\n        this._dataFolder = path.join(this._rushConfiguration.commonTempFolder, folderName);\n    }\n    log(telemetryData) {\n        if (!this._enabled) {\n            return;\n        }\n        const data = Object.assign(Object.assign({}, telemetryData), { machineInfo: telemetryData.machineInfo || {\n                machineArchitecture: os.arch(),\n                // The Node.js model is sometimes padded, for example:\n                // \"AMD Ryzen 7 3700X 8-Core Processor             \"\n                machineCpu: os.cpus()[0].model.trim(),\n                machineCores: os.cpus().length,\n                machineTotalMemoryMiB: Math.round(os.totalmem() / ONE_MEGABYTE_IN_BYTES),\n                machineFreeMemoryMiB: Math.round(os.freemem() / ONE_MEGABYTE_IN_BYTES)\n            }, timestampMs: telemetryData.timestampMs || new Date().getTime(), platform: telemetryData.platform || process.platform, rushVersion: telemetryData.rushVersion || Rush.version });\n        this._store.push(data);\n    }\n    flush() {\n        if (!this._enabled || this._store.length === 0) {\n            return;\n        }\n        const fullPath = this._getFilePath();\n        JsonFile.save(this._store, fullPath, { ensureFolderExists: true, ignoreUndefinedValues: true });\n        if (this._rushSession.hooks.flushTelemetry.isUsed()) {\n            /**\n             * User defined flushTelemetry should not block anything, so we don't await here,\n             * and store the promise into a list so that we can await it later.\n             */\n            const asyncTaskPromise = this._rushSession.hooks.flushTelemetry.promise(this._store);\n            this._flushAsyncTasks.add(asyncTaskPromise);\n            asyncTaskPromise.then(() => {\n                this._flushAsyncTasks.delete(asyncTaskPromise);\n            }, () => {\n                this._flushAsyncTasks.delete(asyncTaskPromise);\n            });\n        }\n        this._store = [];\n        this._cleanUp();\n    }\n    /**\n     * There are some async tasks that are not finished when the process is exiting.\n     */\n    async ensureFlushedAsync() {\n        await Promise.all(this._flushAsyncTasks);\n    }\n    get store() {\n        return this._store;\n    }\n    /**\n     * When there are too many log files, delete the old ones.\n     */\n    _cleanUp() {\n        if (FileSystem.exists(this._dataFolder)) {\n            const files = FileSystem.readFolderItemNames(this._dataFolder);\n            if (files.length > MAX_FILE_COUNT) {\n                const sortedFiles = files\n                    .map((fileName) => {\n                    const filePath = path.join(this._dataFolder, fileName);\n                    const stats = FileSystem.getStatistics(filePath);\n                    return {\n                        filePath: filePath,\n                        modifiedTime: stats.mtime.getTime(),\n                        isFile: stats.isFile()\n                    };\n                })\n                    .filter((value) => {\n                    // Only delete files\n                    return value.isFile;\n                })\n                    .sort((a, b) => {\n                    return a.modifiedTime - b.modifiedTime;\n                })\n                    .map((s) => {\n                    return s.filePath;\n                });\n                const filesToDelete = sortedFiles.length - MAX_FILE_COUNT;\n                for (let i = 0; i < filesToDelete; i++) {\n                    FileSystem.deleteFile(sortedFiles[i]);\n                }\n            }\n        }\n    }\n    _getFilePath() {\n        let fileName = `telemetry_${new Date().toISOString()}`;\n        fileName = fileName.replace(/[\\-\\:\\.]/g, '_') + '.json';\n        return path.join(this._dataFolder, fileName);\n    }\n}\n//# sourceMappingURL=Telemetry.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Utilities } from '../utilities/Utilities';\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\nimport { LastLinkFlagFactory } from '../api/LastLinkFlag';\n/**\n * This class implements the logic for \"rush unlink\"\n */\nexport class UnlinkManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Delete flag file and all the existing node_modules symlinks and all\n     * project/.rush/temp/shrinkwrap-deps.json files\n     *\n     * Returns true if anything was deleted.\n     */\n    unlink(force = false) {\n        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;\n        if (!force && useWorkspaces) {\n            // eslint-disable-next-line no-console\n            console.log(colors.red('Unlinking is not supported when using workspaces. Run \"rush purge\" to remove ' +\n                'project node_modules folders.'));\n            throw new AlreadyReportedError();\n        }\n        LastLinkFlagFactory.getCommonTempFlag(this._rushConfiguration).clear();\n        return this._deleteProjectFiles();\n    }\n    /**\n     * Delete:\n     *  - all the node_modules symlinks of configured Rush projects\n     *  - all of the project/.rush/temp/shrinkwrap-deps.json files of configured Rush projects\n     *\n     * Returns true if anything was deleted\n     * */\n    _deleteProjectFiles() {\n        let didDeleteAnything = false;\n        for (const rushProject of this._rushConfiguration.projects) {\n            const localModuleFolder = path.join(rushProject.projectFolder, 'node_modules');\n            if (FileSystem.exists(localModuleFolder)) {\n                // eslint-disable-next-line no-console\n                console.log(`Purging ${localModuleFolder}`);\n                Utilities.dangerouslyDeletePath(localModuleFolder);\n                didDeleteAnything = true;\n            }\n            const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(rushProject);\n            if (FileSystem.exists(projectShrinkwrapFilePath)) {\n                // eslint-disable-next-line no-console\n                console.log(`Deleting ${projectShrinkwrapFilePath}`);\n                FileSystem.deleteFile(projectShrinkwrapFilePath);\n                didDeleteAnything = true;\n            }\n        }\n        return didDeleteAnything;\n    }\n}\n//# sourceMappingURL=UnlinkManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Options that all package managers share.\n *\n * @public\n */\nexport class PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        this.environmentVariables = json.environmentVariables;\n    }\n}\n//# sourceMappingURL=BasePackageManagerOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\n/**\n * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file\n * which tracks the direct and indirect dependencies that a project consumes. This is used\n * to better determine which projects should be rebuilt when dependencies are updated.\n */\nexport class BaseProjectShrinkwrapFile {\n    constructor(shrinkwrapFile, project) {\n        this.project = project;\n        this.projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(this.project);\n        this.shrinkwrapFile = shrinkwrapFile;\n    }\n    /**\n     * Save an empty project shrinkwrap file. This is used in repos with no dependencies.\n     */\n    static async saveEmptyProjectShrinkwrapFileAsync(project) {\n        const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);\n        await JsonFile.saveAsync({}, projectShrinkwrapFilePath, { ensureFolderExists: true });\n    }\n    /**\n     * Get the fully-qualified path to the <project>/.rush/temp/shrinkwrap-deps.json\n     * for the specified project.\n     */\n    static getFilePathForProject(project) {\n        return `${project.projectRushTempFolder}/${RushConstants.projectShrinkwrapFilename}`;\n    }\n    /**\n     * If the <project>/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.\n     */\n    async deleteIfExistsAsync() {\n        await FileSystem.deleteFileAsync(this.projectShrinkwrapFilePath, { throwIfNotExists: false });\n    }\n}\n//# sourceMappingURL=BaseProjectShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as semver from 'semver';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { DependencySpecifierType } from '../DependencySpecifier';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\n/**\n * This class is a parser for both npm's npm-shrinkwrap.json and pnpm's pnpm-lock.yaml file formats.\n */\nexport class BaseShrinkwrapFile {\n    constructor() {\n        this._alreadyWarnedSpecs = new Set();\n    }\n    static tryGetValue(dictionary, key) {\n        if (dictionary.hasOwnProperty(key)) {\n            return dictionary[key];\n        }\n        return undefined;\n    }\n    /**\n     * Validate the shrinkwrap using the provided policy options.\n     *\n     * @virtual\n     */\n    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) { }\n    /**\n     * Returns true if the shrinkwrap file includes a top-level package that would satisfy the specified\n     * package name and SemVer version range\n     *\n     * @virtual\n     */\n    hasCompatibleTopLevelDependency(dependencySpecifier) {\n        const shrinkwrapDependency = this.getTopLevelDependencyVersion(dependencySpecifier.packageName);\n        if (!shrinkwrapDependency) {\n            return false;\n        }\n        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n    }\n    /**\n     * Returns true if the shrinkwrap file includes a package that would satisfying the specified\n     * package name and SemVer version range.  By default, the dependencies are resolved by looking\n     * at the root of the node_modules folder described by the shrinkwrap file.  However, if\n     * tempProjectName is specified, then the resolution will start in that subfolder.\n     *\n     * Consider this example:\n     *\n     * - node_modules\\\n     *   - temp-project\\\n     *     - lib-a@1.2.3\n     *     - lib-b@1.0.0\n     *   - lib-b@2.0.0\n     *\n     * In this example, hasCompatibleDependency(\"lib-b\", \">= 1.1.0\", \"temp-project\") would fail\n     * because it finds lib-b@1.0.0 which does not satisfy the pattern \">= 1.1.0\".\n     *\n     * @virtual\n     */\n    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {\n        const shrinkwrapDependency = this.tryEnsureDependencyVersion(dependencySpecifier, tempProjectName);\n        if (!shrinkwrapDependency) {\n            return false;\n        }\n        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n    }\n    /**\n     * Check for projects that exist in the shrinkwrap file, but don't exist\n     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.\n     *\n     * @returns a list of orphaned projects.\n     */\n    findOrphanedProjects(rushConfiguration) {\n        const orphanedProjectNames = [];\n        // We can recognize temp projects because they are under the \"@rush-temp\" NPM scope.\n        for (const tempProjectName of this.getTempProjectNames()) {\n            if (!rushConfiguration.findProjectByTempName(tempProjectName)) {\n                orphanedProjectNames.push(tempProjectName);\n            }\n        }\n        return orphanedProjectNames;\n    }\n    _getTempProjectNames(dependencies) {\n        const result = [];\n        for (const key of Object.keys(dependencies)) {\n            // If it starts with @rush-temp, then include it:\n            if (PackageNameParsers.permissive.getScope(key) === RushConstants.rushTempNpmScope) {\n                result.push(key);\n            }\n        }\n        result.sort(); // make the result deterministic\n        return result;\n    }\n    _checkDependencyVersion(projectDependency, shrinkwrapDependency) {\n        let normalizedProjectDependency = projectDependency;\n        let normalizedShrinkwrapDependency = shrinkwrapDependency;\n        // Special handling for NPM package aliases such as this:\n        //\n        // \"dependencies\": {\n        //   \"alias-name\": \"npm:target-name@^1.2.3\"\n        // }\n        //\n        // In this case, the shrinkwrap file will have a key equivalent to \"npm:target-name@1.2.5\",\n        // and so we need to unwrap the target and compare \"1.2.5\" with \"^1.2.3\".\n        if (projectDependency.specifierType === DependencySpecifierType.Alias) {\n            // Does the shrinkwrap install it as an alias?\n            if (shrinkwrapDependency.specifierType === DependencySpecifierType.Alias) {\n                // Does the shrinkwrap have the right package name?\n                if (projectDependency.packageName === shrinkwrapDependency.packageName) {\n                    // Yes, the aliases match, so let's compare their targets in the logic below\n                    normalizedProjectDependency = projectDependency.aliasTarget;\n                    normalizedShrinkwrapDependency = shrinkwrapDependency.aliasTarget;\n                }\n                else {\n                    // If the names are different, then it's a mismatch\n                    return false;\n                }\n            }\n            else {\n                // A non-alias cannot satisfy an alias dependency; at least, let's avoid that idea\n                return false;\n            }\n        }\n        switch (normalizedProjectDependency.specifierType) {\n            case DependencySpecifierType.Version:\n            case DependencySpecifierType.Range:\n                return semver.satisfies(normalizedShrinkwrapDependency.versionSpecifier, normalizedProjectDependency.versionSpecifier);\n            default:\n                // For other version specifier types like \"file:./blah.tgz\" or \"git://github.com/npm/cli.git#v1.0.27\"\n                // we allow the installation to continue but issue a warning.  The \"rush install\" checks will not work\n                // correctly.\n                // Only warn once for each versionSpecifier\n                if (!this._alreadyWarnedSpecs.has(projectDependency.versionSpecifier)) {\n                    this._alreadyWarnedSpecs.add(projectDependency.versionSpecifier);\n                    // eslint-disable-next-line no-console\n                    console.log(colors.yellow(`WARNING: Not validating ${projectDependency.specifierType}-based` +\n                        ` specifier: \"${projectDependency.versionSpecifier}\"`));\n                }\n                return true;\n        }\n    }\n}\n//# sourceMappingURL=BaseShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nconst OPTIONS_ARGUMENT_NAME = 'options';\nconst HASH_TOKEN_NAME = 'hash';\nconst PROJECT_NAME_TOKEN_NAME = 'projectName';\nconst PHASE_NAME_TOKEN_NAME = 'phaseName';\n// This regex matches substrings that look like [token]\nconst TOKEN_REGEX = /\\[[^\\]]*\\]/g;\nexport class CacheEntryId {\n    constructor() { }\n    static parsePattern(pattern) {\n        if (!pattern) {\n            return ({ projectStateHash }) => projectStateHash;\n        }\n        else {\n            pattern = pattern.trim();\n            if (pattern.startsWith('/')) {\n                throw new Error('Cache entry name patterns may not start with a slash.');\n            }\n            const patternWithoutTokens = pattern.replace(TOKEN_REGEX, '');\n            if (patternWithoutTokens.match(/\\]/)) {\n                throw new Error(`Unexpected \"]\" character in cache entry name pattern.`);\n            }\n            if (patternWithoutTokens.match(/\\[/)) {\n                throw new Error('Unclosed token in cache entry name pattern.');\n            }\n            if (!patternWithoutTokens.match(/^[A-z0-9-_\\/]*$/)) {\n                throw new Error('Cache entry name pattern contains an invalid character. ' +\n                    'Only alphanumeric characters, slashes, underscores, and hyphens are allowed.');\n            }\n            let foundHashToken = false;\n            const templateString = pattern.trim().replace(TOKEN_REGEX, (token) => {\n                token = token.substring(1, token.length - 1);\n                let tokenName;\n                let tokenAttribute;\n                const tokenSplitIndex = token.indexOf(':');\n                if (tokenSplitIndex === -1) {\n                    tokenName = token;\n                }\n                else {\n                    tokenName = token.substr(0, tokenSplitIndex);\n                    tokenAttribute = token.substr(tokenSplitIndex + 1);\n                }\n                switch (tokenName) {\n                    case HASH_TOKEN_NAME: {\n                        if (tokenAttribute !== undefined) {\n                            throw new Error(`An attribute isn\\'t supported for the \"${tokenName}\" token.`);\n                        }\n                        foundHashToken = true;\n                        return `\\${${OPTIONS_ARGUMENT_NAME}.projectStateHash}`;\n                    }\n                    case PROJECT_NAME_TOKEN_NAME: {\n                        switch (tokenAttribute) {\n                            case undefined: {\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.projectName}`;\n                            }\n                            case 'normalize': {\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.projectName.replace('@','').replace(/\\\\+/g, '++').replace(/\\\\/\\/g, '+')}`;\n                            }\n                            default: {\n                                throw new Error(`Unexpected attribute \"${tokenAttribute}\" for the \"${tokenName}\" token.`);\n                            }\n                        }\n                    }\n                    case PHASE_NAME_TOKEN_NAME: {\n                        switch (tokenAttribute) {\n                            case undefined: {\n                                throw new Error('Either the \"normalize\" or the \"trimPrefix\" attribute is required ' +\n                                    `for the \"${tokenName}\" token.`);\n                            }\n                            case 'normalize': {\n                                // Replace colons with underscores.\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/:/g, '_')}`;\n                            }\n                            case 'trimPrefix': {\n                                // Trim the \"_phase:\" prefix from the phase name.\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/^_phase:/, '')}`;\n                            }\n                            default: {\n                                throw new Error(`Unexpected attribute \"${tokenAttribute}\" for the \"${tokenName}\" token.`);\n                            }\n                        }\n                    }\n                    default: {\n                        throw new Error(`Unexpected token name \"${tokenName}\".`);\n                    }\n                }\n            });\n            if (!foundHashToken) {\n                throw new Error(`Cache entry name pattern is missing a [${HASH_TOKEN_NAME}] token.`);\n            }\n            // eslint-disable-next-line no-new-func\n            return new Function(OPTIONS_ARGUMENT_NAME, `\"use strict\"\\nreturn \\`${templateString}\\`;`);\n        }\n    }\n}\n//# sourceMappingURL=CacheEntryId.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem } from '@rushstack/node-core-library';\nconst DEFAULT_BUILD_CACHE_FOLDER_NAME = 'build-cache';\n/**\n * A build cache provider using the local file system.\n * Required by all cloud cache providers.\n * @beta\n */\nexport class FileSystemBuildCacheProvider {\n    constructor(options) {\n        this._cacheFolderPath =\n            options.rushUserConfiguration.buildCacheFolder ||\n                path.join(options.rushConfiguration.commonTempFolder, DEFAULT_BUILD_CACHE_FOLDER_NAME);\n    }\n    /**\n     * Returns the absolute disk path for the specified cache id.\n     */\n    getCacheEntryPath(cacheId) {\n        return path.join(this._cacheFolderPath, cacheId);\n    }\n    /**\n     * Validates that the specified cache id exists on disk, and returns the path if it does.\n     */\n    async tryGetCacheEntryPathByIdAsync(terminal, cacheId) {\n        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);\n        if (await FileSystem.existsAsync(cacheEntryFilePath)) {\n            return cacheEntryFilePath;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Writes the specified buffer to the corresponding file system path for the cache id.\n     */\n    async trySetCacheEntryBufferAsync(terminal, cacheId, entryBuffer) {\n        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);\n        await FileSystem.writeFileAsync(cacheEntryFilePath, entryBuffer, { ensureFolderExists: true });\n        terminal.writeVerboseLine(`Wrote cache entry to \"${cacheEntryFilePath}\".`);\n        return cacheEntryFilePath;\n    }\n}\n//# sourceMappingURL=FileSystemBuildCacheProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { FileSystem, InternalError, Async } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nimport { TarExecutable } from '../../utilities/TarExecutable';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\nclass ProjectBuildCache {\n    constructor(cacheId, options) {\n        const { buildCacheConfiguration, project, projectOutputFolderNames, additionalProjectOutputFilePaths } = options;\n        this._project = project;\n        this._localBuildCacheProvider = buildCacheConfiguration.localCacheProvider;\n        this._cloudBuildCacheProvider = buildCacheConfiguration.cloudCacheProvider;\n        this._buildCacheEnabled = buildCacheConfiguration.buildCacheEnabled;\n        this._cacheWriteEnabled = buildCacheConfiguration.cacheWriteEnabled;\n        this._projectOutputFolderNames = projectOutputFolderNames || [];\n        this._additionalProjectOutputFilePaths = additionalProjectOutputFilePaths || [];\n        this._cacheId = cacheId;\n    }\n    static _tryGetTarUtility(terminal) {\n        if (ProjectBuildCache._tarUtilityPromise === null) {\n            ProjectBuildCache._tarUtilityPromise = TarExecutable.tryInitializeAsync(terminal);\n        }\n        return ProjectBuildCache._tarUtilityPromise;\n    }\n    get cacheId() {\n        return this._cacheId;\n    }\n    static async tryGetProjectBuildCache(options) {\n        const cacheId = await ProjectBuildCache._getCacheId(options);\n        return new ProjectBuildCache(cacheId, options);\n    }\n    async tryRestoreFromCacheAsync(terminal, specifiedCacheId) {\n        const cacheId = specifiedCacheId || this._cacheId;\n        if (!cacheId) {\n            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n            return false;\n        }\n        if (!this._buildCacheEnabled) {\n            // Skip reading local and cloud build caches, without any noise\n            return false;\n        }\n        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\n        let cacheEntryBuffer;\n        let updateLocalCacheSuccess;\n        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\n            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');\n            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);\n            if (cacheEntryBuffer) {\n                try {\n                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);\n                    updateLocalCacheSuccess = true;\n                }\n                catch (e) {\n                    updateLocalCacheSuccess = false;\n                }\n            }\n        }\n        if (!localCacheEntryPath && !cacheEntryBuffer) {\n            terminal.writeVerboseLine('This project was not found in the build cache.');\n            return false;\n        }\n        terminal.writeLine('Build cache hit.');\n        const projectFolderPath = this._project.projectFolder;\n        // Purge output folders\n        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\n        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));\n        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);\n        let restoreSuccess = false;\n        if (tarUtility && localCacheEntryPath) {\n            const logFilePath = this._getTarLogFilePath('untar');\n            const tarExitCode = await tarUtility.tryUntarAsync({\n                archivePath: localCacheEntryPath,\n                outputFolderPath: projectFolderPath,\n                logFilePath\n            });\n            if (tarExitCode === 0) {\n                restoreSuccess = true;\n                terminal.writeLine('Successfully restored output from the build cache.');\n            }\n            else {\n                terminal.writeWarningLine('Unable to restore output from the build cache. ' +\n                    `See \"${logFilePath}\" for logs from the tar process.`);\n            }\n        }\n        if (updateLocalCacheSuccess === false) {\n            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\n        }\n        return restoreSuccess;\n    }\n    async trySetCacheEntryAsync(terminal, specifiedCacheId) {\n        var _a, _b, _c;\n        if (!this._cacheWriteEnabled) {\n            // Skip writing local and cloud build caches, without any noise\n            return true;\n        }\n        const cacheId = specifiedCacheId || this._cacheId;\n        if (!cacheId) {\n            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n            return false;\n        }\n        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);\n        if (!filesToCache) {\n            return false;\n        }\n        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);\n        let localCacheEntryPath;\n        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);\n        if (tarUtility) {\n            const finalLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\n            // Derive the temp file from the destination path to ensure they are on the same volume\n            // In the case of a shared network drive containing the build cache, we also need to make\n            // sure the the temp path won't be shared by two parallel rush builds.\n            const randomSuffix = crypto.randomBytes(8).toString('hex');\n            const tempLocalCacheEntryPath = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;\n            const logFilePath = this._getTarLogFilePath('tar');\n            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({\n                archivePath: tempLocalCacheEntryPath,\n                paths: filesToCache.outputFilePaths,\n                project: this._project,\n                logFilePath\n            });\n            if (tarExitCode === 0) {\n                // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file\n                try {\n                    await Async.runWithRetriesAsync({\n                        action: () => FileSystem.moveAsync({\n                            sourcePath: tempLocalCacheEntryPath,\n                            destinationPath: finalLocalCacheEntryPath,\n                            overwrite: true\n                        }),\n                        maxRetries: 2,\n                        retryDelayMs: 500\n                    });\n                }\n                catch (moveError) {\n                    try {\n                        await FileSystem.deleteFileAsync(tempLocalCacheEntryPath);\n                    }\n                    catch (deleteError) {\n                        // Ignored\n                    }\n                    throw moveError;\n                }\n                localCacheEntryPath = finalLocalCacheEntryPath;\n            }\n            else {\n                terminal.writeWarningLine(`\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\n                    `See \"${logFilePath}\" for logs from the tar process.`);\n                return false;\n            }\n        }\n        else {\n            terminal.writeWarningLine(`Unable to locate \"tar\". Please ensure that \"tar\" is on your PATH environment variable, or set the ` +\n                `${EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the \"tar\" binary.`);\n            return false;\n        }\n        let cacheEntryBuffer;\n        let setCloudCacheEntryPromise;\n        // Note that \"writeAllowed\" settings (whether in config or environment) always apply to\n        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and\n        // write to the local build cache.\n        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {\n            if (localCacheEntryPath) {\n                cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n            }\n            else {\n                throw new InternalError('Expected the local cache entry path to be set.');\n            }\n            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);\n        }\n        const updateCloudCacheSuccess = (_c = (await setCloudCacheEntryPromise)) !== null && _c !== void 0 ? _c : true;\n        const success = updateCloudCacheSuccess && !!localCacheEntryPath;\n        if (success) {\n            terminal.writeLine('Successfully set cache entry.');\n        }\n        else if (!localCacheEntryPath && updateCloudCacheSuccess) {\n            terminal.writeWarningLine('Unable to set local cache entry.');\n        }\n        else if (localCacheEntryPath && !updateCloudCacheSuccess) {\n            terminal.writeWarningLine('Unable to set cloud cache entry.');\n        }\n        else {\n            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\n        }\n        return success;\n    }\n    /**\n     * Walks the declared output folders of the project and collects a list of files.\n     * @returns The list of output files as project-relative paths, or `undefined` if a\n     *   symbolic link was encountered.\n     */\n    async _tryCollectPathsToCacheAsync(terminal) {\n        const projectFolderPath = this._project.projectFolder;\n        const outputFilePaths = [];\n        const queue = [];\n        const filteredOutputFolderNames = [];\n        let hasSymbolicLinks = false;\n        // Adds child directories to the queue, files to the path list, and bails on symlinks\n        function processChildren(relativePath, diskPath, children) {\n            for (const child of children) {\n                const childRelativePath = `${relativePath}/${child.name}`;\n                if (child.isSymbolicLink()) {\n                    terminal.writeError(`Unable to include \"${childRelativePath}\" in build cache. It is a symbolic link.`);\n                    hasSymbolicLinks = true;\n                }\n                else if (child.isDirectory()) {\n                    queue.push([childRelativePath, `${diskPath}/${child.name}`]);\n                }\n                else {\n                    outputFilePaths.push(childRelativePath);\n                }\n            }\n        }\n        // Handle declared output folders.\n        for (const outputFolder of this._projectOutputFolderNames) {\n            const diskPath = `${projectFolderPath}/${outputFolder}`;\n            try {\n                const children = await FileSystem.readFolderItemsAsync(diskPath);\n                processChildren(outputFolder, diskPath, children);\n                // The folder exists, record it\n                filteredOutputFolderNames.push(outputFolder);\n            }\n            catch (error) {\n                if (!FileSystem.isNotExistError(error)) {\n                    throw error;\n                }\n                // If the folder does not exist, ignore it.\n            }\n        }\n        for (const [relativePath, diskPath] of queue) {\n            const children = await FileSystem.readFolderItemsAsync(diskPath);\n            processChildren(relativePath, diskPath, children);\n        }\n        if (hasSymbolicLinks) {\n            // Symbolic links do not round-trip safely.\n            return undefined;\n        }\n        // Add additional output file paths\n        await Async.forEachAsync(this._additionalProjectOutputFilePaths, async (additionalProjectOutputFilePath) => {\n            const fullPath = `${projectFolderPath}/${additionalProjectOutputFilePath}`;\n            const pathExists = await FileSystem.existsAsync(fullPath);\n            if (pathExists) {\n                outputFilePaths.push(additionalProjectOutputFilePath);\n            }\n        }, { concurrency: 10 });\n        // Ensure stable output path order.\n        outputFilePaths.sort();\n        return {\n            outputFilePaths,\n            filteredOutputFolderNames\n        };\n    }\n    _getTarLogFilePath(mode) {\n        return path.join(this._project.projectRushTempFolder, `${this._cacheId}.${mode}.log`);\n    }\n    static async _getCacheId(options) {\n        // The project state hash is calculated in the following method:\n        // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is\n        //   calculated and appended to an array\n        // - The current project's recursive dependency projects' hashes are calculated\n        //   and appended to the array\n        // - A SHA1 hash is created and the following data is fed into it, in order:\n        //   1. The JSON-serialized list of output folder names for this\n        //      project (see ProjectBuildCache._projectOutputFolderNames)\n        //   2. The configHash from the operation's runner\n        //   3. Each dependency project hash (from the array constructed in previous steps),\n        //      in sorted alphanumerical-sorted order\n        // - A hex digest of the hash is returned\n        const projectChangeAnalyzer = options.projectChangeAnalyzer;\n        const projectStates = [];\n        const projectsToProcess = new Set();\n        projectsToProcess.add(options.project);\n        for (const projectToProcess of projectsToProcess) {\n            const projectState = await projectChangeAnalyzer._tryGetProjectStateHashAsync(projectToProcess, options.terminal);\n            if (!projectState) {\n                // If we hit any projects with unknown state, return unknown cache ID\n                return undefined;\n            }\n            else {\n                projectStates.push(projectState);\n                for (const dependency of projectToProcess.dependencyProjects) {\n                    projectsToProcess.add(dependency);\n                }\n            }\n        }\n        const sortedProjectStates = projectStates.sort();\n        const hash = crypto.createHash('sha1');\n        // This value is used to force cache bust when the build cache algorithm changes\n        hash.update(`${RushConstants.buildCacheVersion}`);\n        hash.update(RushConstants.hashDelimiter);\n        const serializedOutputFolders = JSON.stringify(options.projectOutputFolderNames);\n        hash.update(serializedOutputFolders);\n        hash.update(RushConstants.hashDelimiter);\n        hash.update(options.configHash);\n        hash.update(RushConstants.hashDelimiter);\n        if (options.additionalContext) {\n            for (const key of Object.keys(options.additionalContext).sort()) {\n                // Add additional context keys and values.\n                //\n                // This choice (to modify the hash for every key regardless of whether a value is set) implies\n                // that just _adding_ an env var to the list of dependsOnEnvVars will modify its hash. This\n                // seems appropriate, because this behavior is consistent whether or not the env var happens\n                // to have a value.\n                hash.update(`${key}=${options.additionalContext[key]}`);\n                hash.update(RushConstants.hashDelimiter);\n            }\n        }\n        for (const projectHash of sortedProjectStates) {\n            hash.update(projectHash);\n            hash.update(RushConstants.hashDelimiter);\n        }\n        const projectStateHash = hash.digest('hex');\n        return options.buildCacheConfiguration.getCacheEntryId({\n            projectName: options.project.packageName,\n            projectStateHash,\n            phaseName: options.phaseName\n        });\n    }\n}\n/**\n * null === we haven't tried to initialize yet\n * undefined === unable to initialize\n */\nProjectBuildCache._tarUtilityPromise = null;\nexport { ProjectBuildCache };\n//# sourceMappingURL=ProjectBuildCache.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { getGitHashForFiles } from '@rushstack/package-deps-hash';\nimport * as path from 'path';\nasync function expandGlobPatternsAsync(globPatterns, packagePath) {\n    const { default: glob } = await import('fast-glob');\n    const matches = await glob(Array.from(globPatterns), {\n        cwd: packagePath,\n        onlyFiles: true,\n        // We want to keep path's type unchanged,\n        // i.e. if the pattern was a  relative path, then matched paths should also be relative paths\n        //      if the pattern was an absolute path, then matched paths should also be absolute paths\n        //\n        // We are doing this because these paths are going to be used to calculate a hash for the build cache and some users\n        // might choose to depend on global files (e.g. `/etc/os-release`) and some might choose to depend on local files\n        // (e.g. `../path/to/workspace/file`)\n        //\n        // In both cases we want that path to the resource would be the same on all machines,\n        // regardless of what is the current working directory.\n        //\n        // That being said, we want to keep `absolute` option here as false:\n        absolute: false\n    });\n    if (matches.length === 0) {\n        throw new Error(`Couldn't find any files matching provided glob patterns: [\"${Array.from(globPatterns).join('\", \"')}\"].`);\n    }\n    return matches;\n}\nfunction getKnownHashes(filePaths, packagePath, repoState) {\n    const missingPaths = [];\n    const foundPaths = new Map();\n    for (const filePath of filePaths) {\n        const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(packagePath, filePath);\n        /**\n         * We are using RegExp here to prevent false positives in the following string.replace function\n         * - `^` anchor makes sure that we are replacing only the beginning of the string\n         * - extra `/` makes sure that we are remove extra slash from the relative path\n         */\n        const gitFilePath = absolutePath.replace(new RegExp('^' + repoState.rootDir + '/'), '');\n        const foundHash = repoState.rawHashes.get(gitFilePath);\n        if (foundHash) {\n            foundPaths.set(filePath, foundHash);\n        }\n        else {\n            missingPaths.push(filePath);\n        }\n    }\n    return { foundPaths, missingPaths };\n}\nexport async function getHashesForGlobsAsync(globPatterns, packagePath, repoState) {\n    const filePaths = await expandGlobPatternsAsync(globPatterns, packagePath);\n    if (!repoState) {\n        return getGitHashForFiles(filePaths, packagePath);\n    }\n    const { foundPaths, missingPaths } = getKnownHashes(filePaths, packagePath, repoState);\n    const calculatedHashes = getGitHashForFiles(missingPaths, packagePath);\n    /**\n     * We want to keep the order of the output the same regardless whether the file was already\n     * hashed by git or not (as this can change, e.g. due to .gitignore).\n     * Therefore we will populate our final hashes map in the same order as `filePaths`.\n     */\n    const result = new Map();\n    for (const filePath of filePaths) {\n        const hash = foundPaths.get(filePath) || calculatedHashes.get(filePath);\n        if (!hash) {\n            // Sanity check -- this should never happen\n            throw new Error(`Failed to calculate hash of file: \"${filePath}\"`);\n        }\n        result.set(filePath, hash);\n    }\n    return result;\n}\n//# sourceMappingURL=getHashesForGlobsAsync.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\nconst KEY_SEPARATOR = ':';\nexport class CobuildLock {\n    constructor(options) {\n        const { cobuildConfiguration, projectBuildCache, cobuildClusterId: clusterId, lockExpireTimeInSeconds, packageName, phaseName } = options;\n        const { cobuildContextId: contextId, cobuildRunnerId: runnerId } = cobuildConfiguration;\n        const { cacheId } = projectBuildCache;\n        this.cobuildConfiguration = cobuildConfiguration;\n        this.projectBuildCache = projectBuildCache;\n        if (!cacheId) {\n            // This should never happen\n            throw new InternalError(`Cache id is require for cobuild lock`);\n        }\n        if (!contextId) {\n            // This should never happen\n            throw new InternalError(`Cobuild context id is require for cobuild lock`);\n        }\n        // Example: cobuild:lock:<contextId>:<clusterId>\n        const lockKey = ['cobuild', 'lock', contextId, clusterId].join(KEY_SEPARATOR);\n        // Example: cobuild:completed:<contextId>:<cacheId>\n        const completedStateKey = ['cobuild', 'completed', contextId, cacheId].join(KEY_SEPARATOR);\n        this._cobuildContext = {\n            contextId,\n            clusterId,\n            runnerId,\n            lockKey,\n            completedStateKey,\n            packageName,\n            phaseName,\n            lockExpireTimeInSeconds: lockExpireTimeInSeconds,\n            cacheId\n        };\n    }\n    async setCompletedStateAsync(state) {\n        await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .setCompletedStateAsync(this._cobuildContext, state);\n    }\n    async getCompletedStateAsync() {\n        const state = await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .getCompletedStateAsync(this._cobuildContext);\n        return state;\n    }\n    async tryAcquireLockAsync() {\n        const acquireLockResult = await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .acquireLockAsync(this._cobuildContext);\n        if (acquireLockResult) {\n            // renew the lock in a redundant way in case of losing the lock\n            await this.renewLockAsync();\n        }\n        return acquireLockResult;\n    }\n    async renewLockAsync() {\n        await this.cobuildConfiguration.getCobuildLockProvider().renewLockAsync(this._cobuildContext);\n    }\n    get cobuildContext() {\n        return this._cobuildContext;\n    }\n}\n//# sourceMappingURL=CobuildLock.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\n/**\n * A disjoint set data structure\n */\nexport class DisjointSet {\n    constructor() {\n        this._forest = new Set();\n        this._parentMap = new Map();\n        this._sizeMap = new Map();\n        this._setByElement = new Map();\n    }\n    destroy() {\n        var _a;\n        this._forest.clear();\n        this._parentMap.clear();\n        this._sizeMap.clear();\n        (_a = this._setByElement) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * Adds a new set containing specific object\n     */\n    add(x) {\n        if (this._forest.has(x)) {\n            return;\n        }\n        this._forest.add(x);\n        this._parentMap.set(x, x);\n        this._sizeMap.set(x, 1);\n        this._setByElement = undefined;\n    }\n    /**\n     * Unions the sets that contain two objects\n     */\n    union(a, b) {\n        let x = this._find(a);\n        let y = this._find(b);\n        if (x === y) {\n            // x and y are already in the same set\n            return;\n        }\n        const xSize = this._getSize(x);\n        const ySize = this._getSize(y);\n        if (xSize < ySize) {\n            const t = x;\n            x = y;\n            y = t;\n        }\n        this._parentMap.set(y, x);\n        this._sizeMap.set(x, xSize + ySize);\n        this._setByElement = undefined;\n    }\n    getAllSets() {\n        if (this._setByElement === undefined) {\n            this._setByElement = new Map();\n            for (const element of this._forest) {\n                const root = this._find(element);\n                let set = this._setByElement.get(root);\n                if (set === undefined) {\n                    set = new Set();\n                    this._setByElement.set(root, set);\n                }\n                set.add(element);\n            }\n        }\n        return this._setByElement.values();\n    }\n    /**\n     * Returns true if x and y are in the same set\n     */\n    isConnected(x, y) {\n        return this._find(x) === this._find(y);\n    }\n    _find(a) {\n        let x = a;\n        let parent = this._getParent(x);\n        while (parent !== x) {\n            parent = this._getParent(parent);\n            this._parentMap.set(x, parent);\n            x = parent;\n            parent = this._getParent(x);\n        }\n        return x;\n    }\n    _getParent(x) {\n        const parent = this._parentMap.get(x);\n        if (parent === undefined) {\n            // This should not happen\n            throw new InternalError(`Can not find parent`);\n        }\n        return parent;\n    }\n    _getSize(x) {\n        const size = this._sizeMap.get(x);\n        if (size === undefined) {\n            // This should not happen\n            throw new InternalError(`Can not get size`);\n        }\n        return size;\n    }\n}\n//# sourceMappingURL=DisjointSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, JsonSchema, Colors } from '@rushstack/node-core-library';\nimport schemaJson from '../../schemas/deploy-scenario.schema.json';\nclass DeployScenarioConfiguration {\n    constructor(json, projectJsonsByName) {\n        this.json = json;\n        this.projectJsonsByName = projectJsonsByName;\n    }\n    /**\n     * Validates that the input string conforms to the naming rules for a \"rush deploy\" scenario name.\n     */\n    static validateScenarioName(scenarioName) {\n        if (!scenarioName) {\n            throw new Error('The scenario name cannot be an empty string');\n        }\n        if (!this._scenarioNameRegExp.test(scenarioName)) {\n            throw new Error(`\"${scenarioName}\" is not a valid scenario name. The name must be comprised of` +\n                ' lowercase letters and numbers, separated by single hyphens. Example: \"my-scenario\"');\n        }\n    }\n    /**\n     * Given the --scenarioName value, return the full path of the filename.\n     *\n     * Example: \"ftp-site\" --> \"...common/config/rush/deploy-ftp-site.json\"\n     * Example: undefined --> \"...common/config/rush/deploy.json\"\n     */\n    static getConfigFilePath(scenarioName, rushConfiguration) {\n        let scenarioFileName;\n        if (scenarioName) {\n            DeployScenarioConfiguration.validateScenarioName(scenarioName);\n            scenarioFileName = `deploy-${scenarioName}.json`;\n        }\n        else {\n            scenarioFileName = `deploy.json`;\n        }\n        return path.join(rushConfiguration.commonRushConfigFolder, scenarioFileName);\n    }\n    static loadFromFile(terminal, scenarioFilePath, rushConfiguration) {\n        if (!FileSystem.exists(scenarioFilePath)) {\n            throw new Error('The scenario config file was not found: ' + scenarioFilePath);\n        }\n        terminal.writeLine(Colors.cyan(`Loading deployment scenario: ${scenarioFilePath}`));\n        const deployScenarioJson = JsonFile.loadAndValidate(scenarioFilePath, DeployScenarioConfiguration._jsonSchema);\n        // Apply the defaults\n        if (!deployScenarioJson.linkCreation) {\n            deployScenarioJson.linkCreation = 'default';\n        }\n        const deployScenarioProjectJsonsByName = new Map();\n        for (const projectSetting of deployScenarioJson.projectSettings || []) {\n            // Validate projectSetting.projectName\n            if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {\n                throw new Error(`The \"projectSettings\" section refers to the project name \"${projectSetting.projectName}\"` +\n                    ` which was not found in rush.json`);\n            }\n            for (const additionalProjectsToInclude of projectSetting.additionalProjectsToInclude || []) {\n                if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {\n                    throw new Error(`The \"additionalProjectsToInclude\" setting refers to the` +\n                        ` project name \"${additionalProjectsToInclude}\" which was not found in rush.json`);\n                }\n            }\n            deployScenarioProjectJsonsByName.set(projectSetting.projectName, projectSetting);\n        }\n        return new DeployScenarioConfiguration(deployScenarioJson, deployScenarioProjectJsonsByName);\n    }\n}\n// Used by validateScenarioName()\n// Matches lowercase words separated by dashes.\n// Example: \"deploy-the-thing123\"\nDeployScenarioConfiguration._scenarioNameRegExp = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nDeployScenarioConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { DeployScenarioConfiguration };\n//# sourceMappingURL=DeployScenarioConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport { FileConstants, FileSystem, JsonFile, LockFile } from '@rushstack/node-core-library';\nimport { LastInstallFlag } from '../../api/LastInstallFlag';\nimport { Utilities } from '../../utilities/Utilities';\nimport { merge } from '../../utilities/objectUtilities';\nexport class InstallHelpers {\n    static generateCommonPackageJson(rushConfiguration, dependencies = new Map()) {\n        const commonPackageJson = {\n            dependencies: {},\n            description: 'Temporary file generated by the Rush tool',\n            name: 'rush-common',\n            private: true,\n            version: '0.0.0'\n        };\n        if (rushConfiguration.packageManager === 'pnpm') {\n            const { pnpmOptions } = rushConfiguration;\n            if (!commonPackageJson.pnpm) {\n                commonPackageJson.pnpm = {};\n            }\n            if (pnpmOptions.globalOverrides) {\n                commonPackageJson.pnpm.overrides = pnpmOptions.globalOverrides;\n            }\n            if (pnpmOptions.globalPackageExtensions) {\n                commonPackageJson.pnpm.packageExtensions = pnpmOptions.globalPackageExtensions;\n            }\n            if (pnpmOptions.globalPeerDependencyRules) {\n                commonPackageJson.pnpm.peerDependencyRules = pnpmOptions.globalPeerDependencyRules;\n            }\n            if (pnpmOptions.globalNeverBuiltDependencies) {\n                commonPackageJson.pnpm.neverBuiltDependencies = pnpmOptions.globalNeverBuiltDependencies;\n            }\n            if (pnpmOptions.globalAllowedDeprecatedVersions) {\n                commonPackageJson.pnpm.allowedDeprecatedVersions = pnpmOptions.globalAllowedDeprecatedVersions;\n            }\n            if (pnpmOptions.globalPatchedDependencies) {\n                commonPackageJson.pnpm.patchedDependencies = pnpmOptions.globalPatchedDependencies;\n            }\n            if (pnpmOptions.unsupportedPackageJsonSettings) {\n                merge(commonPackageJson, pnpmOptions.unsupportedPackageJsonSettings);\n            }\n        }\n        // Add any preferred versions to the top of the commonPackageJson\n        // do this in alphabetical order for simpler debugging\n        for (const dependency of Array.from(dependencies.keys()).sort()) {\n            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);\n        }\n        // Example: \"C:\\MyRepo\\common\\temp\\package.json\"\n        const commonPackageJsonFilename = path.join(rushConfiguration.commonTempFolder, FileConstants.PackageJson);\n        // Don't update the file timestamp unless the content has changed, since \"rush install\"\n        // will consider this timestamp\n        JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });\n    }\n    static getPackageManagerEnvironment(rushConfiguration, options = {}) {\n        let configurationEnvironment = undefined;\n        if (rushConfiguration.packageManager === 'npm') {\n            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;\n            }\n        }\n        else if (rushConfiguration.packageManager === 'pnpm') {\n            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;\n            }\n        }\n        else if (rushConfiguration.packageManager === 'yarn') {\n            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;\n            }\n        }\n        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);\n    }\n    /**\n     * If the \"(p)npm-local\" symlink hasn't been set up yet, this creates it, installing the\n     * specified (P)npm version in the user's home directory if needed.\n     */\n    static async ensureLocalPackageManager(rushConfiguration, rushGlobalFolder, maxInstallAttempts, restrictConsoleOutput) {\n        let logIfConsoleOutputIsNotRestricted;\n        if (restrictConsoleOutput) {\n            logIfConsoleOutputIsNotRestricted = () => {\n                /* noop */\n            };\n        }\n        else {\n            logIfConsoleOutputIsNotRestricted = (message) => {\n                // eslint-disable-next-line no-console\n                console.log(message);\n            };\n        }\n        // Example: \"C:\\Users\\YourName\\.rush\"\n        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;\n        if (!FileSystem.exists(rushUserFolder)) {\n            logIfConsoleOutputIsNotRestricted('Creating ' + rushUserFolder);\n            FileSystem.ensureFolder(rushUserFolder);\n        }\n        const packageManager = rushConfiguration.packageManager;\n        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;\n        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;\n        // Example: \"C:\\Users\\YourName\\.rush\\pnpm-1.2.3\"\n        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);\n        const packageManagerMarker = new LastInstallFlag(packageManagerToolFolder, {\n            node: process.versions.node\n        });\n        logIfConsoleOutputIsNotRestricted(`Trying to acquire lock for ${packageManagerAndVersion}`);\n        const lock = await LockFile.acquire(rushUserFolder, packageManagerAndVersion);\n        logIfConsoleOutputIsNotRestricted(`Acquired lock for ${packageManagerAndVersion}`);\n        if (!packageManagerMarker.isValid() || lock.dirtyWhenAcquired) {\n            logIfConsoleOutputIsNotRestricted(colors.bold(`Installing ${packageManager} version ${packageManagerVersion}\\n`));\n            // note that this will remove the last-install flag from the directory\n            Utilities.installPackageInDirectory({\n                directory: packageManagerToolFolder,\n                packageName: packageManager,\n                version: rushConfiguration.packageManagerToolVersion,\n                tempPackageTitle: `${packageManager}-local-install`,\n                maxInstallAttempts: maxInstallAttempts,\n                // This is using a local configuration to install a package in a shared global location.\n                // Generally that's a bad practice, but in this case if we can successfully install\n                // the package at all, we can reasonably assume it's good for all the repositories.\n                // In particular, we'll assume that two different NPM registries cannot have two\n                // different implementations of the same version of the same package.\n                // This was needed for: https://github.com/microsoft/rushstack/issues/691\n                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder\n            });\n            logIfConsoleOutputIsNotRestricted(`Successfully installed ${packageManager} version ${packageManagerVersion}`);\n        }\n        else {\n            logIfConsoleOutputIsNotRestricted(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);\n        }\n        packageManagerMarker.create();\n        // Example: \"C:\\MyRepo\\common\\temp\"\n        FileSystem.ensureFolder(rushConfiguration.commonTempFolder);\n        // Example: \"C:\\MyRepo\\common\\temp\\pnpm-local\"\n        const localPackageManagerToolFolder = path.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);\n        logIfConsoleOutputIsNotRestricted(`\\nSymlinking \"${localPackageManagerToolFolder}\"`);\n        logIfConsoleOutputIsNotRestricted(`  --> \"${packageManagerToolFolder}\"`);\n        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will\n        // return false for broken symlinks.  There is no way to test without catching an exception.\n        try {\n            FileSystem.deleteFolder(localPackageManagerToolFolder);\n        }\n        catch (error) {\n            if (error.code !== 'ENOENT') {\n                throw error;\n            }\n        }\n        FileSystem.createSymbolicLinkJunction({\n            linkTargetPath: packageManagerToolFolder,\n            newLinkPath: localPackageManagerToolFolder\n        });\n        lock.release();\n    }\n    // Helper for getPackageManagerEnvironment\n    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {\n        const packageManagerEnv = baseEnv;\n        if (environmentVariables) {\n            // eslint-disable-next-line guard-for-in\n            for (const envVar in environmentVariables) {\n                let setEnvironmentVariable = true;\n                // eslint-disable-next-line no-console\n                console.log(`\\nProcessing definition for environment variable: ${envVar}`);\n                if (baseEnv.hasOwnProperty(envVar)) {\n                    setEnvironmentVariable = false;\n                    // eslint-disable-next-line no-console\n                    console.log(`Environment variable already defined:`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Name: ${envVar}`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Existing value: ${baseEnv[envVar]}`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Value set in rush.json: ${environmentVariables[envVar].value}`);\n                    if (environmentVariables[envVar].override) {\n                        setEnvironmentVariable = true;\n                        // eslint-disable-next-line no-console\n                        console.log(`Overriding the environment variable with the value set in rush.json.`);\n                    }\n                    else {\n                        // eslint-disable-next-line no-console\n                        console.log(colors.yellow(`WARNING: Not overriding the value of the environment variable.`));\n                    }\n                }\n                if (setEnvironmentVariable) {\n                    if (options.debug) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Setting environment variable for package manager.`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  Name: ${envVar}`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  Value: ${environmentVariables[envVar].value}`);\n                    }\n                    packageManagerEnv[envVar] = environmentVariables[envVar].value;\n                }\n            }\n        }\n        return packageManagerEnv;\n    }\n}\n//# sourceMappingURL=InstallHelpers.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\n/**\n * Options that are only used when the NPM package manager is selected.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the NPM package manager\n * is not being used.\n *\n * @public\n */\nexport class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        super(json);\n    }\n}\n//# sourceMappingURL=NpmOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { DependencySpecifier } from '../DependencySpecifier';\nexport class NpmShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        // Normalize the data\n        if (!this._shrinkwrapJson.version) {\n            this._shrinkwrapJson.version = '';\n        }\n        if (!this._shrinkwrapJson.name) {\n            this._shrinkwrapJson.name = '';\n        }\n        if (!this._shrinkwrapJson.dependencies) {\n            this._shrinkwrapJson.dependencies = {};\n        }\n        // Workspaces not supported in NPM\n        this.isWorkspaceCompatible = false;\n    }\n    static loadFromFile(shrinkwrapJsonFilename) {\n        try {\n            const shrinkwrapContent = FileSystem.readFile(shrinkwrapJsonFilename);\n            return NpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                return undefined; // file does not exist\n            }\n            throw new Error(`Error reading \"${shrinkwrapJsonFilename}\":\\n  ${error.message}`);\n        }\n    }\n    static loadFromString(shrinkwrapContent) {\n        // strip BOM\n        const data = shrinkwrapContent.charCodeAt(0) === 0xfeff ? shrinkwrapContent.slice(1) : shrinkwrapContent;\n        // We don't use JsonFile/jju here because shrinkwrap.json is a special NPM file format\n        // and typically very large, so we want to load it the same way that NPM does.\n        return new NpmShrinkwrapFile(JSON.parse(data));\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);\n    }\n    /** @override */\n    serialize() {\n        return JsonFile.stringify(this._shrinkwrapJson);\n    }\n    /** @override */\n    getTopLevelDependencyVersion(dependencyName) {\n        // First, check under tempProjectName, as this is the first place we look during linking.\n        const dependencyJson = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);\n        if (!dependencyJson) {\n            return undefined;\n        }\n        return new DependencySpecifier(dependencyName, dependencyJson.version);\n    }\n    /**\n     * @param dependencyName the name of the dependency to get a version for\n     * @param tempProjectName the name of the temp project to check for this dependency\n     * @param versionRange Not used, just exists to satisfy abstract API contract\n     * @override\n     */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        // First, check under tempProjectName, as this is the first place we look during linking.\n        let dependencyJson = undefined;\n        const tempDependency = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, tempProjectName);\n        if (tempDependency && tempDependency.dependencies) {\n            dependencyJson = NpmShrinkwrapFile.tryGetValue(tempDependency.dependencies, dependencySpecifier.packageName);\n        }\n        // Otherwise look at the root of the shrinkwrap file\n        if (!dependencyJson) {\n            return this.getTopLevelDependencyVersion(dependencySpecifier.packageName);\n        }\n        return new DependencySpecifier(dependencySpecifier.packageName, dependencyJson.version);\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return undefined;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, variant) {\n        throw new InternalError('Not implemented');\n    }\n}\n//# sourceMappingURL=NpmShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { OperationStatus } from './OperationStatus';\n/**\n * When the queue returns an unassigned operation, it means there is at least one remote executing operation,\n * at this time, the caller has a chance to make a decision:\n * 1. Manually invoke `tryGetRemoteExecutingOperation()` to get the remote executing operation.\n * 2. If there is no remote executing operation available, wait for some time and return in callback, which\n * internally invoke `assignOperations()` to assign new operations.\n * NOTE: the caller must wait for some time to avoid busy loop and burn CPU cycles.\n */\nexport const UNASSIGNED_OPERATION = 'UNASSIGNED_OPERATION';\n/**\n * Implementation of the async iteration protocol for a collection of IOperation objects.\n * The async iterator will wait for an operation to be ready for execution, or terminate if there are no more operations.\n *\n * @remarks\n * If the caller does not update dependencies prior to invoking `next()` on the iterator again,\n * it must manually invoke `assignOperations()` after performing the updates, otherwise iterators will\n * stall until another operations completes.\n */\nexport class AsyncOperationQueue {\n    /**\n     * @param operations - The set of operations to be executed\n     * @param sortFn - A function that sorts operations in reverse priority order:\n     *   - Returning a positive value indicates that `a` should execute before `b`.\n     *   - Returning a negative value indicates that `b` should execute before `a`.\n     *   - Returning 0 indicates no preference.\n     */\n    constructor(operations, sortFn) {\n        this._queue = computeTopologyAndSort(operations, sortFn);\n        this._pendingIterators = [];\n        this._totalOperations = this._queue.length;\n        this._isDone = false;\n        this._completedOperations = new Set();\n    }\n    /**\n     * For use with `for await (const operation of taskQueue)`\n     * @see {AsyncIterator}\n     */\n    next() {\n        const { _pendingIterators: waitingIterators } = this;\n        const promise = new Promise((resolve) => {\n            waitingIterators.push(resolve);\n        });\n        this.assignOperations();\n        return promise;\n    }\n    /**\n     * Set a callback to be invoked when one operation is completed.\n     * If all operations are completed, set the queue to done, resolve all pending iterators in next cycle.\n     */\n    complete(record) {\n        this._completedOperations.add(record);\n        // Apply status changes to direct dependents\n        if (record.status !== OperationStatus.Failure && record.status !== OperationStatus.Blocked) {\n            // Only do so if the operation did not fail or get blocked\n            for (const item of record.consumers) {\n                // Remove this operation from the dependencies, to unblock the scheduler\n                if (item.dependencies.delete(record) &&\n                    item.dependencies.size === 0 &&\n                    item.status === OperationStatus.Waiting) {\n                    item.status = OperationStatus.Ready;\n                }\n            }\n        }\n        if (this._completedOperations.size === this._totalOperations) {\n            this._isDone = true;\n        }\n    }\n    /**\n     * Routes ready operations with 0 dependencies to waiting iterators. Normally invoked as part of `next()`, but\n     * if the caller does not update operation dependencies prior to calling `next()`, may need to be invoked manually.\n     */\n    assignOperations() {\n        const { _queue: queue, _pendingIterators: waitingIterators } = this;\n        // By iterating in reverse order we do less array shuffling when removing operations\n        for (let i = queue.length - 1; waitingIterators.length > 0 && i >= 0; i--) {\n            const record = queue[i];\n            if (record.status === OperationStatus.Blocked ||\n                record.status === OperationStatus.Skipped ||\n                record.status === OperationStatus.Success ||\n                record.status === OperationStatus.SuccessWithWarning ||\n                record.status === OperationStatus.FromCache ||\n                record.status === OperationStatus.NoOp ||\n                record.status === OperationStatus.Failure) {\n                // It shouldn't be on the queue, remove it\n                queue.splice(i, 1);\n            }\n            else if (record.status === OperationStatus.Queued || record.status === OperationStatus.Executing) {\n                // This operation is currently executing\n                // next one plz :)\n            }\n            else if (record.status === OperationStatus.Waiting) {\n                // This operation is not yet ready to be executed\n                // next one plz :)\n                continue;\n            }\n            else if (record.status === OperationStatus.RemoteExecuting) {\n                // This operation is not ready to execute yet, but it may become ready later\n                // next one plz :)\n                continue;\n            }\n            else if (record.status !== OperationStatus.Ready) {\n                // Sanity check\n                throw new Error(`Unexpected status \"${record.status}\" for queued operation: ${record.name}`);\n            }\n            else {\n                // This task is ready to process, hand it to the iterator.\n                // Needs to have queue semantics, otherwise tools that iterate it get confused\n                record.status = OperationStatus.Queued;\n                waitingIterators.shift()({\n                    value: record,\n                    done: false\n                });\n            }\n            // Otherwise operation is still waiting\n        }\n        // Since items only get removed from the queue when they have a final status, this should be safe.\n        if (queue.length === 0) {\n            this._isDone = true;\n        }\n        if (this._isDone) {\n            for (const resolveAsyncIterator of waitingIterators.splice(0)) {\n                resolveAsyncIterator({\n                    value: undefined,\n                    done: true\n                });\n            }\n            return;\n        }\n        if (waitingIterators.length > 0) {\n            // returns an unassigned operation to let caller decide when there is at least one\n            // remote executing operation which is not ready to process.\n            if (queue.some((operation) => operation.status === OperationStatus.RemoteExecuting)) {\n                waitingIterators.shift()({\n                    value: UNASSIGNED_OPERATION,\n                    done: false\n                });\n            }\n        }\n    }\n    tryGetRemoteExecutingOperation() {\n        const { _queue: queue } = this;\n        // cycle through the queue to find the next operation that is executed remotely\n        for (let i = queue.length - 1; i >= 0; i--) {\n            const operation = queue[i];\n            if (operation.status === OperationStatus.RemoteExecuting) {\n                return operation;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns this queue as an async iterator, such that multiple functions iterating this object concurrently\n     * receive distinct iteration results.\n     */\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n}\n/**\n * Performs a depth-first search to topologically sort the operations, subject to override via sortFn\n */\nfunction computeTopologyAndSort(operations, sortFn) {\n    // Clone the set of operations as an array, so that we can sort it.\n    const queue = Array.from(operations);\n    // Create a collection for detecting visited nodes\n    const cycleDetectorStack = new Set();\n    for (const operation of queue) {\n        calculateCriticalPathLength(operation, cycleDetectorStack);\n    }\n    return queue.sort(sortFn);\n}\n/**\n * Perform a depth-first search to find critical path length.\n * Cycle detection comes at minimal additional cost.\n */\nfunction calculateCriticalPathLength(operation, dependencyChain) {\n    if (dependencyChain.has(operation)) {\n        throw new Error('A cyclic dependency was encountered:\\n  ' +\n            [...dependencyChain, operation]\n                .map((visitedTask) => visitedTask.name)\n                .reverse()\n                .join('\\n  -> ') +\n            '\\nConsider using the decoupledLocalDependencies option for rush.json.');\n    }\n    let { criticalPathLength } = operation;\n    if (criticalPathLength !== undefined) {\n        // This has been visited already\n        return criticalPathLength;\n    }\n    criticalPathLength = 0;\n    if (operation.consumers.size) {\n        dependencyChain.add(operation);\n        for (const consumer of operation.consumers) {\n            criticalPathLength = Math.max(criticalPathLength, calculateCriticalPathLength(consumer, dependencyChain));\n        }\n        dependencyChain.delete(operation);\n    }\n    // Include the contribution from the current operation\n    operation.criticalPathLength = criticalPathLength + operation.weight;\n    // Directly writing operations to an output collection here would yield a topological sorted set\n    // However, we want a bit more fine-tuning of the output than just the raw topology\n    return criticalPathLength;\n}\n//# sourceMappingURL=AsyncOperationQueue.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\nimport { Async, InternalError, NewlineKind, Sort, Terminal } from '@rushstack/node-core-library';\nimport { CollatedTerminal } from '@rushstack/stream-collator';\nimport { DiscardStdoutTransform, TextRewriterTransform } from '@rushstack/terminal';\nimport { SplitterTransform } from '@rushstack/terminal';\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { OperationStatus } from './OperationStatus';\nimport { CobuildLock } from '../cobuild/CobuildLock';\nimport { ProjectBuildCache } from '../buildCache/ProjectBuildCache';\nimport { RushConstants } from '../RushConstants';\nimport { getHashesForGlobsAsync } from '../buildCache/getHashesForGlobsAsync';\nimport { ProjectLogWritable } from './ProjectLogWritable';\nimport { DisjointSet } from '../cobuild/DisjointSet';\nimport { PeriodicCallback } from './PeriodicCallback';\nimport { NullTerminalProvider } from '../../utilities/NullTerminalProvider';\nconst PLUGIN_NAME = 'CacheablePhasedOperationPlugin';\nconst PERIODIC_CALLBACK_INTERVAL_IN_SECONDS = 10;\nexport class CacheableOperationPlugin {\n    constructor(options) {\n        this._buildCacheContextByOperation = new Map();\n        this._options = options;\n    }\n    apply(hooks) {\n        const { allowWarningsInSuccessfulBuild, buildCacheConfiguration, cobuildConfiguration, terminal } = this._options;\n        hooks.beforeExecuteOperations.tapPromise(PLUGIN_NAME, async (recordByOperation, context) => {\n            const { isIncrementalBuildAllowed, projectChangeAnalyzer, projectConfigurations, isInitial } = context;\n            const disjointSet = (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)\n                ? new DisjointSet()\n                : undefined;\n            await Async.forEachAsync(recordByOperation.keys(), async (operation) => {\n                const { associatedProject, associatedPhase, runner } = operation;\n                if (!associatedProject || !associatedPhase || !runner) {\n                    return;\n                }\n                const { name: phaseName } = associatedPhase;\n                const projectConfiguration = projectConfigurations.get(associatedProject);\n                // This value can *currently* be cached per-project, but in the future the list of files will vary\n                // depending on the selected phase.\n                const fileHashes = await projectChangeAnalyzer._tryGetProjectDependenciesAsync(associatedProject, terminal);\n                if (!fileHashes) {\n                    throw new Error(`Build cache is only supported if running in a Git repository. Either disable the build cache or run Rush in a Git repository.`);\n                }\n                const operationSettings = projectConfiguration === null || projectConfiguration === void 0 ? void 0 : projectConfiguration.operationSettingsByOperationName.get(phaseName);\n                const cacheDisabledReason = projectConfiguration\n                    ? projectConfiguration.getCacheDisabledReason(fileHashes.keys(), phaseName)\n                    : `Project does not have a ${RushConstants.rushProjectConfigFilename} configuration file, ` +\n                        'or one provided by a rig, so it does not support caching.';\n                disjointSet === null || disjointSet === void 0 ? void 0 : disjointSet.add(operation);\n                const buildCacheContext = {\n                    // Supports cache writes by default for initial operations.\n                    // Don't write during watch runs for performance reasons (and to avoid flooding the cache)\n                    isCacheWriteAllowed: isInitial,\n                    isCacheReadAllowed: isIncrementalBuildAllowed,\n                    projectBuildCache: undefined,\n                    projectChangeAnalyzer,\n                    operationSettings,\n                    cacheDisabledReason,\n                    cobuildLock: undefined,\n                    cobuildClusterId: undefined,\n                    buildCacheTerminal: undefined,\n                    buildCacheProjectLogWritable: undefined,\n                    periodicCallback: new PeriodicCallback({\n                        interval: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 1000\n                    }),\n                    cacheRestored: false,\n                    isCacheReadAttempted: false\n                };\n                // Upstream runners may mutate the property of build cache context for downstream runners\n                this._buildCacheContextByOperation.set(operation, buildCacheContext);\n            }, {\n                concurrency: 10\n            });\n            if (disjointSet) {\n                // If disjoint set exists, connect build cache disabled project with its consumers\n                for (const [operation, { cacheDisabledReason }] of this._buildCacheContextByOperation) {\n                    const { associatedProject: project, associatedPhase: phase } = operation;\n                    if (project && phase) {\n                        if (cacheDisabledReason) {\n                            /**\n                             * Group the project build cache disabled with its consumers. This won't affect too much in\n                             * a monorepo with high build cache coverage.\n                             *\n                             * The mental model is that if X disables the cache, and Y depends on X, then:\n                             *   1. Y must be built by the same VM that build X;\n                             *   2. OR, Y must be rebuilt on each VM that needs it.\n                             * Approach 1 is probably the better choice.\n                             */\n                            for (const consumer of operation.consumers) {\n                                disjointSet === null || disjointSet === void 0 ? void 0 : disjointSet.union(operation, consumer);\n                            }\n                        }\n                    }\n                }\n                for (const operationSet of disjointSet.getAllSets()) {\n                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) && cobuildConfiguration.cobuildContextId) {\n                        // Get a deterministic ordered array of operations, which is important to get a deterministic cluster id.\n                        const groupedOperations = Array.from(operationSet);\n                        Sort.sortBy(groupedOperations, (operation) => {\n                            return operation.name;\n                        });\n                        // Generates cluster id, cluster id comes from the project folder and phase name of all operations in the same cluster.\n                        const hash = crypto.createHash('sha1');\n                        for (const operation of groupedOperations) {\n                            const { associatedPhase: phase, associatedProject: project } = operation;\n                            if (project && phase) {\n                                hash.update(project.projectRelativeFolder);\n                                hash.update(RushConstants.hashDelimiter);\n                                hash.update(phase.name);\n                                hash.update(RushConstants.hashDelimiter);\n                            }\n                        }\n                        const cobuildClusterId = hash.digest('hex');\n                        // Assign same cluster id to all operations in the same cluster.\n                        for (const record of groupedOperations) {\n                            const buildCacheContext = this._getBuildCacheContextByOperationOrThrow(record);\n                            buildCacheContext.cobuildClusterId = cobuildClusterId;\n                        }\n                    }\n                }\n            }\n        });\n        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {\n            var _a;\n            if (this._buildCacheContextByOperation.size === 0) {\n                return;\n            }\n            const buildCacheContext = this._getBuildCacheContextByOperation(runnerContext.operation);\n            if (!buildCacheContext) {\n                return;\n            }\n            const record = runnerContext;\n            const { associatedProject: project, associatedPhase: phase, runner, _operationMetadataManager: operationMetadataManager } = record;\n            if (!project || !phase || !(runner === null || runner === void 0 ? void 0 : runner.cacheable)) {\n                return;\n            }\n            const runBeforeExecute = async () => {\n                const buildCacheTerminal = this._getBuildCacheTerminal({\n                    record,\n                    buildCacheContext,\n                    buildCacheEnabled: buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled,\n                    rushProject: project,\n                    logFilenameIdentifier: phase.logFilenameIdentifier,\n                    quietMode: record.quietMode,\n                    debugMode: record.debugMode\n                });\n                buildCacheContext.buildCacheTerminal = buildCacheTerminal;\n                const configHash = runner.getConfigHash() || '';\n                let projectBuildCache = await this._tryGetProjectBuildCacheAsync({\n                    buildCacheContext,\n                    buildCacheConfiguration,\n                    rushProject: project,\n                    phase,\n                    configHash,\n                    terminal: buildCacheTerminal,\n                    operationMetadataManager\n                });\n                // Try to acquire the cobuild lock\n                let cobuildLock;\n                if (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) {\n                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildLeafProjectLogOnlyAllowed) &&\n                        record.operation.consumers.size === 0 &&\n                        !projectBuildCache) {\n                        // When the leaf project log only is allowed and the leaf project is build cache \"disabled\", try to get\n                        // a log files only project build cache\n                        projectBuildCache = await this._tryGetLogOnlyProjectBuildCacheAsync({\n                            buildCacheConfiguration,\n                            cobuildConfiguration,\n                            buildCacheContext,\n                            rushProject: project,\n                            phase,\n                            configHash,\n                            terminal: buildCacheTerminal,\n                            operationMetadataManager\n                        });\n                        if (projectBuildCache) {\n                            buildCacheTerminal.writeVerboseLine(`Log files only build cache is enabled for the project \"${project.packageName}\" because the cobuild leaf project log only is allowed`);\n                        }\n                        else {\n                            buildCacheTerminal.writeWarningLine(`Failed to get log files only build cache for the project \"${project.packageName}\"`);\n                        }\n                    }\n                    cobuildLock = await this._tryGetCobuildLockAsync({\n                        buildCacheContext,\n                        projectBuildCache,\n                        cobuildConfiguration,\n                        packageName: project.packageName,\n                        phaseName: phase.name\n                    });\n                }\n                // eslint-disable-next-line require-atomic-updates -- we are mutating the build cache context intentionally\n                buildCacheContext.cobuildLock = cobuildLock;\n                // If possible, we want to skip this operation -- either by restoring it from the\n                // cache, if caching is enabled, or determining that the project\n                // is unchanged (using the older incremental execution logic). These two approaches,\n                // \"caching\" and \"skipping\", are incompatible, so only one applies.\n                //\n                // Note that \"caching\" and \"skipping\" take two different approaches\n                // to tracking dependents:\n                //\n                //   - For caching, \"isCacheReadAllowed\" is set if a project supports\n                //     incremental builds, and determining whether this project or a dependent\n                //     has changed happens inside the hashing logic.\n                //\n                const { logPath, errorLogPath } = ProjectLogWritable.getLogFilePaths({\n                    project,\n                    logFilenameIdentifier: phase.logFilenameIdentifier\n                });\n                const restoreCacheAsync = async (\n                // TODO: Investigate if `projectBuildCacheForRestore` is always the same instance as `projectBuildCache`\n                // above, and if it is, remove this parameter\n                projectBuildCacheForRestore, specifiedCacheId) => {\n                    buildCacheContext.isCacheReadAttempted = true;\n                    const restoreFromCacheSuccess = await (projectBuildCacheForRestore === null || projectBuildCacheForRestore === void 0 ? void 0 : projectBuildCacheForRestore.tryRestoreFromCacheAsync(buildCacheTerminal, specifiedCacheId));\n                    if (restoreFromCacheSuccess) {\n                        buildCacheContext.cacheRestored = true;\n                        // Restore the original state of the operation without cache\n                        await (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.tryRestoreAsync({\n                            terminal: buildCacheTerminal,\n                            logPath,\n                            errorLogPath\n                        }));\n                    }\n                    return !!restoreFromCacheSuccess;\n                };\n                if (cobuildLock) {\n                    // handling rebuilds. \"rush rebuild\" or \"rush retest\" command will save operations to\n                    // the build cache once completed, but does not retrieve them (since the \"incremental\"\n                    // flag is disabled). However, we still need a cobuild to be able to retrieve a finished\n                    // build from another cobuild in this case.\n                    const cobuildCompletedState = await cobuildLock.getCompletedStateAsync();\n                    if (cobuildCompletedState) {\n                        const { status, cacheId } = cobuildCompletedState;\n                        const restoreFromCacheSuccess = await restoreCacheAsync(cobuildLock.projectBuildCache, cacheId);\n                        if (restoreFromCacheSuccess) {\n                            if (cobuildCompletedState) {\n                                return cobuildCompletedState.status;\n                            }\n                            return status;\n                        }\n                    }\n                    else if (!buildCacheContext.isCacheReadAttempted && buildCacheContext.isCacheReadAllowed) {\n                        const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);\n                        if (restoreFromCacheSuccess) {\n                            return OperationStatus.FromCache;\n                        }\n                    }\n                }\n                else if (buildCacheContext.isCacheReadAllowed) {\n                    const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);\n                    if (restoreFromCacheSuccess) {\n                        return OperationStatus.FromCache;\n                    }\n                }\n                if (buildCacheContext.isCacheWriteAllowed && cobuildLock) {\n                    const acquireSuccess = await cobuildLock.tryAcquireLockAsync();\n                    if (acquireSuccess) {\n                        const { periodicCallback } = buildCacheContext;\n                        periodicCallback.addCallback(async () => {\n                            await (cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.renewLockAsync());\n                        });\n                        periodicCallback.start();\n                    }\n                    else {\n                        // failed to acquire the lock, mark current operation to remote executing\n                        return OperationStatus.RemoteExecuting;\n                    }\n                }\n            };\n            try {\n                const earlyReturnStatus = await runBeforeExecute();\n                return earlyReturnStatus;\n            }\n            catch (e) {\n                (_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.close();\n                throw e;\n            }\n        });\n        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {\n            var _a;\n            const record = runnerContext;\n            const { status, stopwatch, _operationMetadataManager: operationMetadataManager, operation } = record;\n            const { associatedProject: project, associatedPhase: phase, runner } = operation;\n            if (!project || !phase || !(runner === null || runner === void 0 ? void 0 : runner.cacheable)) {\n                return;\n            }\n            const buildCacheContext = this._getBuildCacheContextByOperation(operation);\n            if (!buildCacheContext) {\n                return;\n            }\n            // No need to run for the following operation status\n            switch (record.status) {\n                case OperationStatus.NoOp:\n                case OperationStatus.RemoteExecuting: {\n                    return;\n                }\n                default: {\n                    break;\n                }\n            }\n            const { cobuildLock, projectBuildCache, isCacheWriteAllowed, buildCacheTerminal, cacheRestored } = buildCacheContext;\n            try {\n                if (!cacheRestored) {\n                    // Save the metadata to disk\n                    const { logFilenameIdentifier } = phase;\n                    const { duration: durationInSeconds } = stopwatch;\n                    const { logPath, errorLogPath } = ProjectLogWritable.getLogFilePaths({\n                        project,\n                        logFilenameIdentifier\n                    });\n                    await (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.saveAsync({\n                        durationInSeconds,\n                        cobuildContextId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildContextId,\n                        cobuildRunnerId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildRunnerId,\n                        logPath,\n                        errorLogPath\n                    }));\n                }\n                if (!buildCacheTerminal) {\n                    // This should not happen\n                    throw new InternalError(`Build Cache Terminal is not created`);\n                }\n                let setCompletedStatePromiseFunction;\n                let setCacheEntryPromise;\n                if (cobuildLock && isCacheWriteAllowed) {\n                    const { cacheId, contextId } = cobuildLock.cobuildContext;\n                    const finalCacheId = status === OperationStatus.Failure ? `${cacheId}-${contextId}-failed` : cacheId;\n                    switch (status) {\n                        case OperationStatus.SuccessWithWarning:\n                        case OperationStatus.Success:\n                        case OperationStatus.Failure: {\n                            const currentStatus = status;\n                            setCompletedStatePromiseFunction = () => {\n                                return cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.setCompletedStateAsync({\n                                    status: currentStatus,\n                                    cacheId: finalCacheId\n                                });\n                            };\n                            setCacheEntryPromise = () => cobuildLock.projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal, finalCacheId);\n                        }\n                    }\n                }\n                const taskIsSuccessful = status === OperationStatus.Success ||\n                    (status === OperationStatus.SuccessWithWarning &&\n                        record.runner.warningsAreAllowed &&\n                        allowWarningsInSuccessfulBuild);\n                // If the command is successful, we can calculate project hash, and no dependencies were skipped,\n                // write a new cache entry.\n                if (!setCacheEntryPromise && taskIsSuccessful && isCacheWriteAllowed && projectBuildCache) {\n                    setCacheEntryPromise = () => projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal);\n                }\n                if (!cacheRestored) {\n                    const cacheWriteSuccess = await (setCacheEntryPromise === null || setCacheEntryPromise === void 0 ? void 0 : setCacheEntryPromise());\n                    await (setCompletedStatePromiseFunction === null || setCompletedStatePromiseFunction === void 0 ? void 0 : setCompletedStatePromiseFunction());\n                    if (cacheWriteSuccess === false && status === OperationStatus.Success) {\n                        record.status = OperationStatus.SuccessWithWarning;\n                    }\n                }\n            }\n            finally {\n                (_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.close();\n                buildCacheContext.periodicCallback.stop();\n            }\n        });\n        hooks.afterExecuteOperation.tap(PLUGIN_NAME, (record) => {\n            const { operation } = record;\n            const buildCacheContext = this._buildCacheContextByOperation.get(operation);\n            // Status changes to direct dependents\n            let blockCacheWrite = !(buildCacheContext === null || buildCacheContext === void 0 ? void 0 : buildCacheContext.isCacheWriteAllowed);\n            switch (record.status) {\n                case OperationStatus.Skipped: {\n                    // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.\n                    blockCacheWrite = true;\n                    break;\n                }\n            }\n            // Apply status changes to direct dependents\n            if (blockCacheWrite) {\n                for (const consumer of operation.consumers) {\n                    const consumerBuildCacheContext = this._getBuildCacheContextByOperation(consumer);\n                    if (consumerBuildCacheContext) {\n                        consumerBuildCacheContext.isCacheWriteAllowed = false;\n                    }\n                }\n            }\n        });\n        hooks.afterExecuteOperations.tapPromise(PLUGIN_NAME, async () => {\n            this._buildCacheContextByOperation.clear();\n        });\n    }\n    _getBuildCacheContextByOperation(operation) {\n        const buildCacheContext = this._buildCacheContextByOperation.get(operation);\n        return buildCacheContext;\n    }\n    _getBuildCacheContextByOperationOrThrow(operation) {\n        const buildCacheContext = this._getBuildCacheContextByOperation(operation);\n        if (!buildCacheContext) {\n            // This should not happen\n            throw new InternalError(`Build cache context for operation ${operation.name} should be defined`);\n        }\n        return buildCacheContext;\n    }\n    async _tryGetProjectBuildCacheAsync({ buildCacheConfiguration, buildCacheContext, rushProject, phase, configHash, terminal, operationMetadataManager }) {\n        if (!buildCacheContext.projectBuildCache) {\n            const { cacheDisabledReason } = buildCacheContext;\n            if (cacheDisabledReason) {\n                terminal.writeVerboseLine(cacheDisabledReason);\n                return;\n            }\n            const { operationSettings, projectChangeAnalyzer } = buildCacheContext;\n            if (!operationSettings || !buildCacheConfiguration) {\n                // Unreachable, since this will have set `cacheDisabledReason`.\n                return;\n            }\n            const projectOutputFolderNames = operationSettings.outputFolderNames || [];\n            const additionalProjectOutputFilePaths = (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.relativeFilepaths) || [];\n            const additionalContext = {};\n            await updateAdditionalContextAsync({\n                operationSettings,\n                additionalContext,\n                projectChangeAnalyzer,\n                terminal,\n                rushProject\n            });\n            // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n            buildCacheContext.projectBuildCache = await ProjectBuildCache.tryGetProjectBuildCache({\n                project: rushProject,\n                projectOutputFolderNames,\n                additionalProjectOutputFilePaths,\n                additionalContext,\n                buildCacheConfiguration,\n                terminal,\n                configHash,\n                projectChangeAnalyzer,\n                phaseName: phase.name\n            });\n        }\n        return buildCacheContext.projectBuildCache;\n    }\n    // Get a ProjectBuildCache only cache/restore log files\n    async _tryGetLogOnlyProjectBuildCacheAsync({ buildCacheContext, rushProject, terminal, configHash, buildCacheConfiguration, cobuildConfiguration, phase, operationMetadataManager }) {\n        var _a;\n        if (!(buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled)) {\n            return;\n        }\n        const { operationSettings, projectChangeAnalyzer } = buildCacheContext;\n        const projectOutputFolderNames = (_a = operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.outputFolderNames) !== null && _a !== void 0 ? _a : [];\n        const additionalProjectOutputFilePaths = (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.relativeFilepaths) || [];\n        const additionalContext = {\n            // Force the cache to be a log files only cache\n            logFilesOnly: '1'\n        };\n        if (cobuildConfiguration.cobuildContextId) {\n            additionalContext.cobuildContextId = cobuildConfiguration.cobuildContextId;\n        }\n        if (operationSettings) {\n            await updateAdditionalContextAsync({\n                operationSettings,\n                additionalContext,\n                projectChangeAnalyzer,\n                terminal,\n                rushProject\n            });\n        }\n        const projectBuildCache = await ProjectBuildCache.tryGetProjectBuildCache({\n            project: rushProject,\n            projectOutputFolderNames,\n            additionalProjectOutputFilePaths,\n            additionalContext,\n            buildCacheConfiguration,\n            terminal,\n            configHash,\n            projectChangeAnalyzer,\n            phaseName: phase.name\n        });\n        // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n        buildCacheContext.projectBuildCache = projectBuildCache;\n        return projectBuildCache;\n    }\n    async _tryGetCobuildLockAsync({ cobuildConfiguration, buildCacheContext, projectBuildCache, packageName, phaseName }) {\n        if (!buildCacheContext.cobuildLock) {\n            if (projectBuildCache && (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)) {\n                if (!buildCacheContext.cobuildClusterId) {\n                    // This should not happen\n                    throw new InternalError('Cobuild cluster id is not defined');\n                }\n                buildCacheContext.cobuildLock = new CobuildLock({\n                    cobuildConfiguration,\n                    projectBuildCache,\n                    cobuildClusterId: buildCacheContext.cobuildClusterId,\n                    lockExpireTimeInSeconds: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 3,\n                    packageName,\n                    phaseName\n                });\n            }\n        }\n        return buildCacheContext.cobuildLock;\n    }\n    _getBuildCacheTerminal({ record, buildCacheContext, buildCacheEnabled: buildCacheEnabled, rushProject, logFilenameIdentifier, quietMode, debugMode }) {\n        var _a;\n        if (!buildCacheContext.buildCacheTerminal ||\n            ((_a = buildCacheContext.buildCacheProjectLogWritable) === null || _a === void 0 ? void 0 : _a.isOpen) === false) {\n            // The ProjectLogWritable is does not exist or is closed, re-create one\n            buildCacheContext.buildCacheTerminal = this._createBuildCacheTerminal({\n                record,\n                buildCacheContext,\n                buildCacheEnabled,\n                rushProject,\n                logFilenameIdentifier,\n                quietMode,\n                debugMode\n            });\n        }\n        return buildCacheContext.buildCacheTerminal;\n    }\n    _createBuildCacheTerminal({ record, buildCacheContext, buildCacheEnabled, rushProject, logFilenameIdentifier, quietMode, debugMode }) {\n        const silent = record.runner.silent;\n        if (silent) {\n            const nullTerminalProvider = new NullTerminalProvider();\n            return new Terminal(nullTerminalProvider);\n        }\n        let cacheConsoleWritable;\n        // This creates the writer, only do this if necessary.\n        const collatedWriter = record.collatedWriter;\n        const cacheProjectLogWritable = this._tryGetBuildCacheProjectLogWritable({\n            buildCacheContext,\n            buildCacheEnabled,\n            rushProject,\n            collatedTerminal: collatedWriter.terminal,\n            logFilenameIdentifier\n        });\n        if (quietMode) {\n            const discardTransform = new DiscardStdoutTransform({\n                destination: collatedWriter\n            });\n            const normalizeNewlineTransform = new TextRewriterTransform({\n                destination: discardTransform,\n                normalizeNewlines: NewlineKind.Lf,\n                ensureNewlineAtEnd: true\n            });\n            cacheConsoleWritable = normalizeNewlineTransform;\n        }\n        else {\n            cacheConsoleWritable = collatedWriter;\n        }\n        let cacheCollatedTerminal;\n        if (cacheProjectLogWritable) {\n            const cacheSplitterTransform = new SplitterTransform({\n                destinations: [cacheConsoleWritable, cacheProjectLogWritable]\n            });\n            cacheCollatedTerminal = new CollatedTerminal(cacheSplitterTransform);\n        }\n        else {\n            cacheCollatedTerminal = new CollatedTerminal(cacheConsoleWritable);\n        }\n        const buildCacheTerminalProvider = new CollatedTerminalProvider(cacheCollatedTerminal, {\n            debugEnabled: debugMode\n        });\n        return new Terminal(buildCacheTerminalProvider);\n    }\n    _tryGetBuildCacheProjectLogWritable({ buildCacheEnabled, rushProject, buildCacheContext, collatedTerminal, logFilenameIdentifier }) {\n        // Only open the *.cache.log file(s) if the cache is enabled.\n        if (!buildCacheEnabled) {\n            return;\n        }\n        buildCacheContext.buildCacheProjectLogWritable = new ProjectLogWritable(rushProject, collatedTerminal, `${logFilenameIdentifier}.cache`);\n        return buildCacheContext.buildCacheProjectLogWritable;\n    }\n}\nasync function updateAdditionalContextAsync({ operationSettings, additionalContext, projectChangeAnalyzer, terminal, rushProject }) {\n    if (operationSettings.dependsOnEnvVars) {\n        for (const varName of operationSettings.dependsOnEnvVars) {\n            additionalContext['$' + varName] = process.env[varName] || '';\n        }\n    }\n    if (operationSettings.dependsOnAdditionalFiles) {\n        const repoState = await projectChangeAnalyzer._ensureInitializedAsync(terminal);\n        const additionalFiles = await getHashesForGlobsAsync(operationSettings.dependsOnAdditionalFiles, rushProject.projectFolder, repoState);\n        terminal.writeDebugLine(`Including additional files to calculate build cache hash:\\n  ${Array.from(additionalFiles.keys()).join('\\n  ')} `);\n        for (const [filePath, fileHash] of additionalFiles) {\n            additionalContext['file://' + filePath] = fileHash;\n        }\n    }\n}\n//# sourceMappingURL=CacheableOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport path from 'node:path';\nimport { Async, ColorValue, FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'LegacySkipPlugin';\nfunction _areShallowEqual(object1, object2) {\n    for (const n in object1) {\n        if (!(n in object2) || object1[n] !== object2[n]) {\n            return false;\n        }\n    }\n    for (const n in object2) {\n        if (!(n in object1)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Core phased command plugin that implements the legacy skip detection logic, used when build cache is disabled.\n */\nexport class LegacySkipPlugin {\n    constructor(options) {\n        this._options = options;\n    }\n    apply(hooks) {\n        const stateMap = new WeakMap();\n        let projectChangeAnalyzer;\n        const { terminal, changedProjectsOnly, isIncrementalBuildAllowed } = this._options;\n        hooks.createOperations.tap(PLUGIN_NAME, (operations, context) => {\n            projectChangeAnalyzer = context.projectChangeAnalyzer;\n            return operations;\n        });\n        hooks.beforeExecuteOperations.tapPromise(PLUGIN_NAME, async (operations) => {\n            let logGitWarning = false;\n            await Async.forEachAsync(operations.values(), async (record) => {\n                const { operation } = record;\n                const { associatedProject, associatedPhase, runner } = operation;\n                if (!associatedProject || !associatedPhase || !runner) {\n                    return;\n                }\n                if (!runner.cacheable) {\n                    stateMap.set(operation, {\n                        allowSkip: true,\n                        packageDeps: undefined,\n                        packageDepsPath: ''\n                    });\n                    return;\n                }\n                const packageDepsFilename = `package-deps_${associatedPhase.logFilenameIdentifier}.json`;\n                const packageDepsPath = path.join(associatedProject.projectRushTempFolder, packageDepsFilename);\n                let packageDeps;\n                try {\n                    const fileHashes = await projectChangeAnalyzer._tryGetProjectDependenciesAsync(associatedProject, terminal);\n                    if (!fileHashes) {\n                        logGitWarning = true;\n                        return;\n                    }\n                    const files = {};\n                    for (const [filePath, fileHash] of fileHashes) {\n                        files[filePath] = fileHash;\n                    }\n                    packageDeps = {\n                        files,\n                        arguments: runner.getConfigHash()\n                    };\n                }\n                catch (error) {\n                    // To test this code path:\n                    // Delete a project's \".rush/temp/shrinkwrap-deps.json\" then run \"rush build --verbose\"\n                    terminal.writeLine(`Unable to calculate incremental state for ${record.operation.name}: ` +\n                        error.toString());\n                    terminal.writeLine({\n                        text: 'Rush will proceed without incremental execution and change detection.',\n                        foregroundColor: ColorValue.Cyan\n                    });\n                }\n                stateMap.set(operation, {\n                    packageDepsPath,\n                    packageDeps,\n                    allowSkip: isIncrementalBuildAllowed\n                });\n            });\n            if (logGitWarning) {\n                // To test this code path:\n                // Remove the `.git` folder then run \"rush build --verbose\"\n                terminal.writeLine({\n                    text: PrintUtilities.wrapWords('This workspace does not appear to be tracked by Git. ' +\n                        'Rush will proceed without incremental execution, caching, and change detection.'),\n                    foregroundColor: ColorValue.Cyan\n                });\n            }\n        });\n        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {\n            const { operation } = record;\n            const skipRecord = stateMap.get(operation);\n            if (!skipRecord) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            if (!operation.runner.cacheable) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            const { associatedProject } = operation;\n            const { packageDepsPath, packageDeps, allowSkip } = skipRecord;\n            let lastProjectDeps = undefined;\n            try {\n                const lastDepsContents = await FileSystem.readFileAsync(packageDepsPath);\n                lastProjectDeps = JSON.parse(lastDepsContents);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    // Warn and ignore - treat failing to load the file as the operation being not built.\n                    // TODO: Update this to be the terminal specific to the operation.\n                    terminal.writeWarningLine(`Warning: error parsing ${packageDepsPath}: ${e}. Ignoring and treating this operation as not run.`);\n                }\n            }\n            if (allowSkip) {\n                const isPackageUnchanged = !!(lastProjectDeps &&\n                    packageDeps &&\n                    packageDeps.arguments === lastProjectDeps.arguments &&\n                    _areShallowEqual(packageDeps.files, lastProjectDeps.files));\n                if (isPackageUnchanged) {\n                    return OperationStatus.Skipped;\n                }\n            }\n            // TODO: Remove legacyDepsPath with the next major release of Rush\n            const legacyDepsPath = path.join(associatedProject.projectFolder, 'package-deps.json');\n            await Promise.all([\n                // Delete the legacy package-deps.json\n                FileSystem.deleteFileAsync(legacyDepsPath),\n                // If the deps file exists, remove it before starting execution.\n                FileSystem.deleteFileAsync(packageDepsPath)\n            ]);\n        });\n        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {\n            const { status, operation } = record;\n            const skipRecord = stateMap.get(operation);\n            if (!skipRecord) {\n                return;\n            }\n            const blockSkip = !skipRecord.allowSkip ||\n                (!changedProjectsOnly &&\n                    (status === OperationStatus.Success || status === OperationStatus.SuccessWithWarning));\n            if (blockSkip) {\n                for (const consumer of operation.consumers) {\n                    const consumerSkipRecord = stateMap.get(consumer);\n                    if (consumerSkipRecord) {\n                        consumerSkipRecord.allowSkip = false;\n                    }\n                }\n            }\n            if (!record.operation.runner.cacheable) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            const { packageDeps, packageDepsPath } = skipRecord;\n            if ((packageDeps && status === OperationStatus.Success) || status === OperationStatus.NoOp) {\n                // Write deps on success.\n                await JsonFile.saveAsync(packageDeps, packageDepsPath, {\n                    ensureFolderExists: true\n                });\n            }\n        });\n    }\n}\n//# sourceMappingURL=LegacySkipPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Implementation of `IOperationRunner` for operations that require no work, such as empty scripts,\n * skipped operations, or blocked operations.\n */\nexport class NullOperationRunner {\n    constructor({ name, result, silent }) {\n        // This operation does nothing, so timing is meaningless\n        this.reportTiming = false;\n        // The operation is a no-op, so it is faster to not cache it\n        this.cacheable = false;\n        // Nothing will get logged, no point allowing warnings\n        this.warningsAreAllowed = false;\n        this.isNoOp = true;\n        this.name = name;\n        this.result = result;\n        this.silent = silent;\n    }\n    async executeAsync(context) {\n        return this.result;\n    }\n    getConfigHash() {\n        return '';\n    }\n}\n//# sourceMappingURL=NullOperationRunner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the\n * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose\n * implementation manages the actual process of running a single operation.\n *\n * The graph of `Operation` instances will be cloned into a separate execution graph after processing.\n *\n * @alpha\n */\nexport class Operation {\n    constructor(options) {\n        /**\n         * A set of all operations which depend on this operation.\n         */\n        this.consumers = new Set();\n        /**\n         * A set of all dependencies which must be executed before this operation is complete.\n         */\n        this.dependencies = new Set();\n        /**\n         * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of\n         * running the operation.\n         */\n        this.runner = undefined;\n        /**\n         * The weight for this operation. This scalar is the contribution of this operation to the\n         * `criticalPathLength` calculation above. Modify to indicate the following:\n         * - `weight` === 1: indicates that this operation has an average duration\n         * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler\n         *     should try to favor starting it over other, shorter operations. An example might be an operation that\n         *     bundles an entire application and runs whole-program optimization.\n         * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler\n         *     should favor other, longer operations over it. An example might be an operation to unpack a cached\n         *     output, or an operation using NullOperationRunner, which might use a value of 0.\n         */\n        this.weight = 1;\n        this.associatedPhase = options === null || options === void 0 ? void 0 : options.phase;\n        this.associatedProject = options === null || options === void 0 ? void 0 : options.project;\n        this.runner = options === null || options === void 0 ? void 0 : options.runner;\n    }\n    /**\n     * The name of this operation, for logging.\n     */\n    get name() {\n        var _a;\n        return (_a = this.runner) === null || _a === void 0 ? void 0 : _a.name;\n    }\n    /**\n     * Adds the specified operation as a dependency and updates the consumer list.\n     */\n    addDependency(dependency) {\n        // Cast internally to avoid adding the overhead of getters\n        this.dependencies.add(dependency);\n        dependency.consumers.add(this);\n    }\n    /**\n     * Deletes the specified operation as a dependency and updates the consumer list.\n     */\n    deleteDependency(dependency) {\n        // Cast internally to avoid adding the overhead of getters\n        this.dependencies.delete(dependency);\n        dependency.consumers.delete(this);\n    }\n}\n//# sourceMappingURL=Operation.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Encapsulates information about an error\n * @alpha\n */\nexport class OperationError extends Error {\n    constructor(type, message) {\n        super(message);\n        this._type = type;\n    }\n    get message() {\n        return `[${this._type}] '${super.message}'`;\n    }\n    toString() {\n        return this.message;\n    }\n}\n//# sourceMappingURL=OperationError.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { StdioWritable, TextRewriterTransform } from '@rushstack/terminal';\nimport { StreamCollator } from '@rushstack/stream-collator';\nimport { NewlineKind, Async, InternalError } from '@rushstack/node-core-library';\nimport { AsyncOperationQueue, UNASSIGNED_OPERATION } from './AsyncOperationQueue';\nimport { OperationStatus } from './OperationStatus';\nimport { OperationExecutionRecord } from './OperationExecutionRecord';\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH = 79;\nconst prioritySort = (a, b) => {\n    return a.criticalPathLength - b.criticalPathLength;\n};\n/**\n * A class which manages the execution of a set of tasks with interdependencies.\n * Initially, and at the end of each task execution, all unblocked tasks\n * are added to a ready queue which is then executed. This is done continually until all\n * tasks are complete, or prematurely fails if any of the tasks fail.\n */\nexport class OperationExecutionManager {\n    constructor(operations, options) {\n        this._streamCollator_onWriterActive = (writer) => {\n            if (writer) {\n                this._completedOperations++;\n                // Format a header like this\n                //\n                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==\n                // leftPart: \"==[ @rushstack/the-long-thing \"\n                const leftPart = colors.gray('==[') + ' ' + colors.cyan(writer.taskName) + ' ';\n                const leftPartLength = 4 + writer.taskName.length + 1;\n                // rightPart: \" 1 of 1000 ]==\"\n                const completedOfTotal = `${this._completedOperations} of ${this._totalOperations}`;\n                const rightPart = ' ' + colors.white(completedOfTotal) + ' ' + colors.gray(']==');\n                const rightPartLength = 1 + completedOfTotal.length + 4;\n                // middlePart: \"]=================[\"\n                const twoBracketsLength = 2;\n                const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);\n                const middlePart = colors.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');\n                this._terminal.writeStdoutLine('\\n' + leftPart + middlePart + rightPart);\n                if (!this._quietMode) {\n                    this._terminal.writeStdoutLine('');\n                }\n            }\n        };\n        const { quietMode, debugMode, parallelism, changedProjectsOnly, beforeExecuteOperation, afterExecuteOperation, onOperationStatusChanged, beforeExecuteOperations } = options;\n        this._completedOperations = 0;\n        this._quietMode = quietMode;\n        this._hasAnyFailures = false;\n        this._hasAnyNonAllowedWarnings = false;\n        this._changedProjectsOnly = changedProjectsOnly;\n        this._parallelism = parallelism;\n        this._beforeExecuteOperation = beforeExecuteOperation;\n        this._afterExecuteOperation = afterExecuteOperation;\n        this._beforeExecuteOperations = beforeExecuteOperations;\n        this._onOperationStatusChanged = onOperationStatusChanged;\n        // TERMINAL PIPELINE:\n        //\n        // streamCollator --> colorsNewlinesTransform --> StdioWritable\n        //\n        this._outputWritable = options.destination || StdioWritable.instance;\n        this._colorsNewlinesTransform = new TextRewriterTransform({\n            destination: this._outputWritable,\n            normalizeNewlines: NewlineKind.OsDefault,\n            removeColors: !colors.enabled\n        });\n        this._streamCollator = new StreamCollator({\n            destination: this._colorsNewlinesTransform,\n            onWriterActive: this._streamCollator_onWriterActive\n        });\n        this._terminal = this._streamCollator.terminal;\n        // Convert the developer graph to the mutable execution graph\n        const executionRecordContext = {\n            streamCollator: this._streamCollator,\n            onOperationStatusChanged,\n            debugMode,\n            quietMode,\n            changedProjectsOnly\n        };\n        let totalOperations = 0;\n        const executionRecords = (this._executionRecords = new Map());\n        for (const operation of operations) {\n            const executionRecord = new OperationExecutionRecord(operation, executionRecordContext);\n            executionRecords.set(operation, executionRecord);\n            if (!executionRecord.runner.silent) {\n                // Only count non-silent operations\n                totalOperations++;\n            }\n        }\n        this._totalOperations = totalOperations;\n        for (const [operation, consumer] of executionRecords) {\n            for (const dependency of operation.dependencies) {\n                const dependencyRecord = executionRecords.get(dependency);\n                if (!dependencyRecord) {\n                    throw new Error(`Operation \"${consumer.name}\" declares a dependency on operation \"${dependency.name}\" that is not in the set of operations to execute.`);\n                }\n                consumer.dependencies.add(dependencyRecord);\n                dependencyRecord.consumers.add(consumer);\n            }\n        }\n        const executionQueue = new AsyncOperationQueue(this._executionRecords.values(), prioritySort);\n        this._executionQueue = executionQueue;\n    }\n    /**\n     * Executes all operations which have been registered, returning a promise which is resolved when all the\n     * operations are completed successfully, or rejects when any operation fails.\n     */\n    async executeAsync() {\n        var _a;\n        this._completedOperations = 0;\n        const totalOperations = this._totalOperations;\n        if (!this._quietMode) {\n            const plural = totalOperations === 1 ? '' : 's';\n            this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);\n            const nonSilentOperations = [];\n            for (const record of this._executionRecords.values()) {\n                if (!record.runner.silent) {\n                    nonSilentOperations.push(record.name);\n                }\n            }\n            nonSilentOperations.sort();\n            for (const name of nonSilentOperations) {\n                this._terminal.writeStdoutLine(`  ${name}`);\n            }\n            this._terminal.writeStdoutLine('');\n        }\n        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);\n        const maxParallelism = Math.min(totalOperations, this._parallelism);\n        await ((_a = this._beforeExecuteOperations) === null || _a === void 0 ? void 0 : _a.call(this, this._executionRecords));\n        // This function is a callback because it may write to the collatedWriter before\n        // operation.executeAsync returns (and cleans up the writer)\n        const onOperationCompleteAsync = async (record) => {\n            var _a, _b;\n            try {\n                await ((_a = this._afterExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));\n            }\n            catch (e) {\n                // Failed operations get reported here\n                const message = (_b = record.error) === null || _b === void 0 ? void 0 : _b.message;\n                if (message) {\n                    this._terminal.writeStderrLine('Unhandled exception: ');\n                    this._terminal.writeStderrLine(message);\n                }\n                throw e;\n            }\n            this._onOperationComplete(record);\n        };\n        const onOperationStartAsync = async (record) => {\n            var _a;\n            return await ((_a = this._beforeExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));\n        };\n        await Async.forEachAsync(this._executionQueue, async (operation) => {\n            let record;\n            /**\n             * If the operation is UNASSIGNED_OPERATION, it means that the queue is not able to assign a operation.\n             * This happens when some operations run remotely. So, we should try to get a remote executing operation\n             * from the queue manually here.\n             */\n            if (operation === UNASSIGNED_OPERATION) {\n                // Pause for a few time\n                await Async.sleep(5000);\n                record = this._executionQueue.tryGetRemoteExecutingOperation();\n            }\n            else {\n                record = operation;\n            }\n            if (!record) {\n                // Fail to assign a operation, start over again\n                return;\n            }\n            else {\n                await record.executeAsync({\n                    onStart: onOperationStartAsync,\n                    onResult: onOperationCompleteAsync\n                });\n            }\n        }, {\n            concurrency: maxParallelism\n        });\n        const status = this._hasAnyFailures\n            ? OperationStatus.Failure\n            : this._hasAnyNonAllowedWarnings\n                ? OperationStatus.SuccessWithWarning\n                : OperationStatus.Success;\n        return {\n            operationResults: this._executionRecords,\n            status\n        };\n    }\n    /**\n     * Handles the result of the operation and propagates any relevant effects.\n     */\n    _onOperationComplete(record) {\n        var _a;\n        const { runner, name, status } = record;\n        const silent = runner.silent;\n        switch (status) {\n            /**\n             * This operation failed. Mark it as such and all reachable dependents as blocked.\n             */\n            case OperationStatus.Failure: {\n                // Failed operations get reported, even if silent.\n                // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n                const message = (_a = record.error) === null || _a === void 0 ? void 0 : _a.message;\n                // This creates the writer, so don't do this globally\n                const { terminal } = record.collatedWriter;\n                if (message) {\n                    terminal.writeStderrLine(message);\n                }\n                terminal.writeStderrLine(colors.red(`\"${name}\" failed to build.`));\n                const blockedQueue = new Set(record.consumers);\n                for (const blockedRecord of blockedQueue) {\n                    if (blockedRecord.status === OperationStatus.Waiting) {\n                        // Now that we have the concept of architectural no-ops, we could implement this by replacing\n                        // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking\n                        // operations. However, the existing behavior is a bit simpler, so keeping that for now.\n                        if (!blockedRecord.runner.silent) {\n                            terminal.writeStdoutLine(`\"${blockedRecord.name}\" is blocked by \"${name}\".`);\n                        }\n                        blockedRecord.status = OperationStatus.Blocked;\n                        this._executionQueue.complete(blockedRecord);\n                        this._completedOperations++;\n                        for (const dependent of blockedRecord.consumers) {\n                            blockedQueue.add(dependent);\n                        }\n                    }\n                    else if (blockedRecord.status !== OperationStatus.Blocked) {\n                        // It shouldn't be possible for operations to be in any state other than Waiting or Blocked\n                        throw new InternalError(`Blocked operation ${blockedRecord.name} is in an unexpected state: ${blockedRecord.status}`);\n                    }\n                }\n                this._hasAnyFailures = true;\n                break;\n            }\n            /**\n             * This operation was restored from the build cache.\n             */\n            case OperationStatus.FromCache: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(colors.green(`\"${name}\" was restored from the build cache.`));\n                }\n                break;\n            }\n            /**\n             * This operation was skipped via legacy change detection.\n             */\n            case OperationStatus.Skipped: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(colors.green(`\"${name}\" was skipped.`));\n                }\n                break;\n            }\n            /**\n             * This operation intentionally didn't do anything.\n             */\n            case OperationStatus.NoOp: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(colors.gray(`\"${name}\" did not define any work.`));\n                }\n                break;\n            }\n            case OperationStatus.Success: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(colors.green(`\"${name}\" completed successfully in ${record.stopwatch.toString()}.`));\n                }\n                break;\n            }\n            case OperationStatus.SuccessWithWarning: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStderrLine(colors.yellow(`\"${name}\" completed with warnings in ${record.stopwatch.toString()}.`));\n                }\n                this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;\n                break;\n            }\n        }\n        if (record.status !== OperationStatus.RemoteExecuting) {\n            // If the operation was not remote, then we can notify queue that it is complete\n            this._executionQueue.complete(record);\n        }\n    }\n}\n//# sourceMappingURL=OperationExecutionManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { StdioSummarizer } from '@rushstack/terminal';\nimport { InternalError } from '@rushstack/node-core-library';\nimport { OperationStatus } from './OperationStatus';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { OperationMetadataManager } from './OperationMetadataManager';\n/**\n * Internal class representing everything about executing an operation\n *\n * @internal\n */\nexport class OperationExecutionRecord {\n    constructor(operation, context) {\n        /**\n         * The error which occurred while executing this operation, this is stored in case we need\n         * it later (for example to re-print errors at end of execution).\n         */\n        this.error = undefined;\n        /**\n         * This number represents how far away this Operation is from the furthest \"root\" operation (i.e.\n         * an operation with no consumers). This helps us to calculate the critical path (i.e. the\n         * longest chain of projects which must be executed in order, thereby limiting execution speed\n         * of the entire operation tree.\n         *\n         * This number is calculated via a memoized depth-first search, and when choosing the next\n         * operation to execute, the operation with the highest criticalPathLength is chosen.\n         *\n         * Example:\n         * ```\n         *        (0) A\n         *             \\\n         *          (1) B     C (0)         (applications)\n         *               \\   /|\\\n         *                \\ / | \\\n         *             (2) D  |  X (1)      (utilities)\n         *                    | / \\\n         *                    |/   \\\n         *                (2) Y     Z (2)   (other utilities)\n         *\n         * All roots (A & C) have a criticalPathLength of 0.\n         * B has a score of 1, since A depends on it.\n         * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n         * X has a score of 1, since the only package which depends on it is A\n         * Z has a score of 2, since only X depends on it, and X has a score of 1\n         * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n         * ```\n         *\n         * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()\n         */\n        this.criticalPathLength = undefined;\n        /**\n         * The set of operations that must complete before this operation executes.\n         */\n        this.dependencies = new Set();\n        /**\n         * The set of operations that depend on this operation.\n         */\n        this.consumers = new Set();\n        this.stopwatch = new Stopwatch();\n        this.stdioSummarizer = new StdioSummarizer();\n        this._collatedWriter = undefined;\n        const { runner, associatedPhase, associatedProject } = operation;\n        if (!runner) {\n            throw new InternalError(`Operation for phase '${associatedPhase === null || associatedPhase === void 0 ? void 0 : associatedPhase.name}' and project '${associatedProject === null || associatedProject === void 0 ? void 0 : associatedProject.packageName}' has no runner.`);\n        }\n        this.operation = operation;\n        this.runner = runner;\n        this.weight = operation.weight;\n        this.associatedPhase = associatedPhase;\n        this.associatedProject = associatedProject;\n        if (operation.associatedPhase && operation.associatedProject) {\n            this._operationMetadataManager = new OperationMetadataManager({\n                phase: operation.associatedPhase,\n                rushProject: operation.associatedProject\n            });\n        }\n        this._context = context;\n        this._status = operation.dependencies.size > 0 ? OperationStatus.Waiting : OperationStatus.Ready;\n    }\n    get name() {\n        return this.runner.name;\n    }\n    get debugMode() {\n        return this._context.debugMode;\n    }\n    get quietMode() {\n        return this._context.quietMode;\n    }\n    get changedProjectsOnly() {\n        return this._context.changedProjectsOnly;\n    }\n    get collatedWriter() {\n        // Lazy instantiate because the registerTask() call affects display ordering\n        if (!this._collatedWriter) {\n            this._collatedWriter = this._context.streamCollator.registerTask(this.name);\n        }\n        return this._collatedWriter;\n    }\n    get nonCachedDurationMs() {\n        var _a, _b;\n        // Lazy calculated because the state file is created/restored later on\n        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.nonCachedDurationMs;\n    }\n    get cobuildRunnerId() {\n        var _a, _b;\n        // Lazy calculated because the state file is created/restored later on\n        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.cobuildRunnerId;\n    }\n    /**\n     * The current execution status of an operation. Operations start in the 'ready' state,\n     * but can be 'blocked' if an upstream operation failed. It is 'executing' when\n     * the operation is executing. Once execution is complete, it is either 'success' or\n     * 'failure'.\n     */\n    get status() {\n        return this._status;\n    }\n    set status(newStatus) {\n        var _a, _b;\n        if (newStatus === this._status) {\n            return;\n        }\n        this._status = newStatus;\n        (_b = (_a = this._context).onOperationStatusChanged) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n    }\n    async executeAsync({ onStart, onResult }) {\n        var _a;\n        if (this.status === OperationStatus.RemoteExecuting) {\n            this.stopwatch.reset();\n        }\n        this.stopwatch.start();\n        this.status = OperationStatus.Executing;\n        try {\n            const earlyReturnStatus = await onStart(this);\n            // When the operation status returns by the hook, bypass the runner execution.\n            if (earlyReturnStatus) {\n                this.status = earlyReturnStatus;\n            }\n            else {\n                this.status = await this.runner.executeAsync(this);\n            }\n            // Delegate global state reporting\n            await onResult(this);\n        }\n        catch (error) {\n            this.status = OperationStatus.Failure;\n            this.error = error;\n            // Delegate global state reporting\n            await onResult(this);\n        }\n        finally {\n            if (this.status !== OperationStatus.RemoteExecuting) {\n                (_a = this._collatedWriter) === null || _a === void 0 ? void 0 : _a.close();\n                this.stdioSummarizer.close();\n                this.stopwatch.stop();\n            }\n        }\n    }\n}\n//# sourceMappingURL=OperationExecutionRecord.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport * as fs from 'fs';\nimport { Async, FileSystem } from '@rushstack/node-core-library';\nimport { OperationStateFile } from './OperationStateFile';\nimport { RushConstants } from '../RushConstants';\n/**\n * A helper class for managing the meta files of a operation.\n *\n * @internal\n */\nexport class OperationMetadataManager {\n    constructor(options) {\n        const { rushProject, phase } = options;\n        const { projectFolder } = rushProject;\n        const identifier = phase.logFilenameIdentifier;\n        this._metadataFolder = `${RushConstants.projectRushFolderName}/${RushConstants.rushTempFolderName}/operation/${identifier}`;\n        this.stateFile = new OperationStateFile({\n            projectFolder: projectFolder,\n            metadataFolder: this._metadataFolder\n        });\n        this._relativeLogPath = `${this._metadataFolder}/all.log`;\n        this._relativeErrorLogPath = `${this._metadataFolder}/error.log`;\n        this._logPath = `${projectFolder}/${this._relativeLogPath}`;\n        this._errorLogPath = `${projectFolder}/${this._relativeErrorLogPath}`;\n    }\n    /**\n     * Returns the relative paths of the metadata files to project folder.\n     *\n     * Example: `.rush/temp/operation/_phase_build/state.json`\n     * Example: `.rush/temp/operation/_phase_build/all.log`\n     * Example: `.rush/temp/operation/_phase_build/error.log`\n     */\n    get relativeFilepaths() {\n        return [this.stateFile.relativeFilepath, this._relativeLogPath, this._relativeErrorLogPath];\n    }\n    async saveAsync({ durationInSeconds, cobuildContextId, cobuildRunnerId, logPath, errorLogPath }) {\n        const state = {\n            nonCachedDurationMs: durationInSeconds * 1000,\n            cobuildContextId,\n            cobuildRunnerId\n        };\n        await this.stateFile.writeAsync(state);\n        const copyFileOptions = [\n            {\n                sourcePath: logPath,\n                destinationPath: this._logPath\n            },\n            {\n                sourcePath: errorLogPath,\n                destinationPath: this._errorLogPath\n            }\n        ];\n        // Try to copy log files\n        await Async.forEachAsync(copyFileOptions, async (options) => {\n            try {\n                await FileSystem.copyFileAsync(options);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n        });\n    }\n    async tryRestoreAsync({ terminal, logPath, errorLogPath }) {\n        var _a, e_1, _b, _c;\n        await this.stateFile.tryRestoreAsync();\n        // Append cached log into current log file\n        terminal.writeLine(`Restoring cached log file at ${this._logPath}`);\n        let logReadStream;\n        try {\n            logReadStream = fs.createReadStream(this._logPath, {\n                encoding: 'utf-8'\n            });\n            try {\n                for (var _d = true, logReadStream_1 = __asyncValues(logReadStream), logReadStream_1_1; logReadStream_1_1 = await logReadStream_1.next(), _a = logReadStream_1_1.done, !_a;) {\n                    _c = logReadStream_1_1.value;\n                    _d = false;\n                    try {\n                        const data = _c;\n                        terminal.write(data);\n                    }\n                    finally {\n                        _d = true;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = logReadStream_1.return)) await _b.call(logReadStream_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        finally {\n            // Clean up the read steam\n            logReadStream === null || logReadStream === void 0 ? void 0 : logReadStream.close();\n        }\n        // Try to restore cached error log as error log file\n        try {\n            await FileSystem.copyFileAsync({\n                sourcePath: this._errorLogPath,\n                destinationPath: errorLogPath\n            });\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n    }\n}\n//# sourceMappingURL=OperationMetadataManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { InternalError } from '@rushstack/node-core-library';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'OperationResultSummarizerPlugin';\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH = 79;\n/**\n * Phased command plugin that emits a summary of build results to the console.\n */\nexport class OperationResultSummarizerPlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {\n            _printOperationStatus(this._terminal, result);\n        });\n    }\n}\n/**\n * Prints out a report of the status of each project\n * @internal\n */\nexport function _printOperationStatus(terminal, result) {\n    var _a;\n    const { operationResults } = result;\n    const operationsByStatus = new Map();\n    for (const record of operationResults) {\n        if ((_a = record[0].runner) === null || _a === void 0 ? void 0 : _a.silent) {\n            // Don't report silenced operations\n            continue;\n        }\n        const { status } = record[1];\n        switch (status) {\n            // These are the sections that we will report below\n            case OperationStatus.Skipped:\n            case OperationStatus.FromCache:\n            case OperationStatus.Success:\n            case OperationStatus.SuccessWithWarning:\n            case OperationStatus.Blocked:\n            case OperationStatus.Failure:\n            case OperationStatus.NoOp:\n                break;\n            default:\n                // This should never happen\n                throw new InternalError(`Unexpected operation status: ${status}`);\n        }\n        const collection = operationsByStatus.get(status);\n        if (collection) {\n            collection.push(record);\n        }\n        else {\n            operationsByStatus.set(status, [record]);\n        }\n    }\n    // Skip a few lines before we start the summary\n    terminal.writeLine('\\n\\n');\n    // These are ordered so that the most interesting statuses appear last:\n    writeCondensedSummary(terminal, OperationStatus.Skipped, operationsByStatus, colors.green, 'These operations were already up to date:');\n    writeCondensedSummary(terminal, OperationStatus.NoOp, operationsByStatus, colors.gray, 'These operations did not define any work:');\n    writeCondensedSummary(terminal, OperationStatus.FromCache, operationsByStatus, colors.green, 'These operations were restored from the build cache:');\n    writeCondensedSummary(terminal, OperationStatus.Success, operationsByStatus, colors.green, 'These operations completed successfully:');\n    writeDetailedSummary(terminal, OperationStatus.SuccessWithWarning, operationsByStatus, colors.yellow, 'WARNING');\n    writeCondensedSummary(terminal, OperationStatus.Blocked, operationsByStatus, colors.white, 'These operations were blocked by dependencies that failed:');\n    writeDetailedSummary(terminal, OperationStatus.Failure, operationsByStatus, colors.red);\n    terminal.writeLine('');\n    switch (result.status) {\n        case OperationStatus.Failure:\n            terminal.writeErrorLine('Operations failed.\\n');\n            break;\n        case OperationStatus.SuccessWithWarning:\n            terminal.writeWarningLine('Operations succeeded with warnings.\\n');\n            break;\n    }\n}\nfunction writeCondensedSummary(terminal, status, operationsByStatus, headingColor, preamble) {\n    // Example:\n    //\n    // ==[ BLOCKED: 4 projects ]==============================================================\n    //\n    // These projects were blocked by dependencies that failed:\n    //   @scope/name\n    //   e\n    //   k\n    const operations = operationsByStatus.get(status);\n    if (!operations || operations.length === 0) {\n        return;\n    }\n    writeSummaryHeader(terminal, status, operations, headingColor);\n    terminal.writeLine(preamble);\n    let longestTaskName = 0;\n    for (const [operation] of operations) {\n        const nameLength = (operation.name || '').length;\n        if (nameLength > longestTaskName) {\n            longestTaskName = nameLength;\n        }\n    }\n    for (const [operation, operationResult] of operations) {\n        if (operationResult.stopwatch.duration !== 0 &&\n            operation.runner.reportTiming &&\n            operationResult.status !== OperationStatus.Skipped) {\n            const time = operationResult.stopwatch.toString();\n            const padding = ' '.repeat(longestTaskName - (operation.name || '').length);\n            terminal.writeLine(`  ${operation.name}${padding}    ${time}`);\n        }\n        else {\n            terminal.writeLine(`  ${operation.name}`);\n        }\n    }\n    terminal.writeLine('');\n}\nfunction writeDetailedSummary(terminal, status, operationsByStatus, headingColor, shortStatusName) {\n    // Example:\n    //\n    // ==[ SUCCESS WITH WARNINGS: 2 projects ]================================\n    //\n    // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--\n    //\n    // [eslint] Warning: src/logic/operations/OperationsExecutionManager.ts:393:3 ...\n    const operations = operationsByStatus.get(status);\n    if (!operations || operations.length === 0) {\n        return;\n    }\n    writeSummaryHeader(terminal, status, operations, headingColor);\n    if (shortStatusName === undefined) {\n        shortStatusName = status;\n    }\n    for (const [operation, operationResult] of operations) {\n        // Format a header like this\n        //\n        // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--\n        // leftPart: \"--[ WARNINGS: f \"\n        const subheadingText = `${shortStatusName}: ${operation.name}`;\n        const leftPartLength = 4 + subheadingText.length + 1;\n        // rightPart: \" 5.07 seconds ]--\"\n        const time = operationResult.stopwatch.toString();\n        const rightPartLength = 1 + time.length + 1 + 3;\n        // middlePart: \"]----------------------[\"\n        const twoBracketsLength = 2;\n        const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);\n        terminal.writeLine(`${colors.gray('--[')} ${headingColor(subheadingText)} ${colors.gray(`]${'-'.repeat(middlePartLengthMinusTwoBrackets)}[`)} ${colors.white(time)} ${colors.gray(']--')}\\n`);\n        const details = operationResult.stdioSummarizer.getReport();\n        if (details) {\n            // Don't write a newline, because the report will always end with a newline\n            terminal.write(details);\n        }\n        terminal.writeLine('');\n    }\n}\nfunction writeSummaryHeader(terminal, status, operations, headingColor) {\n    // Format a header like this\n    //\n    // ==[ FAILED: 2 operations ]================================================\n    // \"2 operations\"\n    const projectsText = `${operations.length}${operations.length === 1 ? ' operation' : ' operations'}`;\n    const headingText = `${status}: ${projectsText}`;\n    // leftPart: \"==[ FAILED: 2 operations \"\n    const leftPartLength = 3 + 1 + headingText.length + 1;\n    const rightPartLengthMinusBracket = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + 1), 0);\n    // rightPart: \"]======================\"\n    terminal.writeLine(`${colors.gray('==[')} ${headingColor(headingText)} ${colors.gray(`]${'='.repeat(rightPartLengthMinusBracket)}`)}\\n`);\n}\n//# sourceMappingURL=OperationResultSummarizerPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, InternalError, JsonFile } from '@rushstack/node-core-library';\n/**\n * A helper class for managing the state file of a operation.\n *\n * @internal\n */\nclass OperationStateFile {\n    constructor(options) {\n        const { projectFolder, metadataFolder } = options;\n        this.relativeFilepath = `${metadataFolder}/${OperationStateFile.filename}`;\n        this.filepath = `${projectFolder}/${this.relativeFilepath}`;\n    }\n    get state() {\n        return this._state;\n    }\n    async writeAsync(json) {\n        await JsonFile.saveAsync(json, this.filepath, { ensureFolderExists: true, ignoreUndefinedValues: true });\n        this._state = json;\n    }\n    async tryRestoreAsync() {\n        try {\n            this._state = await JsonFile.loadAsync(this.filepath);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                this._state = undefined;\n            }\n            else {\n                // This should not happen\n                throw new InternalError(error);\n            }\n        }\n        return this._state;\n    }\n}\nOperationStateFile.filename = 'state.json';\nexport { OperationStateFile };\n//# sourceMappingURL=OperationStateFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Enumeration defining potential states of an operation\n * @beta\n */\nexport var OperationStatus;\n(function (OperationStatus) {\n    /**\n     * The Operation is ready to execute. All its dependencies have succeeded.\n     */\n    OperationStatus[\"Ready\"] = \"READY\";\n    /**\n     * The Operation is waiting for one or more dependencies to complete.\n     */\n    OperationStatus[\"Waiting\"] = \"WAITING\";\n    /**\n     * The Operation is Queued\n     */\n    OperationStatus[\"Queued\"] = \"QUEUED\";\n    /**\n     * The Operation is currently executing\n     */\n    OperationStatus[\"Executing\"] = \"EXECUTING\";\n    /**\n     * The Operation is currently executing by a remote process\n     */\n    OperationStatus[\"RemoteExecuting\"] = \"REMOTE EXECUTING\";\n    /**\n     * The Operation completed successfully and did not write to standard output\n     */\n    OperationStatus[\"Success\"] = \"SUCCESS\";\n    /**\n     * The Operation completed successfully, but wrote to standard output\n     */\n    OperationStatus[\"SuccessWithWarning\"] = \"SUCCESS WITH WARNINGS\";\n    /**\n     * The Operation was skipped via the legacy incremental build logic\n     */\n    OperationStatus[\"Skipped\"] = \"SKIPPED\";\n    /**\n     * The Operation had its outputs restored from the build cache\n     */\n    OperationStatus[\"FromCache\"] = \"FROM CACHE\";\n    /**\n     * The Operation failed\n     */\n    OperationStatus[\"Failure\"] = \"FAILURE\";\n    /**\n     * The Operation could not be executed because one or more of its dependencies failed\n     */\n    OperationStatus[\"Blocked\"] = \"BLOCKED\";\n    /**\n     * The Operation was a no-op (for example, it had an empty script)\n     */\n    OperationStatus[\"NoOp\"] = \"NO OP\";\n})(OperationStatus || (OperationStatus = {}));\n//# sourceMappingURL=OperationStatus.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A help class to run callbacks in a loop with a specified interval.\n *\n * @beta\n */\nexport class PeriodicCallback {\n    constructor(options) {\n        this._callbacks = [];\n        this._interval = options.interval;\n        this._isRunning = false;\n    }\n    addCallback(callback) {\n        if (this._isRunning) {\n            throw new Error('Can not add callback while watcher is running');\n        }\n        this._callbacks.push(callback);\n    }\n    start() {\n        if (this._intervalId) {\n            throw new Error('Watcher already started');\n        }\n        if (this._callbacks.length === 0) {\n            return;\n        }\n        this._isRunning = true;\n        this._intervalId = setInterval(() => {\n            this._callbacks.forEach((callback) => callback());\n        }, this._interval);\n    }\n    stop() {\n        if (this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n            this._isRunning = false;\n        }\n    }\n}\n//# sourceMappingURL=PeriodicCallback.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Operation } from './Operation';\nimport { OperationStatus } from './OperationStatus';\nimport { NullOperationRunner } from './NullOperationRunner';\nconst PLUGIN_NAME = 'PhasedOperationPlugin';\n/**\n * Core phased command plugin that provides the functionality for generating a base operation graph\n * from the set of selected projects and phases.\n */\nexport class PhasedOperationPlugin {\n    apply(hooks) {\n        hooks.createOperations.tap(PLUGIN_NAME, createOperations);\n    }\n}\nfunction createOperations(existingOperations, context) {\n    const { projectsInUnknownState: changedProjects, phaseOriginal, phaseSelection, projectSelection } = context;\n    const operationsWithWork = new Set();\n    const operations = new Map();\n    // Create tasks for selected phases and projects\n    for (const phase of phaseOriginal) {\n        for (const project of projectSelection) {\n            getOrCreateOperation(phase, project);\n        }\n    }\n    // Recursively expand all consumers in the `operationsWithWork` set.\n    for (const operation of operationsWithWork) {\n        for (const consumer of operation.consumers) {\n            operationsWithWork.add(consumer);\n        }\n    }\n    for (const [key, operation] of operations) {\n        if (!operationsWithWork.has(operation)) {\n            // This operation is in scope, but did not change since it was last executed by the current command.\n            // However, we have no state tracking across executions, so treat as unknown.\n            operation.runner = new NullOperationRunner({\n                name: key,\n                result: OperationStatus.Skipped,\n                silent: true\n            });\n        }\n    }\n    return existingOperations;\n    // Binds phaseSelection, projectSelection, operations via closure\n    function getOrCreateOperation(phase, project) {\n        const key = getOperationKey(phase, project);\n        let operation = operations.get(key);\n        if (!operation) {\n            operation = new Operation({\n                project,\n                phase\n            });\n            if (!phaseSelection.has(phase) || !projectSelection.has(project)) {\n                // Not in scope. Mark skipped because state is unknown.\n                operation.runner = new NullOperationRunner({\n                    name: key,\n                    result: OperationStatus.Skipped,\n                    silent: true\n                });\n            }\n            else if (changedProjects.has(project)) {\n                operationsWithWork.add(operation);\n            }\n            operations.set(key, operation);\n            existingOperations.add(operation);\n            const { dependencies: { self, upstream } } = phase;\n            for (const depPhase of self) {\n                operation.addDependency(getOrCreateOperation(depPhase, project));\n            }\n            if (upstream.size) {\n                const { dependencyProjects } = project;\n                if (dependencyProjects.size) {\n                    for (const depPhase of upstream) {\n                        for (const dependencyProject of dependencyProjects) {\n                            operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));\n                        }\n                    }\n                }\n            }\n        }\n        return operation;\n    }\n}\n// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key\nfunction getOperationKey(phase, project) {\n    return `${project.packageName};${phase.name}`;\n}\n//# sourceMappingURL=PhasedOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, FileWriter, InternalError } from '@rushstack/node-core-library';\nimport { TerminalWritable } from '@rushstack/terminal';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\nimport { RushConstants } from '../RushConstants';\nexport class ProjectLogWritable extends TerminalWritable {\n    constructor(project, terminal, logFilenameIdentifier) {\n        super();\n        this._logWriter = undefined;\n        this._errorLogWriter = undefined;\n        this._project = project;\n        this._terminal = terminal;\n        // Delete the legacy logs\n        const { logPath: legacyLogPath, errorLogPath: legacyErrorLogPath } = ProjectLogWritable.getLogFilePaths({\n            project,\n            logFilenameIdentifier: 'build',\n            isLegacyLog: true\n        });\n        FileSystem.deleteFile(legacyLogPath);\n        FileSystem.deleteFile(legacyErrorLogPath);\n        const { logPath, errorLogPath, relativeLogPath, relativeErrorLogPath } = ProjectLogWritable.getLogFilePaths({\n            project,\n            logFilenameIdentifier\n        });\n        this.logPath = logPath;\n        this.errorLogPath = errorLogPath;\n        this.relativeLogPath = relativeLogPath;\n        this.relativeErrorLogPath = relativeErrorLogPath;\n        if (legacyLogPath !== this.logPath) {\n            FileSystem.deleteFile(this.logPath);\n        }\n        if (legacyErrorLogPath !== this.errorLogPath) {\n            FileSystem.deleteFile(this.errorLogPath);\n        }\n        this._logWriter = FileWriter.open(this.logPath);\n    }\n    static getLogFilePaths({ project, logFilenameIdentifier, isLegacyLog = false }) {\n        const unscopedProjectName = PackageNameParsers.permissive.getUnscopedName(project.packageName);\n        const logFileBaseName = `${unscopedProjectName}.${logFilenameIdentifier}`;\n        const logFilename = `${logFileBaseName}.log`;\n        const errorLogFilename = `${logFileBaseName}.error.log`;\n        const { projectFolder } = project;\n        // If the phased commands experiment is enabled, put logs under `rush-logs`\n        let logFolder;\n        if (!isLegacyLog && project.rushConfiguration.experimentsConfiguration.configuration.phasedCommands) {\n            const logPathPrefix = `${projectFolder}/${RushConstants.rushLogsFolderName}`;\n            FileSystem.ensureFolder(logPathPrefix);\n            logFolder = RushConstants.rushLogsFolderName;\n        }\n        const relativeLogPath = logFolder ? `${logFolder}/${logFilename}` : logFilename;\n        const relativeErrorLogPath = logFolder ? `${logFolder}/${errorLogFilename}` : errorLogFilename;\n        const logPath = `${projectFolder}/${relativeLogPath}`;\n        const errorLogPath = `${projectFolder}/${relativeErrorLogPath}`;\n        return {\n            logPath,\n            errorLogPath,\n            relativeLogPath,\n            relativeErrorLogPath\n        };\n    }\n    // Override writeChunk function to throw custom error\n    writeChunk(chunk) {\n        if (!this._logWriter) {\n            throw new InternalError(`Log writer was closed for ${this.logPath}`);\n        }\n        // Stderr can always get written to a error log writer\n        super.writeChunk(chunk);\n    }\n    onWriteChunk(chunk) {\n        if (!this._logWriter) {\n            throw new InternalError('Output file was closed');\n        }\n        // Both stderr and stdout get written to *.<phaseName>.log\n        this._logWriter.write(chunk.text);\n        if (chunk.kind === \"E\" /* TerminalChunkKind.Stderr */) {\n            // Only stderr gets written to *.<phaseName>.error.log\n            if (!this._errorLogWriter) {\n                this._errorLogWriter = FileWriter.open(this.errorLogPath);\n            }\n            this._errorLogWriter.write(chunk.text);\n        }\n    }\n    onClose() {\n        if (this._logWriter) {\n            try {\n                this._logWriter.close();\n            }\n            catch (error) {\n                this._terminal.writeStderrLine('Failed to close file handle for ' + this._logWriter.filePath);\n            }\n            this._logWriter = undefined;\n        }\n        if (this._errorLogWriter) {\n            try {\n                this._errorLogWriter.close();\n            }\n            catch (error) {\n                this._terminal.writeStderrLine('Failed to close file handle for ' + this._errorLogWriter.filePath);\n            }\n            this._errorLogWriter = undefined;\n        }\n    }\n}\n//# sourceMappingURL=ProjectLogWritable.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Text, NewlineKind, InternalError, Terminal } from '@rushstack/node-core-library';\nimport { TextRewriterTransform, StderrLineTransform, SplitterTransform, DiscardStdoutTransform } from '@rushstack/terminal';\nimport { CollatedTerminal } from '@rushstack/stream-collator';\nimport { Utilities } from '../../utilities/Utilities';\nimport { OperationStatus } from './OperationStatus';\nimport { OperationError } from './OperationError';\nimport { ProjectLogWritable } from './ProjectLogWritable';\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\n/**\n * An `IOperationRunner` subclass that performs an operation via a shell command.\n * Currently contains the build cache logic, pending extraction as separate operations.\n * Supports skipping an operation if allowed and it is already up-to-date.\n */\nexport class ShellOperationRunner {\n    constructor(options) {\n        this.reportTiming = true;\n        this.silent = false;\n        this.cacheable = true;\n        const { phase } = options;\n        this.name = options.displayName;\n        this._rushProject = options.rushProject;\n        this._rushConfiguration = options.rushConfiguration;\n        this._commandToRun = options.commandToRun;\n        this.warningsAreAllowed =\n            EnvironmentConfiguration.allowWarningsInSuccessfulBuild || phase.allowWarningsOnSuccess || false;\n        this._logFilenameIdentifier = phase.logFilenameIdentifier;\n    }\n    async executeAsync(context) {\n        try {\n            return await this._executeAsync(context);\n        }\n        catch (error) {\n            throw new OperationError('executing', error.message);\n        }\n    }\n    getConfigHash() {\n        return this._commandToRun;\n    }\n    async _executeAsync(context) {\n        const projectLogWritable = new ProjectLogWritable(this._rushProject, context.collatedWriter.terminal, this._logFilenameIdentifier);\n        try {\n            //#region OPERATION LOGGING\n            // TERMINAL PIPELINE:\n            //\n            //                             +--> quietModeTransform? --> collatedWriter\n            //                             |\n            // normalizeNewlineTransform --1--> stderrLineTransform --2--> removeColorsTransform --> projectLogWritable\n            //                                                        |\n            //                                                        +--> stdioSummarizer\n            const removeColorsTransform = new TextRewriterTransform({\n                destination: projectLogWritable,\n                removeColors: true,\n                normalizeNewlines: NewlineKind.OsDefault\n            });\n            const splitterTransform2 = new SplitterTransform({\n                destinations: [removeColorsTransform, context.stdioSummarizer]\n            });\n            const stderrLineTransform = new StderrLineTransform({\n                destination: splitterTransform2,\n                newlineKind: NewlineKind.Lf // for StdioSummarizer\n            });\n            const discardTransform = new DiscardStdoutTransform({\n                destination: context.collatedWriter\n            });\n            const splitterTransform1 = new SplitterTransform({\n                destinations: [context.quietMode ? discardTransform : context.collatedWriter, stderrLineTransform]\n            });\n            const normalizeNewlineTransform = new TextRewriterTransform({\n                destination: splitterTransform1,\n                normalizeNewlines: NewlineKind.Lf,\n                ensureNewlineAtEnd: true\n            });\n            const collatedTerminal = new CollatedTerminal(normalizeNewlineTransform);\n            const terminalProvider = new CollatedTerminalProvider(collatedTerminal, {\n                debugEnabled: context.debugMode\n            });\n            const terminal = new Terminal(terminalProvider);\n            //#endregion\n            let hasWarningOrError = false;\n            const projectFolder = this._rushProject.projectFolder;\n            // Run the operation\n            terminal.writeLine('Invoking: ' + this._commandToRun);\n            const subProcess = Utilities.executeLifecycleCommandAsync(this._commandToRun, {\n                rushConfiguration: this._rushConfiguration,\n                workingDirectory: projectFolder,\n                initCwd: this._rushConfiguration.commonTempFolder,\n                handleOutput: true,\n                environmentPathOptions: {\n                    includeProjectBin: true\n                }\n            });\n            // Hook into events, in order to get live streaming of the log\n            if (subProcess.stdout !== null) {\n                subProcess.stdout.on('data', (data) => {\n                    const text = data.toString();\n                    collatedTerminal.writeChunk({ text, kind: \"O\" /* TerminalChunkKind.Stdout */ });\n                });\n            }\n            if (subProcess.stderr !== null) {\n                subProcess.stderr.on('data', (data) => {\n                    const text = data.toString();\n                    collatedTerminal.writeChunk({ text, kind: \"E\" /* TerminalChunkKind.Stderr */ });\n                    hasWarningOrError = true;\n                });\n            }\n            let status = await new Promise((resolve, reject) => {\n                subProcess.on('close', (code) => {\n                    try {\n                        if (code !== 0) {\n                            // Do NOT reject here immediately, give a chance for other logic to suppress the error\n                            context.error = new OperationError('error', `Returned error code: ${code}`);\n                            resolve(OperationStatus.Failure);\n                        }\n                        else if (hasWarningOrError) {\n                            resolve(OperationStatus.SuccessWithWarning);\n                        }\n                        else {\n                            resolve(OperationStatus.Success);\n                        }\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                });\n            });\n            // projectLogWritable should be closed before copy the logs to build cache\n            normalizeNewlineTransform.close();\n            // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should\n            // have closed projectLogWritable.\n            if (projectLogWritable.isOpen) {\n                throw new InternalError('The output file handle was not closed');\n            }\n            if (terminalProvider.hasErrors) {\n                status = OperationStatus.Failure;\n            }\n            return status;\n        }\n        finally {\n            projectLogWritable.close();\n        }\n    }\n}\n/**\n * When running a command from the \"scripts\" block in package.json, if the command\n * contains Unix-style path slashes and the OS is Windows, the package managers will\n * convert slashes to backslashes.  This is a complicated undertaking.  For example, they\n * need to convert \"node_modules/bin/this && ./scripts/that --name keep/this\"\n * to \"node_modules\\bin\\this && .\\scripts\\that --name keep/this\", and they don't want to\n * convert ANY of the slashes in \"cmd.exe /c echo a/b\".  NPM and PNPM use npm-lifecycle for this,\n * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a\n * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.\n *\n * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write\n * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).\n * It's very tricky for a developer to guess what's safe to do without testing every OS.\n * Even simple path separators are not portable, so NPM added heuristics to figure out which\n * slashes are part of a path or not, and convert them.  These workarounds end up having tons\n * of special cases.  They probably could have implemented their own entire minimal cross-platform\n * shell language with less code and less confusion than npm-lifecycle's approach.\n *\n * We've deprecated shell operators inside package.json.  Instead, we advise people to move their\n * scripts into conventional script files, and put only a file path in package.json.  So, for\n * Rush's workaround here, we really only care about supporting the small set of cases seen in the\n * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched\n * (i.e. err on the side of not breaking anything).  We could revisit this later if someone\n * complains about it, but so far nobody has.  :-)\n */\nexport function convertSlashesForWindows(command) {\n    // The first group will match everything up to the first space, \"&\", \"|\", \"<\", \">\", or quote.\n    // The second group matches the remainder.\n    const commandRegExp = /^([^\\s&|<>\"]+)(.*)$/;\n    const match = commandRegExp.exec(command);\n    if (match) {\n        // Example input: \"bin/blarg --path ./config/blah.json && a/b\"\n        // commandPart=\"bin/blarg\"\n        // remainder=\" --path ./config/blah.json && a/b\"\n        const commandPart = match[1];\n        const remainder = match[2];\n        // If the command part already contains a backslash, then leave it alone\n        if (commandPart.indexOf('\\\\') < 0) {\n            // Replace all the slashes with backslashes, e.g. to produce:\n            // \"bin\\blarg --path ./config/blah.json && a/b\"\n            //\n            // NOTE: we don't attempt to process the path parameter or stuff after \"&&\"\n            return Text.replaceAll(commandPart, '/', '\\\\') + remainder;\n        }\n    }\n    // Don't change anything\n    return command;\n}\n//# sourceMappingURL=ShellOperationRunner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nimport { NullOperationRunner } from './NullOperationRunner';\nimport { convertSlashesForWindows, ShellOperationRunner } from './ShellOperationRunner';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'ShellOperationRunnerPlugin';\n/**\n * Core phased command plugin that provides the functionality for executing an operation via shell command.\n */\nexport class ShellOperationRunnerPlugin {\n    apply(hooks) {\n        hooks.createOperations.tap(PLUGIN_NAME, createShellOperations);\n    }\n}\nfunction createShellOperations(operations, context) {\n    const { phaseSelection: selectedPhases, projectChangeAnalyzer, rushConfiguration } = context;\n    const customParametersByPhase = new Map();\n    function getCustomParameterValuesForPhase(phase) {\n        let customParameterValues = customParametersByPhase.get(phase);\n        if (!customParameterValues) {\n            customParameterValues = [];\n            for (const tsCommandLineParameter of phase.associatedParameters) {\n                tsCommandLineParameter.appendToArgList(customParameterValues);\n            }\n            customParametersByPhase.set(phase, customParameterValues);\n        }\n        return customParameterValues;\n    }\n    for (const operation of operations) {\n        const { associatedPhase: phase, associatedProject: project } = operation;\n        if (phase && project && !operation.runner) {\n            // This is a shell command. In the future, may consider having a property on the initial operation\n            // to specify a runner type requested in rush-project.json\n            const customParameterValues = getCustomParameterValuesForPhase(phase);\n            const commandToRun = getScriptToRun(project, phase.name, customParameterValues, phase.shellCommand);\n            if (commandToRun === undefined && phase.missingScriptBehavior === 'error') {\n                throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);\n            }\n            const displayName = getDisplayName(phase, project);\n            if (commandToRun) {\n                const shellOperationRunner = new ShellOperationRunner({\n                    commandToRun: commandToRun || '',\n                    displayName,\n                    phase,\n                    projectChangeAnalyzer,\n                    rushConfiguration,\n                    rushProject: project,\n                    selectedPhases\n                });\n                operation.runner = shellOperationRunner;\n            }\n            else {\n                // Empty build script indicates a no-op, so use a no-op runner\n                operation.runner = new NullOperationRunner({\n                    name: displayName,\n                    result: OperationStatus.NoOp,\n                    silent: phase.missingScriptBehavior === 'silent'\n                });\n            }\n        }\n    }\n    return operations;\n}\nfunction getScriptToRun(rushProject, commandToRun, customParameterValues, shellCommand) {\n    const { scripts } = rushProject.packageJson;\n    const rawCommand = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];\n    if (rawCommand === undefined || rawCommand === null) {\n        return undefined;\n    }\n    if (!rawCommand) {\n        return '';\n    }\n    else {\n        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;\n        return process.platform === 'win32' ? convertSlashesForWindows(fullCommand) : fullCommand;\n    }\n}\nfunction getDisplayName(phase, project) {\n    if (phase.isSynthetic) {\n        // Because this is a synthetic phase, just use the project name because there aren't any other phases\n        return project.packageName;\n    }\n    else {\n        const phaseNameWithoutPrefix = phase.name.slice(RushConstants.phaseNamePrefix.length);\n        return `${project.packageName} (${phaseNameWithoutPrefix})`;\n    }\n}\n//# sourceMappingURL=ShellOperationRunnerPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nconst PLUGIN_NAME = 'ValidateOperationsPlugin';\n/**\n * Core phased command plugin that provides the functionality for generating a base operation graph\n * from the set of selected projects and phases.\n */\nexport class ValidateOperationsPlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, this._validateOperations.bind(this));\n    }\n    _validateOperations(records, context) {\n        const phasesByProject = new Map();\n        for (const { associatedPhase, associatedProject, runner } of records.keys()) {\n            if (associatedProject && associatedPhase && !(runner === null || runner === void 0 ? void 0 : runner.isNoOp)) {\n                // Ignore operations that aren't associated with a project or phase, or that\n                // use the NullOperationRunner (i.e. - the phase doesn't do anything)\n                let projectPhases = phasesByProject.get(associatedProject);\n                if (!projectPhases) {\n                    projectPhases = new Set();\n                    phasesByProject.set(associatedProject, projectPhases);\n                }\n                projectPhases.add(associatedPhase);\n            }\n        }\n        for (const [project, phases] of phasesByProject) {\n            const projectConfiguration = context.projectConfigurations.get(project);\n            if (projectConfiguration) {\n                projectConfiguration.validatePhaseConfiguration(phases, this._terminal);\n            }\n        }\n    }\n}\n//# sourceMappingURL=ValidateOperationsPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport schemaJson from '../../schemas/pnpm-config.schema.json';\n/**\n * Options that are only used when the PNPM package manager is selected.\n * Use this class to load \"common/config/rush/pnpm-config.json\" file,\n * or, load json from \"pnpmOptions\" field in \"rush.json\" for legacy support.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the PNPM package manager\n * is not being used.\n *\n * @public\n */\nclass PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /**\n     * (GENERATED BY RUSH-PNPM PATCH-COMMIT) When modifying this property, make sure you know what you are doing.\n     *\n     * The `globalPatchedDependencies` is added/updated automatically when you run pnpm patch-commit\n     * command. It is a dictionary where the key should be the package name and exact version. The value\n     * should be a relative path to a patch file.\n     *\n     * PNPM documentation: https://pnpm.io/package_json#pnpmpatcheddependencies\n     */\n    get globalPatchedDependencies() {\n        return this._globalPatchedDependencies;\n    }\n    constructor(json, commonTempFolder, jsonFilename) {\n        super(json);\n        this._json = json;\n        this.jsonFilename = jsonFilename;\n        this.pnpmStore = json.pnpmStore || 'local';\n        if (EnvironmentConfiguration.pnpmStorePathOverride) {\n            this.pnpmStorePath = EnvironmentConfiguration.pnpmStorePathOverride;\n        }\n        else if (this.pnpmStore === 'global') {\n            this.pnpmStorePath = '';\n        }\n        else {\n            this.pnpmStorePath = `${commonTempFolder}/pnpm-store`;\n        }\n        this.strictPeerDependencies = !!json.strictPeerDependencies;\n        this.preventManualShrinkwrapChanges = !!json.preventManualShrinkwrapChanges;\n        this.useWorkspaces = !!json.useWorkspaces;\n        this.globalOverrides = json.globalOverrides;\n        this.globalPeerDependencyRules = json.globalPeerDependencyRules;\n        this.globalPackageExtensions = json.globalPackageExtensions;\n        this.globalNeverBuiltDependencies = json.globalNeverBuiltDependencies;\n        this.globalAllowedDeprecatedVersions = json.globalAllowedDeprecatedVersions;\n        this.unsupportedPackageJsonSettings = json.unsupportedPackageJsonSettings;\n        this._globalPatchedDependencies = json.globalPatchedDependencies;\n        this.resolutionMode = json.resolutionMode;\n    }\n    /** @internal */\n    static loadFromJsonFileOrThrow(jsonFilename, commonTempFolder) {\n        const pnpmOptionJson = JsonFile.loadAndValidate(jsonFilename, PnpmOptionsConfiguration._jsonSchema);\n        return new PnpmOptionsConfiguration(pnpmOptionJson || {}, commonTempFolder, jsonFilename);\n    }\n    /** @internal */\n    static loadFromJsonObject(json, commonTempFolder) {\n        return new PnpmOptionsConfiguration(json, commonTempFolder);\n    }\n    /**\n     * Updates patchedDependencies field of the PNPM options in the common/config/rush/pnpm-config.json file.\n     */\n    updateGlobalPatchedDependencies(patchedDependencies) {\n        this._globalPatchedDependencies = patchedDependencies;\n        this._json.globalPatchedDependencies = patchedDependencies;\n        if (this.jsonFilename) {\n            JsonFile.save(this._json, this.jsonFilename, { updateExistingFile: true });\n        }\n    }\n}\nPnpmOptionsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { PnpmOptionsConfiguration };\n//# sourceMappingURL=PnpmOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\nimport { InternalError, JsonFile } from '@rushstack/node-core-library';\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport { RushConstants } from '../RushConstants';\n/**\n *\n */\nexport class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile {\n    /**\n     * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.\n     * @returns True if the project shrinkwrap was created or updated, false otherwise.\n     */\n    async updateProjectShrinkwrapAsync() {\n        const projectShrinkwrapMap = this.generateProjectShrinkwrapMap();\n        return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();\n    }\n    hasChanges(otherShrinkwrap) {\n        if (!otherShrinkwrap.shrinkwrapFile.isWorkspaceCompatible &&\n            !otherShrinkwrap.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName)) {\n            // The project is new to the shrinkwrap file.\n            return true;\n        }\n        const otherMap = otherShrinkwrap.generateProjectShrinkwrapMap();\n        const thisMap = this.generateProjectShrinkwrapMap();\n        if (!thisMap || !otherMap) {\n            // Handle one or both being undefined.\n            return !!(thisMap || otherMap);\n        }\n        if (thisMap.size !== otherMap.size) {\n            // Entries added or removed\n            return true;\n        }\n        for (const [key, value] of thisMap) {\n            if (otherMap.get(key) !== value) {\n                // A dependency changed or was added/removed\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Generate the project shrinkwrap file content\n     */\n    generateProjectShrinkwrapMap() {\n        const projectShrinkwrapMap = this.shrinkwrapFile.isWorkspaceCompatible\n            ? this.generateWorkspaceProjectShrinkwrapMap()\n            : this.generateLegacyProjectShrinkwrapMap();\n        return projectShrinkwrapMap;\n    }\n    generateWorkspaceProjectShrinkwrapMap() {\n        // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies\n        const importerKey = this.shrinkwrapFile.getImporterKeyByPath(this.project.rushConfiguration.commonTempFolder, this.project.projectFolder);\n        const projectShrinkwrapMap = this.shrinkwrapFile.getIntegrityForImporter(importerKey);\n        return projectShrinkwrapMap;\n    }\n    generateLegacyProjectShrinkwrapMap() {\n        const tempProjectDependencyKey = this.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName);\n        if (!tempProjectDependencyKey) {\n            throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);\n        }\n        const parentShrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);\n        const allDependencies = [\n            ...Object.entries(parentShrinkwrapEntry.dependencies || {}),\n            ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})\n        ];\n        const projectShrinkwrapMap = new Map();\n        for (const [name, version] of allDependencies) {\n            if (name.indexOf(`${RushConstants.rushTempNpmScope}/`) < 0) {\n                // Only select the shrinkwrap dependencies that are non-local since we already handle local\n                // project changes\n                this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);\n            }\n        }\n        // Since peer dependencies within on external packages may be hoisted up to the top-level package,\n        // we need to resolve and add these dependencies directly\n        this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);\n        return projectShrinkwrapMap;\n    }\n    _addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {\n        var _a;\n        const specifier = `${name}@${version}`;\n        if (projectShrinkwrapMap.has(specifier)) {\n            // getShrinkwrapEntry is idempotent with respect to name and version\n            return;\n        }\n        const shrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntry(name, version);\n        if (!shrinkwrapEntry) {\n            if (throwIfShrinkwrapEntryMissing) {\n                throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\n            }\n            return;\n        }\n        let integrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;\n        if (!integrity) {\n            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n            // Ex:\n            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n            //   ...\n            //   resolution:\n            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n            const sha256Digest = crypto\n                .createHash('sha256')\n                .update(JSON.stringify(shrinkwrapEntry))\n                .digest('hex');\n            integrity = `${name}@${version}:${sha256Digest}:`;\n        }\n        // Add the current dependency\n        projectShrinkwrapMap.set(specifier, integrity);\n        // Add the dependencies of the dependency\n        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.dependencies || {})) {\n            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry);\n        }\n        // Add the optional dependencies of the dependency, and don't blow up if they don't exist\n        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {\n            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry, \n            /* throwIfShrinkwrapEntryMissing */ false);\n        }\n        // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\n        // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\n        // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\n        // package manager.\n        if (!this.shrinkwrapFile.isWorkspaceCompatible) {\n            this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);\n        }\n    }\n    _resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry) {\n        var _a, _b, _c;\n        for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {\n            // Skip peer dependency resolution of local package peer dependencies\n            if (peerDependencyName.indexOf(RushConstants.rushTempNpmScope) !== -1) {\n                continue;\n            }\n            // Check to see if the peer dependency is satisfied with the current shrinkwrap\n            // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\n            // the specified dependency, check that the parent mentions the dependency in\n            // it's own peer dependencies. If it is, we can rely on the package manager and\n            // make the assumption that we've already found it further up the stack.\n            if (((_a = shrinkwrapEntry.dependencies) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(peerDependencyName)) ||\n                ((_b = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.dependencies) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(peerDependencyName)) ||\n                ((_c = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.peerDependencies) === null || _c === void 0 ? void 0 : _c.hasOwnProperty(peerDependencyName))) {\n                continue;\n            }\n            // As a last attempt, check if it's been hoisted up as a top-level dependency. If\n            // we can't find it, we can assume that it's already been provided somewhere up the\n            // dependency tree.\n            const topLevelDependencySpecifier = this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\n            if (topLevelDependencySpecifier) {\n                this._addDependencyRecursive(projectShrinkwrapMap, peerDependencyName, this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);\n            }\n        }\n    }\n    /**\n     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\n     */\n    async saveAsync(projectShrinkwrapMap) {\n        const file = {};\n        const keys = Array.from(projectShrinkwrapMap.keys()).sort();\n        for (const key of keys) {\n            file[key] = projectShrinkwrapMap.get(key);\n        }\n        await JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });\n    }\n}\n//# sourceMappingURL=PnpmProjectShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport crypto from 'crypto';\nimport colors from 'colors/safe';\nimport { FileSystem, AlreadyReportedError, Import, Path, InternalError } from '@rushstack/node-core-library';\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { DependencySpecifier } from '../DependencySpecifier';\nimport { PNPM_SHRINKWRAP_YAML_FORMAT } from './PnpmYamlCommon';\nimport { RushConstants } from '../RushConstants';\nimport { DependencyType, PackageJsonEditor } from '../../api/PackageJsonEditor';\nimport { PnpmfileConfiguration } from './PnpmfileConfiguration';\nimport { PnpmProjectShrinkwrapFile } from './PnpmProjectShrinkwrapFile';\nimport { PnpmOptionsConfiguration } from './PnpmOptionsConfiguration';\nconst yamlModule = Import.lazy('js-yaml', require);\n/**\n * Given an encoded \"dependency key\" from the PNPM shrinkwrap file, this parses it into an equivalent\n * DependencySpecifier.\n *\n * @returns a SemVer string, or undefined if the version specifier cannot be parsed\n */\nexport function parsePnpmDependencyKey(dependencyName, versionSpecifier) {\n    if (!versionSpecifier) {\n        return undefined;\n    }\n    const dependencyKey = normalizePnpmVersionSpecifier(versionSpecifier);\n    if (/^\\w+:/.test(dependencyKey)) {\n        // If it starts with an NPM scheme such as \"file:projects/my-app.tgz\", we don't support that\n        return undefined;\n    }\n    // The package name parsed from the dependency key, or dependencyName if it was omitted.\n    // Example: \"@scope/depame\"\n    let parsedPackageName;\n    // The trailing portion of the dependency key that includes the version and optional peer dependency path.\n    // Example: \"2.8.0/chai@3.5.0+sinon@1.17.7\"\n    let parsedInstallPath;\n    // Example: \"path.pkgs.visualstudio.com/@scope/depame/1.4.0\"  --> 0=\"@scope/depame\" 1=\"1.4.0\"\n    // Example: \"/isarray/2.0.1\"                                  --> 0=\"isarray\"       1=\"2.0.1\"\n    // Example: \"/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7\"       --> 0=\"sinon-chai\"    1=\"2.8.0/chai@3.5.0+sinon@1.17.7\"\n    // Example: \"/typescript@5.1.6\"                               --> 0=typescript      1=\"5.1.6\"\n    // Example: 1.2.3_peer-dependency@.4.5.6                      --> no match\n    // Example: 1.2.3_@scope+peer-dependency@.4.5.6               --> no match\n    // Example: 1.2.3(peer-dependency@.4.5.6)                     --> no match\n    // Example: 1.2.3(@scope/peer-dependency@.4.5.6)              --> no match\n    const packageNameMatch = /^[^\\/(]*\\/((?:@[^\\/(]+\\/)?[^\\/(]+)[\\/@](.*)$/.exec(dependencyKey);\n    if (packageNameMatch) {\n        parsedPackageName = packageNameMatch[1];\n        parsedInstallPath = packageNameMatch[2];\n    }\n    else {\n        parsedPackageName = dependencyName;\n        // Example: \"23.6.0_babel-core@6.26.3\"\n        // Example: \"23.6.0\"\n        parsedInstallPath = dependencyKey;\n    }\n    // The SemVer value\n    // Example: \"2.8.0\"\n    let parsedVersionPart;\n    // Example: \"23.6.0_babel-core@6.26.3\" --> \"23.6.0\"\n    // Example: \"2.8.0/chai@3.5.0+sinon@1.17.7\" --> \"2.8.0\"\n    // Example: \"0.53.1(@types/node@14.18.36)\" --> \"0.53.1\"\n    const versionMatch = /^([^\\(\\/_]+)[(\\/_]/.exec(parsedInstallPath);\n    if (versionMatch) {\n        parsedVersionPart = versionMatch[1];\n    }\n    else {\n        // Example: \"2.8.0\"\n        parsedVersionPart = parsedInstallPath;\n    }\n    // By this point, we expect parsedVersionPart to be a valid SemVer range\n    if (!parsedVersionPart) {\n        return undefined;\n    }\n    if (!semver.valid(parsedVersionPart)) {\n        const urlRegex = /^(git@|@)?([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}(\\/|\\+)([^\\/\\\\]+\\/?)*([^\\/\\\\]+)$/i;\n        // Test for urls:\n        // Examples:\n        //     @github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     github.com.au/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     git@bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.co.in/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        if (urlRegex.test(dependencyKey)) {\n            const dependencySpecifier = new DependencySpecifier(dependencyName, dependencyKey);\n            return dependencySpecifier;\n        }\n        else {\n            return undefined;\n        }\n    }\n    // Is it an alias for a different package?\n    if (parsedPackageName === dependencyName) {\n        // No, it's a regular dependency\n        return new DependencySpecifier(parsedPackageName, parsedVersionPart);\n    }\n    else {\n        // If the parsed package name is different from the dependencyName, then this is an NPM package alias\n        return new DependencySpecifier(dependencyName, `npm:${parsedPackageName}@${parsedVersionPart}`);\n    }\n}\nexport function normalizePnpmVersionSpecifier(versionSpecifier) {\n    if (typeof versionSpecifier === 'string') {\n        return versionSpecifier;\n    }\n    else {\n        return versionSpecifier.version;\n    }\n}\nexport class PnpmShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        // Normalize the data\n        const lockfileVersion = shrinkwrapJson.lockfileVersion;\n        if (typeof lockfileVersion === 'string') {\n            this.shrinkwrapFileMajorVersion = parseInt(lockfileVersion.substring(0, lockfileVersion.indexOf('.')), 10);\n        }\n        else if (typeof lockfileVersion === 'number') {\n            this.shrinkwrapFileMajorVersion = lockfileVersion;\n        }\n        else {\n            this.shrinkwrapFileMajorVersion = 0;\n        }\n        this.registry = shrinkwrapJson.registry || '';\n        this.dependencies = new Map(Object.entries(shrinkwrapJson.dependencies || {}));\n        this.importers = new Map(Object.entries(shrinkwrapJson.importers || {}));\n        this.specifiers = new Map(Object.entries(shrinkwrapJson.specifiers || {}));\n        this.packages = new Map(Object.entries(shrinkwrapJson.packages || {}));\n        this.overrides = new Map(Object.entries(shrinkwrapJson.overrides || {}));\n        // Importers only exist in workspaces\n        this.isWorkspaceCompatible = this.importers.size > 0;\n        this._integrities = new Map();\n    }\n    static loadFromFile(shrinkwrapYamlFilename) {\n        try {\n            const shrinkwrapContent = FileSystem.readFile(shrinkwrapYamlFilename);\n            return PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                return undefined; // file does not exist\n            }\n            throw new Error(`Error reading \"${shrinkwrapYamlFilename}\":\\n  ${error.message}`);\n        }\n    }\n    static loadFromString(shrinkwrapContent) {\n        const parsedData = yamlModule.safeLoad(shrinkwrapContent);\n        return new PnpmShrinkwrapFile(parsedData);\n    }\n    getShrinkwrapHash(experimentsConfig) {\n        // The 'omitImportersFromPreventManualShrinkwrapChanges' experiment skips the 'importers' section\n        // when computing the hash, since the main concern is changes to the overall external dependency footprint\n        const { omitImportersFromPreventManualShrinkwrapChanges } = experimentsConfig || {};\n        const shrinkwrapContent = this._serializeInternal(omitImportersFromPreventManualShrinkwrapChanges);\n        return crypto.createHash('sha1').update(shrinkwrapContent).digest('hex');\n    }\n    /** @override */\n    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) {\n        super.validate(packageManagerOptionsConfig, policyOptions);\n        if (!(packageManagerOptionsConfig instanceof PnpmOptionsConfiguration)) {\n            throw new Error('The provided package manager options are not valid for PNPM shrinkwrap files.');\n        }\n        if (!policyOptions.allowShrinkwrapUpdates) {\n            if (!policyOptions.repoState.isValid) {\n                // eslint-disable-next-line no-console\n                console.log(colors.red(`The ${RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker ` +\n                    'in the file. You may need to run \"rush update\" to refresh its contents.') + '\\n');\n                throw new AlreadyReportedError();\n            }\n            // Only check the hash if allowShrinkwrapUpdates is false. If true, the shrinkwrap file\n            // may have changed and the hash could be invalid.\n            if (packageManagerOptionsConfig.preventManualShrinkwrapChanges) {\n                if (!policyOptions.repoState.pnpmShrinkwrapHash) {\n                    // eslint-disable-next-line no-console\n                    console.log(colors.red('The existing shrinkwrap file hash could not be found. You may need to run \"rush update\" to ' +\n                        'populate the hash. See the \"preventManualShrinkwrapChanges\" setting documentation for details.') + '\\n');\n                    throw new AlreadyReportedError();\n                }\n                if (this.getShrinkwrapHash(experimentsConfig) !== policyOptions.repoState.pnpmShrinkwrapHash) {\n                    // eslint-disable-next-line no-console\n                    console.log(colors.red('The shrinkwrap file hash does not match the expected hash. Please run \"rush update\" to ensure the ' +\n                        'shrinkwrap file is up to date. See the \"preventManualShrinkwrapChanges\" setting documentation for ' +\n                        'details.') + '\\n');\n                    throw new AlreadyReportedError();\n                }\n            }\n        }\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._getTempProjectNames(this._shrinkwrapJson.dependencies || {});\n    }\n    /**\n     * Gets the path to the tarball file if the package is a tarball.\n     * Returns undefined if the package entry doesn't exist or the package isn't a tarball.\n     * Example of return value: file:projects/build-tools.tgz\n     */\n    getTarballPath(packageName) {\n        var _a;\n        const dependency = this.packages.get(packageName);\n        return (_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball;\n    }\n    getTopLevelDependencyKey(dependencyName) {\n        return this.dependencies.get(dependencyName);\n    }\n    /**\n     * Gets the version number from the list of top-level dependencies in the \"dependencies\" section\n     * of the shrinkwrap file. Sample return values:\n     *   '2.1.113'\n     *   '1.9.0-dev.27'\n     *   'file:projects/empty-webpart-project.tgz'\n     *   undefined\n     *\n     * @override\n     */\n    getTopLevelDependencyVersion(dependencyName) {\n        var _a;\n        let value = this.dependencies.get(dependencyName);\n        if (value) {\n            value = normalizePnpmVersionSpecifier(value);\n            // Getting the top level dependency version from a PNPM lockfile version 5.x or 6.1\n            // --------------------------------------------------------------------------\n            //\n            // 1) Top-level tarball dependency entries in pnpm-lock.yaml look like in 5.x:\n            //    ```\n            //    '@rush-temp/sp-filepicker': 'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5'\n            //    ```\n            //    And in version 6.1, they look like:\n            //    ```\n            //    '@rush-temp/sp-filepicker':\n            //      specifier: file:./projects/generate-api-docs.tgz\n            //      version: file:projects/generate-api-docs.tgz\n            //    ```\n            //    Then, it would be defined below (version 5.x):\n            //    ```\n            //    'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5':\n            //      dependencies:\n            //       '@microsoft/load-themed-styles': 1.10.7\n            //       ...\n            //      resolution:\n            //       integrity: sha512-guuoFIc**==\n            //       tarball: 'file:projects/sp-filepicker.tgz'\n            //    ```\n            //    Or in version 6.1:\n            //    ```\n            //    file:projects/sp-filepicker.tgz:\n            //      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}\n            //      name: '@rush-temp/sp-filepicker'\n            //      version: 0.0.0\n            //      dependencies:\n            //        '@microsoft/load-themed-styles': 1.10.7\n            //        ...\n            //      dev: false\n            //    ```\n            //    Here, we are interested in the part 'file:projects/sp-filepicker.tgz'. Splitting by underscores is not the\n            //    best way to get this because file names could have underscores in them. Instead, we could use the tarball\n            //    field in the resolution section.\n            // 2) Top-level non-tarball dependency entries in pnpm-lock.yaml would look like in 5.x:\n            //    ```\n            //    '@rushstack/set-webpack-public-path-plugin': 2.1.133\n            //    @microsoft/sp-build-node': 1.9.0-dev.27_typescript@2.9.2\n            //    ```\n            //    And in version 6.1, they look like:\n            //    ```\n            //    '@rushstack/set-webpack-public-path-plugin':\n            //      specifier: ^2.1.133\n            //      version: 2.1.133\n            //    '@microsoft/sp-build-node':\n            //      specifier: 1.9.0-dev.27\n            //      version: 1.9.0-dev.27(typescript@2.9.2)\n            //    ```\n            //    Here, we could either just split by underscores and take the first part (5.x) or use the specifier field\n            //    (6.1).\n            // The below code is also compatible with lockfile versions < 5.1\n            const dependency = this.packages.get(value);\n            if (((_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball) && value.startsWith(dependency.resolution.tarball)) {\n                return new DependencySpecifier(dependencyName, dependency.resolution.tarball);\n            }\n            else {\n                let underscoreOrParenthesisIndex = value.indexOf('_');\n                if (underscoreOrParenthesisIndex < 0) {\n                    underscoreOrParenthesisIndex = value.indexOf('(');\n                }\n                if (underscoreOrParenthesisIndex >= 0) {\n                    value = value.substring(0, underscoreOrParenthesisIndex);\n                }\n            }\n            return new DependencySpecifier(dependencyName, value);\n        }\n        return undefined;\n    }\n    /**\n     * The PNPM shrinkwrap file has top-level dependencies on the temp projects like this (version 5.x):\n     *\n     * ```\n     * dependencies:\n     *   '@rush-temp/my-app': 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0'\n     * packages:\n     *   /@types/node/10.14.15:\n     *     dev: false\n     *   'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0':\n     *     dev: false\n     *     name: '@rush-temp/my-app'\n     *     version: 0.0.0\n     * ```\n     *\n     * or in version 6.1, like this:\n     * ```\n     * dependencies:\n     *  '@rush-temp/my-app':\n     *    specifier: file:./projects/my-app.tgz\n     *    version: file:projects/my-app.tgz\n     *  packages:\n     *    /@types/node@10.14.15:\n     *      resolution: {integrity: sha512-iAB+**==}\n     *      dev: false\n     *    file:projects/my-app.tgz\n     *      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}\n     *      name: '@rush-temp/my-app'\n     *      version: 0.0.0\n     *      dependencies:\n     *        '@microsoft/load-themed-styles': 1.10.7\n     *        ...\n     *      dev: false\n     * ```\n     *\n     * We refer to 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0' or 'file:projects/my-app.tgz' as\n     * the temp project dependency key of the temp project '@rush-temp/my-app'.\n     */\n    getTempProjectDependencyKey(tempProjectName) {\n        const tempProjectDependencyKey = this.dependencies.get(tempProjectName);\n        return tempProjectDependencyKey ? normalizePnpmVersionSpecifier(tempProjectDependencyKey) : undefined;\n    }\n    getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey) {\n        return this.packages.get(tempProjectDependencyKey);\n    }\n    getShrinkwrapEntry(name, version) {\n        const packageId = this._getPackageId(name, version);\n        return this.packages.get(packageId);\n    }\n    /**\n     * Serializes the PNPM Shrinkwrap file\n     *\n     * @override\n     */\n    serialize() {\n        return this._serializeInternal(false);\n    }\n    /**\n     * Gets the resolved version number of a dependency for a specific temp project.\n     * For PNPM, we can reuse the version that another project is using.\n     * Note that this function modifies the shrinkwrap data if tryReusingPackageVersionsFromShrinkwrap is set to true.\n     *\n     * @override\n     */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the\n        // shrinkwrap file puts our dependency in either the top of the node_modules folder\n        // or underneath the package we are looking at.\n        // This is because the PNPM shrinkwrap file describes the exact links that need to be created\n        // to recreate the graph..\n        // Because of this, we actually need to check for a version that this package is directly\n        // linked to.\n        const packageName = dependencySpecifier.packageName;\n        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);\n        if (!tempProjectDependencyKey) {\n            return undefined;\n        }\n        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);\n        if (!packageDescription ||\n            !packageDescription.dependencies ||\n            !packageDescription.dependencies.hasOwnProperty(packageName)) {\n            return undefined;\n        }\n        const dependencyKey = packageDescription.dependencies[packageName];\n        return this._parsePnpmDependencyKey(packageName, dependencyKey);\n    }\n    /** @override */\n    findOrphanedProjects(rushConfiguration) {\n        // The base shrinkwrap handles orphaned projects the same across all package managers,\n        // but this is only valid for non-workspace installs\n        if (!this.isWorkspaceCompatible) {\n            return super.findOrphanedProjects(rushConfiguration);\n        }\n        const orphanedProjectPaths = [];\n        for (const importerKey of this.getImporterKeys()) {\n            // PNPM importer keys are relative paths from the workspace root, which is the common temp folder\n            const rushProjectPath = path.resolve(rushConfiguration.commonTempFolder, importerKey);\n            if (!rushConfiguration.tryGetProjectForPath(rushProjectPath)) {\n                orphanedProjectPaths.push(rushProjectPath);\n            }\n        }\n        return orphanedProjectPaths;\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return new PnpmProjectShrinkwrapFile(this, project);\n    }\n    *getImporterKeys() {\n        // Filter out the root importer used for the generated package.json in the root\n        // of the install, since we do not use this.\n        for (const key of this.importers.keys()) {\n            if (key !== '.') {\n                yield key;\n            }\n        }\n    }\n    getImporterKeyByPath(workspaceRoot, projectFolder) {\n        return Path.convertToSlashes(path.relative(workspaceRoot, projectFolder));\n    }\n    getImporter(importerKey) {\n        return this.importers.get(importerKey);\n    }\n    getIntegrityForImporter(importerKey) {\n        // This logic formerly lived in PnpmProjectShrinkwrapFile. Moving it here allows caching of the external\n        // dependency integrity relationships across projects\n        let integrityMap = this._integrities.get(importerKey);\n        if (!integrityMap) {\n            const importer = this.getImporter(importerKey);\n            if (importer) {\n                integrityMap = new Map();\n                this._integrities.set(importerKey, integrityMap);\n                const sha256Digest = crypto\n                    .createHash('sha256')\n                    .update(JSON.stringify(importer))\n                    .digest('base64');\n                const selfIntegrity = `${importerKey}:${sha256Digest}:`;\n                integrityMap.set(importerKey, selfIntegrity);\n                const { dependencies, devDependencies, optionalDependencies } = importer;\n                const externalFilter = (name, versionSpecifier) => {\n                    const version = normalizePnpmVersionSpecifier(versionSpecifier);\n                    return !version.includes('link:');\n                };\n                if (dependencies) {\n                    this._addIntegrities(integrityMap, dependencies, false, externalFilter);\n                }\n                if (devDependencies) {\n                    this._addIntegrities(integrityMap, devDependencies, false, externalFilter);\n                }\n                if (optionalDependencies) {\n                    this._addIntegrities(integrityMap, optionalDependencies, true, externalFilter);\n                }\n            }\n        }\n        return integrityMap;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, variant) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        const importerKey = this.getImporterKeyByPath(project.rushConfiguration.commonTempFolder, project.projectFolder);\n        const importer = this.getImporter(importerKey);\n        if (!importer) {\n            return true;\n        }\n        // First, let's transform the package.json using the pnpmfile\n        const packageJson = project.packageJsonEditor.saveToObject();\n        // Initialize the pnpmfile if it doesn't exist\n        if (!this._pnpmfileConfiguration) {\n            this._pnpmfileConfiguration = await PnpmfileConfiguration.initializeAsync(project.rushConfiguration, {\n                variant\n            });\n        }\n        // Use a new PackageJsonEditor since it will classify each dependency type, making tracking the\n        // found versions much simpler.\n        const { dependencyList, devDependencyList } = PackageJsonEditor.fromObject(this._pnpmfileConfiguration.transform(packageJson), project.packageJsonEditor.filePath);\n        const allDependencies = [...dependencyList, ...devDependencyList];\n        if (this.shrinkwrapFileMajorVersion < 6) {\n            // PNPM <= v7\n            // Then get the unique package names and map them to package versions.\n            const dependencyVersions = new Map();\n            for (const packageDependency of allDependencies) {\n                // We will also filter out peer dependencies since these are not installed at development time.\n                if (packageDependency.dependencyType === DependencyType.Peer) {\n                    continue;\n                }\n                const foundDependency = dependencyVersions.get(packageDependency.name);\n                if (!foundDependency) {\n                    dependencyVersions.set(packageDependency.name, packageDependency);\n                }\n                else {\n                    // Shrinkwrap will prioritize optional dependencies, followed by regular dependencies, with dev being\n                    // the least prioritized. We will only keep the most prioritized option.\n                    // See: https://github.com/pnpm/pnpm/blob/main/packages/lockfile-utils/src/satisfiesPackageManifest.ts\n                    switch (foundDependency.dependencyType) {\n                        case DependencyType.Optional:\n                            break;\n                        case DependencyType.Regular:\n                            if (packageDependency.dependencyType === DependencyType.Optional) {\n                                dependencyVersions.set(packageDependency.name, packageDependency);\n                            }\n                            break;\n                        case DependencyType.Dev:\n                            dependencyVersions.set(packageDependency.name, packageDependency);\n                            break;\n                    }\n                }\n            }\n            // Then validate that the dependency fields are as expected in the shrinkwrap to avoid false-negatives\n            // when moving a package from one field to the other.\n            for (const { dependencyType, name } of dependencyVersions.values()) {\n                switch (dependencyType) {\n                    case DependencyType.Optional:\n                        if (!((_a = importer.optionalDependencies) === null || _a === void 0 ? void 0 : _a[name]))\n                            return true;\n                        break;\n                    case DependencyType.Regular:\n                        if (!((_b = importer.dependencies) === null || _b === void 0 ? void 0 : _b[name]))\n                            return true;\n                        break;\n                    case DependencyType.Dev:\n                        if (!((_c = importer.devDependencies) === null || _c === void 0 ? void 0 : _c[name]))\n                            return true;\n                        break;\n                }\n            }\n            const specifiers = importer.specifiers;\n            if (!specifiers) {\n                throw new InternalError('Expected specifiers to be defined, but is expected in lockfile version 5');\n            }\n            // Then validate the length matches between the importer and the dependency list, since duplicates are\n            // a valid use-case. Importers will only take one of these values, so no need to do more work here.\n            if (dependencyVersions.size !== Object.keys(specifiers).length) {\n                return true;\n            }\n            // Finally, validate that all values in the importer are also present in the dependency list.\n            for (const [importerPackageName, importerVersionSpecifier] of Object.entries(specifiers)) {\n                const foundDependency = dependencyVersions.get(importerPackageName);\n                if (!foundDependency) {\n                    return true;\n                }\n                const resolvedVersion = (_d = this.overrides.get(importerPackageName)) !== null && _d !== void 0 ? _d : foundDependency.version;\n                if (resolvedVersion !== importerVersionSpecifier) {\n                    return true;\n                }\n            }\n        }\n        else {\n            // PNPM v8\n            const importerOptionalDependencies = new Set(Object.keys((_e = importer.optionalDependencies) !== null && _e !== void 0 ? _e : {}));\n            const importerDependencies = new Set(Object.keys((_f = importer.dependencies) !== null && _f !== void 0 ? _f : {}));\n            const importerDevDependencies = new Set(Object.keys((_g = importer.devDependencies) !== null && _g !== void 0 ? _g : {}));\n            for (const { dependencyType, name, version } of allDependencies) {\n                let isOptional = false;\n                let specifierFromLockfile;\n                let isDevDepFallThrough = false;\n                switch (dependencyType) {\n                    case DependencyType.Optional: {\n                        specifierFromLockfile = (_h = importer.optionalDependencies) === null || _h === void 0 ? void 0 : _h[name];\n                        importerOptionalDependencies.delete(name);\n                        break;\n                    }\n                    case DependencyType.Peer: {\n                        // Peer dependencies of workspace projects may be installed as regular dependencies\n                        isOptional = true; // fall through\n                    }\n                    case DependencyType.Dev: {\n                        specifierFromLockfile = (_j = importer.devDependencies) === null || _j === void 0 ? void 0 : _j[name];\n                        if (specifierFromLockfile) {\n                            // If the dev dependency is not found, it may be installed as a regular dependency,\n                            // so fall through\n                            importerDevDependencies.delete(name);\n                            break;\n                        }\n                        // If fall through, there is a chance the package declares an inconsistent version, ignore it.\n                        isDevDepFallThrough = true;\n                    }\n                    // eslint-disable-next-line no-fallthrough\n                    case DependencyType.Regular:\n                        specifierFromLockfile = (_k = importer.dependencies) === null || _k === void 0 ? void 0 : _k[name];\n                        importerDependencies.delete(name);\n                        break;\n                }\n                if (!specifierFromLockfile) {\n                    if (!isOptional) {\n                        return true;\n                    }\n                }\n                else {\n                    if (typeof specifierFromLockfile === 'string') {\n                        throw new Error(`The PNPM lockfile is in an unexpected format. The \"${name}\" package is specified as ` +\n                            `\"${specifierFromLockfile}\" instead of an object.`);\n                    }\n                    else {\n                        // TODO: Emit an error message when someone tries to override a version of something in one of their\n                        // local repo packages.\n                        const resolvedVersion = (_l = this.overrides.get(name)) !== null && _l !== void 0 ? _l : version;\n                        if (specifierFromLockfile.specifier !== resolvedVersion && !isDevDepFallThrough && !isOptional) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            // Finally, validate that all values in the importer are also present in the dependency list.\n            if (importerOptionalDependencies.size > 0 ||\n                importerDependencies.size > 0 ||\n                importerDevDependencies.size > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _getIntegrityForPackage(specifier, optional) {\n        var _a;\n        const integrities = this._integrities;\n        let integrityMap = integrities.get(specifier);\n        if (integrityMap) {\n            return integrityMap;\n        }\n        integrityMap = new Map();\n        integrities.set(specifier, integrityMap);\n        const shrinkwrapEntry = this.packages.get(specifier);\n        if (!shrinkwrapEntry) {\n            if (!optional) {\n                // This algorithm heeds to be robust against missing shrinkwrap entries, so we can't just throw\n                // Instead set it to a value which will not match any valid shrinkwrap record\n                integrityMap.set(specifier, 'Missing shrinkwrap entry!');\n            }\n            // Indicate an empty entry\n            return integrityMap;\n        }\n        let selfIntegrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;\n        if (!selfIntegrity) {\n            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n            // Ex:\n            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n            //   ...\n            //   resolution:\n            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n            const sha256Digest = crypto\n                .createHash('sha256')\n                .update(JSON.stringify(shrinkwrapEntry))\n                .digest('base64');\n            selfIntegrity = `${specifier}:${sha256Digest}:`;\n        }\n        integrityMap.set(specifier, selfIntegrity);\n        const { dependencies, optionalDependencies } = shrinkwrapEntry;\n        if (dependencies) {\n            this._addIntegrities(integrityMap, dependencies, false);\n        }\n        if (optionalDependencies) {\n            this._addIntegrities(integrityMap, optionalDependencies, true);\n        }\n        return integrityMap;\n    }\n    _addIntegrities(integrityMap, collection, optional, filter) {\n        for (const [name, version] of Object.entries(collection)) {\n            if (filter && !filter(name, version)) {\n                continue;\n            }\n            const packageId = this._getPackageId(name, version);\n            if (integrityMap.has(packageId)) {\n                // The entry could already have been added as a nested dependency\n                continue;\n            }\n            const contribution = this._getIntegrityForPackage(packageId, optional);\n            for (const [dep, integrity] of contribution) {\n                integrityMap.set(dep, integrity);\n            }\n        }\n    }\n    /**\n     * Gets the package description for a tempProject from the shrinkwrap file.\n     */\n    _getPackageDescription(tempProjectDependencyKey) {\n        const packageDescription = this.packages.get(tempProjectDependencyKey);\n        return packageDescription && packageDescription.dependencies ? packageDescription : undefined;\n    }\n    _getPackageId(name, versionSpecifier) {\n        const version = normalizePnpmVersionSpecifier(versionSpecifier);\n        if (this.shrinkwrapFileMajorVersion >= 6) {\n            if (version.startsWith('@github')) {\n                // This is a github repo reference\n                return version;\n            }\n            else {\n                return version.startsWith('/') ? version : `/${name}@${version}`;\n            }\n        }\n        else {\n            // Version can sometimes be in the form of a path that's already in the /name/version format.\n            return version.indexOf('/') !== -1 ? version : `/${name}/${version}`;\n        }\n    }\n    _parsePnpmDependencyKey(dependencyName, pnpmDependencyKey) {\n        if (pnpmDependencyKey) {\n            const result = parsePnpmDependencyKey(dependencyName, pnpmDependencyKey);\n            if (!result) {\n                throw new Error(`Cannot parse PNPM shrinkwrap version specifier: \"${pnpmDependencyKey}\"` +\n                    ` for \"${dependencyName}\"`);\n            }\n            return result;\n        }\n        else {\n            return undefined;\n        }\n    }\n    _serializeInternal(omitImporters = false) {\n        // Ensure that if any of the top-level properties are provided but empty are removed. We populate the object\n        // properties when we read the shrinkwrap but PNPM does not set these top-level properties unless they are present.\n        const shrinkwrapToSerialize = {};\n        for (const [key, value] of Object.entries(this._shrinkwrapJson)) {\n            if (omitImporters && key === 'importers') {\n                continue;\n            }\n            if (!value || typeof value !== 'object' || Object.keys(value).length > 0) {\n                shrinkwrapToSerialize[key] = value;\n            }\n        }\n        return yamlModule.safeDump(shrinkwrapToSerialize, PNPM_SHRINKWRAP_YAML_FORMAT);\n    }\n}\n//# sourceMappingURL=PnpmShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// This is based on PNPM's own configuration:\n// https://github.com/pnpm/pnpm-shrinkwrap/blob/master/src/write.ts\nexport const PNPM_SHRINKWRAP_YAML_FORMAT = {\n    lineWidth: 1000,\n    noCompatMode: true,\n    noRefs: true,\n    sortKeys: true\n};\n//# sourceMappingURL=PnpmYamlCommon.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, Import, JsonFile, MapExtensions } from '@rushstack/node-core-library';\nimport * as pnpmfile from './PnpmfileShim';\nimport { pnpmfileShimFilename, scriptsFolderPath } from '../../utilities/PathConstants';\n/**\n * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,\n * optionally utilizing a pnpmfile shim to inject preferred versions.\n */\nexport class PnpmfileConfiguration {\n    constructor(context) {\n        this._context = context;\n    }\n    static async initializeAsync(rushConfiguration, pnpmfileShimOptions) {\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`PnpmfileConfiguration cannot be used with package manager \"${rushConfiguration.packageManager}\"`);\n        }\n        // Set the context to swallow log output and store our settings\n        const context = {\n            log: (message) => { },\n            pnpmfileShimSettings: await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, pnpmfileShimOptions)\n        };\n        return new PnpmfileConfiguration(context);\n    }\n    static async writeCommonTempPnpmfileShimAsync(rushConfiguration, options) {\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`PnpmfileConfiguration cannot be used with package manager \"${rushConfiguration.packageManager}\"`);\n        }\n        const targetDir = rushConfiguration.commonTempFolder;\n        const pnpmfilePath = path.join(targetDir, rushConfiguration.packageManagerWrapper.pnpmfileFilename);\n        // Write the shim itself\n        await FileSystem.copyFileAsync({\n            sourcePath: `${scriptsFolderPath}/${pnpmfileShimFilename}`,\n            destinationPath: pnpmfilePath\n        });\n        const pnpmfileShimSettings = await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, options);\n        // Write the settings file used by the shim\n        await JsonFile.saveAsync(pnpmfileShimSettings, path.join(targetDir, 'pnpmfileSettings.json'), {\n            ensureFolderExists: true\n        });\n    }\n    static async _getPnpmfileShimSettingsAsync(rushConfiguration, options) {\n        let allPreferredVersions = {};\n        let allowedAlternativeVersions = {};\n        const workspaceVersions = {};\n        // Only workspaces shims in the common versions using pnpmfile\n        if (rushConfiguration.packageManagerOptions.useWorkspaces) {\n            const commonVersionsConfiguration = rushConfiguration.getCommonVersions();\n            const preferredVersions = new Map();\n            MapExtensions.mergeFromMap(preferredVersions, commonVersionsConfiguration.getAllPreferredVersions());\n            MapExtensions.mergeFromMap(preferredVersions, rushConfiguration.getImplicitlyPreferredVersions());\n            allPreferredVersions = MapExtensions.toObject(preferredVersions);\n            allowedAlternativeVersions = MapExtensions.toObject(commonVersionsConfiguration.allowedAlternativeVersions);\n            for (const project of rushConfiguration.projects) {\n                workspaceVersions[project.packageName] = project.packageJson.version;\n            }\n        }\n        const settings = {\n            allPreferredVersions,\n            allowedAlternativeVersions,\n            workspaceVersions,\n            semverPath: Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })\n        };\n        // Use the provided path if available. Otherwise, use the default path.\n        const userPnpmfilePath = rushConfiguration.getPnpmfilePath(options === null || options === void 0 ? void 0 : options.variant);\n        if (userPnpmfilePath && FileSystem.exists(userPnpmfilePath)) {\n            settings.userPnpmfilePath = userPnpmfilePath;\n        }\n        return settings;\n    }\n    /**\n     * Transform a package.json file using the pnpmfile.js hook.\n     * @returns the transformed object, or the original input if pnpmfile.js was not found.\n     */\n    transform(packageJson) {\n        var _a;\n        if (!((_a = pnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) || !this._context) {\n            return packageJson;\n        }\n        else {\n            return pnpmfile.hooks.readPackage(packageJson, this._context);\n        }\n    }\n}\n//# sourceMappingURL=PnpmfileConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar _a;\nlet settings;\nlet allPreferredVersions;\nlet allowedAlternativeVersions;\nlet userPnpmfile;\nlet semver;\n// Initialize all external aspects of the pnpmfile shim. When using the shim, settings\n// are always expected to be available. Init must be called before running any hook that\n// depends on a resource obtained from or related to the settings, and will require modules\n// once so they aren't repeatedly required in the hook functions.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction init(context) {\n    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:\n    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134\n    // So we need to normalize the context format before we move on\n    if (typeof context !== 'object' || Array.isArray(context)) {\n        context = {\n            log: (message) => { },\n            originalContext: context\n        };\n    }\n    if (!settings) {\n        // Initialize the settings from file\n        if (!context.pnpmfileShimSettings) {\n            context.pnpmfileShimSettings = __non_webpack_require__('./pnpmfileSettings.json');\n        }\n        settings = context.pnpmfileShimSettings;\n    }\n    else if (!context.pnpmfileShimSettings) {\n        // Reuse the already initialized settings\n        context.pnpmfileShimSettings = settings;\n    }\n    if (!allPreferredVersions && settings.allPreferredVersions) {\n        allPreferredVersions = new Map(Object.entries(settings.allPreferredVersions));\n    }\n    if (!allowedAlternativeVersions && settings.allowedAlternativeVersions) {\n        allowedAlternativeVersions = new Map(Object.entries(settings.allowedAlternativeVersions).map(([packageName, versions]) => {\n            return [packageName, new Set(versions)];\n        }));\n    }\n    // If a userPnpmfilePath is provided, we expect it to exist\n    if (!userPnpmfile && settings.userPnpmfilePath) {\n        userPnpmfile = require(settings.userPnpmfilePath);\n    }\n    // If a semverPath is provided, we expect it to exist\n    if (!semver && settings.semverPath) {\n        semver = require(settings.semverPath);\n    }\n    // Return the normalized context\n    return context;\n}\n// Set the preferred versions on the dependency map. If the version on the map is an allowedAlternativeVersion\n// then skip it. Otherwise, check to ensure that the common version is a subset of the specified version. If\n// it is, then replace the specified version with the preferredVersion\nfunction setPreferredVersions(dependencies) {\n    var _a;\n    for (const [name, version] of Object.entries(dependencies || {})) {\n        const preferredVersion = allPreferredVersions === null || allPreferredVersions === void 0 ? void 0 : allPreferredVersions.get(name);\n        if (preferredVersion && !((_a = allowedAlternativeVersions === null || allowedAlternativeVersions === void 0 ? void 0 : allowedAlternativeVersions.get(name)) === null || _a === void 0 ? void 0 : _a.has(version))) {\n            let preferredVersionRange;\n            let versionRange;\n            try {\n                preferredVersionRange = new semver.Range(preferredVersion);\n                versionRange = new semver.Range(version);\n            }\n            catch (_b) {\n                // Swallow invalid range errors\n            }\n            if (preferredVersionRange &&\n                versionRange &&\n                semver.subset(preferredVersionRange, versionRange, { includePrerelease: true })) {\n                dependencies[name] = preferredVersion;\n            }\n        }\n    }\n}\nexport const hooks = {\n    // Call the original pnpmfile (if it exists)\n    afterAllResolved: (lockfile, context) => {\n        var _a;\n        context = init(context);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)\n            ? userPnpmfile.hooks.afterAllResolved(lockfile, context)\n            : lockfile;\n    },\n    // Set the preferred versions in the package, then call the original pnpmfile (if it exists)\n    readPackage: (pkg, context) => {\n        var _a;\n        context = init(context);\n        setPreferredVersions(pkg.dependencies);\n        setPreferredVersions(pkg.devDependencies);\n        setPreferredVersions(pkg.optionalDependencies);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;\n    },\n    // Call the original pnpmfile (if it exists)\n    filterLog: (_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.filterLog\n};\n//# sourceMappingURL=PnpmfileShim.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, Async, FileSystem } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\n/**\n * Ensures the environment where the Rush repo exists is valid\n */\nexport async function validateAsync(rushConfiguration, options) {\n    if (rushConfiguration.experimentsConfiguration.configuration.forbidPhantomResolvableNodeModulesFolders) {\n        const pathParts = rushConfiguration.rushJsonFolder.split(/[\\/\\\\]/);\n        const existingNodeModulesPaths = [];\n        await Async.forEachAsync(pathParts, async (pathPart, index) => {\n            const potentialNodeModulesPath = `${pathParts.slice(0, index + 1).join('/')}/node_modules`;\n            const pathExists = await FileSystem.existsAsync(potentialNodeModulesPath);\n            if (pathExists) {\n                existingNodeModulesPaths.push(potentialNodeModulesPath);\n            }\n        }, { concurrency: 5 });\n        if (existingNodeModulesPaths.length > 0) {\n            const paths = existingNodeModulesPaths.sort().join(', ');\n            let errorMessage = `The following node_modules folders exist in the path to the Rush repo: ${paths}. ` +\n                `This is not supported, and may cause issues.`;\n            if (options.bypassPolicyAllowed) {\n                errorMessage += ` To ignore, use the \"${RushConstants.bypassPolicyFlagLongName}\" flag.`;\n            }\n            // eslint-disable-next-line no-console\n            console.error(errorMessage);\n            throw new AlreadyReportedError();\n        }\n    }\n}\n//# sourceMappingURL=EnvironmentPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Git } from '../Git';\nimport { RushConstants } from '../RushConstants';\nexport function validate(rushConfiguration, options) {\n    const git = new Git(rushConfiguration);\n    if (!git.isGitPresent()) {\n        // If Git isn't installed, or this Rush project is not under a Git working folder,\n        // then we don't care about the Git email\n        // eslint-disable-next-line no-console\n        console.log(colors.cyan('Ignoring Git validation because the Git binary was not found in the shell path.') + '\\n');\n        return;\n    }\n    if (!git.isPathUnderGitWorkingTree()) {\n        // If Git isn't installed, or this Rush project is not under a Git working folder,\n        // then we don't care about the Git email\n        // eslint-disable-next-line no-console\n        console.log(colors.cyan('Ignoring Git validation because this is not a Git working folder.') + '\\n');\n        return;\n    }\n    // If there isn't a Git policy, then we don't care whether the person configured\n    // a Git email address at all.  This helps people who don't\n    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {\n        if (git.tryGetGitEmail() === undefined) {\n            return;\n        }\n        // Otherwise, if an email *is* configured at all, then we still perform the basic\n        // sanity checks (e.g. no spaces in the address).\n    }\n    let userEmail;\n    try {\n        userEmail = git.getGitEmail();\n        // sanity check; a valid email should not contain any whitespace\n        // if this fails, then we have another issue to report\n        if (!userEmail.match(/^\\S+$/g)) {\n            // eslint-disable-next-line no-console\n            console.log([\n                colors.red('Your Git email address is invalid: ' + JSON.stringify(userEmail)),\n                '',\n                `To configure your Git email address, try something like this:`,\n                '',\n                ...getEmailExampleLines(rushConfiguration),\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n    }\n    catch (e) {\n        if (e instanceof AlreadyReportedError) {\n            let errorMessage = 'Aborting, so you can go fix your settings.';\n            if (options.bypassPolicyAllowed) {\n                errorMessage += ` (Or use \"${RushConstants.bypassPolicyFlagLongName}\" to skip.)`;\n            }\n            // eslint-disable-next-line no-console\n            console.log(colors.red(errorMessage));\n            throw e;\n        }\n        else {\n            throw e;\n        }\n    }\n    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {\n        // If there is no policy, then we're good\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log('Checking Git policy for this repository.\\n');\n    // If there is a policy, at least one of the RegExp's must match\n    for (const pattern of rushConfiguration.gitAllowedEmailRegExps) {\n        const regex = new RegExp(`^${pattern}$`, 'i');\n        if (userEmail.match(regex)) {\n            return;\n        }\n    }\n    // Show the user's name as well.\n    // Ex. \"Example Name <name@example.com>\"\n    let fancyEmail = colors.cyan(userEmail);\n    try {\n        const userName = Utilities.executeCommandAndCaptureOutput(git.gitPath, ['config', 'user.name'], '.').trim();\n        if (userName) {\n            fancyEmail = `${userName} <${fancyEmail}>`;\n        }\n    }\n    catch (e) {\n        // but if it fails, this isn't critical, so don't bother them about it\n    }\n    // eslint-disable-next-line no-console\n    console.log([\n        'Hey there!  To keep things tidy, this repo asks you to submit your Git commits using an email like ' +\n            (rushConfiguration.gitAllowedEmailRegExps.length > 1 ? 'one of these patterns:' : 'this pattern:'),\n        '',\n        ...rushConfiguration.gitAllowedEmailRegExps.map((pattern) => '    ' + colors.cyan(pattern)),\n        '',\n        '...but yours is configured like this:',\n        '',\n        `    ${fancyEmail}`,\n        '',\n        'To fix it, you can use commands like this:',\n        '',\n        ...getEmailExampleLines(rushConfiguration),\n        ''\n    ].join('\\n'));\n    let errorMessage = 'Aborting, so you can go fix your settings.';\n    if (options.bypassPolicyAllowed) {\n        errorMessage += ` (Or use \"${RushConstants.bypassPolicyFlagLongName}\" to skip.)`;\n    }\n    // eslint-disable-next-line no-console\n    console.log(colors.red(errorMessage));\n    throw new AlreadyReportedError();\n}\nexport function getEmailExampleLines(rushConfiguration) {\n    return [\n        colors.cyan('    git config --local user.name \"Example Name\"'),\n        colors.cyan(`    git config --local user.email \"${rushConfiguration.gitSampleEmail || 'name@example.com'}\"`)\n    ];\n}\n//# sourceMappingURL=GitEmailPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as GitEmailPolicy from './GitEmailPolicy';\nimport * as ShrinkwrapFilePolicy from './ShrinkwrapFilePolicy';\nimport * as EnvironmentPolicy from './EnvironmentPolicy';\nexport async function validatePolicyAsync(rushConfiguration, options) {\n    if (!options.bypassPolicy) {\n        GitEmailPolicy.validate(rushConfiguration, options);\n        await EnvironmentPolicy.validateAsync(rushConfiguration, options);\n        if (!options.allowShrinkwrapUpdates) {\n            // Don't validate the shrinkwrap if updates are allowed, as it's likely to change\n            // It also may have merge conflict markers, which PNPM can gracefully handle, but the validator cannot\n            ShrinkwrapFilePolicy.validate(rushConfiguration, options);\n        }\n    }\n}\n//# sourceMappingURL=PolicyValidator.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\n/**\n *  A policy that validates shrinkwrap files used by package managers.\n */\nexport function validate(rushConfiguration, options) {\n    // eslint-disable-next-line no-console\n    console.log('Validating package manager shrinkwrap file.\\n');\n    const shrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(rushConfiguration.packageManager, rushConfiguration.packageManagerOptions, rushConfiguration.getCommittedShrinkwrapFilename(options.shrinkwrapVariant));\n    if (!shrinkwrapFile) {\n        // eslint-disable-next-line no-console\n        console.log('Shrinkwrap file could not be found, skipping validation.\\n');\n        return;\n    }\n    // Run shrinkwrap-specific validation\n    shrinkwrapFile.validate(rushConfiguration.packageManagerOptions, Object.assign(Object.assign({}, options), { repoState: rushConfiguration.getRepoState(options.shrinkwrapVariant) }), rushConfiguration.experimentsConfiguration.configuration);\n}\n//# sourceMappingURL=ShrinkwrapFilePolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';\nexport class GitChangedProjectSelectorParser {\n    constructor(rushConfiguration, options) {\n        this._rushConfiguration = rushConfiguration;\n        this._options = options;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal }) {\n        const projectChangeAnalyzer = new ProjectChangeAnalyzer(this._rushConfiguration);\n        const options = Object.assign({ terminal, targetBranchName: unscopedSelector }, this._options);\n        return await projectChangeAnalyzer.getChangedProjectsAsync(options);\n    }\n    getCompletions() {\n        return [this._rushConfiguration.repositoryDefaultBranch, 'HEAD~1', 'HEAD'];\n    }\n}\n//# sourceMappingURL=GitChangedProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, PackageName } from '@rushstack/node-core-library';\nexport class NamedProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const project = this._rushConfiguration.findProjectByShorthandName(unscopedSelector);\n        if (!project) {\n            terminal.writeErrorLine(`The project name \"${unscopedSelector}\" passed to \"${parameterName}\" does not exist in rush.json.`);\n            throw new AlreadyReportedError();\n        }\n        return [project];\n    }\n    getCompletions() {\n        const unscopedNamesMap = new Map();\n        const scopedNames = new Set();\n        for (const project of this._rushConfiguration.rushConfigurationJson.projects) {\n            scopedNames.add(project.packageName);\n            const unscopedName = PackageName.getUnscopedName(project.packageName);\n            const count = unscopedNamesMap.get(unscopedName) || 0;\n            unscopedNamesMap.set(unscopedName, count + 1);\n        }\n        const unscopedNames = [];\n        for (const [unscopedName, unscopedNameCount] of unscopedNamesMap) {\n            // don't suggest ambiguous unscoped names\n            if (unscopedNameCount === 1 && !scopedNames.has(unscopedName)) {\n                unscopedNames.push(unscopedName);\n            }\n        }\n        return unscopedNames.sort().concat([...scopedNames].sort());\n    }\n}\n//# sourceMappingURL=NamedProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nexport class TagProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const selection = this._rushConfiguration.projectsByTag.get(unscopedSelector);\n        if (!selection) {\n            terminal.writeErrorLine(`The tag \"${unscopedSelector}\" passed to \"${parameterName}\" is not specified for any projects in rush.json.`);\n            throw new AlreadyReportedError();\n        }\n        return selection;\n    }\n    getCompletions() {\n        return this._rushConfiguration.projectsByTag.keys();\n    }\n}\n//# sourceMappingURL=TagProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nexport class VersionPolicyProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const selection = new Set();\n        if (!this._rushConfiguration.versionPolicyConfiguration.versionPolicies.has(unscopedSelector)) {\n            terminal.writeErrorLine(`The version policy \"${unscopedSelector}\" passed to \"${parameterName}\" does not exist in version-policies.json.`);\n            throw new AlreadyReportedError();\n        }\n        for (const project of this._rushConfiguration.projects) {\n            if (project.versionPolicyName === unscopedSelector) {\n                selection.add(project);\n            }\n        }\n        return selection;\n    }\n    getCompletions() {\n        return this._rushConfiguration.versionPolicyConfiguration.versionPolicies.keys();\n    }\n}\n//# sourceMappingURL=VersionPolicyProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport schemaJson from '../../schemas/artifactory.schema.json';\n/**\n * Use this class to load the \"common/config/rush/artifactory.json\" config file.\n * It configures the \"rush setup\" command.\n */\nclass ArtifactoryConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFileName) {\n        this._jsonFileName = jsonFileName;\n        this.configuration = {\n            packageRegistry: {\n                enabled: false,\n                registryUrl: '',\n                artifactoryWebsiteUrl: ''\n            }\n        };\n        if (FileSystem.exists(this._jsonFileName)) {\n            this.configuration = JsonFile.loadAndValidate(this._jsonFileName, ArtifactoryConfiguration._jsonSchema);\n            if (!this.configuration.packageRegistry.credentialType) {\n                this.configuration.packageRegistry.credentialType = 'password';\n            }\n        }\n    }\n}\nArtifactoryConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { ArtifactoryConfiguration };\n//# sourceMappingURL=ArtifactoryConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as readline from 'readline';\nimport * as process from 'process';\nimport { AlreadyReportedError, InternalError } from '@rushstack/node-core-library';\n// TODO: Integrate these into the AnsiEscape API in @rushstack/node-core-library\n// As part of that work we should generalize the \"Colors\" API to support more general\n// terminal escapes, and simplify the interface for that API.\nconst ANSI_ESCAPE_SHOW_CURSOR = '\\u001B[?25l';\nconst ANSI_ESCAPE_HIDE_CURSOR = '\\u001B[?25h';\nexport class KeyboardLoop {\n    constructor() {\n        this._cursorHidden = false;\n        this._onKeypress = (character, key) => {\n            if (key.name === 'c' && key.ctrl && !key.meta && !key.shift) {\n                // Intercept CTRL+C\n                process.kill(process.pid, 'SIGINT');\n                return;\n            }\n            try {\n                this.onKeypress(character, key);\n            }\n            catch (error) {\n                throw new InternalError('Uncaught exception in Prompter.onKeypress(): ' + error.toString());\n            }\n        };\n        this.stdin = process.stdin;\n        this.stderr = process.stderr;\n    }\n    get capturedInput() {\n        return this._readlineInterface !== undefined;\n    }\n    _captureInput() {\n        if (this._readlineInterface) {\n            return;\n        }\n        this._checkForTTY();\n        this._readlineInterface = readline.createInterface({ input: this.stdin });\n        readline.emitKeypressEvents(process.stdin);\n        this.stdin.setRawMode(true);\n        this.stdin.addListener('keypress', this._onKeypress);\n    }\n    _checkForTTY() {\n        var _a;\n        // Typescript thinks setRawMode always extists, but we're testing that assumption here.\n        if (this.stdin.isTTY && this.stdin.setRawMode) {\n            return;\n        }\n        if (process.platform === 'win32') {\n            const shell = (_a = process.env.SHELL) !== null && _a !== void 0 ? _a : '';\n            if (shell.toUpperCase().endsWith('BASH.EXE')) {\n                // Git Bash has a known problem where the Node.js TTY is lost when invoked via an NPM binary script.\n                // eslint-disable-next-line no-console\n                console.error(colors.red('ERROR: It appears that Rush was invoked from Git Bash shell, which does not support the\\n' +\n                    'TTY mode for interactive input that is required by this feature.') +\n                    '\\n\\nKnown workarounds are:\\n' +\n                    '- Invoke Rush using \"winpty rush.cmd\" instead of \"rush\"\\n' +\n                    '- Or add this to your .bashrc:  alias rush=\"winpty rush.cmd\"\\n' +\n                    '- Or create a Git Bash shortcut icon that launches\\n' +\n                    '  \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" instead of \"git-bash.exe\"\\n\\n' +\n                    'For details, refer to https://github.com/microsoft/rushstack/issues/3217');\n                throw new AlreadyReportedError();\n            }\n        }\n        // eslint-disable-next-line no-console\n        console.error(colors.red('ERROR: Rush was invoked by a command whose STDIN does not support the TTY mode for\\n' +\n            'interactive input that is required by this feature.') + '\\n\\nTry invoking \"rush\" directly from your shell.');\n        throw new AlreadyReportedError();\n    }\n    _uncaptureInput() {\n        if (!this._readlineInterface) {\n            return;\n        }\n        this.stdin.removeListener('keypress', this._onKeypress);\n        this.stdin.setRawMode(false);\n        this._readlineInterface.close();\n        this._readlineInterface = undefined;\n    }\n    hideCursor() {\n        if (this._cursorHidden) {\n            return;\n        }\n        this._cursorHidden = true;\n        this.stderr.write(ANSI_ESCAPE_SHOW_CURSOR);\n    }\n    unhideCursor() {\n        if (!this._cursorHidden) {\n            return;\n        }\n        this._cursorHidden = false;\n        this.stderr.write(ANSI_ESCAPE_HIDE_CURSOR);\n    }\n    async startAsync() {\n        try {\n            this._captureInput();\n            this.onStart();\n            await new Promise((resolve, reject) => {\n                this._resolvePromise = resolve;\n                this._rejectPromise = reject;\n            });\n        }\n        finally {\n            this._uncaptureInput();\n            this.unhideCursor();\n        }\n    }\n    resolveAsync() {\n        if (!this._resolvePromise) {\n            return;\n        }\n        this._resolvePromise();\n        this._resolvePromise = undefined;\n        this._rejectPromise = undefined;\n    }\n    rejectAsync(error) {\n        if (!this._rejectPromise) {\n            return;\n        }\n        this._rejectPromise(error);\n        this._resolvePromise = undefined;\n        this._rejectPromise = undefined;\n    }\n    /** @virtual */\n    onStart() { }\n    /** @virtual */\n    onKeypress(character, key) { }\n}\n//# sourceMappingURL=KeyboardLoop.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { AlreadyReportedError, Colors, ConsoleTerminalProvider, Executable, FileSystem, InternalError, NewlineKind, Terminal, Text } from '@rushstack/node-core-library';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { Utilities } from '../../utilities/Utilities';\nimport { ArtifactoryConfiguration } from './ArtifactoryConfiguration';\nimport { WebClient } from '../../utilities/WebClient';\nimport { TerminalInput } from './TerminalInput';\nconst defaultMessages = {\n    introduction: 'This monorepo consumes packages from an Artifactory private NPM registry.',\n    obtainAnAccount: 'Please contact the repository maintainers for help with setting up an Artifactory user account.',\n    visitWebsite: 'Please open this URL in your web browser:',\n    locateUserName: 'Your user name appears in the upper-right corner of the JFrog website.',\n    locateApiKey: 'Click \"Edit Profile\" on the JFrog website.  Click the \"Generate API Key\"' +\n        \" button if you haven't already done so previously.\",\n    userNamePrompt: 'What is your Artifactory user name?',\n    apiKeyPrompt: 'What is your Artifactory API key?'\n};\nexport class SetupPackageRegistry {\n    constructor(options) {\n        this._options = options;\n        this.rushConfiguration = options.rushConfiguration;\n        this._terminal = new Terminal(new ConsoleTerminalProvider({\n            verboseEnabled: options.isDebug\n        }));\n        this._artifactoryConfiguration = new ArtifactoryConfiguration(path.join(this.rushConfiguration.commonRushConfigFolder, 'artifactory.json'));\n        this._messages = Object.assign(Object.assign({}, defaultMessages), this._artifactoryConfiguration.configuration.packageRegistry.messageOverrides);\n    }\n    _writeInstructionBlock(message) {\n        if (message === '') {\n            return;\n        }\n        this._terminal.writeLine(PrintUtilities.wrapWords(message));\n        this._terminal.writeLine();\n    }\n    /**\n     * Test whether the NPM token is valid.\n     *\n     * @returns - `true` if valid, `false` if not valid\n     */\n    async checkOnly() {\n        var _a;\n        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;\n        if (!packageRegistry.enabled) {\n            this._terminal.writeVerbose('Skipping package registry setup because packageRegistry.enabled=false');\n            return true;\n        }\n        const registryUrl = ((packageRegistry === null || packageRegistry === void 0 ? void 0 : packageRegistry.registryUrl) || '').trim();\n        if (registryUrl.length === 0) {\n            throw new Error('The \"registryUrl\" setting in artifactory.json is missing or empty');\n        }\n        if (!this._options.syncNpmrcAlreadyCalled) {\n            Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this.rushConfiguration.commonTempFolder);\n        }\n        // Artifactory does not implement the \"npm ping\" protocol or any equivalent REST API.\n        // But if we query a package that is known not to exist, Artifactory will only return\n        // a 404 error if it is successfully authenticated.  We can use this negative query\n        // to validate the credentials.\n        const npmArgs = [\n            'view',\n            '@rushstack/nonexistent-package',\n            '--json',\n            '--registry=' + packageRegistry.registryUrl\n        ];\n        this._terminal.writeLine('Testing access to private NPM registry: ' + packageRegistry.registryUrl);\n        const result = Executable.spawnSync('npm', npmArgs, {\n            currentWorkingDirectory: this.rushConfiguration.commonTempFolder,\n            stdio: ['ignore', 'pipe', 'pipe'],\n            // Wait at most 10 seconds for \"npm view\" to succeed\n            timeoutMs: 10 * 1000\n        });\n        this._terminal.writeLine();\n        // (This is not exactly correct, for example Node.js puts a string in error.errno instead of a string.)\n        const error = result.error;\n        if (error) {\n            if (error.code === 'ETIMEDOUT') {\n                // For example, an incorrect \"https-proxy\" setting can hang for a long time\n                throw new Error('The \"npm view\" command timed out; check your .npmrc file for an incorrect setting');\n            }\n            throw new Error('Error invoking \"npm view\": ' + result.error);\n        }\n        if (result.status === 0) {\n            throw new InternalError('\"npm view\" unexpectedly succeeded');\n        }\n        // NPM 6.x writes to stdout\n        let jsonContent = SetupPackageRegistry._tryFindJson(result.stdout);\n        if (jsonContent === undefined) {\n            // NPM 7.x writes dirty output to stderr; see https://github.com/npm/cli/issues/2740\n            jsonContent = SetupPackageRegistry._tryFindJson(result.stderr);\n        }\n        if (jsonContent === undefined) {\n            throw new InternalError('The \"npm view\" command did not return a JSON structure');\n        }\n        let jsonOutput;\n        try {\n            jsonOutput = JSON.parse(jsonContent);\n        }\n        catch (e) {\n            this._terminal.writeVerboseLine('NPM response:\\n\\n--------\\n' + jsonContent + '\\n--------\\n\\n');\n            throw new InternalError('The \"npm view\" command returned an invalid JSON structure');\n        }\n        const errorCode = (_a = jsonOutput === null || jsonOutput === void 0 ? void 0 : jsonOutput.error) === null || _a === void 0 ? void 0 : _a.code;\n        if (typeof errorCode !== 'string') {\n            this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n            throw new InternalError('The \"npm view\" command returned unexpected output');\n        }\n        switch (errorCode) {\n            case 'E404':\n                this._terminal.writeLine('NPM credentials are working');\n                this._terminal.writeLine();\n                return true;\n            case 'E401':\n            case 'E403':\n                this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n                // Credentials are missing or expired\n                return false;\n            default:\n                this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n                throw new Error(`The \"npm view\" command returned an unexpected error code \"${errorCode}\"`);\n        }\n    }\n    /**\n     * Test whether the NPM token is valid.  If not, prompt to update it.\n     */\n    async checkAndSetup() {\n        if (await this.checkOnly()) {\n            return;\n        }\n        this._terminal.writeWarningLine('NPM credentials are missing or expired');\n        this._terminal.writeLine();\n        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;\n        const fixThisProblem = await TerminalInput.promptYesNo({\n            message: 'Fix this problem now?',\n            defaultValue: false\n        });\n        this._terminal.writeLine();\n        if (!fixThisProblem) {\n            return;\n        }\n        this._writeInstructionBlock(this._messages.introduction);\n        const hasArtifactoryAccount = await TerminalInput.promptYesNo({\n            message: 'Do you already have an Artifactory user account?'\n        });\n        this._terminal.writeLine();\n        if (!hasArtifactoryAccount) {\n            this._writeInstructionBlock(this._messages.obtainAnAccount);\n            throw new AlreadyReportedError();\n        }\n        if (this._messages.visitWebsite) {\n            this._writeInstructionBlock(this._messages.visitWebsite);\n            const artifactoryWebsiteUrl = this._artifactoryConfiguration.configuration.packageRegistry.artifactoryWebsiteUrl;\n            if (artifactoryWebsiteUrl) {\n                this._terminal.writeLine('  ', Colors.cyan(artifactoryWebsiteUrl));\n                this._terminal.writeLine();\n            }\n        }\n        this._writeInstructionBlock(this._messages.locateUserName);\n        let artifactoryUser = await TerminalInput.promptLine({\n            message: this._messages.userNamePrompt\n        });\n        this._terminal.writeLine();\n        artifactoryUser = artifactoryUser.trim();\n        if (artifactoryUser.length === 0) {\n            this._terminal.writeLine(Colors.red('Operation aborted because the input was empty'));\n            this._terminal.writeLine();\n            throw new AlreadyReportedError();\n        }\n        this._writeInstructionBlock(this._messages.locateApiKey);\n        let artifactoryKey = await TerminalInput.promptPasswordLine({\n            message: this._messages.apiKeyPrompt\n        });\n        this._terminal.writeLine();\n        artifactoryKey = artifactoryKey.trim();\n        if (artifactoryKey.length === 0) {\n            this._terminal.writeLine(Colors.red('Operation aborted because the input was empty'));\n            this._terminal.writeLine();\n            throw new AlreadyReportedError();\n        }\n        await this._fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry);\n    }\n    /**\n     * Fetch a valid NPM token from the Artifactory service and add it to the `~/.npmrc` file,\n     * preserving other settings in that file.\n     */\n    async _fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry) {\n        this._terminal.writeLine('\\nFetching an NPM token from the Artifactory service...');\n        const webClient = new WebClient();\n        webClient.addBasicAuthHeader(artifactoryUser, artifactoryKey);\n        let queryUrl = packageRegistry.registryUrl;\n        if (!queryUrl.endsWith('/')) {\n            queryUrl += '/';\n        }\n        // There doesn't seem to be a way to invoke the \"/auth\" REST endpoint without a resource name.\n        // Artifactory's NPM folders always seem to contain a \".npm\" folder, so we can use that to obtain\n        // our token.\n        queryUrl += `auth/.npm`;\n        let response;\n        try {\n            response = await webClient.fetchAsync(queryUrl);\n        }\n        catch (e) {\n            // eslint-disable-next-line no-console\n            console.log(e.toString());\n            return;\n        }\n        if (!response.ok) {\n            if (response.status === 401) {\n                throw new Error('Authorization failed; the Artifactory user name or API key may be incorrect.');\n            }\n            throw new Error(`The Artifactory request failed:\\n  (${response.status}) ${response.statusText}`);\n        }\n        // We expect a response like this:\n        //\n        //   @.npm:registry=https://your-company.jfrog.io/your-artifacts/api/npm/npm-private/\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:_password=dGhlIHRva2VuIGdvZXMgaGVyZQ==\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:username=your.name@your-company.com\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:email=your.name@your-company.com\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:always-auth=true\n        const responseText = await response.text();\n        const responseLines = Text.convertToLf(responseText).trim().split('\\n');\n        if (responseLines.length < 2 || !responseLines[0].startsWith('@.npm:')) {\n            throw new Error('Unexpected response from Artifactory');\n        }\n        responseLines.shift(); // Remove the @.npm line\n        // If we are configured to use authToken for authentication, we still go through the above process\n        // (both to ensure the user's credentials are valid, and to let Artifactory format the standard\n        // npmrc boilerplate for us), but we'll discard the generated password and use the authToken instead.\n        if (packageRegistry.credentialType === 'authToken') {\n            for (let i = 0; i < responseLines.length; i++) {\n                responseLines[i] = responseLines[i].replace(/_password=.+/, '_authToken=' + artifactoryKey);\n            }\n        }\n        // These are the lines to be injected in ~/.npmrc\n        const linesToAdd = [];\n        // Start with userNpmrcLinesToAdd...\n        if (packageRegistry.userNpmrcLinesToAdd) {\n            linesToAdd.push(...packageRegistry.userNpmrcLinesToAdd);\n        }\n        // ...then append the stuff we got from the REST API, but discard any junk that isn't a proper key/value\n        linesToAdd.push(...responseLines.filter((x) => SetupPackageRegistry._getNpmrcKey(x) !== undefined));\n        const npmrcPath = path.join(Utilities.getHomeFolder(), '.npmrc');\n        this._mergeLinesIntoNpmrc(npmrcPath, linesToAdd);\n    }\n    /**\n     * Update the `~/.npmrc` file by adding `linesToAdd` to it.\n     * @remarks\n     *\n     * If the `.npmrc` file has existing content, it gets merged as follows:\n     * - If `linesToAdd` contains key/value pairs and the key already appears in .npmrc,\n     *   that line will be overwritten in place\n     * - If `linesToAdd` contains non-key lines (e.g. a comment) and it exactly matches a\n     *   line in .npmrc, then that line will be kept where it is\n     * - The remaining `linesToAdd` that weren't handled by one of the two rules above\n     *   are simply appended to the end of the file\n     * - Under no circumstances is a duplicate key/value added to the file; in the case of\n     *   duplicates, the earliest line in `linesToAdd` takes precedence\n     */\n    _mergeLinesIntoNpmrc(npmrcPath, linesToAdd) {\n        // We'll replace entries with \"undefined\" if they get discarded\n        const workingLinesToAdd = [...linesToAdd];\n        // Now build a table of .npmrc keys that can be replaced if they already exist in the file.\n        // For example, if we are adding \"always-auth=false\" then we should delete an existing line\n        // that says \"always-auth=true\".\n        const keysToReplace = new Map(); // key --> linesToAdd index\n        for (let index = 0; index < workingLinesToAdd.length; ++index) {\n            const lineToAdd = workingLinesToAdd[index];\n            const key = SetupPackageRegistry._getNpmrcKey(lineToAdd);\n            if (key !== undefined) {\n                // If there are duplicate keys, the first one takes precedence.\n                // In particular this means \"userNpmrcLinesToAdd\" takes precedence over the REST API response\n                if (keysToReplace.has(key)) {\n                    // Discard the duplicate key\n                    workingLinesToAdd[index] = undefined;\n                }\n                else {\n                    keysToReplace.set(key, index);\n                }\n            }\n        }\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colors.green('Adding Artifactory token to: '), npmrcPath);\n        const npmrcLines = [];\n        if (FileSystem.exists(npmrcPath)) {\n            const npmrcContent = FileSystem.readFile(npmrcPath, { convertLineEndings: NewlineKind.Lf });\n            npmrcLines.push(...npmrcContent.trimRight().split('\\n'));\n        }\n        if (npmrcLines.length === 1 && npmrcLines[0] === '') {\n            // Edge case where split() adds a blank line to the start of the file\n            npmrcLines.length = 0;\n        }\n        // Make a set of existing .npmrc lines that are not key/value pairs.\n        const npmrcNonKeyLinesSet = new Set();\n        for (const npmrcLine of npmrcLines) {\n            const trimmed = npmrcLine.trim();\n            if (trimmed.length > 0) {\n                if (SetupPackageRegistry._getNpmrcKey(trimmed) === undefined) {\n                    npmrcNonKeyLinesSet.add(trimmed);\n                }\n            }\n        }\n        // Overwrite any existing lines that match a key from \"linesToAdd\"\n        for (let index = 0; index < npmrcLines.length; ++index) {\n            const line = npmrcLines[index];\n            const key = SetupPackageRegistry._getNpmrcKey(line);\n            if (key) {\n                const linesToAddIndex = keysToReplace.get(key);\n                if (linesToAddIndex !== undefined) {\n                    npmrcLines[index] = workingLinesToAdd[linesToAddIndex] || '';\n                    // Delete it since it's been replaced\n                    keysToReplace.delete(key);\n                    // Also remove it from \"linesToAdd\"\n                    workingLinesToAdd[linesToAddIndex] = undefined;\n                }\n            }\n        }\n        if (npmrcLines.length > 0 && npmrcLines[npmrcLines.length - 1] !== '') {\n            // Append a blank line\n            npmrcLines.push('');\n        }\n        // Add any remaining values that weren't matched above\n        for (const lineToAdd of workingLinesToAdd) {\n            // If a line is undefined, that means we already used it to replace an existing line above\n            if (lineToAdd !== undefined) {\n                // If a line belongs to npmrcNonKeyLinesSet, then we should not add it because it's\n                // already in the .npmrc file\n                if (!npmrcNonKeyLinesSet.has(lineToAdd.trim())) {\n                    npmrcLines.push(lineToAdd);\n                }\n            }\n        }\n        // Save the result\n        FileSystem.writeFile(npmrcPath, npmrcLines.join('\\n').trimRight() + '\\n');\n    }\n    static _getNpmrcKey(npmrcLine) {\n        if (SetupPackageRegistry._isCommentLine(npmrcLine)) {\n            return undefined;\n        }\n        const delimiterIndex = npmrcLine.indexOf('=');\n        if (delimiterIndex < 1) {\n            return undefined;\n        }\n        const key = npmrcLine.substring(0, delimiterIndex + 1);\n        return key.trim();\n    }\n    static _isCommentLine(npmrcLine) {\n        return /^\\s*#/.test(npmrcLine);\n    }\n    /**\n     * This is a workaround for https://github.com/npm/cli/issues/2740 where the NPM tool sometimes\n     * mixes together JSON and terminal messages in a single STDERR stream.\n     *\n     * @remarks\n     * Given an input like this:\n     * ```\n     * npm ERR! 404 Note that you can also install from a\n     * npm ERR! 404 tarball, folder, http url, or git url.\n     * {\n     *   \"error\": {\n     *     \"code\": \"E404\",\n     *     \"summary\": \"Not Found - GET https://registry.npmjs.org/@rushstack%2fnonexistent-package - Not found\"\n     *   }\n     * }\n     * npm ERR! A complete log of this run can be found in:\n     * ```\n     *\n     * @returns the JSON section, or `undefined` if a JSON object could not be detected\n     */\n    static _tryFindJson(dirtyOutput) {\n        const lines = dirtyOutput.split(/\\r?\\n/g);\n        let startIndex;\n        let endIndex;\n        // Find the first line that starts with \"{\"\n        for (let i = 0; i < lines.length; ++i) {\n            const line = lines[i];\n            if (/^\\s*\\{/.test(line)) {\n                startIndex = i;\n                break;\n            }\n        }\n        if (startIndex === undefined) {\n            return undefined;\n        }\n        // Find the last line that ends with \"}\"\n        for (let i = lines.length - 1; i >= startIndex; --i) {\n            const line = lines[i];\n            if (/\\}\\s*$/.test(line)) {\n                endIndex = i;\n                break;\n            }\n        }\n        if (endIndex === undefined) {\n            return undefined;\n        }\n        return lines.slice(startIndex, endIndex + 1).join('\\n');\n    }\n}\n//# sourceMappingURL=SetupPackageRegistry.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as readline from 'readline';\nimport * as process from 'process';\nimport colors from 'colors/safe';\nimport { AnsiEscape } from '@rushstack/node-core-library';\nimport { KeyboardLoop } from './KeyboardLoop';\nclass YesNoKeyboardLoop extends KeyboardLoop {\n    constructor(options) {\n        super();\n        this.result = undefined;\n        this.options = options;\n    }\n    onStart() {\n        this.stderr.write(colors.green('==>') + ' ');\n        this.stderr.write(colors.bold(this.options.message));\n        let optionSuffix = '';\n        switch (this.options.defaultValue) {\n            case true:\n                optionSuffix = '(Y/n)';\n                break;\n            case false:\n                optionSuffix = '(y/N)';\n                break;\n            default:\n                optionSuffix = '(y/n)';\n                break;\n        }\n        this.stderr.write(' ' + colors.bold(optionSuffix) + ' ');\n    }\n    onKeypress(character, key) {\n        if (this.result !== undefined) {\n            return;\n        }\n        switch (key.name) {\n            case 'y':\n                this.result = true;\n                break;\n            case 'n':\n                this.result = false;\n                break;\n            case 'enter':\n            case 'return':\n                if (this.options.defaultValue !== undefined) {\n                    this.result = this.options.defaultValue;\n                }\n                break;\n        }\n        if (this.result !== undefined) {\n            this.stderr.write(this.result ? 'Yes\\n' : 'No\\n');\n            this.resolveAsync();\n            return;\n        }\n    }\n}\nclass PasswordKeyboardLoop extends KeyboardLoop {\n    constructor(options) {\n        super();\n        this._startX = 0;\n        this._printedY = 0;\n        this._lastPrintedLength = 0;\n        this.result = '';\n        this._options = options;\n        this._passwordCharacter =\n            this._options.passwordCharacter === undefined ? '*' : this._options.passwordCharacter.substr(0, 1);\n    }\n    _getLineWrapWidth() {\n        return this.stderr.columns ? this.stderr.columns : 80;\n    }\n    onStart() {\n        this.result = '';\n        readline.cursorTo(this.stderr, 0);\n        readline.clearLine(this.stderr, 1);\n        const prefix = colors.green('==>') + ' ' + colors.bold(this._options.message) + ' ';\n        this.stderr.write(prefix);\n        let lineStartIndex = prefix.lastIndexOf('\\n');\n        if (lineStartIndex < 0) {\n            lineStartIndex = 0;\n        }\n        const line = prefix.substring(lineStartIndex);\n        this._startX = AnsiEscape.removeCodes(line).length % this._getLineWrapWidth();\n    }\n    onKeypress(character, key) {\n        switch (key.name) {\n            case 'enter':\n            case 'return':\n                if (this._passwordCharacter !== '') {\n                    // To avoid disclosing the length of the password, after the user presses ENTER,\n                    // replace the \"*********\" sequence with exactly three stars (\"***\").\n                    this._render(this._passwordCharacter.repeat(3));\n                }\n                this.stderr.write('\\n');\n                this.resolveAsync();\n                return;\n            case 'backspace':\n                this.result = this.result.substring(0, this.result.length - 1);\n                this._render(this.result);\n                break;\n            default:\n                let printable = true;\n                if (character === '') {\n                    printable = false;\n                }\n                else if (key.name && key.name.length !== 1 && key.name !== 'space') {\n                    printable = false;\n                }\n                else if (!key.name && !key.sequence) {\n                    printable = false;\n                }\n                if (printable) {\n                    this.result += character;\n                    this._render(this.result);\n                }\n        }\n    }\n    _render(text) {\n        // Optimize rendering when we don't need to erase anything\n        const needsClear = text.length < this._lastPrintedLength;\n        this._lastPrintedLength = text.length;\n        this.hideCursor();\n        // Restore Y\n        while (this._printedY > 0) {\n            readline.cursorTo(this.stderr, 0);\n            if (needsClear) {\n                readline.clearLine(this.stderr, 1);\n            }\n            readline.moveCursor(this.stderr, 0, -1);\n            --this._printedY;\n        }\n        // Restore X\n        readline.cursorTo(this.stderr, this._startX);\n        let i = 0;\n        let column = this._startX;\n        this._printedY = 0;\n        let buffer = '';\n        while (i < text.length) {\n            if (this._passwordCharacter === '') {\n                buffer += text.substr(i, 1);\n            }\n            else {\n                buffer += this._passwordCharacter;\n            }\n            ++i;\n            ++column;\n            // -1 to avoid weird TTY behavior in final column\n            if (column >= this._getLineWrapWidth() - 1) {\n                column = 0;\n                ++this._printedY;\n                buffer += '\\n';\n            }\n        }\n        this.stderr.write(buffer);\n        if (needsClear) {\n            readline.clearLine(this.stderr, 1);\n        }\n        this.unhideCursor();\n    }\n}\nexport class TerminalInput {\n    static async _readLine() {\n        const readlineInterface = readline.createInterface({ input: process.stdin });\n        try {\n            return await new Promise((resolve, reject) => {\n                readlineInterface.question('', (answer) => {\n                    resolve(answer);\n                });\n            });\n        }\n        finally {\n            readlineInterface.close();\n        }\n    }\n    static async promptYesNo(options) {\n        const keyboardLoop = new YesNoKeyboardLoop(options);\n        await keyboardLoop.startAsync();\n        return keyboardLoop.result;\n    }\n    static async promptLine(options) {\n        const stderr = process.stderr;\n        stderr.write(colors.green('==>') + ' ');\n        stderr.write(colors.bold(options.message));\n        stderr.write(' ');\n        return await TerminalInput._readLine();\n    }\n    static async promptPasswordLine(options) {\n        const keyboardLoop = new PasswordKeyboardLoop(options);\n        await keyboardLoop.startAsync();\n        return keyboardLoop.result;\n    }\n}\n//# sourceMappingURL=TerminalInput.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { DependencyType } from '../../api/PackageJsonEditor';\nimport { VersionMismatchFinderProject } from './VersionMismatchFinderProject';\nimport { VersionMismatchFinderCommonVersions } from './VersionMismatchFinderCommonVersions';\nimport { CustomTipId } from '../../api/CustomTipsConfiguration';\nconst TRUNCATE_AFTER_PACKAGE_NAME_COUNT = 5;\nexport class VersionMismatchFinder {\n    constructor(projects, allowedAlternativeVersions) {\n        this._projects = projects;\n        this._mismatches = new Map();\n        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();\n        this._analyze();\n    }\n    static rushCheck(rushConfiguration, terminal, options = {}) {\n        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { terminal, isRushCheckCommand: true }));\n    }\n    static ensureConsistentVersions(rushConfiguration, terminal, options = {}) {\n        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { terminal, isRushCheckCommand: false, truncateLongPackageNameLists: true }));\n    }\n    /**\n     * Populates a version mismatch finder object given a Rush Configuration.\n     * Intentionally considers preferred versions.\n     */\n    static getMismatches(rushConfiguration, options = {}) {\n        const commonVersions = rushConfiguration.getCommonVersions(options.variant);\n        const projects = [];\n        // Create an object for the purposes of reporting conflicts with preferredVersions from common-versions.json\n        // Make sure this one is first so it doesn't get truncated when a long list is printed\n        projects.push(new VersionMismatchFinderCommonVersions(commonVersions));\n        for (const project of rushConfiguration.projects) {\n            projects.push(new VersionMismatchFinderProject(project));\n        }\n        return new VersionMismatchFinder(projects, commonVersions.allowedAlternativeVersions);\n    }\n    static _checkForInconsistentVersions(rushConfiguration, options) {\n        if (rushConfiguration.ensureConsistentVersions || options.isRushCheckCommand) {\n            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfiguration, options);\n            if (options.printAsJson) {\n                mismatchFinder.printAsJson();\n            }\n            else {\n                mismatchFinder.print(options.truncateLongPackageNameLists);\n                if (mismatchFinder.numberOfMismatches > 0) {\n                    // eslint-disable-next-line no-console\n                    console.log(colors.red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies!`));\n                    rushConfiguration.customTipsConfiguration._showErrorTip(options.terminal, CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS);\n                    if (!options.isRushCheckCommand && options.truncateLongPackageNameLists) {\n                        // There isn't a --verbose flag in `rush install`/`rush update`, so a long list will always be truncated.\n                        // eslint-disable-next-line no-console\n                        console.log('For more detailed reporting about these version mismatches, use the \"rush check --verbose\" command.');\n                    }\n                    throw new AlreadyReportedError();\n                }\n                else {\n                    if (options.isRushCheckCommand) {\n                        // eslint-disable-next-line no-console\n                        console.log(colors.green(`Found no mis-matching dependencies!`));\n                    }\n                }\n            }\n        }\n    }\n    get mismatches() {\n        return this._mismatches;\n    }\n    get numberOfMismatches() {\n        return this._mismatches.size;\n    }\n    getMismatches() {\n        return this._getKeys(this._mismatches);\n    }\n    getVersionsOfMismatch(mismatch) {\n        return this._mismatches.has(mismatch) ? this._getKeys(this._mismatches.get(mismatch)) : undefined;\n    }\n    getConsumersOfMismatch(mismatch, version) {\n        const mismatchedPackage = this._mismatches.get(mismatch);\n        if (!mismatchedPackage) {\n            return undefined;\n        }\n        const mismatchedVersion = mismatchedPackage.get(version);\n        return mismatchedVersion;\n    }\n    printAsJson() {\n        const mismatchDependencies = [];\n        this.getMismatches().forEach((dependency) => {\n            const mismatchDependencyVersionArray = [];\n            this.getVersionsOfMismatch(dependency).forEach((version) => {\n                const projects = [];\n                this.getConsumersOfMismatch(dependency, version).forEach((project) => {\n                    projects.push(project.friendlyName);\n                });\n                const mismatchDependencyVersion = {\n                    version: version,\n                    projects: projects\n                };\n                mismatchDependencyVersionArray.push(mismatchDependencyVersion);\n            });\n            const mismatchDependency = {\n                dependencyName: dependency,\n                versions: mismatchDependencyVersionArray\n            };\n            mismatchDependencies.push(mismatchDependency);\n        });\n        const output = {\n            mismatchedVersions: mismatchDependencies\n        };\n        // eslint-disable-next-line no-console\n        console.log(JSON.stringify(output, undefined, 2));\n    }\n    print(truncateLongPackageNameLists = false) {\n        // Iterate over the list. For any dependency with mismatching versions, print the projects\n        this.getMismatches().forEach((dependency) => {\n            // eslint-disable-next-line no-console\n            console.log(colors.yellow(dependency));\n            this.getVersionsOfMismatch(dependency).forEach((version) => {\n                // eslint-disable-next-line no-console\n                console.log(`  ${version}`);\n                const consumersOfMismatch = this.getConsumersOfMismatch(dependency, version);\n                let numberToPrint = truncateLongPackageNameLists\n                    ? TRUNCATE_AFTER_PACKAGE_NAME_COUNT\n                    : consumersOfMismatch.length;\n                let numberRemaining = consumersOfMismatch.length;\n                for (const { friendlyName } of consumersOfMismatch) {\n                    if (numberToPrint-- === 0) {\n                        break;\n                    }\n                    numberRemaining--;\n                    // eslint-disable-next-line no-console\n                    console.log(`   - ${friendlyName}`);\n                }\n                if (numberRemaining > 0) {\n                    // eslint-disable-next-line no-console\n                    console.log(`   (and ${numberRemaining} others)`);\n                }\n            });\n            // eslint-disable-next-line no-console\n            console.log();\n        });\n    }\n    _analyze() {\n        this._projects.forEach((project) => {\n            if (!project.skipRushCheck) {\n                // NOTE: We do not consider peer dependencies here.  The purpose of \"rush check\" is\n                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas\n                // peer dependencies are just a compatibility statement that will be satisfied by a\n                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency\n                // patterns consistent, but on the other hand different projects may have different\n                // levels of compatibility -- we should wait for someone to actually request this feature\n                // before we get into that.)\n                project.allDependencies.forEach((dependency) => {\n                    if (dependency.dependencyType !== DependencyType.Peer) {\n                        const version = dependency.version;\n                        const isCyclic = project.decoupledLocalDependencies.has(dependency.name);\n                        if (this._isVersionAllowedAlternative(dependency.name, version)) {\n                            return;\n                        }\n                        const name = dependency.name + (isCyclic ? ' (cyclic)' : '');\n                        let dependencyVersions = this._mismatches.get(name);\n                        if (!dependencyVersions) {\n                            this._mismatches.set(name, (dependencyVersions = new Map()));\n                        }\n                        const consumers = dependencyVersions.get(version);\n                        if (!consumers) {\n                            dependencyVersions.set(version, [project]);\n                        }\n                        else {\n                            consumers.push(project);\n                        }\n                    }\n                });\n            }\n        });\n        this._mismatches.forEach((mismatches, project) => {\n            if (mismatches.size <= 1) {\n                this._mismatches.delete(project);\n            }\n        });\n    }\n    _isVersionAllowedAlternative(dependency, version) {\n        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);\n        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _getKeys(iterable) {\n        const keys = [];\n        if (iterable) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            iterable.forEach((value, key) => {\n                keys.push(key);\n            });\n        }\n        return keys;\n    }\n}\n//# sourceMappingURL=VersionMismatchFinder.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nimport { PackageJsonDependency, DependencyType } from '../../api/PackageJsonEditor';\nimport { VersionMismatchFinderEntity } from './VersionMismatchFinderEntity';\nexport class VersionMismatchFinderCommonVersions extends VersionMismatchFinderEntity {\n    constructor(commonVersionsConfiguration) {\n        super({\n            friendlyName: `preferred versions from ${RushConstants.commonVersionsFilename}`,\n            decoupledLocalDependencies: new Set()\n        });\n        this._fileManager = commonVersionsConfiguration;\n    }\n    get filePath() {\n        return this._fileManager.filePath;\n    }\n    get allDependencies() {\n        const dependencies = [];\n        this._fileManager.getAllPreferredVersions().forEach((version, dependencyName) => {\n            dependencies.push(this._getPackageJsonDependency(dependencyName, version));\n        });\n        return dependencies;\n    }\n    tryGetDependency(packageName) {\n        const version = this._fileManager.getAllPreferredVersions().get(packageName);\n        if (!version) {\n            return undefined;\n        }\n        else {\n            return this._getPackageJsonDependency(packageName, version);\n        }\n    }\n    tryGetDevDependency(packageName) {\n        return undefined; // common-versions.json doesn't have a distinction between dev and non-dev dependencies\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        if (dependencyType !== DependencyType.Regular) {\n            throw new Error(`${RushConstants.commonVersionsFilename} only accepts \"${DependencyType.Regular}\" dependencies`);\n        }\n        this._fileManager.preferredVersions.set(packageName, newVersion);\n    }\n    removeDependency(packageName) {\n        throw new Error('Not supported.');\n    }\n    saveIfModified() {\n        return this._fileManager.save();\n    }\n    _getPackageJsonDependency(dependencyName, version) {\n        return new PackageJsonDependency(dependencyName, version, DependencyType.Regular, () => this.addOrUpdateDependency(dependencyName, version, DependencyType.Regular));\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderCommonVersions.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class VersionMismatchFinderEntity {\n    constructor(options) {\n        this.friendlyName = options.friendlyName;\n        this.decoupledLocalDependencies = options.decoupledLocalDependencies;\n        this.skipRushCheck = options.skipRushCheck;\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderEntity.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { VersionMismatchFinderEntity } from './VersionMismatchFinderEntity';\nexport class VersionMismatchFinderProject extends VersionMismatchFinderEntity {\n    constructor(project) {\n        super({\n            friendlyName: project.packageName,\n            decoupledLocalDependencies: project.decoupledLocalDependencies,\n            skipRushCheck: project.skipRushCheck\n        });\n        this._fileManager = project.packageJsonEditor;\n        this.packageName = project.packageName;\n    }\n    get filePath() {\n        return this._fileManager.filePath;\n    }\n    get allDependencies() {\n        return [...this._fileManager.dependencyList, ...this._fileManager.devDependencyList];\n    }\n    tryGetDependency(packageName) {\n        return this._fileManager.tryGetDependency(packageName);\n    }\n    tryGetDevDependency(packageName) {\n        return this._fileManager.tryGetDevDependency(packageName);\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        return this._fileManager.addOrUpdateDependency(packageName, newVersion, dependencyType);\n    }\n    removeDependency(packageName, dependencyType) {\n        return this._fileManager.removeDependency(packageName, dependencyType);\n    }\n    saveIfModified() {\n        return this._fileManager.saveIfModified();\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderProject.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\n/**\n * Options that are only used when the yarn package manager is selected.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the yarn package manager\n * is not being used.\n *\n * @public\n */\nexport class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        super(json);\n        this.ignoreEngines = !!json.ignoreEngines;\n    }\n}\n//# sourceMappingURL=YarnOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { FileSystem, InternalError, Import } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\nconst lockfileModule = Import.lazy('@yarnpkg/lockfile', require);\n/**\n * Support for consuming the \"yarn.lock\" file.\n *\n * Yarn refers to its shrinkwrap file as a \"lock file\", even though it has nothing to do\n * with file locking.  Apparently this was based on a convention of the Ruby bundler.\n * Since Rush has to work interchangeably with 3 different package managers, here we refer\n * generically to yarn.lock as a \"shrinkwrap file\".\n *\n * If Rush's Yarn support gains popularity, we will try to improve the wording of\n * logging messages to use terminology more consistent with Yarn's own documentation.\n */\nclass YarnShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        this._tempProjectNames = [];\n        const seenEntries = new Set();\n        for (const key of Object.keys(this._shrinkwrapJson)) {\n            // Example key:\n            const packageNameAndSemVer = YarnShrinkwrapFile._decodePackageNameAndSemVer(key);\n            // If it starts with @rush-temp, then include it:\n            if (PackageNameParsers.permissive.getScope(packageNameAndSemVer.packageName) ===\n                RushConstants.rushTempNpmScope) {\n                if (!/^file:/i.test(packageNameAndSemVer.semVerRange)) {\n                    // Sanity check to make sure this is a real package.\n                    // (Nobody should ever have an actual dependency on an \"@rush-temp/\" package.\n                    throw new Error('Unexpected package/semver expression found in the Yarn shrinkwrap file (yarn.lock): ' +\n                        JSON.stringify(key));\n                }\n                if (!seenEntries.add(packageNameAndSemVer.packageName)) {\n                    // Sanity check -- this should never happen\n                    throw new Error('Duplicate @rush-temp package found in the Yarn shrinkwrap file (yarn.lock): ' +\n                        JSON.stringify(key));\n                }\n                this._tempProjectNames.push(packageNameAndSemVer.packageName);\n                const entry = this._shrinkwrapJson[key];\n                // Yarn fails installation if the integrity hash does not match a \"file://\" reference to a tarball.\n                // This is incorrect:  Normally a mismatched integrity hash does indicate a corrupted download,\n                // since an NPM registry normally guarantees that a specific version number cannot be republished\n                // with different content.  But this is NOT true for a \"file://\" reference, and there are valid\n                // reasons why someone would update the file.  (PNPM handles this correctly, by simply reinstalling\n                // the tarball if its hash has changed.)\n                //\n                // As a workaround, we can simply remove the hashes from the shrinkwrap file.  We will convert this:\n                //   \"file:./projects/my-project.tgz#80cefe05fd715e65219d1ed481209dc4023408aa\"\n                // ..to this:\n                //   \"file:./projects/my-project.tgz\"\n                const indexOfHash = entry.resolved.indexOf('#');\n                if (indexOfHash >= 0) {\n                    entry.resolved = entry.resolved.substring(0, indexOfHash);\n                }\n            }\n        }\n        this._tempProjectNames.sort(); // make the result deterministic\n        // We don't support Yarn workspaces yet\n        this.isWorkspaceCompatible = false;\n    }\n    static loadFromFile(shrinkwrapFilename) {\n        try {\n            const shrinkwrapContent = FileSystem.readFile(shrinkwrapFilename);\n            return YarnShrinkwrapFile.loadFromString(shrinkwrapContent);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                return undefined; // file does not exist\n            }\n            throw new Error(`Error reading \"${shrinkwrapFilename}\":\\n  ${error.message}`);\n        }\n    }\n    static loadFromString(shrinkwrapContent) {\n        const shrinkwrapJson = lockfileModule.parse(shrinkwrapContent);\n        return new YarnShrinkwrapFile(shrinkwrapJson.object);\n    }\n    /**\n     * The `@yarnpkg/lockfile` API only partially deserializes its data, and expects the caller\n     * to parse the yarn.lock lookup keys (sometimes called a \"pattern\").\n     *\n     * Example input:  \"js-tokens@^3.0.0 || ^4.0.0\"\n     * Example output: { packageName: \"js-tokens\", semVerRange: \"^3.0.0 || ^4.0.0\" }\n     */\n    static _decodePackageNameAndSemVer(packageNameAndSemVer) {\n        const result = YarnShrinkwrapFile._packageNameAndSemVerRegExp.exec(packageNameAndSemVer);\n        if (!result) {\n            // Sanity check -- this should never happen\n            throw new Error('Unable to parse package/semver expression in the Yarn shrinkwrap file (yarn.lock): ' +\n                JSON.stringify(packageNameAndSemVer));\n        }\n        const packageName = result[1] || '';\n        const parsedPackageName = PackageNameParsers.permissive.tryParse(packageName);\n        if (parsedPackageName.error) {\n            // Sanity check -- this should never happen\n            throw new Error('Invalid package name the Yarn shrinkwrap file (yarn.lock): ' +\n                JSON.stringify(packageNameAndSemVer) +\n                '\\n' +\n                parsedPackageName.error);\n        }\n        return {\n            packageName,\n            semVerRange: result[2] || ''\n        };\n    }\n    /**\n     * This is the inverse of _decodePackageNameAndSemVer():\n     * Given an IPackageNameAndSemVer object, recreate the yarn.lock lookup key\n     * (sometimes called a \"pattern\").\n     */\n    static _encodePackageNameAndSemVer(packageNameAndSemVer) {\n        return packageNameAndSemVer.packageName + '@' + packageNameAndSemVer.semVerRange;\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._tempProjectNames;\n    }\n    /** @override */\n    hasCompatibleTopLevelDependency(dependencySpecifier) {\n        // It seems like we should normalize the key somehow, but Yarn apparently does not\n        // do any normalization.\n        const key = YarnShrinkwrapFile._encodePackageNameAndSemVer({\n            packageName: dependencySpecifier.packageName,\n            semVerRange: dependencySpecifier.versionSpecifier\n        });\n        // Check whether this exact key appears in the shrinkwrap file\n        return Object.hasOwnProperty.call(this._shrinkwrapJson, key);\n    }\n    /** @override */\n    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {\n        return this.hasCompatibleTopLevelDependency(dependencySpecifier);\n    }\n    /** @override */\n    serialize() {\n        return lockfileModule.stringify(this._shrinkwrapJson);\n    }\n    /** @override */\n    getTopLevelDependencyVersion(dependencyName) {\n        throw new InternalError('Not implemented');\n    }\n    /** @override */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        throw new InternalError('Not implemented');\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return undefined;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, variant) {\n        throw new InternalError('Not implemented');\n    }\n}\n// Example inputs:\n// \"js-tokens@^3.0.0 || ^4.0.0\"\n// \"@rush-temp/api-extractor-test-03@file:./projects/api-extractor-test-03.tgz\"\nYarnShrinkwrapFile._packageNameAndSemVerRegExp = /^(@?[^@\\s]+)(?:@(.*))?$/;\nexport { YarnShrinkwrapFile };\n//# sourceMappingURL=YarnShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AsyncSeriesBailHook, AsyncSeriesHook, AsyncSeriesWaterfallHook, SyncHook } from 'tapable';\n/**\n * Hooks into the execution process for phased commands\n * @alpha\n */\nexport class PhasedCommandHooks {\n    constructor() {\n        /**\n         * Hook invoked to create operations for execution.\n         * Use the context to distinguish between the initial run and phased runs.\n         */\n        this.createOperations = new AsyncSeriesWaterfallHook(['operations', 'context'], 'createOperations');\n        /**\n         * Hook invoked before operation start\n         * Hook is series for stable output.\n         */\n        this.beforeExecuteOperations = new AsyncSeriesHook(['records', 'context']);\n        /**\n         * Hook invoked when operation status changed\n         * Hook is series for stable output.\n         */\n        this.onOperationStatusChanged = new SyncHook(['record']);\n        /**\n         * Hook invoked after executing a set of operations.\n         * Use the context to distinguish between the initial run and phased runs.\n         * Hook is series for stable output.\n         */\n        this.afterExecuteOperations = new AsyncSeriesHook(['results', 'context']);\n        /**\n         * Hook invoked before executing a operation.\n         */\n        this.beforeExecuteOperation = new AsyncSeriesBailHook(['runnerContext'], 'beforeExecuteOperation');\n        /**\n         * Hook invoked after executing a operation.\n         */\n        this.afterExecuteOperation = new AsyncSeriesHook(['runnerContext'], 'afterExecuteOperation');\n        /**\n         * Hook invoked after a run has finished and the command is watching for changes.\n         * May be used to display additional relevant data to the user.\n         * Only relevant when running in watch mode.\n         */\n        this.waitingForChanges = new SyncHook(undefined, 'waitingForChanges');\n        /**\n         * Hook invoked after executing operations and before waitingForChanges. Allows the caller\n         * to augment or modify the log entry about to be written.\n         */\n        this.beforeLog = new SyncHook(['telemetryData'], 'beforeLog');\n    }\n}\n//# sourceMappingURL=PhasedCommandHooks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PluginLoaderBase } from './PluginLoaderBase';\n/**\n * @beta\n */\nexport class AutoinstallerPluginLoader extends PluginLoaderBase {\n    constructor(options) {\n        super(options);\n        this.autoinstaller = new Autoinstaller({\n            autoinstallerName: options.pluginConfiguration.autoinstallerName,\n            rushConfiguration: this._rushConfiguration,\n            restrictConsoleOutput: options.restrictConsoleOutput,\n            rushGlobalFolder: options.rushGlobalFolder\n        });\n        this.packageFolder = path.join(this.autoinstaller.folderFullPath, 'node_modules', this.packageName);\n    }\n    /**\n     * The folder where rush plugins static files are stored.\n     * Example: `C:\\MyRepo\\common\\autoinstallers\\<autoinstaller_name>\\rush-plugins`\n     */\n    static getPluginAutoinstallerStorePath(autoinstaller) {\n        return path.join(autoinstaller.folderFullPath, 'rush-plugins');\n    }\n    update() {\n        const packageName = this.packageName;\n        const pluginName = this.pluginName;\n        const packageFolder = this.packageFolder;\n        const manifestPath = path.join(packageFolder, RushConstants.rushPluginManifestFilename);\n        // validate\n        const manifest = JsonFile.loadAndValidate(manifestPath, AutoinstallerPluginLoader._jsonSchema);\n        FileSystem.copyFile({\n            sourcePath: manifestPath,\n            destinationPath: this._getManifestPath()\n        });\n        const pluginManifest = manifest.plugins.find((item) => item.pluginName === pluginName);\n        if (!pluginManifest) {\n            throw new Error(`A plugin named \"${pluginName}\" is not provided by the Rush plugin package \"${packageName}\"`);\n        }\n        const commandLineJsonFilePath = pluginManifest.commandLineJsonFilePath;\n        if (commandLineJsonFilePath) {\n            const commandLineJsonFullFilePath = path.join(packageFolder, commandLineJsonFilePath);\n            if (!FileSystem.exists(commandLineJsonFullFilePath)) {\n                this._terminal.writeErrorLine(`The Rush plugin \"${pluginName}\" from \"${packageName}\" specifies a commandLineJsonFilePath` +\n                    ` ${commandLineJsonFilePath} that does not exist.`);\n            }\n            FileSystem.copyFile({\n                sourcePath: commandLineJsonFullFilePath,\n                destinationPath: this._getCommandLineJsonFilePath()\n            });\n        }\n    }\n    _getCommandLineAdditionalPathFolders() {\n        const additionalPathFolders = super._getCommandLineAdditionalPathFolders();\n        additionalPathFolders.push(\n        // Example: `common/autoinstaller/plugins/node_modules/.bin`\n        path.join(this.autoinstaller.folderFullPath, 'node_modules', '.bin'));\n        return additionalPathFolders;\n    }\n    _getPluginOptions() {\n        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();\n        const optionsSchema = this._getRushPluginOptionsSchema();\n        let pluginOptions = {};\n        try {\n            pluginOptions = JsonFile.load(optionsJsonFilePath);\n        }\n        catch (e) {\n            if (FileSystem.isFileDoesNotExistError(e)) {\n                if (optionsSchema) {\n                    throw new Error(`Plugin options are required by ${this.pluginName} from package ${this.packageName}, please create it at ${optionsJsonFilePath}.`);\n                }\n                else {\n                    return {};\n                }\n            }\n            throw e;\n        }\n        if (optionsSchema) {\n            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);\n        }\n        return pluginOptions;\n    }\n    _getManifestPath() {\n        return path.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, RushConstants.rushPluginManifestFilename);\n    }\n    _getCommandLineJsonFilePath() {\n        return path.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, this.pluginName, RushConstants.commandLineFilename);\n    }\n}\n//# sourceMappingURL=AutoinstallerPluginLoader.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PluginLoaderBase } from './PluginLoaderBase';\n/**\n * @remarks\n * Used to load plugins that are dependencies of Rush.\n */\nexport class BuiltInPluginLoader extends PluginLoaderBase {\n    constructor(options) {\n        super(options);\n        this.packageFolder = options.pluginConfiguration.pluginPackageFolder;\n    }\n}\n//# sourceMappingURL=BuiltInPluginLoader.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, InternalError, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport * as path from 'path';\nimport { CommandLineConfiguration } from '../../api/CommandLineConfiguration';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { RushSdk } from './RushSdk';\nimport schemaJson from '../../schemas/rush-plugin-manifest.schema.json';\nclass PluginLoaderBase {\n    constructor({ pluginConfiguration, rushConfiguration, terminal }) {\n        this.packageName = pluginConfiguration.packageName;\n        this.pluginName = pluginConfiguration.pluginName;\n        this._rushConfiguration = rushConfiguration;\n        this._terminal = terminal;\n    }\n    load() {\n        const resolvedPluginPath = this._resolvePlugin();\n        if (!resolvedPluginPath) {\n            return undefined;\n        }\n        const pluginOptions = this._getPluginOptions();\n        RushSdk.ensureInitialized();\n        return this._loadAndValidatePluginPackage(resolvedPluginPath, pluginOptions);\n    }\n    get pluginManifest() {\n        return this._getRushPluginManifest();\n    }\n    getCommandLineConfiguration() {\n        const commandLineJsonFilePath = this._getCommandLineJsonFilePath();\n        if (!commandLineJsonFilePath) {\n            return undefined;\n        }\n        const commandLineConfiguration = CommandLineConfiguration.tryLoadFromFile(commandLineJsonFilePath);\n        if (!commandLineConfiguration) {\n            return undefined;\n        }\n        for (const additionalPathFolder of this._getCommandLineAdditionalPathFolders().reverse()) {\n            commandLineConfiguration.prependAdditionalPathFolder(additionalPathFolder);\n        }\n        commandLineConfiguration.shellCommandTokenContext = {\n            packageFolder: this.packageFolder\n        };\n        return commandLineConfiguration;\n    }\n    _getCommandLineAdditionalPathFolders() {\n        return [\n            // Example: `@microsoft/rush-lib/node_modules/<packageName>/node_modules/.bin`\n            // Example: `common/autoinstaller/plugins/node_modules/<packageName>/node_modules/.bin`\n            path.join(this.packageFolder, 'node_modules', '.bin')\n        ];\n    }\n    _getCommandLineJsonFilePath() {\n        const { commandLineJsonFilePath } = this._getRushPluginManifest();\n        if (!commandLineJsonFilePath) {\n            return undefined;\n        }\n        return path.join(this.packageFolder, commandLineJsonFilePath);\n    }\n    _loadAndValidatePluginPackage(resolvedPluginPath, options) {\n        let pluginPackage;\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const loadedPluginPackage = require(resolvedPluginPath);\n            pluginPackage = loadedPluginPackage.default || loadedPluginPackage;\n        }\n        catch (e) {\n            throw new InternalError(`Error loading rush plugin from \"${resolvedPluginPath}\": ${e}`);\n        }\n        if (!pluginPackage) {\n            throw new InternalError(`Rush plugin loaded from \"${resolvedPluginPath}\" is null or undefined.`);\n        }\n        this._terminal.writeVerboseLine(`Loaded rush plugin from \"${resolvedPluginPath}\"`);\n        const plugin = new pluginPackage(options);\n        if (!plugin.apply || typeof pluginPackage.apply !== 'function') {\n            throw new InternalError(`Rush plugin must define an \"apply\" function. The plugin loaded from \"${resolvedPluginPath}\" ` +\n                'either doesn\\'t define an \"apply\" property, or its value isn\\'t a function.');\n        }\n        return plugin;\n    }\n    _resolvePlugin() {\n        const entryPoint = this._getRushPluginManifest().entryPoint;\n        if (!entryPoint) {\n            return undefined;\n        }\n        const packageFolder = this.packageFolder;\n        const modulePath = path.join(packageFolder, entryPoint);\n        if (!FileSystem.exists(modulePath)) {\n            throw new InternalError(`Unable to find entry point \"${modulePath}\" for rush plugin \"${this.pluginName}\".`);\n        }\n        return modulePath;\n    }\n    _getPluginOptions() {\n        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();\n        const optionsSchema = this._getRushPluginOptionsSchema();\n        let pluginOptions = {};\n        try {\n            pluginOptions = JsonFile.load(optionsJsonFilePath);\n        }\n        catch (e) {\n            if (FileSystem.isFileDoesNotExistError(e)) {\n                return {};\n            }\n            throw e;\n        }\n        if (optionsSchema) {\n            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);\n        }\n        return pluginOptions;\n    }\n    _getPluginOptionsJsonFilePath() {\n        return path.join(this._rushConfiguration.rushPluginOptionsFolder, `${this.pluginName}.json`);\n    }\n    _getRushPluginOptionsSchema() {\n        const optionsSchema = this._getRushPluginManifest().optionsSchema;\n        if (!optionsSchema) {\n            return undefined;\n        }\n        const optionsSchemaFilePath = path.join(this.packageFolder, optionsSchema);\n        return JsonSchema.fromFile(optionsSchemaFilePath);\n    }\n    _getRushPluginManifest() {\n        if (!this._manifestCache) {\n            const packageName = this.packageName;\n            const pluginName = this.pluginName;\n            const manifestPath = this._getManifestPath();\n            if (!FileSystem.exists(manifestPath)) {\n                throw new Error(`Manifest for rush plugin package ${packageName} not found.\\nPlease run 'rush update' first.`);\n            }\n            const rushPluginManifestJson = JsonFile.loadAndValidate(manifestPath, PluginLoaderBase._jsonSchema);\n            const pluginManifest = rushPluginManifestJson.plugins.find((item) => item.pluginName === pluginName);\n            if (!pluginManifest) {\n                throw new Error(`${pluginName} is not provided by Rush plugin package \"${packageName}\"`);\n            }\n            this._manifestCache = pluginManifest;\n        }\n        return this._manifestCache;\n    }\n    _getManifestPath() {\n        return path.join(this.packageFolder, RushConstants.rushPluginManifestFilename);\n    }\n}\nPluginLoaderBase._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\nexport { PluginLoaderBase };\n//# sourceMappingURL=PluginLoaderBase.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nclass RushSdk {\n    static ensureInitialized() {\n        if (!RushSdk._initialized) {\n            const rushLibModule = require('../../index');\n            // The \"@rushstack/rush-sdk\" shim will look for this global variable to obtain\n            // Rush's instance of \"@microsoft/rush-lib\".\n            global.___rush___rushLibModule = rushLibModule;\n            RushSdk._initialized = true;\n        }\n    }\n}\nRushSdk._initialized = false;\nexport { RushSdk };\n//# sourceMappingURL=RushSdk.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Import, InternalError } from '@rushstack/node-core-library';\nimport { BuiltInPluginLoader } from './PluginLoader/BuiltInPluginLoader';\nimport { AutoinstallerPluginLoader } from './PluginLoader/AutoinstallerPluginLoader';\nimport { Rush } from '../api/Rush';\nexport class PluginManager {\n    constructor(options) {\n        var _a, _b;\n        this._loadedPluginNames = new Set();\n        this._terminal = options.terminal;\n        this._rushConfiguration = options.rushConfiguration;\n        this._rushSession = options.rushSession;\n        this._restrictConsoleOutput = options.restrictConsoleOutput;\n        this._rushGlobalFolder = options.rushGlobalFolder;\n        this._installedAutoinstallerNames = new Set();\n        // Eventually we will require end users to explicitly configure all Rush plugins in use, regardless of\n        // whether they are first party or third party plugins.  However, we're postponing that requirement\n        // until after the plugin feature has stabilized and is fully documented.  In the meantime, Rush's\n        // built-in plugins are dependencies of @microsoft/rush-lib and get loaded by default (without any\n        // configuration).\n        //\n        // The plugins have devDependencies on Rush, which would create a circular dependency in our local\n        // workspace if we added them to rush-lib/package.json.  Instead we put them in a special section\n        // \"publishOnlyDependencies\" which gets moved into \"dependencies\" during publishing.\n        const builtInPluginConfigurations = options.builtInPluginConfigurations;\n        const ownPackageJsonDependencies = Rush._rushLibPackageJson.dependencies || {};\n        function tryAddBuiltInPlugin(builtInPluginName, pluginPackageName) {\n            if (!pluginPackageName) {\n                pluginPackageName = `@rushstack/${builtInPluginName}`;\n            }\n            if (ownPackageJsonDependencies[pluginPackageName]) {\n                builtInPluginConfigurations.push({\n                    packageName: pluginPackageName,\n                    pluginName: builtInPluginName,\n                    pluginPackageFolder: Import.resolvePackage({\n                        packageName: pluginPackageName,\n                        baseFolderPath: __dirname\n                    })\n                });\n            }\n        }\n        tryAddBuiltInPlugin('rush-amazon-s3-build-cache-plugin');\n        tryAddBuiltInPlugin('rush-azure-storage-build-cache-plugin');\n        tryAddBuiltInPlugin('rush-http-build-cache-plugin');\n        // This is a secondary plugin inside the `@rushstack/rush-azure-storage-build-cache-plugin`\n        // package. Because that package comes with Rush (for now), it needs to get registered here.\n        // If the necessary config file doesn't exist, this plugin doesn't do anything.\n        tryAddBuiltInPlugin('rush-azure-interactive-auth-plugin', '@rushstack/rush-azure-storage-build-cache-plugin');\n        this._builtInPluginLoaders = builtInPluginConfigurations.map((pluginConfiguration) => {\n            return new BuiltInPluginLoader({\n                pluginConfiguration,\n                rushConfiguration: this._rushConfiguration,\n                terminal: this._terminal\n            });\n        });\n        this._autoinstallerPluginLoaders = ((_b = (_a = this._rushConfiguration) === null || _a === void 0 ? void 0 : _a._rushPluginsConfiguration.configuration.plugins) !== null && _b !== void 0 ? _b : []).map((pluginConfiguration) => {\n            return new AutoinstallerPluginLoader({\n                pluginConfiguration,\n                rushConfiguration: this._rushConfiguration,\n                terminal: this._terminal,\n                restrictConsoleOutput: this._restrictConsoleOutput,\n                rushGlobalFolder: this._rushGlobalFolder\n            });\n        });\n    }\n    /**\n     * If an error occurs while attempting to load plugins, it will be saved in this property.\n     * Rush will attempt to continue and will report the error later by `BaseRushAction._throwPluginErrorIfNeed()`\n     * (unless we are invoking a command that is used to fix plugin problems).\n     */\n    get error() {\n        return this._error;\n    }\n    async updateAsync() {\n        await this._preparePluginAutoinstallersAsync(this._autoinstallerPluginLoaders);\n        const preparedAutoinstallerNames = new Set();\n        for (const { autoinstaller } of this._autoinstallerPluginLoaders) {\n            const storePath = AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(autoinstaller);\n            if (!preparedAutoinstallerNames.has(autoinstaller.name)) {\n                FileSystem.ensureEmptyFolder(storePath);\n                preparedAutoinstallerNames.add(autoinstaller.name);\n            }\n        }\n        for (const pluginLoader of this._autoinstallerPluginLoaders) {\n            pluginLoader.update();\n        }\n    }\n    async reinitializeAllPluginsForCommandAsync(commandName) {\n        this._error = undefined;\n        await this.tryInitializeUnassociatedPluginsAsync();\n        await this.tryInitializeAssociatedCommandPluginsAsync(commandName);\n    }\n    async _preparePluginAutoinstallersAsync(pluginLoaders) {\n        for (const { autoinstaller } of pluginLoaders) {\n            if (!this._installedAutoinstallerNames.has(autoinstaller.name)) {\n                await autoinstaller.prepareAsync();\n                this._installedAutoinstallerNames.add(autoinstaller.name);\n            }\n        }\n    }\n    async tryInitializeUnassociatedPluginsAsync() {\n        try {\n            const autoinstallerPluginLoaders = this._getUnassociatedPluginLoaders(this._autoinstallerPluginLoaders);\n            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);\n            const builtInPluginLoaders = this._getUnassociatedPluginLoaders(this._builtInPluginLoaders);\n            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);\n        }\n        catch (e) {\n            this._error = e;\n        }\n    }\n    async tryInitializeAssociatedCommandPluginsAsync(commandName) {\n        try {\n            const autoinstallerPluginLoaders = this._getPluginLoadersForCommand(commandName, this._autoinstallerPluginLoaders);\n            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);\n            const builtInPluginLoaders = this._getPluginLoadersForCommand(commandName, this._builtInPluginLoaders);\n            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);\n        }\n        catch (e) {\n            this._error = e;\n        }\n    }\n    tryGetCustomCommandLineConfigurationInfos() {\n        const commandLineConfigurationInfos = [];\n        for (const pluginLoader of this._autoinstallerPluginLoaders) {\n            const commandLineConfiguration = pluginLoader.getCommandLineConfiguration();\n            if (commandLineConfiguration) {\n                commandLineConfigurationInfos.push({\n                    commandLineConfiguration,\n                    pluginLoader\n                });\n            }\n        }\n        return commandLineConfigurationInfos;\n    }\n    _initializePlugins(pluginLoaders) {\n        for (const pluginLoader of pluginLoaders) {\n            const pluginName = pluginLoader.pluginName;\n            if (this._loadedPluginNames.has(pluginName)) {\n                throw new Error(`Error applying plugin: A plugin with name \"${pluginName}\" has already been applied`);\n            }\n            const plugin = pluginLoader.load();\n            this._loadedPluginNames.add(pluginName);\n            if (plugin) {\n                this._applyPlugin(plugin, pluginName);\n            }\n        }\n    }\n    _getUnassociatedPluginLoaders(pluginLoaders) {\n        return pluginLoaders.filter((pluginLoader) => {\n            return !pluginLoader.pluginManifest.associatedCommands;\n        });\n    }\n    _getPluginLoadersForCommand(commandName, pluginLoaders) {\n        return pluginLoaders.filter((pluginLoader) => {\n            var _a;\n            return (_a = pluginLoader.pluginManifest.associatedCommands) === null || _a === void 0 ? void 0 : _a.includes(commandName);\n        });\n    }\n    _applyPlugin(plugin, pluginName) {\n        try {\n            plugin.apply(this._rushSession, this._rushConfiguration);\n        }\n        catch (e) {\n            throw new InternalError(`Error applying \"${pluginName}\": ${e}`);\n        }\n    }\n}\n//# sourceMappingURL=PluginManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AsyncParallelHook, AsyncSeriesHook, HookMap } from 'tapable';\n/**\n * Hooks into the lifecycle of the Rush process invocation that plugins may tap into.\n *\n * @beta\n */\nexport class RushLifecycleHooks {\n    constructor() {\n        /**\n         * The hook to run before executing any Rush CLI Command.\n         */\n        this.initialize = new AsyncSeriesHook(['command'], 'initialize');\n        /**\n         * The hook to run before executing any global Rush CLI Command (defined in command-line.json).\n         */\n        this.runAnyGlobalCustomCommand = new AsyncSeriesHook(['command'], 'runAnyGlobalCustomCommand');\n        /**\n         * A hook map to allow plugins to hook specific named global commands (defined in command-line.json) before execution.\n         */\n        this.runGlobalCustomCommand = new HookMap((key) => {\n            return new AsyncSeriesHook(['command'], key);\n        }, 'runGlobalCustomCommand');\n        /**\n         * The hook to run before executing any phased Rush CLI Command (defined in command-line.json, or the default \"build\" or \"rebuild\").\n         */\n        this.runAnyPhasedCommand = new AsyncSeriesHook(['command'], 'runAnyPhasedCommand');\n        /**\n         * A hook map to allow plugins to hook specific named phased commands (defined in command-line.json) before execution.\n         */\n        this.runPhasedCommand = new HookMap((key) => {\n            return new AsyncSeriesHook(['command'], key);\n        }, 'runPhasedCommand');\n        /**\n         * The hook to run between preparing the common/temp folder and invoking the package manager during \"rush install\" or \"rush update\".\n         */\n        this.beforeInstall = new AsyncSeriesHook(['command'], 'beforeInstall');\n        /**\n         * A hook to allow plugins to hook custom logic to process telemetry data.\n         */\n        this.flushTelemetry = new AsyncParallelHook(['telemetryData'], 'flushTelemetry');\n    }\n}\n//# sourceMappingURL=RushLifeCycle.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\nimport { Logger } from './logging/Logger';\nimport { RushLifecycleHooks } from './RushLifeCycle';\n/**\n * @beta\n */\nexport class RushSession {\n    constructor(options) {\n        this._cloudBuildCacheProviderFactories = new Map();\n        this._cobuildLockProviderFactories = new Map();\n        this._options = options;\n        this.hooks = new RushLifecycleHooks();\n    }\n    getLogger(name) {\n        if (!name) {\n            throw new InternalError('RushSession.getLogger(name) called without a name');\n        }\n        const terminalProvider = this._options.terminalProvider;\n        const loggerOptions = {\n            loggerName: name,\n            getShouldPrintStacks: () => this._options.getIsDebugMode(),\n            terminalProvider\n        };\n        return new Logger(loggerOptions);\n    }\n    get terminalProvider() {\n        return this._options.terminalProvider;\n    }\n    registerCloudBuildCacheProviderFactory(cacheProviderName, factory) {\n        if (this._cloudBuildCacheProviderFactories.has(cacheProviderName)) {\n            throw new Error(`A build cache provider factory for ${cacheProviderName} has already been registered`);\n        }\n        this._cloudBuildCacheProviderFactories.set(cacheProviderName, factory);\n    }\n    getCloudBuildCacheProviderFactory(cacheProviderName) {\n        return this._cloudBuildCacheProviderFactories.get(cacheProviderName);\n    }\n    registerCobuildLockProviderFactory(cobuildLockProviderName, factory) {\n        if (this._cobuildLockProviderFactories.has(cobuildLockProviderName)) {\n            throw new Error(`A cobuild lock provider factory for ${cobuildLockProviderName} has already been registered`);\n        }\n        this._cobuildLockProviderFactories.set(cobuildLockProviderName, factory);\n    }\n    getCobuildLockProviderFactory(cobuildLockProviderName) {\n        return this._cobuildLockProviderFactories.get(cobuildLockProviderName);\n    }\n}\n//# sourceMappingURL=RushSession.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Terminal } from '@rushstack/node-core-library';\nexport class Logger {\n    constructor(options) {\n        this._errors = [];\n        this._warnings = [];\n        this._options = options;\n        this.terminal = new Terminal(options.terminalProvider);\n    }\n    get errors() {\n        return [...this.errors];\n    }\n    get warnings() {\n        return [...this.warnings];\n    }\n    static getErrorMessage(error) {\n        return error.message;\n    }\n    /**\n     * {@inheritdoc ILogger.emitError}\n     */\n    emitError(error) {\n        this._errors.push(error);\n        this.terminal.writeErrorLine(`Error: ${Logger.getErrorMessage(error)}`);\n        if (this._shouldPrintStacks && error.stack) {\n            this.terminal.writeErrorLine(error.stack);\n        }\n    }\n    /**\n     * {@inheritdoc ILogger.emitWarning}\n     */\n    emitWarning(warning) {\n        this._warnings.push(warning);\n        this.terminal.writeWarningLine(`Warning: ${Logger.getErrorMessage(warning)}`);\n        if (this._shouldPrintStacks && warning.stack) {\n            this.terminal.writeWarningLine(warning.stack);\n        }\n    }\n    get _shouldPrintStacks() {\n        return this._options.getShouldPrintStacks();\n    }\n}\n//# sourceMappingURL=Logger.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as child_process from 'child_process';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { Text, Path, FileSystem } from '@rushstack/node-core-library';\nimport { Utilities } from './Utilities';\n/**\n * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().\n * It works by moving one or more folders into a temporary \"recycler\" folder, and then launches a separate\n * background process to recursively delete that folder.\n */\nexport class AsyncRecycler {\n    constructor(recyclerFolder) {\n        this.recyclerFolder = path.resolve(recyclerFolder);\n        this._movedFolderCount = 0;\n        this._deleting = false;\n        this._prefix = `${Date.now()}`;\n    }\n    /**\n     * Synchronously moves the specified folder into the recycler folder.  If the specified folder\n     * does not exist, then no operation is performed.  After calling this function one or more times,\n     * deleteAll() must be called to actually delete the contents of the recycler folder.\n     */\n    moveFolder(folderPath) {\n        if (this._deleting) {\n            throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');\n        }\n        if (Path.isUnder(this.recyclerFolder, folderPath)) {\n            throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');\n        }\n        if (!FileSystem.exists(folderPath)) {\n            return;\n        }\n        ++this._movedFolderCount;\n        // We need to do a simple \"fs.renameSync\" here, however if the folder we're trying to rename\n        // has a lock, or if its destination container doesn't exist yet,\n        // then there seems to be some OS process (virus scanner?) that holds\n        // a lock on the folder for a split second, which causes renameSync to\n        // fail. To workaround that, retry for up to 7 seconds before giving up.\n        const maxWaitTimeMs = 7 * 1000;\n        Utilities.createFolderWithRetry(this.recyclerFolder);\n        Utilities.retryUntilTimeout(() => this._renameOrRecurseInFolder(folderPath), maxWaitTimeMs, (e) => new Error(`Error: ${e}\\nOften this is caused by a file lock from a process like the virus scanner.`), 'recycleFolder');\n    }\n    /**\n     * This deletes all items under the specified folder, except for the items in the membersToExclude.\n     * To be conservative, a case-insensitive comparison is used for membersToExclude.\n     * The membersToExclude must be file/folder names that would match readdir() results.\n     */\n    moveAllItemsInFolder(folderPath, membersToExclude) {\n        const resolvedFolderPath = path.resolve(folderPath);\n        const excludeSet = new Set((membersToExclude || []).map((x) => x.toUpperCase()));\n        for (const dirent of FileSystem.readFolderItems(resolvedFolderPath)) {\n            const normalizedMemberName = dirent.name.toUpperCase();\n            if (!excludeSet.has(normalizedMemberName)) {\n                const absolutePath = path.resolve(folderPath, dirent.name);\n                if (dirent.isDirectory()) {\n                    this._renameOrRecurseInFolder(absolutePath);\n                }\n                else {\n                    FileSystem.deleteFile(absolutePath);\n                }\n            }\n        }\n    }\n    /**\n     * Starts an asynchronous process to delete the recycler folder.  Deleting will continue\n     * even if the current Node.js process is killed.\n     *\n     * NOTE: To avoid spawning multiple instances of the same command, moveFolder()\n     * MUST NOT be called again after deleteAll() has started.\n     */\n    deleteAll() {\n        if (this._deleting) {\n            throw new Error('AsyncRecycler.deleteAll() must not be called more than once');\n        }\n        this._deleting = true;\n        if (this._movedFolderCount === 0) {\n            // Nothing to do\n            return;\n        }\n        // Asynchronously delete the folder contents.\n        let command;\n        let args;\n        const options = {\n            detached: true,\n            // The child won't stay alive unless we detach its stdio\n            stdio: 'ignore'\n        };\n        if (os.platform() === 'win32') {\n            // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create\n            // the new console for us.\n            command = 'cmd.exe';\n            // In PowerShell single-quote literals, single quotes are escaped by doubling them\n            const escapedRecyclerFolder = Text.replaceAll(this.recyclerFolder, \"'\", \"''\");\n            // As of PowerShell 3.0, the \"\\\\?\" prefix can be used for paths that exceed MAX_PATH.\n            // (This prefix does not seem to work for cmd.exe's \"rd\" command.)\n            args = [\n                '/c',\n                '\"' +\n                    'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command' +\n                    ` Get-ChildItem -Force '${escapedRecyclerFolder}'` +\n                    // The \"^|\" here prevents cmd.exe from interpreting the \"|\" symbol\n                    ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse \"\\\\\\\\?\\\\$($_.FullName)\" }` +\n                    '\"'\n            ];\n            options.windowsVerbatimArguments = true;\n        }\n        else {\n            command = 'rm';\n            args = ['-rf'];\n            let pathCount = 0;\n            // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually\n            // rather than rely on an unknown shell.\n            for (const filename of FileSystem.readFolderItemNames(this.recyclerFolder)) {\n                // The \".\" and \"..\" are supposed to be excluded, but let's be safe\n                if (filename !== '.' && filename !== '..') {\n                    args.push(path.join(this.recyclerFolder, filename));\n                    ++pathCount;\n                }\n            }\n            if (pathCount === 0) {\n                // Nothing to do\n                return;\n            }\n        }\n        const process = child_process.spawn(command, args, options);\n        // The child won't stay alive unless we unlink it from the parent process\n        process.unref();\n    }\n    _renameOrRecurseInFolder(folderPath) {\n        const ordinal = this._movedFolderCount++;\n        const targetDir = `${this.recyclerFolder}/${this._prefix}_${ordinal}`;\n        try {\n            fs.renameSync(folderPath, targetDir);\n            return;\n        }\n        catch (err) {\n            if (FileSystem.isNotExistError(err)) {\n                return;\n            }\n            if (err.code !== 'EPERM') {\n                throw err;\n            }\n        }\n        const children = FileSystem.readFolderItems(folderPath);\n        for (const child of children) {\n            const absoluteChild = `${folderPath}/${child.name}`;\n            if (child.isDirectory()) {\n                this._renameOrRecurseInFolder(absoluteChild);\n            }\n            else {\n                FileSystem.deleteFile(absoluteChild);\n            }\n        }\n        // Yes, this is a folder. The API deletes empty folders, too.\n        FileSystem.deleteFile(folderPath);\n    }\n}\n//# sourceMappingURL=AsyncRecycler.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { TerminalProviderSeverity } from '@rushstack/node-core-library';\nexport class CollatedTerminalProvider {\n    get hasErrors() {\n        return this._hasErrors;\n    }\n    get hasWarnings() {\n        return this._hasWarnings;\n    }\n    constructor(collatedTerminal, options) {\n        this._hasErrors = false;\n        this._hasWarnings = false;\n        this._debugEnabled = false;\n        this.supportsColor = true;\n        this.eolCharacter = '\\n';\n        this._collatedTerminal = collatedTerminal;\n        this._debugEnabled = !!(options === null || options === void 0 ? void 0 : options.debugEnabled);\n    }\n    write(data, severity) {\n        switch (severity) {\n            case TerminalProviderSeverity.log:\n            case TerminalProviderSeverity.verbose: {\n                // Unlike the basic ConsoleTerminalProvider, verbose messages are always passed\n                // to stdout -- by convention the user-controlled build script output is sent\n                // to verbose, and will be routed to a variety of other providers in the ProjectBuilder.\n                this._collatedTerminal.writeChunk({ text: data, kind: \"O\" /* TerminalChunkKind.Stdout */ });\n                break;\n            }\n            case TerminalProviderSeverity.debug: {\n                // Similar to the basic ConsoleTerminalProvider, debug messages are discarded\n                // unless they are explicitly enabled.\n                if (this._debugEnabled) {\n                    this._collatedTerminal.writeChunk({ text: data, kind: \"O\" /* TerminalChunkKind.Stdout */ });\n                }\n                break;\n            }\n            case TerminalProviderSeverity.error: {\n                this._collatedTerminal.writeChunk({ text: data, kind: \"E\" /* TerminalChunkKind.Stderr */ });\n                this._hasErrors = true;\n                break;\n            }\n            case TerminalProviderSeverity.warning: {\n                this._collatedTerminal.writeChunk({ text: data, kind: \"E\" /* TerminalChunkKind.Stderr */ });\n                this._hasWarnings = true;\n                break;\n            }\n            default: {\n                throw new Error(`Unexpected severity: ${severity}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=CollatedTerminalProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Utilities } from './Utilities';\nimport * as semver from 'semver';\nexport class Npm {\n    static publishedVersions(packageName, cwd, env, extraArgs = []) {\n        const versions = [];\n        try {\n            const packageTime = Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'time', '--json', ...extraArgs], cwd, env, true);\n            if (packageTime && packageTime !== '') {\n                Object.keys(JSON.parse(packageTime)).forEach((v) => {\n                    if (semver.valid(v)) {\n                        versions.push(v);\n                    }\n                });\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Package ${packageName} time value does not exist. Fall back to versions.`);\n                // time property does not exist. It happens sometimes. Fall back to versions.\n                const packageVersions = Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'versions', '--json', ...extraArgs], cwd, env, true);\n                if (packageVersions && packageVersions.length > 0) {\n                    const parsedPackageVersions = JSON.parse(packageVersions);\n                    // NPM <= 6 always returns an array, NPM >= 7 returns a string if the package has only one version available\n                    (Array.isArray(parsedPackageVersions) ? parsedPackageVersions : [parsedPackageVersions]).forEach((version) => {\n                        versions.push(version);\n                    });\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.log(`No version is found for ${packageName}`);\n                }\n            }\n        }\n        catch (error) {\n            if (error.message.indexOf('npm ERR! 404') >= 0) {\n                // eslint-disable-next-line no-console\n                console.log(`Package ${packageName} does not exist in the registry.`);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Failed to get NPM information about ${packageName}.`);\n                throw error;\n            }\n        }\n        return versions;\n    }\n}\n//# sourceMappingURL=Npm.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A terminal provider like /dev/null\n */\nexport class NullTerminalProvider {\n    constructor() {\n        this.supportsColor = false;\n        this.eolCharacter = '\\n';\n    }\n    write() { }\n}\n//# sourceMappingURL=NullTerminalProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,\n * 'lib/x' and 'lib/y' do not.\n */\nexport class OverlappingPathAnalyzer {\n    constructor() {\n        this._root = {\n            encounteredLabels: new Set(),\n            paths: {}\n        };\n    }\n    addPathAndGetFirstEncounteredLabels(path, label) {\n        const pathParts = path.split('/');\n        let currentNode = this._root;\n        let currentNodeIsNew = false;\n        let labelWasAlreadyPresentInCurrentNode = false;\n        for (const pathPart of pathParts) {\n            if (pathPart === '') {\n                continue;\n            }\n            if (currentNode.label) {\n                return [currentNode.label];\n            }\n            if (!currentNode.paths[pathPart]) {\n                currentNodeIsNew = true;\n                currentNode = currentNode.paths[pathPart] = {\n                    encounteredLabels: new Set(),\n                    paths: {}\n                };\n            }\n            else {\n                currentNodeIsNew = false;\n                currentNode = currentNode.paths[pathPart];\n            }\n            labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);\n            if (!labelWasAlreadyPresentInCurrentNode) {\n                currentNode.encounteredLabels.add(label);\n            }\n        }\n        if (currentNodeIsNew) {\n            currentNode.label = label;\n            return undefined;\n        }\n        else if (labelWasAlreadyPresentInCurrentNode) {\n            return Array.from(currentNode.encounteredLabels);\n        }\n        else {\n            const clonedEncounteredLabels = new Set(currentNode.encounteredLabels);\n            clonedEncounteredLabels.delete(label);\n            return Array.from(clonedEncounteredLabels);\n        }\n    }\n}\n//# sourceMappingURL=OverlappingPathAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonLookup } from '@rushstack/node-core-library';\n/**\n * The currently-executing rush-lib package's root folder path.\n */\nexport const rushLibFolderRootPath = PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);\n/**\n * The path to the assets folder in rush-lib.\n */\nexport const assetsFolderPath = `${rushLibFolderRootPath}/assets`;\n/**\n * The folder name (\"scripts\") where the scripts in rush-lib are built.\n */\nexport const scriptsFolderName = 'scripts';\nexport const pnpmfileShimFilename = 'PnpmfileShim.js';\nexport const installRunScriptFilename = 'install-run.js';\nexport const installRunRushScriptFilename = 'install-run-rush.js';\nexport const installRunRushxScriptFilename = 'install-run-rushx.js';\nexport const installRunRushPnpmScriptFilename = 'install-run-rush-pnpm.js';\n/**\n * The path to the scripts folder in rush-lib/dist.\n */\nexport const scriptsFolderPath = `${rushLibFolderRootPath}/dist/${scriptsFolderName}`;\n//# sourceMappingURL=PathConstants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonLookup } from '@rushstack/node-core-library';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nconst rootDir = PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);\nif (rootDir) {\n    // Route to the 'main' field of package.json\n    const rushLibIndex = require.resolve(rootDir, { paths: [] });\n    process.env[EnvironmentVariableNames.RUSH_LIB_PATH] = rushLibIndex;\n}\n//# sourceMappingURL=SetRushLibPath.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Utilities } from './Utilities';\n/**\n * Used with the Stopwatch class.\n */\nexport var StopwatchState;\n(function (StopwatchState) {\n    StopwatchState[StopwatchState[\"Stopped\"] = 1] = \"Stopped\";\n    StopwatchState[StopwatchState[\"Started\"] = 2] = \"Started\";\n})(StopwatchState || (StopwatchState = {}));\n/**\n * Represents a typical timer/stopwatch which keeps track\n * of elapsed time in between two events.\n */\nexport class Stopwatch {\n    constructor(getTime = Utilities.getTimeInMs) {\n        this._startTime = undefined;\n        this._endTime = undefined;\n        this._getTime = getTime;\n        this._state = StopwatchState.Stopped;\n    }\n    /**\n     * Static helper function which creates a stopwatch which is immediately started\n     */\n    static start() {\n        return new Stopwatch().start();\n    }\n    get state() {\n        return this._state;\n    }\n    /**\n     * Starts the stopwatch. Note that if end() has been called,\n     * reset() should be called before calling start() again.\n     */\n    start() {\n        if (this._startTime !== undefined) {\n            throw new Error('Call reset() before starting the Stopwatch');\n        }\n        this._startTime = this._getTime();\n        this._endTime = undefined;\n        this._state = StopwatchState.Started;\n        return this;\n    }\n    /**\n     * Stops executing the stopwatch and saves the current timestamp\n     */\n    stop() {\n        this._endTime = this._startTime !== undefined ? this._getTime() : undefined;\n        this._state = StopwatchState.Stopped;\n        return this;\n    }\n    /**\n     * Resets all values of the stopwatch back to the original\n     */\n    reset() {\n        this._endTime = this._startTime = undefined;\n        this._state = StopwatchState.Stopped;\n        return this;\n    }\n    /**\n     * Displays how long the stopwatch has been executing in a human readable format.\n     */\n    toString() {\n        if (this._state === StopwatchState.Stopped && this._startTime === undefined) {\n            return '0.00 seconds (stopped)';\n        }\n        const totalSeconds = this.duration;\n        if (totalSeconds > 60) {\n            const minutes = Math.floor(totalSeconds / 60);\n            const seconds = totalSeconds % 60.0;\n            return `${minutes.toFixed(0)} minute${minutes === 1 ? '' : 's'} ${seconds.toFixed(1)} seconds`;\n        }\n        else {\n            return `${totalSeconds.toFixed(2)} seconds`;\n        }\n    }\n    /**\n     * Get the duration in seconds.\n     */\n    get duration() {\n        if (this._startTime === undefined) {\n            return 0;\n        }\n        const curTime = this._endTime !== undefined ? this._endTime : this._getTime();\n        return (curTime - this._startTime) / 1000.0;\n    }\n    /**\n     * Return the start time of the most recent stopwatch run.\n     */\n    get startTime() {\n        return this._startTime;\n    }\n    /**\n     * Return the end time of the most recent stopwatch run.\n     */\n    get endTime() {\n        return this._endTime;\n    }\n}\n//# sourceMappingURL=Stopwatch.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport os from 'os';\nimport { Executable, FileSystem, FileWriter } from '@rushstack/node-core-library';\nimport events from 'events';\nimport { EnvironmentConfiguration } from '../api/EnvironmentConfiguration';\nexport class TarExecutable {\n    constructor(tarExecutablePath) {\n        this._tarExecutablePath = tarExecutablePath;\n    }\n    static async tryInitializeAsync(terminal) {\n        terminal.writeVerboseLine('Trying to find \"tar\" binary');\n        const tarExecutablePath = EnvironmentConfiguration.tarBinaryPath || (await TarExecutable._tryFindTarExecutablePathAsync());\n        if (!tarExecutablePath) {\n            terminal.writeVerboseLine('\"tar\" was not found on the PATH');\n            return undefined;\n        }\n        return new TarExecutable(tarExecutablePath);\n    }\n    /**\n     * @returns\n     * The \"tar\" exit code\n     */\n    async tryUntarAsync(options) {\n        return await this._spawnTarWithLoggingAsync(\n        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n        [\n            // [Windows bsdtar 3.3.2] Extract: tar -x [options] [<patterns>]\n            '-x',\n            // [Windows bsdtar 3.3.2] -m    Don't restore modification times\n            '-m',\n            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n            '-f',\n            options.archivePath\n        ], options.outputFolderPath, options.logFilePath);\n    }\n    /**\n     * @returns\n     * The \"tar\" exit code\n     */\n    async tryCreateArchiveFromProjectPathsAsync(options) {\n        const { project, archivePath, paths, logFilePath } = options;\n        const tarInput = paths.join('\\n');\n        // On Windows, tar.exe will report a \"Failed to clean up compressor\" error if the target folder\n        // does not exist (GitHub #2622)\n        await FileSystem.ensureFolderAsync(path.dirname(archivePath));\n        const projectFolderPath = project.projectFolder;\n        const tarExitCode = await this._spawnTarWithLoggingAsync(\n        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n        [\n            // [Windows bsdtar 3.3.2] -c Create\n            '-c',\n            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n            '-f',\n            archivePath,\n            // [Windows bsdtar 3.3.2] -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma\n            '-z',\n            // [GNU tar 1.33] -T, --files-from=FILE      get names to extract or create from FILE\n            //\n            // Windows bsdtar does not document this parameter, but seems to accept it.\n            '--files-from=-'\n        ], projectFolderPath, logFilePath, tarInput);\n        return tarExitCode;\n    }\n    async _spawnTarWithLoggingAsync(args, currentWorkingDirectory, logFilePath, input) {\n        // Runs \"tar\" with the specified args and logs its output to the specified location.\n        // The log file looks like this:\n        //\n        // Windows:\n        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n        // Invoking \"C:\\WINDOWS\\system32\\tar.exe -x -f E:\\rush-cache\\d18105f7f83eb610b468be4e2421681f4a52e44d\"\n        //\n        // ======= BEGIN PROCESS OUTPUT =======\n        // [stdout] <tar stdout output>\n        // [stderr] <tar stderr output>\n        // ======== END PROCESS OUTPUT ========\n        //\n        // Exited with code \"0\"\n        //\n        // Linux:\n        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n        // Invoking \"/bin/tar -x -f /home/username/rush-cache/d18105f7f83eb610b468be4e2421681f4a52e44d\"\n        //\n        // ======= BEGIN PROCESS OUTPUT =======\n        // [stdout] <tar stdout output>\n        // [stderr] <tar stderr output>\n        // ======== END PROCESS OUTPUT ========\n        //\n        // Exited with code \"0\"\n        await FileSystem.ensureFolderAsync(path.dirname(logFilePath));\n        const fileWriter = FileWriter.open(logFilePath);\n        fileWriter.write([\n            `Start time: ${new Date().toString()}`,\n            `Invoking \"${this._tarExecutablePath} ${args.join(' ')}\"`,\n            '',\n            `======= BEGIN PROCESS INPUT ======`,\n            input || '',\n            '======== END PROCESS INPUT =======',\n            '======= BEGIN PROCESS OUTPUT =======',\n            ''\n        ].join('\\n'));\n        const childProcess = Executable.spawn(this._tarExecutablePath, args, {\n            currentWorkingDirectory: currentWorkingDirectory\n        });\n        childProcess.stdout.on('data', (chunk) => fileWriter.write(`[stdout] ${chunk}`));\n        childProcess.stderr.on('data', (chunk) => fileWriter.write(`[stderr] ${chunk}`));\n        if (input !== undefined) {\n            childProcess.stdin.write(input, 'utf-8');\n            childProcess.stdin.end();\n        }\n        // Wait for process to exit and all streams to close\n        const [tarExitCode] = await events.once(childProcess, 'close');\n        fileWriter.write(['======== END PROCESS OUTPUT ========', '', `Exited with code \"${tarExitCode}\"`].join('\\n'));\n        fileWriter.close();\n        return tarExitCode;\n    }\n    static async _tryFindTarExecutablePathAsync() {\n        if (os.platform() === 'win32') {\n            // If we're running on Windows, first try to use the OOB tar executable. If\n            // we're running in the Git Bash, the tar executable on the PATH doesn't handle\n            // Windows file paths correctly.\n            // eslint-disable-next-line dot-notation\n            const windowsFolderPath = process.env['WINDIR'];\n            if (windowsFolderPath) {\n                const defaultWindowsTarExecutablePath = `${windowsFolderPath}\\\\system32\\\\tar.exe`;\n                if (await FileSystem.existsAsync(defaultWindowsTarExecutablePath)) {\n                    return defaultWindowsTarExecutablePath;\n                }\n            }\n        }\n        return Executable.tryResolve('tar');\n    }\n}\n//# sourceMappingURL=TarExecutable.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as child_process from 'child_process';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { performance } from 'perf_hooks';\nimport { JsonFile, FileSystem, FileConstants } from '@rushstack/node-core-library';\nimport { syncNpmrc } from './npmrcUtilities';\nimport { PassThrough } from 'stream';\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const UNINITIALIZED = 'UNINITIALIZED';\nclass Utilities {\n    /**\n     * Get the user's home directory. On windows this looks something like \"C:\\users\\username\\\" and on UNIX\n     * this looks something like \"/home/username/\"\n     */\n    static getHomeFolder() {\n        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];\n        const dirError = \"Unable to determine the current user's home directory\";\n        if (unresolvedUserFolder === undefined) {\n            throw new Error(dirError);\n        }\n        const homeFolder = path.resolve(unresolvedUserFolder);\n        if (!FileSystem.exists(homeFolder)) {\n            throw new Error(dirError);\n        }\n        return homeFolder;\n    }\n    /**\n     * Node.js equivalent of performance.now().\n     */\n    static getTimeInMs() {\n        return performance.now();\n    }\n    /**\n     * Retries a function until a timeout is reached. The function is expected to throw if it failed and\n     *  should be retried.\n     */\n    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {\n        const startTime = Utilities.getTimeInMs();\n        let looped = false;\n        let result;\n        for (;;) {\n            try {\n                result = fn();\n                break;\n            }\n            catch (e) {\n                looped = true;\n                const currentTime = Utilities.getTimeInMs();\n                if (currentTime - startTime > maxWaitTimeMs) {\n                    throw getTimeoutError(e);\n                }\n            }\n        }\n        if (looped) {\n            const currentTime = Utilities.getTimeInMs();\n            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);\n            // This logging statement isn't meaningful to the end-user. `fnName` should be updated\n            // to something like `operationDescription`\n            // eslint-disable-next-line no-console\n            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);\n        }\n        return result;\n    }\n    /**\n     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a\n     * retry loop to recover from temporary locks that may be held by other processes.\n     * If the folder already exists, no error occurs.\n     */\n    static createFolderWithRetry(folderName) {\n        // Note: If a file exists with the same name, then we fall through and report\n        // an error.\n        if (Utilities.directoryExists(folderName)) {\n            return;\n        }\n        // We need to do a simple \"FileSystem.ensureFolder(localModulesFolder)\" here,\n        // however if the folder we deleted above happened to contain any files,\n        // then there seems to be some OS process (virus scanner?) that holds\n        // a lock on the folder for a split second, which causes mkdirSync to\n        // fail.  To workaround that, retry for up to 7 seconds before giving up.\n        const maxWaitTimeMs = 7 * 1000;\n        return Utilities.retryUntilTimeout(() => FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}\\nOften this is caused by a file lock ` +\n            'from a process such as your text editor, command prompt, ' +\n            'or a filesystem watcher.'), 'createFolderWithRetry');\n    }\n    /**\n     * Determines if a path points to a directory and that it exists.\n     */\n    static directoryExists(directoryPath) {\n        let exists = false;\n        try {\n            const lstat = FileSystem.getLinkStatistics(directoryPath);\n            exists = lstat.isDirectory();\n        }\n        catch (e) {\n            /* no-op */\n        }\n        return exists;\n    }\n    /**\n     * BE VERY CAREFUL CALLING THIS FUNCTION!\n     * If you specify the wrong folderPath (e.g. \"/\"), it could potentially delete your entire\n     * hard disk.\n     */\n    static dangerouslyDeletePath(folderPath) {\n        try {\n            FileSystem.deleteFolder(folderPath);\n        }\n        catch (e) {\n            throw new Error(`${e.message}\\nOften this is caused by a file lock from a process ` +\n                'such as your text editor, command prompt, or a filesystem watcher');\n        }\n    }\n    /*\n     * Returns true if dateToCompare is more recent than all of the inputFilenames, which\n     * would imply that we don't need to rebuild it. Returns false if any of the files\n     * does not exist.\n     * NOTE: The filenames can also be paths for directories, in which case the directory\n     * timestamp is compared.\n     */\n    static isFileTimestampCurrent(dateToCompare, inputFilenames) {\n        for (const inputFilename of inputFilenames) {\n            if (!FileSystem.exists(inputFilename)) {\n                return false;\n            }\n            const inputStats = FileSystem.getStatistics(inputFilename);\n            if (dateToCompare < inputStats.mtime) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static executeCommand(options) {\n        Utilities._executeCommandInternal(options.command, options.args, options.workingDirectory, options.suppressOutput ? undefined : [0, 1, 2], options.environment, options.keepEnvironment);\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     *\n     * It's basically the same as executeCommand() except that it returns a Promise.\n     */\n    static async executeCommandAndInspectOutputAsync(options, onStdoutStreamChunk) {\n        await Utilities._executeCommandAndInspectOutputInternalAsync(options.command, options.args, options.workingDirectory, options.suppressOutput ? undefined : onStdoutStreamChunk ? ['inherit', 'pipe', 'inherit'] : [0, 1, 2], options.environment, options.keepEnvironment, onStdoutStreamChunk);\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static executeCommandAndCaptureOutput(command, args, workingDirectory, environment, keepEnvironment = false) {\n        const result = Utilities._executeCommandInternal(command, args, workingDirectory, ['pipe', 'pipe', 'pipe'], environment, keepEnvironment);\n        return result.stdout.toString();\n    }\n    /**\n     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.\n     */\n    static executeCommandWithRetry(options, maxAttempts, retryCallback) {\n        if (maxAttempts < 1) {\n            throw new Error('The maxAttempts parameter cannot be less than 1');\n        }\n        let attemptNumber = 1;\n        for (;;) {\n            try {\n                Utilities.executeCommand(options);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log('\\nThe command failed:');\n                // eslint-disable-next-line no-console\n                console.log(` ${options.command} ` + options.args.join(' '));\n                // eslint-disable-next-line no-console\n                console.log(`ERROR: ${error.toString()}`);\n                if (attemptNumber < maxAttempts) {\n                    ++attemptNumber;\n                    // eslint-disable-next-line no-console\n                    console.log(`Trying again (attempt #${attemptNumber})...\\n`);\n                    if (retryCallback) {\n                        retryCallback();\n                    }\n                    continue;\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.error(`Giving up after ${attemptNumber} attempts\\n`);\n                    throw error;\n                }\n            }\n            break;\n        }\n    }\n    /**\n     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.\n     * Using `onStdoutStreamChunk` to process the output of the command.\n     *\n     * Note: This is similar to {@link executeCommandWithRetry} except that it returns a Promise and provides a callback to process the output.\n     */\n    static async executeCommandAndProcessOutputWithRetryAsync(options, maxAttempts, onStdoutStreamChunk, retryCallback) {\n        if (maxAttempts < 1) {\n            throw new Error('The maxAttempts parameter cannot be less than 1');\n        }\n        let attemptNumber = 1;\n        for (;;) {\n            try {\n                await Utilities.executeCommandAndInspectOutputAsync(options, onStdoutStreamChunk);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log('\\nThe command failed:');\n                // eslint-disable-next-line no-console\n                console.log(` ${options.command} ` + options.args.join(' '));\n                // eslint-disable-next-line no-console\n                console.log(`ERROR: ${error.toString()}`);\n                if (attemptNumber < maxAttempts) {\n                    ++attemptNumber;\n                    // eslint-disable-next-line no-console\n                    console.log(`Trying again (attempt #${attemptNumber})...\\n`);\n                    if (retryCallback) {\n                        retryCallback();\n                    }\n                    continue;\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.error(`Giving up after ${attemptNumber} attempts\\n`);\n                    throw error;\n                }\n            }\n            break;\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommand(command, options) {\n        const result = Utilities._executeLifecycleCommandInternal(command, child_process.spawnSync, options);\n        if (options.handleOutput) {\n            Utilities._processResult(result);\n        }\n        if (result.status !== null) {\n            return result.status;\n        }\n        else {\n            throw result.error || new Error('An unknown error occurred.');\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommandAsync(command, options) {\n        return Utilities._executeLifecycleCommandInternal(command, child_process.spawn, options);\n    }\n    /**\n     * For strings passed to a shell command, this adds appropriate escaping\n     * to avoid misinterpretation of spaces or special characters.\n     *\n     * Example: 'hello there' --> '\"hello there\"'\n     */\n    static escapeShellParameter(parameter) {\n        // This approach is based on what NPM 7 now does:\n        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34\n        return JSON.stringify(parameter);\n    }\n    /**\n     * Installs a package by name and version in the specified directory.\n     */\n    static installPackageInDirectory(options) {\n        const directory = path.resolve(options.directory);\n        if (FileSystem.exists(directory)) {\n            // eslint-disable-next-line no-console\n            console.log('Deleting old files from ' + directory);\n        }\n        FileSystem.ensureEmptyFolder(directory);\n        const npmPackageJson = {\n            dependencies: {\n                [options.packageName]: options.version\n            },\n            description: 'Temporary file generated by the Rush tool',\n            name: options.tempPackageTitle,\n            private: true,\n            version: '0.0.0'\n        };\n        JsonFile.save(npmPackageJson, path.join(directory, FileConstants.PackageJson));\n        if (options.commonRushConfigFolder) {\n            Utilities.syncNpmrc(options.commonRushConfigFolder, directory);\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\nRunning \"npm install\" in ' + directory);\n        // NOTE: Here we use whatever version of NPM we happen to find in the PATH\n        Utilities.executeCommandWithRetry({\n            command: 'npm',\n            args: ['install'],\n            workingDirectory: directory,\n            environment: Utilities._createEnvironmentForRushCommand({}),\n            suppressOutput: options.suppressOutput\n        }, options.maxInstallAttempts);\n    }\n    /**\n     * Copies the file \"sourcePath\" to \"destinationPath\", overwriting the target file location.\n     * If the source file does not exist, then the target file is deleted.\n     */\n    static syncFile(sourcePath, destinationPath) {\n        if (FileSystem.exists(sourcePath)) {\n            // eslint-disable-next-line no-console\n            console.log(`Copying \"${sourcePath}\"`);\n            // eslint-disable-next-line no-console\n            console.log(`  --> \"${destinationPath}\"`);\n            FileSystem.copyFile({ sourcePath, destinationPath });\n        }\n        else {\n            if (FileSystem.exists(destinationPath)) {\n                // If the source file doesn't exist and there is one in the target, delete the one in the target\n                // eslint-disable-next-line no-console\n                console.log(`Deleting ${destinationPath}`);\n                FileSystem.deleteFile(destinationPath);\n            }\n        }\n    }\n    static getRushConfigNotFoundError() {\n        return new Error('Unable to find rush.json configuration file');\n    }\n    static async usingAsync(getDisposableAsync, doActionAsync) {\n        let disposable;\n        try {\n            disposable = (await getDisposableAsync());\n            await doActionAsync(disposable);\n        }\n        finally {\n            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n        }\n    }\n    static _executeLifecycleCommandInternal(command, spawnFunction, options) {\n        var _a;\n        let shellCommand = process.env.comspec || 'cmd';\n        let commandFlags = '/d /s /c';\n        let useShell = true;\n        if (process.platform !== 'win32') {\n            shellCommand = 'sh';\n            commandFlags = '-c';\n            useShell = false;\n        }\n        const environment = Utilities._createEnvironmentForRushCommand({\n            initCwd: options.initCwd,\n            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { rushJsonFolder: (_a = options.rushConfiguration) === null || _a === void 0 ? void 0 : _a.rushJsonFolder, projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })\n        });\n        return spawnFunction(shellCommand, [commandFlags, command], {\n            cwd: options.workingDirectory,\n            shell: useShell,\n            env: environment,\n            stdio: options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2]\n        });\n    }\n    /**\n     * Returns a process.env environment suitable for executing lifecycle scripts.\n     * @param initialEnvironment - an existing environment to copy instead of process.env\n     *\n     * @remarks\n     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally\n     * via the parent process's environment.\n     */\n    static _createEnvironmentForRushCommand(options) {\n        var _a;\n        if (options.initialEnvironment === undefined) {\n            options.initialEnvironment = process.env;\n        }\n        // Set some defaults for the environment\n        const environment = {};\n        if ((_a = options.pathOptions) === null || _a === void 0 ? void 0 : _a.rushJsonFolder) {\n            environment.RUSHSTACK_FILE_ERROR_BASE_FOLDER = options.pathOptions.rushJsonFolder;\n        }\n        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {\n            const normalizedKey = os.platform() === 'win32' ? key.toUpperCase() : key;\n            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere\n            // with Rush's installations.  If we actually want it, we will set it explicitly below.\n            if (normalizedKey === 'INIT_CWD') {\n                continue;\n            }\n            // When NPM invokes a lifecycle event, it copies its entire configuration into environment\n            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring\n            // this along.\n            //\n            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring\n            // back specific environment variables that the repo maintainer has determined to be safe.\n            if (normalizedKey.match(/^NPM_CONFIG_/)) {\n                continue;\n            }\n            // Use the uppercased environment variable name on Windows because environment variable names\n            // are case-insensitive on Windows\n            environment[normalizedKey] = options.initialEnvironment[key];\n        }\n        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers\n        // the directory that NPM started in.  This allows naive scripts to change their current working directory\n        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends\n        // for toolchain scripts to be professionally written (versus brittle stuff like\n        // \"cd ./lib && npm run tsc && cd ..\"), we support INIT_CWD for compatibility.\n        //\n        // More about this feature: https://github.com/npm/npm/pull/12356\n        if (options.initCwd) {\n            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation\n        }\n        if (options.pathOptions) {\n            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);\n            }\n            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);\n            }\n            if (options.pathOptions.additionalPathFolders) {\n                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(path.delimiter);\n            }\n        }\n        return environment;\n    }\n    /**\n     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,\n     * if `rootDirectory` is \"/foobar\" and `existingPath` is \"/bin\", this function will return\n     * \"/foobar/node_modules/.bin:/bin\"\n     */\n    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {\n        const binPath = path.resolve(rootDirectory, 'node_modules', '.bin');\n        if (existingPath) {\n            return `${binPath}${path.delimiter}${existingPath}`;\n        }\n        else {\n            return binPath;\n        }\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     *\n     * It's the same as _executeCommandInternal except that it returns a promise.\n     */\n    static async _executeCommandAndInspectOutputInternalAsync(command, args, workingDirectory, stdio, environment, keepEnvironment = false, onStdoutStreamChunk) {\n        return new Promise((resolve, reject) => {\n            var _a;\n            const options = {\n                cwd: workingDirectory,\n                shell: true,\n                stdio: stdio,\n                env: keepEnvironment\n                    ? environment\n                    : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment })\n            };\n            // Only escape the command if it actually contains spaces:\n            const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);\n            const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));\n            const childProcess = child_process.spawn(escapedCommand, escapedArgs, options);\n            const inspectStream = new PassThrough();\n            inspectStream.on('data', (chunk) => {\n                const strData = chunk.toString();\n                onStdoutStreamChunk === null || onStdoutStreamChunk === void 0 ? void 0 : onStdoutStreamChunk(strData);\n            });\n            childProcess.on('close', (code, signal) => {\n                // TODO: Is it possible that the childProcess is closed before the receiving the last chunks?\n                if (code === 0) {\n                    resolve();\n                }\n                else {\n                    // mimic the current sync version \"_executeCommandInternal\" behavior.\n                    reject(new Error(`The command failed with exit code ${code}`));\n                }\n            });\n            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(inspectStream).pipe(process.stdout);\n        });\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static _executeCommandInternal(command, args, workingDirectory, stdio, environment, keepEnvironment = false) {\n        const options = {\n            cwd: workingDirectory,\n            shell: true,\n            stdio: stdio,\n            env: keepEnvironment\n                ? environment\n                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment }),\n            maxBuffer: 10 * 1024 * 1024 // Set default max buffer size to 10MB\n        };\n        // This is needed since we specify shell=true below.\n        // NOTE: On Windows if we escape \"NPM\", the spawnSync() function runs something like this:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"\"NPM\" \"install\"\"' ]\n        //\n        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's \"%~dp0\" variable will\n        // return the current working directory instead of the batch file's directory.\n        // The workaround is to not escape, npm, i.e. do this instead:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"npm \"install\"\"' ]\n        //\n        // We will come up with a better solution for this when we promote executeCommand()\n        // into node-core-library, but for now this hack will unblock people:\n        // Only escape the command if it actually contains spaces:\n        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);\n        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));\n        let result = child_process.spawnSync(escapedCommand, escapedArgs, options);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (result.error && result.error.errno === 'ENOENT') {\n            // This is a workaround for GitHub issue #25330\n            // https://github.com/nodejs/node-v0.x-archive/issues/25330\n            //\n            // TODO: The fully worked out solution for this problem is now provided by the \"Executable\" API\n            // from @rushstack/node-core-library\n            result = child_process.spawnSync(command + '.cmd', args, options);\n        }\n        Utilities._processResult(result);\n        return result;\n    }\n    static _processResult(result) {\n        if (result.error) {\n            result.error.message += '\\n' + (result.stderr ? result.stderr.toString() + '\\n' : '');\n            throw result.error;\n        }\n        if (result.status) {\n            throw new Error('The command failed with exit code ' +\n                result.status +\n                '\\n' +\n                (result.stderr ? result.stderr.toString() : ''));\n        }\n    }\n}\nUtilities.syncNpmrc = syncNpmrc;\nexport { Utilities };\n//# sourceMappingURL=Utilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as process from 'process';\nimport * as fetch from 'node-fetch';\nimport { Import } from '@rushstack/node-core-library';\n// ===================================================================================================================\n// AS A TEMPORARY WORKAROUND, THIS FILE WAS COPY+PASTED INTO THE \"rush-amazon-s3-build-cache-plugin\" PROJECT.\n// See that copy for notes.\n// ===================================================================================================================\nconst createHttpsProxyAgent = Import.lazy('https-proxy-agent', require);\n/**\n * For use with {@link WebClient}.\n */\nexport var WebClientProxy;\n(function (WebClientProxy) {\n    WebClientProxy[WebClientProxy[\"None\"] = 0] = \"None\";\n    WebClientProxy[WebClientProxy[\"Detect\"] = 1] = \"Detect\";\n    WebClientProxy[WebClientProxy[\"Fiddler\"] = 2] = \"Fiddler\";\n})(WebClientProxy || (WebClientProxy = {}));\n/**\n * A helper for issuing HTTP requests.\n */\nexport class WebClient {\n    constructor() {\n        this.standardHeaders = new fetch.Headers();\n        this.accept = '*/*';\n        this.userAgent = `rush node/${process.version} ${os.platform()} ${os.arch()}`;\n        this.proxy = WebClientProxy.Detect;\n    }\n    static mergeHeaders(target, source) {\n        source.forEach((value, name) => {\n            target.set(name, value);\n        });\n    }\n    addBasicAuthHeader(userName, password) {\n        this.standardHeaders.set('Authorization', 'Basic ' + Buffer.from(userName + ':' + password).toString('base64'));\n    }\n    async fetchAsync(url, options) {\n        const headers = new fetch.Headers();\n        WebClient.mergeHeaders(headers, this.standardHeaders);\n        if (options === null || options === void 0 ? void 0 : options.headers) {\n            WebClient.mergeHeaders(headers, options.headers);\n        }\n        if (this.userAgent) {\n            headers.set('user-agent', this.userAgent);\n        }\n        if (this.accept) {\n            headers.set('accept', this.accept);\n        }\n        let proxyUrl = '';\n        switch (this.proxy) {\n            case WebClientProxy.Detect:\n                if (process.env.HTTPS_PROXY) {\n                    proxyUrl = process.env.HTTPS_PROXY;\n                }\n                else if (process.env.HTTP_PROXY) {\n                    proxyUrl = process.env.HTTP_PROXY;\n                }\n                break;\n            case WebClientProxy.Fiddler:\n                // For debugging, disable cert validation\n                // eslint-disable-next-line\n                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';\n                proxyUrl = 'http://localhost:8888/';\n                break;\n        }\n        let agent = undefined;\n        if (proxyUrl) {\n            agent = createHttpsProxyAgent(proxyUrl);\n        }\n        const timeoutMs = (options === null || options === void 0 ? void 0 : options.timeoutMs) !== undefined ? options.timeoutMs : 15 * 1000; // 15 seconds\n        const requestInit = {\n            method: options === null || options === void 0 ? void 0 : options.verb,\n            headers: headers,\n            agent: agent,\n            timeout: timeoutMs\n        };\n        const putOptions = options;\n        if (putOptions === null || putOptions === void 0 ? void 0 : putOptions.body) {\n            requestInit.body = putOptions.body;\n        }\n        return await fetch.default(url, requestInit);\n    }\n}\n//# sourceMappingURL=WebClient.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// IMPORTANT - do not use any non-built-in libraries in this file\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * This function reads the content for given .npmrc file path, and also trims\n * unusable lines from the .npmrc file.\n *\n * @returns\n * The text of the the .npmrc.\n */\n// create a global _combinedNpmrc for cache purpose\nconst _combinedNpmrcMap = new Map();\nfunction _trimNpmrcFile(sourceNpmrcPath) {\n    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);\n    if (combinedNpmrcFromCache !== undefined) {\n        return combinedNpmrcFromCache;\n    }\n    let npmrcFileLines = fs.readFileSync(sourceNpmrcPath).toString().split('\\n');\n    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());\n    const resultLines = [];\n    // This finds environment variable tokens that look like \"${VAR_NAME}\"\n    const expansionRegExp = /\\$\\{([^\\}]+)\\}/g;\n    // Comment lines start with \"#\" or \";\"\n    const commentRegExp = /^\\s*[#;]/;\n    // Trim out lines that reference environment variables that aren't defined\n    for (let line of npmrcFileLines) {\n        let lineShouldBeTrimmed = false;\n        //remove spaces before or after key and value\n        line = line\n            .split('=')\n            .map((lineToTrim) => lineToTrim.trim())\n            .join('=');\n        // Ignore comment lines\n        if (!commentRegExp.test(line)) {\n            const environmentVariables = line.match(expansionRegExp);\n            if (environmentVariables) {\n                for (const token of environmentVariables) {\n                    // Remove the leading \"${\" and the trailing \"}\" from the token\n                    const environmentVariableName = token.substring(2, token.length - 1);\n                    // Is the environment variable defined?\n                    if (!process.env[environmentVariableName]) {\n                        // No, so trim this line\n                        lineShouldBeTrimmed = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (lineShouldBeTrimmed) {\n            // Example output:\n            // \"; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}\"\n            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);\n        }\n        else {\n            resultLines.push(line);\n        }\n    }\n    const combinedNpmrc = resultLines.join('\\n');\n    //save the cache\n    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n * As a workaround, copyAndTrimNpmrcFile() copies the .npmrc file to the target folder, and also trims\n * unusable lines from the .npmrc file.\n *\n * Why are we trimming the .npmrc lines?  NPM allows environment variables to be specified in\n * the .npmrc file to provide different authentication tokens for different registry.\n * However, if the environment variable is undefined, it expands to an empty string, which\n * produces a valid-looking mapping with an invalid URL that causes an error.  Instead,\n * we'd prefer to skip that line and continue looking in other places such as the user's\n * home directory.\n *\n * @returns\n * The text of the the .npmrc with lines containing undefined variables commented out.\n */\nfunction _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath) {\n    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose\n    logger.info(`  --> \"${targetNpmrcPath}\"`);\n    const combinedNpmrc = _trimNpmrcFile(sourceNpmrcPath);\n    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n * syncNpmrc() copies the .npmrc file to the target folder, and also trims unusable lines from the .npmrc file.\n * If the source .npmrc file not exist, then syncNpmrc() will delete an .npmrc that is found in the target folder.\n *\n * IMPORTANT: THIS CODE SHOULD BE KEPT UP TO DATE WITH Utilities._syncNpmrc()\n *\n * @returns\n * The text of the the synced .npmrc, if one exists. If one does not exist, then undefined is returned.\n */\nexport function syncNpmrc(sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {\n    // eslint-disable-next-line no-console\n    info: console.log,\n    // eslint-disable-next-line no-console\n    error: console.error\n}) {\n    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');\n    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');\n    try {\n        if (fs.existsSync(sourceNpmrcPath)) {\n            return _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath);\n        }\n        else if (fs.existsSync(targetNpmrcPath)) {\n            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target\n            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose\n            fs.unlinkSync(targetNpmrcPath);\n        }\n    }\n    catch (e) {\n        throw new Error(`Error syncing .npmrc file: ${e}`);\n    }\n}\nexport function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey) {\n    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;\n    //if .npmrc file does not exist, return false directly\n    if (!fs.existsSync(sourceNpmrcPath)) {\n        return false;\n    }\n    const trimmedNpmrcFile = _trimNpmrcFile(sourceNpmrcPath);\n    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');\n    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;\n}\n//# sourceMappingURL=npmrcUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Determines if two objects are deeply equal.\n */\nexport function objectsAreDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const aType = typeof a;\n        const bType = typeof b;\n        if (aType !== bType) {\n            return false;\n        }\n        else {\n            if (aType === 'object') {\n                if (a === null || b === null) {\n                    // We already handled the case where a === b, so if either is null, they are not equal\n                    return false;\n                }\n                else if (Array.isArray(a)) {\n                    if (!Array.isArray(b) || a.length !== b.length) {\n                        return false;\n                    }\n                    else {\n                        for (let i = 0; i < a.length; ++i) {\n                            if (!objectsAreDeepEqual(a[i], b[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n                else {\n                    const aObjectProperties = new Set(Object.getOwnPropertyNames(a));\n                    const bObjectProperties = new Set(Object.getOwnPropertyNames(b));\n                    if (aObjectProperties.size !== bObjectProperties.size) {\n                        return false;\n                    }\n                    else {\n                        for (const property of aObjectProperties) {\n                            if (bObjectProperties.delete(property)) {\n                                if (!objectsAreDeepEqual(a[property], b[property])) {\n                                    return false;\n                                }\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n                        return bObjectProperties.size === 0;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n        }\n    }\n}\nexport function cloneDeep(obj) {\n    return cloneDeepInner(obj, new Set());\n}\nexport function merge(base, other) {\n    if (typeof other === 'object' && other !== null && !Array.isArray(other)) {\n        for (const [key, value] of Object.entries(other)) {\n            if (key in base) {\n                const baseValue = base[key];\n                if (typeof baseValue === 'object' && baseValue !== null && !Array.isArray(baseValue)) {\n                    base[key] = merge(baseValue, value);\n                }\n                else {\n                    base[key] = value;\n                }\n            }\n            else {\n                base[key] = value;\n            }\n        }\n        return base;\n    }\n    else {\n        return other;\n    }\n}\nfunction cloneDeepInner(obj, seenObjects) {\n    if (seenObjects.has(obj)) {\n        throw new Error('Circular reference detected');\n    }\n    else if (typeof obj === 'object') {\n        if (obj === null) {\n            return null;\n        }\n        else {\n            seenObjects.add(obj);\n            if (Array.isArray(obj)) {\n                const result = [];\n                for (const item of obj) {\n                    result.push(cloneDeepInner(item, new Set(seenObjects)));\n                }\n                return result;\n            }\n            else {\n                const result = {};\n                for (const key of Object.getOwnPropertyNames(obj)) {\n                    const value = obj[key];\n                    result[key] = cloneDeepInner(value, new Set(seenObjects));\n                }\n                return result;\n            }\n        }\n    }\n    else {\n        return obj;\n    }\n}\n//# sourceMappingURL=objectUtilities.js.map"],"names":[],"sourceRoot":""}