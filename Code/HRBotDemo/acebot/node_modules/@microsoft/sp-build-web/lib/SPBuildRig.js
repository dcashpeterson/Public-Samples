"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPBuildRig = exports.postCopy = exports.preCopy = void 0;
const yargs = __importStar(require("yargs"));
const semver = __importStar(require("semver"));
const true_case_path_1 = require("true-case-path");
const coreBuild = __importStar(require("@microsoft/gulp-core-build"));
const gulp_core_build_typescript_1 = require("@microsoft/gulp-core-build-typescript");
const BuildRigConstants_1 = require("./BuildRigConstants");
exports.preCopy = new coreBuild.CopyTask();
exports.postCopy = new coreBuild.CopyTask();
/**
 * This class represents the basic shared build rig for all SPFx Rigs. It defines a few
 * simple sub-tasks, and only registers a "build" task.
 */
class SPBuildRig {
    constructor() {
        this._preBuildTasks = [];
        this._postTypescriptTasks = [];
        this._postBuildTasks = [];
        this._postTelemetryTask = [];
        this._preTelemetryTask = [];
        this.nodeSupportedVersionRange = '>=12.13.0 <13.0.0 || >=14.15.0 <15.0.0 || >=16.13.0 <17.0.0 || >=18.17.1 <19.0.0';
    }
    initialize(gulp) {
        if (!semver.satisfies(process.version, this.nodeSupportedVersionRange)) {
            throw new Error(`Your dev environment is running NodeJS version ${process.version} which does` +
                ' not meet the requirements for running this tool. This tool requires a version of NodeJS' +
                ` that matches ${this.nodeSupportedVersionRange}`);
        }
        // Initialize yargs & figure out which command we are running
        const yargsArgs = this.getYargs();
        const command = yargsArgs.argv._[0];
        this.args = yargsArgs.argv;
        // Collect the tasks which need to be registered
        const tasks = this.getTasks();
        // Reset the args and reconfigure based on the selected command
        yargsArgs.reset();
        if (tasks.has(command)) {
            const task = tasks.get(command);
            if (task && task.arguments) {
                task.arguments(yargsArgs);
            }
        }
        // Note this overrides the getters for ship and production on args
        this.args.ship = this.args.production = this.args.production || this.args.ship;
        // Since gulp-core-build doesn't recognize the --ship flag, ensure it gets the right state
        coreBuild.mergeConfig({
            production: this.args.ship,
            shouldWarningsFailBuild: this.args.ship
        });
        // Register all the tasks with gulp-core-build
        tasks.forEach((definition, name) => {
            coreBuild.task(name, definition.executable);
        });
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            // Configure tasks for a normal build
            // eslint-disable-next-line no-console
            console.log('Build target: ' +
                (this.args.ship
                    ? BuildRigConstants_1.BuildRigConstants.flavors.ship.toUpperCase()
                    : BuildRigConstants_1.BuildRigConstants.flavors.debug.toUpperCase()));
            this.setupSharedConfig();
        }
        coreBuild.initialize(gulp);
        // Try to ensure the casing of the rootPath is correct
        try {
            const originalRootPath = coreBuild.getConfig().rootPath;
            const normalizedRootPath = (0, true_case_path_1.trueCasePathSync)(originalRootPath);
            if (normalizedRootPath !== originalRootPath) {
                coreBuild.mergeConfig({
                    rootPath: normalizedRootPath
                });
                // eslint-disable-next-line no-console
                console.log(`Normalized project rootPath from "${originalRootPath}" to ${normalizedRootPath}`);
            }
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(`An error occurred when normalizing the project root path: ${e}`);
        }
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            this.finalizeSharedConfig();
        }
    }
    /**
     * Register additional telemetry sub-tasks to run at the end of the sequence
     */
    addPostTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTelemetryTask);
    }
    /**
     * Register additional telemetry sub-tasks to run at the beginning of the sequence
     */
    addPreTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preTelemetryTask);
    }
    /**
     * Register additional sub-tasks to run before the typescript subtask.
     * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
     */
    addPreBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preBuildTasks);
    }
    /**
     * Register additional sub-tasks to run after the typescript subtask.
     * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
     */
    addPostTypescriptTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
     * Register additional sub-tasks to run after the typescript subtask.
     * @deprecated - Use {@link addPostTypescriptTask} instead
     */
    addBuildTasks(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
     * Register additional sub-tasks to run after the entire build.
     * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
     */
    addPostBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postBuildTasks);
    }
    /**
     * Override this function to register more top-level command line arguments (i.e. not task-specific).
     * Ideally, extend the ICoreBuildArgs when hooking into this function
     *
     * Registers the command line arguments which are available for this rig
     */
    getYargs() {
        return yargs
            .usage()
            .option('production', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        })
            .option('ship', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        })
            .option('verbose', {
            describe: 'run the build with verbose logging'
        })
            .option('tasks', {
            alias: ['T', 'tasks-simple'],
            describe: 'shows the list of tasks which can be run'
        })
            .help('h')
            .global(['production', 'verbose', 'h'])
            .option('locale', {
            describe: 'override the default culture (e.g. "fr-fr")',
            type: 'string'
        })
            .option('lite', {
            alias: 'l',
            describe: 'Speeds up the build by running the minimal set of tasks required to produce an executable output',
            type: 'boolean'
        })
            .command(BuildRigConstants_1.BuildRigConstants.tasks.build, 'build the project')
            .command(BuildRigConstants_1.BuildRigConstants.tasks.default, 'equivalent to bundle');
    }
    /**
     * Override this function to create new top-level tasks which can be executed via the command line
     *
     * Register 2 tasks, build and default, which simply copy files, then run typescript and tslint
     */
    getTasks() {
        const result = new Map();
        result.set(BuildRigConstants_1.BuildRigConstants.tasks.build, { executable: this.getBuildTask() });
        result.set(BuildRigConstants_1.BuildRigConstants.tasks.default, { executable: this.getBuildTask() });
        return result;
    }
    /**
     * Override this function to overwrite the "build" task
     */
    getBuildTask() {
        return coreBuild.serial(exports.preCopy, coreBuild.serial(this._preBuildTasks), this.getCoreBuildTask(), coreBuild.serial(this._postBuildTasks), exports.postCopy);
    }
    /**
     * Override this function to redefine the core build loop
     */
    getCoreBuildTask() {
        return coreBuild.parallel(gulp_core_build_typescript_1.lintCmd, coreBuild.serial(coreBuild.serial(gulp_core_build_typescript_1.tscCmd, gulp_core_build_typescript_1.apiExtractor), coreBuild.serial(...this._postTypescriptTasks)));
    }
    /**
     * Override this function to do configuration before the configuration .json files have been loaded
     */
    setupSharedConfig() {
        exports.preCopy.name = 'pre-copy';
        exports.postCopy.name = 'post-copy';
        // adding release folder to the list of folders to be removed during the clean task run
        coreBuild.clean.getCleanMatch = () => ['release'];
    }
    /**
     * Override this function to do configuration after the configuration .json files have been loaded
     *
     * This function cleans up the shared config by populating task config properties that depend on other tasks'
     *  user-defined properties.
     */
    finalizeSharedConfig() {
        if (this.args.lite) {
            this._disableTasks(gulp_core_build_typescript_1.lintCmd);
        }
    }
    addTaskOrListOfTasks(tasks, array) {
        if (tasks.length) {
            array.push(...tasks);
        }
        else {
            array.push(tasks);
        }
    }
    _disableTasks(...tasks) {
        tasks.forEach((task) => {
            task.isEnabled = () => false;
            coreBuild.verbose(`Disabling task: ${task.name}`);
        });
    }
}
exports.SPBuildRig = SPBuildRig;
//# sourceMappingURL=SPBuildRig.js.map