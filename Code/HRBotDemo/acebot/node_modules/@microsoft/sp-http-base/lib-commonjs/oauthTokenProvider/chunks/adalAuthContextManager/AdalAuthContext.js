"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var AadConstants_1 = tslib_1.__importDefault(require("../../AadConstants"));
var AadErrorHandler_1 = require("../../AadErrorHandler");
/**
 * Class that's extends on the Error class and adds an extra member variable
 * @internal
 */
var DetailedError = /** @class */ (function (_super) {
    tslib_1.__extends(DetailedError, _super);
    function DetailedError(errorMessage, errorCode) {
        var _this = _super.call(this, errorMessage) || this;
        _this._errorCode = errorCode;
        return _this;
    }
    Object.defineProperty(DetailedError.prototype, "errorCode", {
        get: function () {
            return this._errorCode;
        },
        enumerable: false,
        configurable: true
    });
    return DetailedError;
}(Error));
/**
 * Class that wraps the ADAL's authentication class
 * @internal
 */
var AdalAuthContext = /** @class */ (function () {
    function AdalAuthContext(authContext, aadUserId) {
        this.clientId = authContext.config.clientId;
        this._aadUserId = aadUserId || '';
        this._patchAdalAuthContext(authContext);
        this._authContext = authContext;
        this._extraQueryParameter = authContext.config.extraQueryParameter;
    }
    AdalAuthContext.prototype.getToken = function (resourceEndpoint, optionsOrUseCachedToken) {
        var _this = this;
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? optionsOrUseCachedToken
            : {
                useCachedToken: optionsOrUseCachedToken
            };
        var _a = options.useCachedToken, useCachedToken = _a === void 0 ? true : _a;
        var acquireAccessTokenQosMonitor = new sp_diagnostics_1._QosMonitor('AdalTokenProvider.GetToken');
        var extraData = {
            alias: 'false',
            CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
            isInternal: this.clientId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID
        };
        return this._getAccessToken(resourceEndpoint, useCachedToken, extraData)
            .then(function (token) {
            if (extraData.isInternal) {
                extraData.name = resourceEndpoint;
            }
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return token;
        })
            .catch(function (e) {
            AadErrorHandler_1.AadErrorHandler._handleInteractionRequiredFailures(_this._authContext, e.message, resourceEndpoint);
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, e, resourceEndpoint, extraData);
            // Expected errors will log and throw an exception from the previous function
            acquireAccessTokenQosMonitor.writeUnexpectedFailure(e.errorCode, e, extraData);
            throw e;
        });
    };
    AdalAuthContext.prototype._getAccessToken = function (resourceEndpoint, useCachedToken, extraData) {
        var cachedAccessToken = this._tryGetCachedAccessToken(resourceEndpoint);
        if (useCachedToken && cachedAccessToken) {
            // No network request was made.
            extraData.CorrelationId = sp_core_library_1.Guid.empty.toString();
            extraData.alias = 'true';
            return Promise.resolve(cachedAccessToken);
        }
        else {
            return this._fetchAccessToken(resourceEndpoint, extraData);
        }
    };
    /**
     * Returns an access token if a valid cached token exists
     */
    AdalAuthContext.prototype._tryGetCachedAccessToken = function (resourceEndpoint) {
        var cachedToken;
        try {
            cachedToken = this._authContext.getCachedToken(resourceEndpoint);
            var jwtToken = this._authContext._extractIdToken(cachedToken);
            if (jwtToken.oid !== this._aadUserId || jwtToken.appid !== this.clientId) {
                cachedToken = undefined;
            }
        }
        catch (e) {
            // Empty block
        }
        return cachedToken;
    };
    AdalAuthContext.prototype._fetchAccessToken = function (resourceEndpoint, extraData) {
        var _this = this;
        var acquireAccessTokenQosMonitor = new sp_diagnostics_1._QosMonitor('AdalTokenProvider.AcquireAccessTokenSilent');
        this._authContext.config.correlationId = extraData.CorrelationId;
        this._authContext.config.extraQueryParameter = this._extraQueryParameter;
        // Attempt to fetch a new access token
        return this._fetchAccessTokenSilent(resourceEndpoint)
            .catch(function (firstError) {
            // The login hint can cause failures. ESTS does not support parsing of error codes.
            _this._authContext.config.extraQueryParameter = undefined;
        })
            .then(function (token) {
            if (token) {
                return token;
            }
            // Use a new correlation id for retry
            var correlationId = sp_core_library_1.Guid.newGuid().toString();
            _this._authContext.config.correlationId = correlationId;
            extraData.CorrelationId = correlationId;
            return _this._fetchAccessTokenSilent(resourceEndpoint);
        })
            .catch(function (secondError) {
            _this._authContext.config.extraQueryParameter = _this._extraQueryParameter;
            _this._monitorAndThrowForAccessTokenExpectedFailures(acquireAccessTokenQosMonitor, secondError, resourceEndpoint, extraData);
            if (secondError.message.indexOf('Token renewal operation failed due to timeout') > -1) {
                secondError.message =
                    secondError.message +
                        ' - AADCorrelationId: ' +
                        extraData.CorrelationId +
                        ' - ClientId: ' +
                        _this.clientId;
            }
            acquireAccessTokenQosMonitor.writeUnexpectedFailure(secondError.errorCode, secondError, extraData);
            throw secondError;
        })
            .then(function (token) {
            _this._authContext.config.extraQueryParameter = _this._extraQueryParameter;
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return token;
        });
    };
    /**
     * Throws an exception if an expected error has occurred. List of expected errors are listed in AadConstants.ts
     */
    AdalAuthContext.prototype._monitorAndThrowForAccessTokenExpectedFailures = function (acquireAccessTokenQosMonitor, aadError, resourceEndpoint, correlationObject) {
        if (AadErrorHandler_1.AadErrorHandler._doesAadErrorCodeExist(aadError.message, AadConstants_1.default.EXPECTED_AAD_ERRORS)) {
            acquireAccessTokenQosMonitor.writeExpectedFailure(aadError.errorCode, aadError, correlationObject);
            throw aadError;
        }
    };
    /**
     * Wraps the ADAL.js callback code with a promise.
     */
    AdalAuthContext.prototype._fetchAccessTokenSilent = function (resourceEndpoint) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._authContext.acquireToken(resourceEndpoint, function (errorDescription, token, errorType) {
                if (!token) {
                    reject(new DetailedError('Error - Type : ' + errorType + ' - Description : ' + errorDescription, errorType));
                }
                else {
                    resolve(token);
                }
            });
        });
    };
    /**
     * Patching ADAL context to address design issues.
     */
    AdalAuthContext.prototype._patchAdalAuthContext = function (authContext) {
        var _this = this;
        // AuthContext object has a weird mechanism that forces the object to be a singleton
        // We're fixing this so that we can have multiple authContext objects
        Object.getPrototypeOf(authContext)._singletonInstance = undefined;
        // Patching ADAL's iframe to include sandbox mode
        authContext._addAdalFrame = function (iframeId) {
            return _this._addAdalFrame(authContext, iframeId);
        };
        // Patching ADAL's iframe rendering logic to avoid setTimeout.
        authContext._loadFrame = function (urlNavigate, frameName) {
            return _this._loadFrame(authContext, urlNavigate, frameName);
        };
        // Patching ADAL's to avoid fetching id token before access token
        authContext._user = {};
        // This is required for the MFA scenario. SPFxSingleSignOn.aspx reads this value redirects to the original page.
        authContext._saveItem(authContext.CONSTANTS.STORAGE.LOGIN_REQUEST, window.location.href);
    };
    /**
     * Adds the hidden iframe for silent token renewal. This code is a security fix to ADAL.js's iframe
     * rendering code. IE11 doesn't support dynamically setting attributes on an iFrame element, so
     * we must patch the original implementation. Original code is in ADAL.js addAdalFrame.
     * https://github.com/AzureAD/azure-activedirectory-library-for-js/ for source code
     */
    AdalAuthContext.prototype._addAdalFrame = function (authContext, iframeId) {
        if (typeof iframeId === 'undefined') {
            return;
        }
        authContext.info('Add adal frame to document:' + iframeId);
        var adalFrame = document.getElementById(iframeId);
        var sandboxAttributes = 'allow-same-origin allow-scripts allow-forms allow-pointer-lock';
        if (!adalFrame) {
            if (document.createElement && // Check if document.createElement exists
                document.documentElement &&
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {
                var ifr = document.createElement('iframe');
                ifr.setAttribute('id', iframeId);
                ifr.setAttribute('aria-hidden', 'true');
                ifr.setAttribute('sandbox', sandboxAttributes);
                ifr.style.visibility = 'hidden';
                ifr.style.position = 'absolute';
                ifr.style.width = ifr.style.height = ifr.style.border = '0';
                adalFrame = document.getElementsByTagName('body')[0].appendChild(ifr);
            }
            else if (document.body && document.body.insertAdjacentHTML) {
                document.body.insertAdjacentHTML('beforeEnd', '<iframe sandbox="' +
                    sandboxAttributes +
                    '" name="' +
                    iframeId +
                    '" id="' +
                    iframeId +
                    '" style="display:none"></iframe>');
            }
            var windowFrames = window.frames;
            if (windowFrames && windowFrames[iframeId]) {
                adalFrame = windowFrames[iframeId];
            }
        }
        return adalFrame;
    };
    /**
     * Opens a hidden iframe for silent token renewal. The original code performed this action in a really weird
     * and inefficent way, so we're fixing it.
     * Original code is in ADAL.js loadFrame.
     * https://github.com/AzureAD/azure-activedirectory-library-for-js/ for source code
     */
    AdalAuthContext.prototype._loadFrame = function (authContext, urlNavigate, frameName) {
        authContext.info('LoadFrame: ' + frameName);
        var frameHandle = authContext._addAdalFrame(frameName);
        frameHandle.src = urlNavigate;
    };
    return AdalAuthContext;
}());
exports.default = AdalAuthContext;
//# sourceMappingURL=AdalAuthContext.js.map