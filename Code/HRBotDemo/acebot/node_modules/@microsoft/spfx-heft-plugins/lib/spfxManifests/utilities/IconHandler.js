"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IconHandler = exports.IconPathType = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const path = __importStar(require("path"));
const getFullHash_1 = require("./getFullHash");
/**
 * @internal
 * The type of icon URL defined in a user-created manifest.
 */
var IconPathType;
(function (IconPathType) {
    /**
     * Something that doesn't fit into another category. A warning will be printed.
     */
    IconPathType[IconPathType["Malformed"] = 0] = "Malformed";
    /**
     * An absolute URL. Something that begins with a protocol (i.e. - http://...).
     */
    IconPathType[IconPathType["AbsoluteUrl"] = 1] = "AbsoluteUrl";
    /**
     * A relative URL. Something that begins with an alphanumeric character, but doesn't look like a protocol.
     */
    IconPathType[IconPathType["RelativeUrl"] = 2] = "RelativeUrl";
    /**
     * A relative filesystem path. Something that begins with "./" or "../"
     */
    IconPathType[IconPathType["RelativePath"] = 3] = "RelativePath";
    /**
     * A data:image;... url
     */
    IconPathType[IconPathType["DataUrl"] = 4] = "DataUrl";
})(IconPathType = exports.IconPathType || (exports.IconPathType = {}));
/**
 * @internal
 */
class IconHandler {
    static getIconPathType(iconPath) {
        if (!iconPath) {
            return undefined;
        }
        else if (iconPath.match(/^\.{1,2}\/.+/)) {
            return IconPathType.RelativePath;
        }
        else if (iconPath.match(/^data:image\/.+/)) {
            return IconPathType.DataUrl;
        }
        else if (iconPath.match(/^\w+:\/\/.+/)) {
            return IconPathType.AbsoluteUrl;
        }
        else if (iconPath.match(/^\w+/)) {
            return IconPathType.RelativeUrl;
        }
        else {
            return IconPathType.Malformed;
        }
    }
    static processIconPath(terminal, compilation, manifestPath, iconPath) {
        const iconPathType = IconHandler.getIconPathType(iconPath);
        switch (iconPathType) {
            case IconPathType.RelativePath: {
                const iconAbsolutePath = path.resolve(path.dirname(manifestPath), iconPath || '');
                terminal.writeVerboseLine(`Found relative icon path "${iconPath}", resolved to "${iconAbsolutePath}"`);
                if (!node_core_library_1.FileSystem.exists(iconAbsolutePath)) {
                    compilation.errors.push(new Error(`Icon file missing from resolved path "${iconAbsolutePath}". The manifest icon will be missing.`));
                    return undefined;
                }
                else {
                    const ext = path.extname(iconAbsolutePath);
                    const iconBaseName = path.basename(iconAbsolutePath, ext);
                    const iconContent = node_core_library_1.FileSystem.readFileToBuffer(iconAbsolutePath);
                    const hash = (0, getFullHash_1.getFullHash)(iconContent);
                    const iconFilename = `${iconBaseName}_${hash}${ext}`;
                    compilation.fileDependencies.add(iconAbsolutePath);
                    compilation.assets[iconFilename] = {
                        source: () => iconContent,
                        size: () => iconContent.length
                    };
                    return iconFilename;
                }
            }
            case IconPathType.AbsoluteUrl: {
                terminal.writeVerboseLine(`Found absolute icon URL "${iconPath}"`);
                break;
            }
            case IconPathType.DataUrl: {
                terminal.writeVerboseLine(`Found data:image icon URL "${iconPath}"`);
                break;
            }
            case IconPathType.RelativeUrl: {
                compilation.warnings.push(`The icon path "${iconPath}" appears to be a relative web URL. This means that when the ` +
                    'icon is rendered, this URL will be relative to the CDN url for the rest of the package assets. If a ' +
                    'relative filesystem path was intended, prepend the path with "./".');
                break;
            }
            case undefined: {
                break;
            }
            default: {
                compilation.warnings.push(`The icon path "${iconPath}" appears to be malformed. The icon may not render as expected.`);
                break;
            }
        }
        return iconPath;
    }
}
exports.IconHandler = IconHandler;
//# sourceMappingURL=IconHandler.js.map