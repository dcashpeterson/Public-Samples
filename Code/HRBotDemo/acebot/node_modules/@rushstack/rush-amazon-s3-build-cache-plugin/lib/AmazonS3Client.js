"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmazonS3Client = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const crypto = __importStar(require("crypto"));
const fetch = __importStar(require("node-fetch"));
const AmazonS3Credentials_1 = require("./AmazonS3Credentials");
const CONTENT_HASH_HEADER_NAME = 'x-amz-content-sha256';
const DATE_HEADER_NAME = 'x-amz-date';
const HOST_HEADER_NAME = 'host';
const SECURITY_TOKEN_HEADER_NAME = 'x-amz-security-token';
const protocolRegex = /^https?:\/\//;
const portRegex = /:(\d{1,5})$/;
// Similar to https://docs.microsoft.com/en-us/javascript/api/@azure/storage-blob/storageretrypolicytype?view=azure-node-latest
var StorageRetryPolicyType;
(function (StorageRetryPolicyType) {
    StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(StorageRetryPolicyType || (StorageRetryPolicyType = {}));
const storageRetryOptions = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyType.EXPONENTIAL
};
/**
 * A helper for reading and updating objects on Amazon S3
 *
 * @public
 */
class AmazonS3Client {
    constructor(credentials, options, webClient, terminal) {
        this._credentials = credentials;
        this._terminal = terminal;
        this._validateEndpoint(options.s3Endpoint);
        this._s3Endpoint = options.s3Endpoint;
        this._s3Region = options.s3Region;
        this._webClient = webClient;
    }
    // https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html#create-signature-presign-entire-payload
    // We want to keep all slashes non encoded
    static UriEncode(input) {
        let output = '';
        for (let i = 0; i < input.length; i += 1) {
            const ch = input[i];
            if (ch.match(/[A-Za-z0-9~._-]|\//)) {
                output += ch;
            }
            else {
                if (ch === ' ') {
                    output += '%20';
                }
                else {
                    output += `%${ch.charCodeAt(0).toString(16).toUpperCase()}`;
                }
            }
        }
        return output;
    }
    static tryDeserializeCredentials(credentialString) {
        return (0, AmazonS3Credentials_1.fromRushEnv)(credentialString);
    }
    async getObjectAsync(objectName) {
        this._writeDebugLine('Reading object from S3');
        return await this._sendCacheRequestWithRetries(async () => {
            const response = await this._makeRequestAsync('GET', objectName);
            if (response.ok) {
                return {
                    hasNetworkError: false,
                    response: await response.buffer()
                };
            }
            else if (response.status === 404) {
                return {
                    hasNetworkError: false,
                    response: undefined
                };
            }
            else if ((response.status === 400 || response.status === 401 || response.status === 403) &&
                !this._credentials) {
                // unauthorized due to not providing credentials,
                // silence error for better DX when e.g. running locally without credentials
                this._writeWarningLine(`No credentials found and received a ${response.status}`, ' response code from the cloud storage.', ' Maybe run rush update-cloud-credentials', ' or set the RUSH_BUILD_CACHE_CREDENTIAL env');
                return {
                    hasNetworkError: false,
                    response: undefined
                };
            }
            else if (response.status === 400 || response.status === 401 || response.status === 403) {
                throw await this._getS3ErrorAsync(response);
            }
            else {
                const error = await this._getS3ErrorAsync(response);
                return {
                    hasNetworkError: true,
                    error
                };
            }
        });
    }
    async uploadObjectAsync(objectName, objectBuffer) {
        if (!this._credentials) {
            throw new Error('Credentials are required to upload objects to S3.');
        }
        await this._sendCacheRequestWithRetries(async () => {
            const response = await this._makeRequestAsync('PUT', objectName, objectBuffer);
            if (!response.ok) {
                return {
                    hasNetworkError: true,
                    error: await this._getS3ErrorAsync(response)
                };
            }
            return {
                hasNetworkError: false,
                response: undefined
            };
        });
    }
    _writeDebugLine(...messageParts) {
        // if the terminal has been closed then don't bother sending a debug message
        try {
            this._terminal.writeDebugLine(...messageParts);
        }
        catch (err) {
            // ignore error
        }
    }
    _writeWarningLine(...messageParts) {
        // if the terminal has been closed then don't bother sending a warning message
        try {
            this._terminal.writeWarningLine(...messageParts);
        }
        catch (err) {
            // ignore error
        }
    }
    async _makeRequestAsync(verb, objectName, body) {
        const isoDateString = this._getIsoDateString();
        const bodyHash = this._getSha256(body);
        const headers = new fetch.Headers();
        headers.set(DATE_HEADER_NAME, isoDateString.dateTime);
        headers.set(CONTENT_HASH_HEADER_NAME, bodyHash);
        // the host can be e.g. https://s3.aws.com or http://localhost:9000
        const host = this._s3Endpoint.replace(protocolRegex, '');
        const canonicalUri = AmazonS3Client.UriEncode(`/${objectName}`);
        this._writeDebugLine(node_core_library_1.Colors.bold('Canonical URI: '), canonicalUri);
        if (this._credentials) {
            // Compute the authorization header. See https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html
            const canonicalHeaders = [
                `${HOST_HEADER_NAME}:${host}`,
                `${CONTENT_HASH_HEADER_NAME}:${bodyHash}`,
                `${DATE_HEADER_NAME}:${isoDateString.dateTime}`
            ];
            // Handle signing with temporary credentials (via sts:assume-role)
            if (this._credentials.sessionToken) {
                canonicalHeaders.push(`${SECURITY_TOKEN_HEADER_NAME}:${this._credentials.sessionToken}`);
            }
            // the canonical headers must be sorted by header name
            canonicalHeaders.sort((aHeader, bHeader) => {
                const aHeaderName = aHeader.split(':')[0];
                const bHeaderName = bHeader.split(':')[0];
                if (aHeaderName < bHeaderName) {
                    return -1;
                }
                if (aHeaderName > bHeaderName) {
                    return 1;
                }
                return 0;
            });
            // the singed header names are derived from the canonicalHeaders
            const signedHeaderNamesString = canonicalHeaders
                .map((header) => {
                const headerName = header.split(':')[0];
                return headerName;
            })
                .join(';');
            // The canonical request looks like this:
            //  GET
            // /test.txt
            //
            // host:examplebucket.s3.amazonaws.com
            // range:bytes=0-9
            // x-amz-content-sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
            // x-amz-date:20130524T000000Z
            //
            // host;range;x-amz-content-sha256;x-amz-date
            // e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
            const canonicalRequest = [
                verb,
                canonicalUri,
                '',
                ...canonicalHeaders,
                '',
                signedHeaderNamesString,
                bodyHash
            ].join('\n');
            const canonicalRequestHash = this._getSha256(canonicalRequest);
            const scope = `${isoDateString.date}/${this._s3Region}/s3/aws4_request`;
            // The string to sign looks like this:
            // AWS4-HMAC-SHA256
            // 20130524T423589Z
            // 20130524/us-east-1/s3/aws4_request
            // 7344ae5b7ee6c3e7e6b0fe0640412a37625d1fbfff95c48bbb2dc43964946972
            const stringToSign = [
                'AWS4-HMAC-SHA256',
                isoDateString.dateTime,
                scope,
                canonicalRequestHash
            ].join('\n');
            const dateKey = this._getSha256Hmac(`AWS4${this._credentials.secretAccessKey}`, isoDateString.date);
            const dateRegionKey = this._getSha256Hmac(dateKey, this._s3Region);
            const dateRegionServiceKey = this._getSha256Hmac(dateRegionKey, 's3');
            const signingKey = this._getSha256Hmac(dateRegionServiceKey, 'aws4_request');
            const signature = this._getSha256Hmac(signingKey, stringToSign, 'hex');
            const authorizationHeader = `AWS4-HMAC-SHA256 Credential=${this._credentials.accessKeyId}/${scope},SignedHeaders=${signedHeaderNamesString},Signature=${signature}`;
            headers.set('Authorization', authorizationHeader);
            if (this._credentials.sessionToken) {
                // Handle signing with temporary credentials (via sts:assume-role)
                headers.set('X-Amz-Security-Token', this._credentials.sessionToken);
            }
        }
        const webFetchOptions = {
            verb,
            headers
        };
        if (verb === 'PUT') {
            webFetchOptions.body = body;
        }
        const url = `${this._s3Endpoint}${canonicalUri}`;
        this._writeDebugLine(node_core_library_1.Colors.bold(node_core_library_1.Colors.underline('Sending request to S3')));
        this._writeDebugLine(node_core_library_1.Colors.bold('HOST: '), url);
        this._writeDebugLine(node_core_library_1.Colors.bold('Headers: '));
        headers.forEach((value, name) => {
            this._writeDebugLine(node_core_library_1.Colors.cyan(`\t${name}: ${value}`));
        });
        const response = await this._webClient.fetchAsync(url, webFetchOptions);
        return response;
    }
    _getSha256Hmac(key, data, encoding) {
        const hash = crypto.createHmac('sha256', key);
        hash.update(data);
        if (encoding) {
            return hash.digest(encoding);
        }
        else {
            return hash.digest();
        }
    }
    _getSha256(data) {
        if (data) {
            const hash = crypto.createHash('sha256');
            hash.update(data);
            return hash.digest('hex');
        }
        else {
            // This is the null SHA256 hash
            return 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
        }
    }
    _getIsoDateString(date = new Date()) {
        let dateString = date.toISOString();
        dateString = dateString.replace(/[-:]/g, ''); // Remove separator characters
        dateString = dateString.substring(0, 15); // Drop milliseconds
        // dateTime is an ISO8601 date. It looks like "20130524T423589"
        // date is an ISO date. It looks like "20130524"
        return {
            dateTime: `${dateString}Z`,
            date: dateString.substring(0, 8)
        };
    }
    async _safeReadResponseText(response) {
        try {
            return await response.text();
        }
        catch (err) {
            // ignore the error
        }
        return undefined;
    }
    async _getS3ErrorAsync(response) {
        const text = await this._safeReadResponseText(response);
        return new Error(`Amazon S3 responded with status code ${response.status} (${response.statusText})${text ? `\n${text}` : ''}`);
    }
    /**
     * Validates a S3 endpoint which is http(s):// + hostname + port. Hostname validated according to RFC 1123
     * {@link https://docs.aws.amazon.com/general/latest/gr/s3.html}
     */
    _validateEndpoint(s3Endpoint) {
        let host = s3Endpoint;
        if (!s3Endpoint) {
            throw new Error('A S3 endpoint must be provided');
        }
        if (!s3Endpoint.match(protocolRegex)) {
            throw new Error('The S3 endpoint must start with https:// or http://');
        }
        host = host.replace(protocolRegex, '');
        if (host.match(/\//)) {
            throw new Error('The path should be omitted from the endpoint. Use s3Prefix to specify a path');
        }
        const portMatch = s3Endpoint.match(portRegex);
        if (portMatch) {
            const port = Number(portMatch[1]);
            if (Number.isNaN(port) || port > 65535) {
                throw new Error(`Port: ${port} is an invalid port number`);
            }
            host = host.replace(portRegex, '');
        }
        if (host.endsWith('.')) {
            host = host.slice(0, host.length - 1);
        }
        if (host.length > 253) {
            throw new Error('The S3 endpoint is too long. RFC 1123 specifies a hostname should be no longer than 253 characters.');
        }
        const subDomains = host.split('.');
        const subDomainRegex = /^[a-zA-Z0-9-]+$/;
        const isValid = subDomains.every((subDomain) => {
            return (subDomainRegex.test(subDomain) &&
                subDomain.length < 64 &&
                !subDomain.startsWith('-') &&
                !subDomain.endsWith('-'));
        });
        if (!isValid) {
            throw new Error('Invalid S3 endpoint. Some part of the hostname contains invalid characters or is too long');
        }
    }
    async _sendCacheRequestWithRetries(sendRequest) {
        const response = await sendRequest();
        const log = this._writeDebugLine.bind(this);
        if (response.hasNetworkError) {
            if (storageRetryOptions && storageRetryOptions.maxTries > 1) {
                log('Network request failed. Will retry request as specified in storageRetryOptions');
                async function retry(retryAttempt) {
                    const { retryDelayInMs, retryPolicyType, maxTries, maxRetryDelayInMs } = storageRetryOptions;
                    let delay = retryDelayInMs;
                    if (retryPolicyType === StorageRetryPolicyType.EXPONENTIAL) {
                        delay = retryDelayInMs * Math.pow(2, retryAttempt - 1);
                    }
                    delay = Math.min(maxRetryDelayInMs, delay);
                    log(`Will retry request in ${delay}s...`);
                    await node_core_library_1.Async.sleep(delay);
                    const retryResponse = await sendRequest();
                    if (retryResponse.hasNetworkError) {
                        if (retryAttempt < maxTries - 1) {
                            log('The retried request failed, will try again');
                            return retry(retryAttempt + 1);
                        }
                        else {
                            log('The retried request failed and has reached the maxTries limit');
                            throw retryResponse.error;
                        }
                    }
                    return retryResponse.response;
                }
                return retry(1);
            }
            else {
                log('Network request failed and storageRetryOptions is not specified');
                throw response.error;
            }
        }
        return response.response;
    }
}
exports.AmazonS3Client = AmazonS3Client;
//# sourceMappingURL=AmazonS3Client.js.map