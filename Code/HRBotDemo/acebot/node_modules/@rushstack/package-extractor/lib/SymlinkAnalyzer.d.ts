import { type FileSystemStats } from '@rushstack/node-core-library';
export interface IPathNodeBase {
    kind: 'file' | 'folder' | 'link';
    nodePath: string;
    linkStats: FileSystemStats;
}
/**
 * Represents a file object analyzed by {@link SymlinkAnalyzer}.
 */
export interface IFileNode extends IPathNodeBase {
    kind: 'file';
}
/**
 * Represents a folder object analyzed by {@link SymlinkAnalyzer}.
 */
export interface IFolderNode extends IPathNodeBase {
    kind: 'folder';
}
/**
 * Represents a symbolic link analyzed by {@link SymlinkAnalyzer}.
 */
export interface ILinkNode extends IPathNodeBase {
    kind: 'link';
    /**
     * The immediate target that the symlink resolves to.
     */
    linkTarget: string;
}
export type PathNode = IFileNode | IFolderNode | ILinkNode;
/**
 * Represents a symbolic link.
 *
 * @public
 */
export interface ILinkInfo {
    /**
     * The type of link that was encountered.
     */
    kind: 'fileLink' | 'folderLink';
    /**
     * The path to the link, relative to the root of the extractor output folder.
     */
    linkPath: string;
    /**
     * The target that the link points to.
     */
    targetPath: string;
}
export interface ISymlinkAnalyzerOptions {
    requiredSourceParentPath?: string;
}
export declare class SymlinkAnalyzer {
    private readonly _requiredSourceParentPath;
    private readonly _nodesByPath;
    private readonly _linkInfosByPath;
    constructor(options?: ISymlinkAnalyzerOptions);
    analyzePathAsync(inputPath: string, preserveLinks?: boolean): Promise<PathNode>;
    /**
     * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePathAsync}.
     */
    reportSymlinks(): ILinkInfo[];
}
//# sourceMappingURL=SymlinkAnalyzer.d.ts.map