{"version":3,"file":"Path.js","sourceRoot":"","sources":["../src/Path.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\n\r\nexport type ParsedPath = path.ParsedPath;\r\n\r\nexport class Path {\r\n  /**\r\n   * Whether the filesystem is assumed to be case sensitive for Path operations.\r\n   *\r\n   * @remarks\r\n   * Regardless of operating system, a given file system's paths may be case-sensitive or case-insensitive.\r\n   * If a volume is mounted under a subfolder, then different parts of a path can even have different\r\n   * case-sensitivity.  The Node.js \"path\" API naively assumes that all Windows paths are case-insensitive,\r\n   * and that all other OS's are case-sensitive.  This is way off, for example a modern MacBook has a\r\n   * case-insensitive filesystem by default.  There isn't an easy workaround because Node.js does not expose\r\n   * the native OS APIs that would give accurate answers.\r\n   *\r\n   * The TypeScript compiler does somewhat better: it performs an empirical test of its own bundle path to see\r\n   * whether it can be read using different case.  If so, it normalizes all paths to lowercase (sometimes with\r\n   * no API for retrieving the real path).  This caused our Path.isUnder() to return incorrect answers because\r\n   * it relies on Node.js path.relative().\r\n   *\r\n   * To solve that problem, Path.ts performs an empirical test similar to what the TypeScript compiler does,\r\n   * and then we adjust path.relative() to be case insensitive if appropriate.\r\n   *\r\n   * @see {@link https://nodejs.org/en/docs/guides/working-with-different-filesystems/}\r\n   */\r\n  public static usingCaseSensitive: boolean = Path._detectCaseSensitive();\r\n\r\n  private static _detectCaseSensitive(): boolean {\r\n    // Can our own file be accessed using a path with different case?  If so, then the filesystem is case-insensitive.\r\n    return !fs.existsSync(__filename.toUpperCase());\r\n  }\r\n\r\n  // Removes redundant trailing slashes from a path.\r\n  private static _trimTrailingSlashes(inputPath: string): string {\r\n    // Examples:\r\n    // \"/a/b///\\\\\" --> \"/a/b\"\r\n    // \"/\"         --> \"/\"\r\n    return inputPath.replace(/(?<=[^\\/\\\\])[\\/\\\\]+$/, '');\r\n  }\r\n\r\n  // An implementation of path.relative() that is case-insensitive.\r\n  private static _relativeCaseInsensitive(from: string, to: string): string {\r\n    // path.relative() apples path.normalize() and also trims any trailing slashes.\r\n    // Since we'll be matching toNormalized against result, we need to do that for our string as well.\r\n    const normalizedTo: string = Path._trimTrailingSlashes(path.normalize(to));\r\n\r\n    // We start by converting everything to uppercase and call path.relative()\r\n    const uppercasedFrom: string = from.toUpperCase();\r\n    const uppercasedTo: string = normalizedTo.toUpperCase();\r\n\r\n    // The result will be all uppercase because its inputs were uppercased\r\n    const uppercasedResult: string = path.relative(uppercasedFrom, uppercasedTo);\r\n\r\n    // Are there any cased characters in the result?\r\n    if (uppercasedResult.toLowerCase() === uppercasedResult) {\r\n      // No cased characters\r\n      // Example: \"../..\"\r\n      return uppercasedResult;\r\n    }\r\n\r\n    // Example:\r\n    //   from=\"/a/b/c\"\r\n    //   to=\"/a/b/d/e\"\r\n    //\r\n    //   fromNormalized=\"/A/B/C\"\r\n    //   toNormalized=\"/A/B/D/E\"\r\n    //\r\n    //   result=\"../D/E\"\r\n    //\r\n    // Scan backwards comparing uppercasedResult versus uppercasedTo, stopping at the first place where they differ.\r\n    let resultIndex: number = uppercasedResult.length;\r\n    let toIndex: number = normalizedTo.length;\r\n    for (;;) {\r\n      if (resultIndex === 0 || toIndex === 0) {\r\n        // Stop if we reach the start of the string\r\n        break;\r\n      }\r\n\r\n      if (uppercasedResult.charCodeAt(resultIndex - 1) !== uppercasedTo.charCodeAt(toIndex - 1)) {\r\n        // Stop before we reach a character that is different\r\n        break;\r\n      }\r\n\r\n      --resultIndex;\r\n      --toIndex;\r\n    }\r\n\r\n    // Replace the matching part with the properly cased substring from the \"normalizedTo\" input\r\n    //\r\n    // Example:\r\n    //   \"..\" + \"/d/e\" = \"../d/e\"\r\n    return uppercasedResult.substring(0, resultIndex) + normalizedTo.substring(toIndex);\r\n  }\r\n\r\n  public static relative(from: string, to: string): string {\r\n    if (!Path.usingCaseSensitive) {\r\n      return Path._relativeCaseInsensitive(from, to);\r\n    }\r\n    return path.relative(from, to);\r\n  }\r\n\r\n  // --------------------------------------------------------------------------------------------------------\r\n  // The operations below don't care about case sensitivity\r\n\r\n  public static dirname(p: string): string {\r\n    return path.dirname(p);\r\n  }\r\n\r\n  public static join(...paths: string[]): string {\r\n    return path.join(...paths);\r\n  }\r\n\r\n  public static resolve(...pathSegments: string[]): string {\r\n    return path.resolve(...pathSegments);\r\n  }\r\n\r\n  public static parse(pathString: string): ParsedPath {\r\n    return path.parse(pathString);\r\n  }\r\n\r\n  // --------------------------------------------------------------------------------------------------------\r\n  // The operations below are borrowed from @rushstack/node-core-library\r\n\r\n  private static _relativePathRegex: RegExp = /^[.\\/\\\\]+$/;\r\n\r\n  /**\r\n   * Returns true if \"childPath\" is located inside the \"parentFolderPath\" folder\r\n   * or one of its child folders.  Note that \"parentFolderPath\" is not considered to be\r\n   * under itself.  The \"childPath\" can refer to any type of file system object.\r\n   *\r\n   * @remarks\r\n   * The indicated file/folder objects are not required to actually exist on disk.\r\n   * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\r\n   * If the paths are relative, they will first be resolved using path.resolve().\r\n   */\r\n  public static isUnder(childPath: string, parentFolderPath: string): boolean {\r\n    const relativePath: string = Path.relative(childPath, parentFolderPath);\r\n    return Path._relativePathRegex.test(relativePath);\r\n  }\r\n\r\n  /**\r\n   * Returns true if `path1` and `path2` refer to the same underlying path.\r\n   *\r\n   * @remarks\r\n   *\r\n   * The comparison is performed using `path.relative()`.\r\n   */\r\n  public static isEqual(path1: string, path2: string): boolean {\r\n    return Path.relative(path1, path2) === '';\r\n  }\r\n\r\n  /**\r\n   * Replaces Windows-style backslashes with POSIX-style slashes.\r\n   *\r\n   * @remarks\r\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\r\n   */\r\n  public static convertToSlashes(inputPath: string): string {\r\n    return inputPath.split('\\\\').join('/');\r\n  }\r\n}\r\n"]}