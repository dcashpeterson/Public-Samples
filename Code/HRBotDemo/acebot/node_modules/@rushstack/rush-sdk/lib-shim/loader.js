"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RushSdkLoader = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const helpers_1 = require("./helpers");
/**
 * Exposes operations that control how the `@microsoft/rush-lib` engine is
 * located and loaded.
 * @public
 */
class RushSdkLoader {
    /**
     * Throws an "AbortError" exception if abortSignal.aborted is true.
     */
    static _checkForCancel(abortSignal, onNotifyEvent, progressPercent) {
        if (!(abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
            return;
        }
        if (onNotifyEvent) {
            onNotifyEvent({
                logMessage: {
                    kind: 'info',
                    text: `The operation was canceled`
                },
                progressPercent
            });
        }
        const error = new Error('The operation was canceled');
        error.name = 'AbortError';
        throw error;
    }
    /**
     * Returns true if the Rush engine has already been loaded.
     */
    static get isLoaded() {
        return helpers_1.sdkContext.rushLibModule !== undefined;
    }
    /**
     * Manually load the Rush engine based on rush.json found for `rushJsonSearchFolder`.
     * Throws an exception if {@link RushSdkLoader.isLoaded} is already `true`.
     *
     * @remarks
     * This API supports an callback that can be used display a progress bar,
     * log of operations, and allow the operation to be canceled prematurely.
     */
    static async loadAsync(options) {
        // SCENARIO 5: The rush-lib engine is loaded manually using rushSdkLoader.loadAsync().
        var _a, _b;
        if (!options) {
            options = {};
        }
        if (RushSdkLoader.isLoaded) {
            throw new Error('RushSdkLoader.loadAsync() failed because the Rush engine has already been loaded');
        }
        const onNotifyEvent = options.onNotifyEvent;
        let progressPercent = undefined;
        const abortSignal = options.abortSignal;
        try {
            const rushJsonSearchFolder = (_a = options.rushJsonSearchFolder) !== null && _a !== void 0 ? _a : process.cwd();
            if (onNotifyEvent) {
                onNotifyEvent({
                    logMessage: {
                        kind: 'debug',
                        text: `Searching for rush.json starting from: ` + rushJsonSearchFolder
                    },
                    progressPercent
                });
            }
            const rushJsonPath = (0, helpers_1.tryFindRushJsonLocation)(rushJsonSearchFolder);
            if (!rushJsonPath) {
                throw new Error('Unable to find rush.json in the specified folder or its parent folders:\n' +
                    `${rushJsonSearchFolder}\n`);
            }
            const monorepoRoot = path.dirname(rushJsonPath);
            const rushJson = await node_core_library_1.JsonFile.loadAsync(rushJsonPath);
            const { rushVersion } = rushJson;
            const installRunNodeModuleFolder = path.join(monorepoRoot, `common/temp/install-run/@microsoft+rush@${rushVersion}`);
            try {
                // First, try to load the version of "rush-lib" that was installed by install-run-rush.js
                if (onNotifyEvent) {
                    onNotifyEvent({
                        logMessage: {
                            kind: 'info',
                            text: `Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`
                        },
                        progressPercent
                    });
                }
                helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
            }
            catch (e1) {
                let installAndRunRushStderrContent = '';
                try {
                    const installAndRunRushJSPath = path.join(monorepoRoot, 'common/scripts/install-run-rush.js');
                    if (onNotifyEvent) {
                        onNotifyEvent({
                            logMessage: {
                                kind: 'info',
                                text: 'The Rush engine has not been installed yet. Invoking install-run-rush.js...'
                            },
                            progressPercent
                        });
                    }
                    // Start the installation
                    progressPercent = 0;
                    const installAndRunRushProcess = node_core_library_1.Executable.spawnSync('node', [installAndRunRushJSPath, '--help'], {
                        stdio: 'pipe'
                    });
                    installAndRunRushStderrContent = installAndRunRushProcess.stderr;
                    if (installAndRunRushProcess.status !== 0) {
                        throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to install`);
                    }
                    if (abortSignal) {
                        RushSdkLoader._checkForCancel(abortSignal, onNotifyEvent, progressPercent);
                    }
                    // TODO: Implement incremental progress updates
                    progressPercent = 90;
                    // Retry to load "rush-lib" after install-run-rush run
                    if (onNotifyEvent) {
                        onNotifyEvent({
                            logMessage: {
                                kind: 'debug',
                                text: `Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush a second time`
                            },
                            progressPercent
                        });
                    }
                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
                    progressPercent = 100;
                }
                catch (e2) {
                    // eslint-disable-next-line no-console
                    console.error(`${installAndRunRushStderrContent}`);
                    throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to load`);
                }
            }
            if (helpers_1.sdkContext.rushLibModule !== undefined) {
                // to track which scenario is active and how it got initialized.
                global.___rush___rushLibModuleFromInstallAndRunRush = helpers_1.sdkContext.rushLibModule;
                if (onNotifyEvent) {
                    onNotifyEvent({
                        logMessage: {
                            kind: 'debug',
                            text: `Loaded ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`
                        },
                        progressPercent
                    });
                }
            }
        }
        catch (e) {
            if (onNotifyEvent) {
                onNotifyEvent({
                    logMessage: {
                        kind: 'info',
                        text: 'The operation failed: ' + ((_b = e.message) !== null && _b !== void 0 ? _b : 'An unknown error occurred')
                    },
                    progressPercent
                });
            }
            throw e;
        }
    }
}
exports.RushSdkLoader = RushSdkLoader;
//# sourceMappingURL=loader.js.map