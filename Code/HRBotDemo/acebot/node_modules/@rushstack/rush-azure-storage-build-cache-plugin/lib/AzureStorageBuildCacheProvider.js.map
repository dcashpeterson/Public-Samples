{"version":3,"file":"AzureStorageBuildCacheProvider.js","sourceRoot":"","sources":["../src/AzureStorageBuildCacheProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { ITerminal } from '@rushstack/node-core-library';\nimport {\n  type ICloudBuildCacheProvider,\n  EnvironmentVariableNames,\n  RushConstants,\n  EnvironmentConfiguration,\n  type ICredentialCacheEntry\n} from '@rushstack/rush-sdk';\nimport {\n  type BlobClient,\n  BlobServiceClient,\n  type BlockBlobClient,\n  type ContainerClient\n} from '@azure/storage-blob';\nimport { AzureAuthorityHosts } from '@azure/identity';\n\nimport {\n  AzureStorageAuthentication,\n  type IAzureStorageAuthenticationOptions\n} from './AzureStorageAuthentication';\n\nexport interface IAzureStorageBuildCacheProviderOptions extends IAzureStorageAuthenticationOptions {\n  blobPrefix?: string;\n}\n\ninterface IBlobError extends Error {\n  statusCode: number;\n  code: string;\n  response?: {\n    status: string;\n    parsedHeaders?: {\n      errorCode: string;\n    };\n  };\n}\n\nexport class AzureStorageBuildCacheProvider\n  extends AzureStorageAuthentication\n  implements ICloudBuildCacheProvider\n{\n  private readonly _blobPrefix: string | undefined;\n  private readonly _environmentCredential: string | undefined;\n\n  public get isCacheWriteAllowed(): boolean {\n    return EnvironmentConfiguration.buildCacheWriteAllowed ?? this._isCacheWriteAllowedByConfiguration;\n  }\n\n  private _containerClient: ContainerClient | undefined;\n\n  public constructor(options: IAzureStorageBuildCacheProviderOptions) {\n    super({\n      credentialUpdateCommandForLogging: `rush ${RushConstants.updateCloudCredentialsCommandName}`,\n      ...options\n    });\n\n    this._blobPrefix = options.blobPrefix;\n    this._environmentCredential = EnvironmentConfiguration.buildCacheCredential;\n\n    if (!(this._azureEnvironment in AzureAuthorityHosts)) {\n      throw new Error(\n        `The specified Azure Environment (\"${this._azureEnvironment}\") is invalid. If it is specified, it must ` +\n          `be one of: ${Object.keys(AzureAuthorityHosts).join(', ')}`\n      );\n    }\n  }\n\n  public async tryGetCacheEntryBufferByIdAsync(\n    terminal: ITerminal,\n    cacheId: string\n  ): Promise<Buffer | undefined> {\n    const blobClient: BlobClient = await this._getBlobClientForCacheIdAsync(cacheId, terminal);\n\n    try {\n      const blobExists: boolean = await blobClient.exists();\n      if (blobExists) {\n        return await blobClient.downloadToBuffer();\n      } else {\n        return undefined;\n      }\n    } catch (err) {\n      const e: IBlobError = err as IBlobError;\n      const errorMessage: string =\n        'Error getting cache entry from Azure Storage: ' +\n        [e.name, e.message, e.response?.status, e.response?.parsedHeaders?.errorCode]\n          .filter((piece: string | undefined) => piece)\n          .join(' ');\n\n      if (e.response?.parsedHeaders?.errorCode === 'PublicAccessNotPermitted') {\n        // This error means we tried to read the cache with no credentials, but credentials are required.\n        // We'll assume that the configuration of the cache is correct and the user has to take action.\n        terminal.writeWarningLine(\n          `${errorMessage}\\n\\n` +\n            `You need to configure Azure Storage SAS credentials to access the build cache.\\n` +\n            `Update the credentials by running \"rush ${RushConstants.updateCloudCredentialsCommandName}\", \\n` +\n            `or provide a SAS in the ` +\n            `${EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL} environment variable.`\n        );\n      } else if (e.response?.parsedHeaders?.errorCode === 'AuthenticationFailed') {\n        // This error means the user's credentials are incorrect, but not expired normally. They might have\n        // gotten corrupted somehow, or revoked manually in Azure Portal.\n        terminal.writeWarningLine(\n          `${errorMessage}\\n\\n` +\n            `Your Azure Storage SAS credentials are not valid.\\n` +\n            `Update the credentials by running \"rush ${RushConstants.updateCloudCredentialsCommandName}\", \\n` +\n            `or provide a SAS in the ` +\n            `${EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL} environment variable.`\n        );\n      } else if (e.response?.parsedHeaders?.errorCode === 'AuthorizationPermissionMismatch') {\n        // This error is not solvable by the user, so we'll assume it is a configuration error, and revert\n        // to providing likely next steps on configuration. (Hopefully this error is rare for a regular\n        // developer, more likely this error will appear while someone is configuring the cache for the\n        // first time.)\n        terminal.writeWarningLine(\n          `${errorMessage}\\n\\n` +\n            `Your Azure Storage SAS credentials are valid, but do not have permission to read the build cache.\\n` +\n            `Make sure you have added the role 'Storage Blob Data Reader' to the appropriate user(s) or group(s)\\n` +\n            `on your storage account in the Azure Portal.`\n        );\n      } else {\n        // We don't know what went wrong, hopefully we'll print something useful.\n        terminal.writeWarningLine(errorMessage);\n      }\n      return undefined;\n    }\n  }\n\n  public async trySetCacheEntryBufferAsync(\n    terminal: ITerminal,\n    cacheId: string,\n    entryStream: Buffer\n  ): Promise<boolean> {\n    if (!this.isCacheWriteAllowed) {\n      terminal.writeErrorLine(\n        'Writing to Azure Blob Storage cache is not allowed in the current configuration.'\n      );\n      return false;\n    }\n\n    const blobClient: BlobClient = await this._getBlobClientForCacheIdAsync(cacheId, terminal);\n    const blockBlobClient: BlockBlobClient = blobClient.getBlockBlobClient();\n    let blobAlreadyExists: boolean = false;\n\n    try {\n      blobAlreadyExists = await blockBlobClient.exists();\n    } catch (err) {\n      const e: IBlobError = err as IBlobError;\n\n      // If RUSH_BUILD_CACHE_CREDENTIAL is set but is corrupted or has been rotated\n      // in Azure Portal, or the user's own cached credentials have been corrupted or\n      // invalidated, we'll print the error and continue (this way we don't fail the\n      // actual rush build).\n      const errorMessage: string =\n        'Error checking if cache entry exists in Azure Storage: ' +\n        [e.name, e.message, e.response?.status, e.response?.parsedHeaders?.errorCode]\n          .filter((piece: string | undefined) => piece)\n          .join(' ');\n\n      terminal.writeWarningLine(errorMessage);\n    }\n\n    if (blobAlreadyExists) {\n      terminal.writeVerboseLine('Build cache entry blob already exists.');\n      return true;\n    } else {\n      try {\n        await blockBlobClient.upload(entryStream, entryStream.length);\n        return true;\n      } catch (e) {\n        if ((e as IBlobError).statusCode === 409 /* conflict */) {\n          // If something else has written to the blob at the same time,\n          // it's probably a concurrent process that is attempting to write\n          // the same cache entry. That is an effective success.\n          terminal.writeVerboseLine(\n            'Azure Storage returned status 409 (conflict). The cache entry has ' +\n              `probably already been set by another builder. Code: \"${(e as IBlobError).code}\".`\n          );\n          return true;\n        } else {\n          terminal.writeWarningLine(`Error uploading cache entry to Azure Storage: ${e}`);\n          return false;\n        }\n      }\n    }\n  }\n\n  private async _getBlobClientForCacheIdAsync(cacheId: string, terminal: ITerminal): Promise<BlobClient> {\n    const client: ContainerClient = await this._getContainerClientAsync(terminal);\n    const blobName: string = this._blobPrefix ? `${this._blobPrefix}/${cacheId}` : cacheId;\n    return client.getBlobClient(blobName);\n  }\n\n  private async _getContainerClientAsync(terminal: ITerminal): Promise<ContainerClient> {\n    if (!this._containerClient) {\n      let sasString: string | undefined = this._environmentCredential;\n      if (!sasString) {\n        const credentialEntry: ICredentialCacheEntry | undefined = await this.tryGetCachedCredentialAsync({\n          expiredCredentialBehavior: 'logWarning',\n          terminal\n        });\n\n        sasString = credentialEntry?.credential;\n      }\n\n      let blobServiceClient: BlobServiceClient;\n      if (sasString) {\n        const connectionString: string = this._getConnectionString(sasString);\n        blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);\n      } else if (!this._isCacheWriteAllowedByConfiguration) {\n        // If cache write isn't allowed and we don't have a credential, assume the blob supports anonymous read\n        blobServiceClient = new BlobServiceClient(this._storageAccountUrl);\n      } else {\n        throw new Error(\n          \"An Azure Storage SAS credential hasn't been provided, or has expired. \" +\n            `Update the credentials by running \"rush ${RushConstants.updateCloudCredentialsCommandName}\", ` +\n            `or provide a SAS in the ` +\n            `${EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL} environment variable`\n        );\n      }\n\n      this._containerClient = blobServiceClient.getContainerClient(this._storageContainerName);\n    }\n\n    return this._containerClient;\n  }\n\n  private _getConnectionString(sasString: string | undefined): string {\n    const blobEndpoint: string = `BlobEndpoint=${this._storageAccountUrl}`;\n    if (sasString) {\n      const connectionString: string = `${blobEndpoint};SharedAccessSignature=${sasString}`;\n      return connectionString;\n    } else {\n      return blobEndpoint;\n    }\n  }\n}\n"]}