"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolutionPackager = void 0;
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const heft_config_file_1 = require("@rushstack/heft-config-file");
const node_core_library_1 = require("@rushstack/node-core-library");
const createPackage_1 = __importDefault(require("./packageSolution/createPackage"));
const WebpackConfigurationPlugin_1 = __importDefault(require("../webpackConfigurationPlugin/WebpackConfigurationPlugin"));
const UrlUtilities_1 = require("../../utilities/UrlUtilities");
const DEFAULT_CONFIG = {
    paths: {
        packageDir: 'sharepoint',
        debugDir: 'solution/debug',
        zippedPackage: 'solution/ClientSolution.sppkg',
        featureXmlDir: 'feature_xml',
        sharepointAssetDir: 'assets',
        teamsDir: 'teams'
    },
    contentTypes: {
        xml: 'text/xml',
        rels: 'application/vnd.openxmlformats-package.relationships+xml',
        webpart: 'text/xml',
        htm: 'text/html',
        html: 'text/html',
        aspx: 'text/xml',
        resx: 'text/xml',
        js: 'application/javascript',
        json: 'application/json',
        png: 'image/png',
        jpg: 'image/jpeg',
        bmp: 'image/bmp',
        gif: 'image/gif'
    },
    solution: {
        name: 'A Sample Solution',
        id: '00000000-0000-0000-0000-000000000000'
    }
};
/**
 * @internal
 */
class SolutionPackager {
    constructor(options) {
        this._alreadyTriedToLoadConfig = false;
        this._buildFolder = options.buildFolder;
        this._webpackOutputFolderPaths = WebpackConfigurationPlugin_1.default.getSpfxWebpackFolders(this._buildFolder);
        this._terminal = options.terminal;
        this._emitError = options.emitError;
        this._emitWarning = options.emitWarning;
    }
    async packageSolutionAsync(production, prettyPrintXml = false, noSpppkg = false) {
        const config = await this._ensureConfigFileAsync();
        if (!config) {
            this._emitError(new Error(`A ${SolutionPackager._configFile.projectRelativeFilePath} file does not ` +
                `exist in this project, so this project cannot produce a SharePoint solution package.`));
            return;
        }
        if (config.solution.includeClientSideAssets && !production) {
            this._emitWarning(new Error('This is not a production build (--production), therefore the ' +
                '"includeClientSideAssets" setting will be ignored.'));
            config.solution.includeClientSideAssets = false;
        }
        const ignoredAssets = ['**/*.map'];
        let assetsFolderPath;
        let manifestsFolderPath;
        if (production) {
            manifestsFolderPath = `${this._webpackOutputFolderPaths.releaseFolder}/manifests`;
            assetsFolderPath = `${this._webpackOutputFolderPaths.releaseFolder}/assets`;
        }
        else {
            manifestsFolderPath = assetsFolderPath = this._webpackOutputFolderPaths.outputFolder;
        }
        const manifestMap = new Map();
        let foundAnyManifests = false;
        const manifestFilenames = await node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob_1.default, '*.manifest.json', {
            cwd: manifestsFolderPath
        });
        await node_core_library_1.Async.forEachAsync(manifestFilenames, async (manifestFilename) => {
            foundAnyManifests = true;
            const manifest = await node_core_library_1.JsonFile.loadAsync(`${manifestsFolderPath}/${manifestFilename}`);
            if (manifest.componentType === 'WebPart') {
                const webpartManifest = manifest;
                if (webpartManifest.supportedHosts) {
                    let foundTeamsTab = false;
                    let foundMeetingsTab = false;
                    for (const supportedHost of webpartManifest.supportedHosts) {
                        if (supportedHost === 'TeamsMeetingApp') {
                            foundMeetingsTab = true;
                        }
                        else if (supportedHost === 'TeamsPersonalApp' || supportedHost === 'TeamsTab') {
                            foundTeamsTab = true;
                        }
                    }
                    if (foundTeamsTab && foundMeetingsTab) {
                        this._emitError(new Error(`Manifest contains supported host of TeamsMeetingApp as well as another tab type and is not compatible`));
                    }
                }
            }
            // Re-enable fail on validation error https://onedrive.visualstudio.com/WEX!/_workitems/edit/1056377
            this._terminal.writeLine(`Found manifest: ${manifestFilename}`);
            ignoredAssets.push(manifestFilename);
            manifestMap.set(manifest.id, manifest);
        }, { concurrency: 5 });
        if (!manifestMap.size) {
            if (foundAnyManifests) {
                this._emitError(new Error(`Manifests were found in '${manifestsFolderPath}', but were not valid.`));
            }
            else {
                this._emitError(new Error(`No manifests were found in '${manifestsFolderPath}'. Ensure a build has completed successfully`));
            }
            return;
        }
        // Collect all the assets, if necessary
        let assets;
        if (config.solution.includeClientSideAssets) {
            const assetsPaths = await node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob_1.default, '**/*.*', {
                ignore: ignoredAssets,
                cwd: assetsFolderPath
            });
            assets = assetsPaths.map((filename) => {
                this._terminal.writeLine(node_core_library_1.Colors.cyan(`Found client-side build resource: ${filename}`));
                return {
                    originalFilename: `${assetsFolderPath}/${filename}`,
                    packageFilename: filename
                };
            });
        }
        else {
            assets = [];
        }
        // Always copy everything from the teams folder
        const teamsIconPaths = await node_core_library_1.LegacyAdapters.convertCallbackToPromise(glob_1.default, '**/*.*', {
            ignore: ignoredAssets,
            cwd: config.paths.teamsDir
        });
        const teamsIcons = teamsIconPaths.map((filename) => {
            this._terminal.writeLine(node_core_library_1.Colors.cyan(`Found teams icons: ${filename}`));
            return {
                originalFilename: `${config.paths.teamsDir}/${filename}`,
                packageFilename: filename
            };
        });
        // eslint-disable-next-line require-atomic-updates
        config.solution.clientSideAssets = [...assets, ...teamsIcons];
        // Adding screenshots to the list of client side assets
        const { metadata } = config.solution;
        if (metadata && metadata.screenshotPaths) {
            const screenshots = [];
            for (let screenshotPathIdx = 0, screenshotPathsLen = metadata.screenshotPaths.length; screenshotPathIdx < screenshotPathsLen; screenshotPathIdx++) {
                let screenshotPath = metadata.screenshotPaths[screenshotPathIdx];
                if (!UrlUtilities_1.UrlUtilities.isUrl(screenshotPath)) {
                    screenshotPath = path_1.default.join(config.paths.packageDir, metadata.screenshotPaths[screenshotPathIdx]);
                    const screenshotExists = await node_core_library_1.FileSystem.existsAsync(screenshotPath);
                    if (screenshotExists) {
                        const screenshotFilename = path_1.default.basename(screenshotPath);
                        this._terminal.writeLine(node_core_library_1.Colors.cyan(`Found screenshot: ${screenshotFilename}`));
                        screenshots.push({
                            originalFilename: screenshotPath,
                            packageFilename: screenshotFilename
                        });
                        // updating screenshot to store filename - for XML generation
                        metadata.screenshotPaths[screenshotPathIdx] = screenshotFilename;
                    }
                    else {
                        this._emitError(new Error(`Can't find the screenshot at ${screenshotPath}. Ensure the file exists.`));
                    }
                }
            }
            config.solution.clientSideAssets.push(...screenshots);
            if (config.solution.iconPath) {
                const iconPath = path_1.default.join(config.paths.packageDir, config.solution.iconPath);
                const iconExists = await node_core_library_1.FileSystem.existsAsync(iconPath);
                if (iconExists) {
                    const iconName = path_1.default.basename(iconPath);
                    this._terminal.writeLine(node_core_library_1.Colors.cyan(`Found icon: ${iconName}`));
                    const iconClientSideAsset = {
                        originalFilename: iconPath,
                        packageFilename: iconName
                    };
                    config.solution.clientSideAssets.push(iconClientSideAsset);
                }
                else {
                    this._emitError(new Error(`Can't find the icon at ${iconPath}. Ensure the file exists.`));
                }
            }
        }
        const xmlSerializationOptions = {
            indent: prettyPrintXml ? '  ' : undefined,
            declaration: {
                encoding: 'utf-8'
            }
        };
        await (0, createPackage_1.default)(this._terminal, xmlSerializationOptions, config, manifestMap, noSpppkg);
    }
    async getCleanPathsAsync() {
        const config = await this._ensureConfigFileAsync();
        if (config) {
            return [config.paths.debugDir, config.paths.zippedPackage];
        }
        else {
            return [];
        }
    }
    async _ensureConfigFileAsync() {
        if (!this._alreadyTriedToLoadConfig) {
            let config = await SolutionPackager._configFile.tryLoadConfigurationFileForProjectAsync(this._terminal, this._buildFolder);
            this._alreadyTriedToLoadConfig = true;
            if (config) {
                // Include defaults
                config = {
                    ...DEFAULT_CONFIG,
                    ...config
                };
                config.paths = {
                    ...DEFAULT_CONFIG.paths,
                    ...config.paths
                };
                // Resolve paths
                const packageDir = `${this._buildFolder}/${config.paths.packageDir}`;
                config.paths = {
                    packageDir: packageDir,
                    debugDir: `${packageDir}/${config.paths.debugDir}`,
                    zippedPackage: `${packageDir}/${config.paths.zippedPackage}`,
                    featureXmlDir: `${packageDir}/${config.paths.featureXmlDir}`,
                    sharepointAssetDir: `${packageDir}/${config.paths.sharepointAssetDir}`,
                    teamsDir: `${this._buildFolder}/${config.paths.teamsDir}`
                };
                this._updateContentTypes(config);
            }
            this._config = config;
        }
        return this._config;
    }
    _updateContentTypes(config) {
        if (!config.solution || !config.solution.features) {
            return;
        }
        if (!config.contentTypes) {
            config.contentTypes = {};
        }
        for (const feature of config.solution.features) {
            const { assets } = feature;
            if (assets) {
                const { elementFiles } = assets;
                if (elementFiles) {
                    const fileExtensions = this._getFilesExtensions(elementFiles);
                    for (const fileExtension of fileExtensions) {
                        if (!config.contentTypes[fileExtension]) {
                            config.contentTypes[fileExtension] = 'application/octet-stream';
                        }
                    }
                }
            }
        }
    }
    _getFilesExtensions(filePaths) {
        return filePaths.map((filePath) => filePath.slice(filePath.lastIndexOf('.') + 1));
    }
}
exports.SolutionPackager = SolutionPackager;
SolutionPackager._configFile = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: 'config/package-solution.json',
    jsonSchemaPath: `${__dirname}/package-solution.schema.json`
});
//# sourceMappingURL=SolutionPackager.js.map