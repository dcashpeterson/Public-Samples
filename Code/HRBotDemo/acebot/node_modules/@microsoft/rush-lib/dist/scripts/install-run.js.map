{"version":3,"file":"scripts/install-run.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACyB;AACI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAe;AACxC;AACA;AACA,gEAAgE,SAAS;AACzE,iCAAiC,KAAK,KAAK;AAC3C,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAkE,cAAc;AAClG,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB,IAAI;AACpD,0BAA0B,gBAAgB;AAC1C;AACA,IAAI,6CAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B,sCAAS;AACrC,4BAA4B,sCAAS;AACrC;AACA,YAAY,0CAAa;AACzB;AACA;AACA,iBAAiB,0CAAa;AAC9B;AACA,oCAAoC,gBAAgB,IAAI;AACxD,YAAY,0CAAa;AACzB;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACO;AACP,+BAA+B,kBAAkB;AACjD;AACA,SAAS,0CAAa;AACtB;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;;;;;;;;;;AC9HA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAC8C;AACrB;AACA;AACI;AAC2B;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,wCAAW;AAC3B;AACA,oCAAoC,mDAAqB,gBAAgB,WAAW;AACpF,gDAAgD,mCAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAqB,qBAAqB,WAAW;AAChF;AACA;AACA;AACA,6EAA6E,EAAE;AAC/E;AACA;AACA,aAAa,0CAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0CAAa;AACtB,0BAA0B,yCAAY;AACtC;AACA,QAAQ,yCAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sCAAS;AAClC,iBAAiB,0CAAa;AAC9B,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA;AACA,qEAAqE,sCAAS,8BAA8B,KAAK,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C,YAAY,oEAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAsB,sBAAsB,KAAK,GAAG,QAAQ;AACtG;AACA;AACA,aAAa;AACb;AACA,kEAAkE,6BAA6B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS,aAAa,KAAK,IAAI,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC,sCAAS;AAC9C,gBAAgB,0CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC,yCAAY,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAS;AACtC,aAAa,0CAAa;AAC1B;AACA;AACA,6BAA6B,4CAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0CAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAY;AACrC;AACA,gCAAgC,yCAAY;AAC5C;AACA,YAAY,4CAAe;AAC3B;AACA;AACA;AACA;AACA,sCAAsC,yCAAY;AAClD,gBAAgB,0CAAa;AAC7B;AACA,gBAAgB,0CAAa,oBAAoB,sCAAS,oCAAoC,sBAAsB;AACpH;AACA;AACA;AACA;AACA,sEAAsE,qBAAqB,KAAK,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,sCAAS;AACzC,QAAQ,6CAAgB;AACxB;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA,uBAAuB,oDAAsB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA,oCAAoC,QAAQ;AAC5C;AACA,8CAA8C,KAAK,GAAG,QAAQ;AAC9D;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAY;AACtC,4BAA4B,wCAAW,oBAAoB,QAAQ;AACnE,WAAW,yCAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAS;AACtC,QAAQ,6CAAgB;AACxB;AACA;AACA,mEAAmE,qBAAqB;AACxF;AACA;AACO;AACP;AACA,6BAA6B,sCAAS;AACtC;AACA,sFAAsF,YAAY,GAAG,eAAe;AACpH;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C,QAAQ,oEAAS;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,EAAE,yBAAyB;AAClF;AACA;AACA;AACA,0BAA0B,yCAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wCAAW;AACnE,qDAAqD,QAAQ;AAC7D,iEAAiE,2CAAc;AAC/E,iBAAiB,oDAAsB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0CAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK,GAAG,QAAQ;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA,uC","sources":["webpack://@microsoft/rush-lib/./lib-esnext/utilities/npmrcUtilities.js","webpack://@microsoft/rush-lib/external node-commonjs \"child_process\"","webpack://@microsoft/rush-lib/external node-commonjs \"fs\"","webpack://@microsoft/rush-lib/external node-commonjs \"os\"","webpack://@microsoft/rush-lib/external node-commonjs \"path\"","webpack://@microsoft/rush-lib/webpack/bootstrap","webpack://@microsoft/rush-lib/webpack/runtime/compat get default export","webpack://@microsoft/rush-lib/webpack/runtime/define property getters","webpack://@microsoft/rush-lib/webpack/runtime/hasOwnProperty shorthand","webpack://@microsoft/rush-lib/webpack/runtime/make namespace object","webpack://@microsoft/rush-lib/./lib-esnext/scripts/install-run.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// IMPORTANT - do not use any non-built-in libraries in this file\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * This function reads the content for given .npmrc file path, and also trims\n * unusable lines from the .npmrc file.\n *\n * @returns\n * The text of the the .npmrc.\n */\n// create a global _combinedNpmrc for cache purpose\nconst _combinedNpmrcMap = new Map();\nfunction _trimNpmrcFile(sourceNpmrcPath) {\n    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);\n    if (combinedNpmrcFromCache !== undefined) {\n        return combinedNpmrcFromCache;\n    }\n    let npmrcFileLines = fs.readFileSync(sourceNpmrcPath).toString().split('\\n');\n    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());\n    const resultLines = [];\n    // This finds environment variable tokens that look like \"${VAR_NAME}\"\n    const expansionRegExp = /\\$\\{([^\\}]+)\\}/g;\n    // Comment lines start with \"#\" or \";\"\n    const commentRegExp = /^\\s*[#;]/;\n    // Trim out lines that reference environment variables that aren't defined\n    for (let line of npmrcFileLines) {\n        let lineShouldBeTrimmed = false;\n        //remove spaces before or after key and value\n        line = line\n            .split('=')\n            .map((lineToTrim) => lineToTrim.trim())\n            .join('=');\n        // Ignore comment lines\n        if (!commentRegExp.test(line)) {\n            const environmentVariables = line.match(expansionRegExp);\n            if (environmentVariables) {\n                for (const token of environmentVariables) {\n                    // Remove the leading \"${\" and the trailing \"}\" from the token\n                    const environmentVariableName = token.substring(2, token.length - 1);\n                    // Is the environment variable defined?\n                    if (!process.env[environmentVariableName]) {\n                        // No, so trim this line\n                        lineShouldBeTrimmed = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (lineShouldBeTrimmed) {\n            // Example output:\n            // \"; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}\"\n            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);\n        }\n        else {\n            resultLines.push(line);\n        }\n    }\n    const combinedNpmrc = resultLines.join('\\n');\n    //save the cache\n    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n * As a workaround, copyAndTrimNpmrcFile() copies the .npmrc file to the target folder, and also trims\n * unusable lines from the .npmrc file.\n *\n * Why are we trimming the .npmrc lines?  NPM allows environment variables to be specified in\n * the .npmrc file to provide different authentication tokens for different registry.\n * However, if the environment variable is undefined, it expands to an empty string, which\n * produces a valid-looking mapping with an invalid URL that causes an error.  Instead,\n * we'd prefer to skip that line and continue looking in other places such as the user's\n * home directory.\n *\n * @returns\n * The text of the the .npmrc with lines containing undefined variables commented out.\n */\nfunction _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath) {\n    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose\n    logger.info(`  --> \"${targetNpmrcPath}\"`);\n    const combinedNpmrc = _trimNpmrcFile(sourceNpmrcPath);\n    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n * syncNpmrc() copies the .npmrc file to the target folder, and also trims unusable lines from the .npmrc file.\n * If the source .npmrc file not exist, then syncNpmrc() will delete an .npmrc that is found in the target folder.\n *\n * IMPORTANT: THIS CODE SHOULD BE KEPT UP TO DATE WITH Utilities._syncNpmrc()\n *\n * @returns\n * The text of the the synced .npmrc, if one exists. If one does not exist, then undefined is returned.\n */\nexport function syncNpmrc(sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {\n    // eslint-disable-next-line no-console\n    info: console.log,\n    // eslint-disable-next-line no-console\n    error: console.error\n}) {\n    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');\n    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');\n    try {\n        if (fs.existsSync(sourceNpmrcPath)) {\n            return _copyAndTrimNpmrcFile(logger, sourceNpmrcPath, targetNpmrcPath);\n        }\n        else if (fs.existsSync(targetNpmrcPath)) {\n            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target\n            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose\n            fs.unlinkSync(targetNpmrcPath);\n        }\n    }\n    catch (e) {\n        throw new Error(`Error syncing .npmrc file: ${e}`);\n    }\n}\nexport function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey) {\n    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;\n    //if .npmrc file does not exist, return false directly\n    if (!fs.existsSync(sourceNpmrcPath)) {\n        return false;\n    }\n    const trimmedNpmrcFile = _trimNpmrcFile(sourceNpmrcPath);\n    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');\n    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;\n}\n//# sourceMappingURL=npmrcUtilities.js.map","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/* eslint-disable no-console */\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { syncNpmrc } from '../utilities/npmrcUtilities';\nexport const RUSH_JSON_FILENAME = 'rush.json';\nconst RUSH_TEMP_FOLDER_ENV_VARIABLE_NAME = 'RUSH_TEMP_FOLDER';\nconst INSTALL_RUN_LOCKFILE_PATH_VARIABLE = 'INSTALL_RUN_LOCKFILE_PATH';\nconst INSTALLED_FLAG_FILENAME = 'installed.flag';\nconst NODE_MODULES_FOLDER_NAME = 'node_modules';\nconst PACKAGE_JSON_FILENAME = 'package.json';\n/**\n * Parse a package specifier (in the form of name\\@version) into name and version parts.\n */\nfunction _parsePackageSpecifier(rawPackageSpecifier) {\n    rawPackageSpecifier = (rawPackageSpecifier || '').trim();\n    const separatorIndex = rawPackageSpecifier.lastIndexOf('@');\n    let name;\n    let version = undefined;\n    if (separatorIndex === 0) {\n        // The specifier starts with a scope and doesn't have a version specified\n        name = rawPackageSpecifier;\n    }\n    else if (separatorIndex === -1) {\n        // The specifier doesn't have a version\n        name = rawPackageSpecifier;\n    }\n    else {\n        name = rawPackageSpecifier.substring(0, separatorIndex);\n        version = rawPackageSpecifier.substring(separatorIndex + 1);\n    }\n    if (!name) {\n        throw new Error(`Invalid package specifier: ${rawPackageSpecifier}`);\n    }\n    return { name, version };\n}\nlet _npmPath = undefined;\n/**\n * Get the absolute path to the npm executable\n */\nexport function getNpmPath() {\n    if (!_npmPath) {\n        try {\n            if (os.platform() === 'win32') {\n                // We're on Windows\n                const whereOutput = childProcess.execSync('where npm', { stdio: [] }).toString();\n                const lines = whereOutput.split(os.EOL).filter((line) => !!line);\n                // take the last result, we are looking for a .cmd command\n                // see https://github.com/microsoft/rushstack/issues/759\n                _npmPath = lines[lines.length - 1];\n            }\n            else {\n                // We aren't on Windows - assume we're on *NIX or Darwin\n                _npmPath = childProcess.execSync('command -v npm', { stdio: [] }).toString();\n            }\n        }\n        catch (e) {\n            throw new Error(`Unable to determine the path to the NPM tool: ${e}`);\n        }\n        _npmPath = _npmPath.trim();\n        if (!fs.existsSync(_npmPath)) {\n            throw new Error('The NPM executable does not exist');\n        }\n    }\n    return _npmPath;\n}\nfunction _ensureFolder(folderPath) {\n    if (!fs.existsSync(folderPath)) {\n        const parentDir = path.dirname(folderPath);\n        _ensureFolder(parentDir);\n        fs.mkdirSync(folderPath);\n    }\n}\n/**\n * Create missing directories under the specified base directory, and return the resolved directory.\n *\n * Does not support \".\" or \"..\" path segments.\n * Assumes the baseFolder exists.\n */\nfunction _ensureAndJoinPath(baseFolder, ...pathSegments) {\n    let joinedPath = baseFolder;\n    try {\n        for (let pathSegment of pathSegments) {\n            pathSegment = pathSegment.replace(/[\\\\\\/]/g, '+');\n            joinedPath = path.join(joinedPath, pathSegment);\n            if (!fs.existsSync(joinedPath)) {\n                fs.mkdirSync(joinedPath);\n            }\n        }\n    }\n    catch (e) {\n        throw new Error(`Error building local installation folder (${path.join(baseFolder, ...pathSegments)}): ${e}`);\n    }\n    return joinedPath;\n}\nfunction _getRushTempFolder(rushCommonFolder) {\n    const rushTempFolder = process.env[RUSH_TEMP_FOLDER_ENV_VARIABLE_NAME];\n    if (rushTempFolder !== undefined) {\n        _ensureFolder(rushTempFolder);\n        return rushTempFolder;\n    }\n    else {\n        return _ensureAndJoinPath(rushCommonFolder, 'temp');\n    }\n}\n/**\n * Compare version strings according to semantic versioning.\n * Returns a positive integer if \"a\" is a later version than \"b\",\n * a negative integer if \"b\" is later than \"a\",\n * and 0 otherwise.\n */\nfunction _compareVersionStrings(a, b) {\n    const aParts = a.split(/[.-]/);\n    const bParts = b.split(/[.-]/);\n    const numberOfParts = Math.max(aParts.length, bParts.length);\n    for (let i = 0; i < numberOfParts; i++) {\n        if (aParts[i] !== bParts[i]) {\n            return (Number(aParts[i]) || 0) - (Number(bParts[i]) || 0);\n        }\n    }\n    return 0;\n}\n/**\n * Resolve a package specifier to a static version\n */\nfunction _resolvePackageVersion(logger, rushCommonFolder, { name, version }) {\n    if (!version) {\n        version = '*'; // If no version is specified, use the latest version\n    }\n    if (version.match(/^[a-zA-Z0-9\\-\\+\\.]+$/)) {\n        // If the version contains only characters that we recognize to be used in static version specifiers,\n        // pass the version through\n        return version;\n    }\n    else {\n        // version resolves to\n        try {\n            const rushTempFolder = _getRushTempFolder(rushCommonFolder);\n            const sourceNpmrcFolder = path.join(rushCommonFolder, 'config', 'rush');\n            syncNpmrc(sourceNpmrcFolder, rushTempFolder, undefined, logger);\n            const npmPath = getNpmPath();\n            // This returns something that looks like:\n            // ```\n            // [\n            //   \"3.0.0\",\n            //   \"3.0.1\",\n            //   ...\n            //   \"3.0.20\"\n            // ]\n            // ```\n            //\n            // if multiple versions match the selector, or\n            //\n            // ```\n            // \"3.0.0\"\n            // ```\n            //\n            // if only a single version matches.\n            const npmVersionSpawnResult = childProcess.spawnSync(npmPath, ['view', `${name}@${version}`, 'version', '--no-update-notifier', '--json'], {\n                cwd: rushTempFolder,\n                stdio: []\n            });\n            if (npmVersionSpawnResult.status !== 0) {\n                throw new Error(`\"npm view\" returned error code ${npmVersionSpawnResult.status}`);\n            }\n            const npmViewVersionOutput = npmVersionSpawnResult.stdout.toString();\n            const parsedVersionOutput = JSON.parse(npmViewVersionOutput);\n            const versions = Array.isArray(parsedVersionOutput)\n                ? parsedVersionOutput\n                : [parsedVersionOutput];\n            let latestVersion = versions[0];\n            for (let i = 1; i < versions.length; i++) {\n                const latestVersionCandidate = versions[i];\n                if (_compareVersionStrings(latestVersionCandidate, latestVersion) > 0) {\n                    latestVersion = latestVersionCandidate;\n                }\n            }\n            if (!latestVersion) {\n                throw new Error('No versions found for the specified version range.');\n            }\n            return latestVersion;\n        }\n        catch (e) {\n            throw new Error(`Unable to resolve version ${version} of package ${name}: ${e}`);\n        }\n    }\n}\nlet _rushJsonFolder;\n/**\n * Find the absolute path to the folder containing rush.json\n */\nexport function findRushJsonFolder() {\n    if (!_rushJsonFolder) {\n        let basePath = __dirname;\n        let tempPath = __dirname;\n        do {\n            const testRushJsonPath = path.join(basePath, RUSH_JSON_FILENAME);\n            if (fs.existsSync(testRushJsonPath)) {\n                _rushJsonFolder = basePath;\n                break;\n            }\n            else {\n                basePath = tempPath;\n            }\n        } while (basePath !== (tempPath = path.dirname(basePath))); // Exit the loop when we hit the disk root\n        if (!_rushJsonFolder) {\n            throw new Error('Unable to find rush.json.');\n        }\n    }\n    return _rushJsonFolder;\n}\n/**\n * Detects if the package in the specified directory is installed\n */\nfunction _isPackageAlreadyInstalled(packageInstallFolder) {\n    try {\n        const flagFilePath = path.join(packageInstallFolder, INSTALLED_FLAG_FILENAME);\n        if (!fs.existsSync(flagFilePath)) {\n            return false;\n        }\n        const fileContents = fs.readFileSync(flagFilePath).toString();\n        return fileContents.trim() === process.version;\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Delete a file. Fail silently if it does not exist.\n */\nfunction _deleteFile(file) {\n    try {\n        fs.unlinkSync(file);\n    }\n    catch (err) {\n        if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {\n            throw err;\n        }\n    }\n}\n/**\n * Removes the following files and directories under the specified folder path:\n *  - installed.flag\n *  -\n *  - node_modules\n */\nfunction _cleanInstallFolder(rushTempFolder, packageInstallFolder, lockFilePath) {\n    try {\n        const flagFile = path.resolve(packageInstallFolder, INSTALLED_FLAG_FILENAME);\n        _deleteFile(flagFile);\n        const packageLockFile = path.resolve(packageInstallFolder, 'package-lock.json');\n        if (lockFilePath) {\n            fs.copyFileSync(lockFilePath, packageLockFile);\n        }\n        else {\n            // Not running `npm ci`, so need to cleanup\n            _deleteFile(packageLockFile);\n            const nodeModulesFolder = path.resolve(packageInstallFolder, NODE_MODULES_FOLDER_NAME);\n            if (fs.existsSync(nodeModulesFolder)) {\n                const rushRecyclerFolder = _ensureAndJoinPath(rushTempFolder, 'rush-recycler');\n                fs.renameSync(nodeModulesFolder, path.join(rushRecyclerFolder, `install-run-${Date.now().toString()}`));\n            }\n        }\n    }\n    catch (e) {\n        throw new Error(`Error cleaning the package install folder (${packageInstallFolder}): ${e}`);\n    }\n}\nfunction _createPackageJson(packageInstallFolder, name, version) {\n    try {\n        const packageJsonContents = {\n            name: 'ci-rush',\n            version: '0.0.0',\n            dependencies: {\n                [name]: version\n            },\n            description: \"DON'T WARN\",\n            repository: \"DON'T WARN\",\n            license: 'MIT'\n        };\n        const packageJsonPath = path.join(packageInstallFolder, PACKAGE_JSON_FILENAME);\n        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJsonContents, undefined, 2));\n    }\n    catch (e) {\n        throw new Error(`Unable to create package.json: ${e}`);\n    }\n}\n/**\n * Run \"npm install\" in the package install folder.\n */\nfunction _installPackage(logger, packageInstallFolder, name, version, command) {\n    try {\n        logger.info(`Installing ${name}...`);\n        const npmPath = getNpmPath();\n        const result = childProcess.spawnSync(npmPath, [command], {\n            stdio: 'inherit',\n            cwd: packageInstallFolder,\n            env: process.env\n        });\n        if (result.status !== 0) {\n            throw new Error(`\"npm ${command}\" encountered an error`);\n        }\n        logger.info(`Successfully installed ${name}@${version}`);\n    }\n    catch (e) {\n        throw new Error(`Unable to install package: ${e}`);\n    }\n}\n/**\n * Get the \".bin\" path for the package.\n */\nfunction _getBinPath(packageInstallFolder, binName) {\n    const binFolderPath = path.resolve(packageInstallFolder, NODE_MODULES_FOLDER_NAME, '.bin');\n    const resolvedBinName = os.platform() === 'win32' ? `${binName}.cmd` : binName;\n    return path.resolve(binFolderPath, resolvedBinName);\n}\n/**\n * Write a flag file to the package's install directory, signifying that the install was successful.\n */\nfunction _writeFlagFile(packageInstallFolder) {\n    try {\n        const flagFilePath = path.join(packageInstallFolder, INSTALLED_FLAG_FILENAME);\n        fs.writeFileSync(flagFilePath, process.version);\n    }\n    catch (e) {\n        throw new Error(`Unable to create installed.flag file in ${packageInstallFolder}`);\n    }\n}\nexport function installAndRun(logger, packageName, packageVersion, packageBinName, packageBinArgs, lockFilePath = process.env[INSTALL_RUN_LOCKFILE_PATH_VARIABLE]) {\n    const rushJsonFolder = findRushJsonFolder();\n    const rushCommonFolder = path.join(rushJsonFolder, 'common');\n    const rushTempFolder = _getRushTempFolder(rushCommonFolder);\n    const packageInstallFolder = _ensureAndJoinPath(rushTempFolder, 'install-run', `${packageName}@${packageVersion}`);\n    if (!_isPackageAlreadyInstalled(packageInstallFolder)) {\n        // The package isn't already installed\n        _cleanInstallFolder(rushTempFolder, packageInstallFolder, lockFilePath);\n        const sourceNpmrcFolder = path.join(rushCommonFolder, 'config', 'rush');\n        syncNpmrc(sourceNpmrcFolder, packageInstallFolder, undefined, logger);\n        _createPackageJson(packageInstallFolder, packageName, packageVersion);\n        const command = lockFilePath ? 'ci' : 'install';\n        _installPackage(logger, packageInstallFolder, packageName, packageVersion, command);\n        _writeFlagFile(packageInstallFolder);\n    }\n    const statusMessage = `Invoking \"${packageBinName} ${packageBinArgs.join(' ')}\"`;\n    const statusMessageLine = new Array(statusMessage.length + 1).join('-');\n    logger.info('\\n' + statusMessage + '\\n' + statusMessageLine + '\\n');\n    const binPath = _getBinPath(packageInstallFolder, packageBinName);\n    const binFolderPath = path.resolve(packageInstallFolder, NODE_MODULES_FOLDER_NAME, '.bin');\n    // Windows environment variables are case-insensitive.  Instead of using SpawnSyncOptions.env, we need to\n    // assign via the process.env proxy to ensure that we append to the right PATH key.\n    const originalEnvPath = process.env.PATH || '';\n    let result;\n    try {\n        // Node.js on Windows can not spawn a file when the path has a space on it\n        // unless the path gets wrapped in a cmd friendly way and shell mode is used\n        const shouldUseShell = binPath.includes(' ') && os.platform() === 'win32';\n        const platformBinPath = shouldUseShell ? `\"${binPath}\"` : binPath;\n        process.env.PATH = [binFolderPath, originalEnvPath].join(path.delimiter);\n        result = childProcess.spawnSync(platformBinPath, packageBinArgs, {\n            stdio: 'inherit',\n            windowsVerbatimArguments: false,\n            shell: shouldUseShell,\n            cwd: process.cwd(),\n            env: process.env\n        });\n    }\n    finally {\n        process.env.PATH = originalEnvPath;\n    }\n    if (result.status !== null) {\n        return result.status;\n    }\n    else {\n        throw result.error || new Error('An unknown error occurred.');\n    }\n}\nexport function runWithErrorAndStatusCode(logger, fn) {\n    process.exitCode = 1;\n    try {\n        const exitCode = fn();\n        process.exitCode = exitCode;\n    }\n    catch (e) {\n        logger.error('\\n\\n' + e.toString() + '\\n\\n');\n    }\n}\nfunction _run() {\n    const [nodePath /* Ex: /bin/node */, scriptPath /* /repo/common/scripts/install-run-rush.js */, rawPackageSpecifier /* qrcode@^1.2.0 */, packageBinName /* qrcode */, ...packageBinArgs /* [-f, myproject/lib] */] = process.argv;\n    if (!nodePath) {\n        throw new Error('Unexpected exception: could not detect node path');\n    }\n    if (path.basename(scriptPath).toLowerCase() !== 'install-run.js') {\n        // If install-run.js wasn't directly invoked, don't execute the rest of this function. Return control\n        // to the script that (presumably) imported this file\n        return;\n    }\n    if (process.argv.length < 4) {\n        console.log('Usage: install-run.js <package>@<version> <command> [args...]');\n        console.log('Example: install-run.js qrcode@1.2.2 qrcode https://rushjs.io');\n        process.exit(1);\n    }\n    const logger = { info: console.log, error: console.error };\n    runWithErrorAndStatusCode(logger, () => {\n        const rushJsonFolder = findRushJsonFolder();\n        const rushCommonFolder = _ensureAndJoinPath(rushJsonFolder, 'common');\n        const packageSpecifier = _parsePackageSpecifier(rawPackageSpecifier);\n        const name = packageSpecifier.name;\n        const version = _resolvePackageVersion(logger, rushCommonFolder, packageSpecifier);\n        if (packageSpecifier.version !== version) {\n            console.log(`Resolved to ${name}@${version}`);\n        }\n        return installAndRun(logger, name, version, packageBinName, packageBinArgs);\n    });\n}\n_run();\n//# sourceMappingURL=install-run.js.map"],"names":[],"sourceRoot":""}