"use strict";
/**
 * Using a manifest map, creates component definitions and updates a package definition's element guids with
 * actual objects
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const uuid = __importStar(require("uuid"));
const node_core_library_1 = require("@rushstack/node-core-library");
// NOTE: this value is required for the client side asset packaging feature. The base URL value must match exactly
// with the server-side value in the file SPClientSideThirdPartyComponentProvider.cs. This informs the server-side
// third-party component provider that it needs to replace this URL with the public CDN URL.
const clientSideAssetLibraryPseudoUrl = 'HTTPS://SPCLIENTSIDEASSETLIBRARY/';
function createComponent(terminal, manifest) {
    if (!manifest.id || !manifest || !manifest.componentType) {
        return undefined;
    }
    if (manifest.componentType === 'Application') {
        return createApplicationComponent(manifest);
    }
    else if (manifest.componentType === 'WebPart') {
        return createWebPartComponent(manifest);
    }
    else if (manifest.componentType === 'Extension') {
        return createExtensionComponent(manifest);
    }
    else if (manifest.componentType === 'Library') {
        return createLibraryComponent(manifest);
    }
    else if (manifest.componentType === 'AdaptiveCardExtension') {
        return createLibraryComponent(manifest);
    }
    else {
        terminal.writeLine(`Component type '${manifest.componentType}' not recognized. Skipping manifest.`);
        return undefined;
    }
}
function getRequiresCustomScriptProperty(manifest) {
    // a manifest either has requiresCustomScript or the deprecated safeWithCustomScriptDisabled
    // however, we are now ignoring the value of safeWithCustomScriptDisabled since it was formerly
    // set to false in the generator's templates
    // if they have the value set to 'false', we will print a warning
    const requiresCustomScript = !!manifest.requiresCustomScript;
    delete manifest.requiresCustomScript;
    delete manifest.safeWithCustomScriptDisabled;
    return requiresCustomScript; // this will default this value to false
}
function createExtensionComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        name: manifest.alias,
        description: `${manifest.extensionType} - ${manifest.alias}`,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createLibraryComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        name: manifest.alias,
        description: `Library - ${manifest.alias}`,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createApplicationComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        name: manifest.title.default,
        description: manifest.description.default,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createWebPartComponent(manifest) {
    let i = 0;
    const entries = manifest.preconfiguredEntries.map((entry) => {
        return {
            id: manifest.id + '_' + i++,
            name: entry.title.default,
            description: entry.description.default,
            webPartData: buildWebPartData(manifest, entry)
        };
    });
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    // Use the first entry name and description for the component
    return {
        name: manifest.preconfiguredEntries[0].title.default,
        description: manifest.preconfiguredEntries[0].description.default,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {
            entries: entries
        }
    };
}
function buildWebPartData(manifest, entry) {
    return JSON.stringify({
        id: manifest.id,
        instanceId: undefined,
        title: entry.title.default,
        description: entry.description.default,
        version: manifest.version,
        properties: entry.properties
    });
}
function createComponentMapFromManifests(terminal, manifests) {
    terminal.writeLine(`Attempting creating component definitions for {${manifests.size}} manifests`);
    const components = new Map();
    manifests.forEach((manifest, key) => {
        const component = createComponent(terminal, manifest);
        if (component) {
            components.set(key, component);
        }
    });
    terminal.writeLine(`Created component definitions for {${components.size}} manifests`);
    return components;
}
function createFeatureFromComponent(component) {
    return {
        title: `${component.name} Feature`,
        description: `A feature which activates the Client-Side ${component.manifest.componentType} named ` +
            `${component.name}`,
        id: component.id || uuid.v4(),
        // or generate a new uuid if it doesn't (e.g. for client-side assets feature)
        components: [component],
        assets: {
            elementFiles: [],
            elementManifests: [],
            upgradeActions: []
        }
    };
}
/**
 * Normalizes the passed in solution definition by cross referencing componentIds with the collected list
 * of manifests in the repo. If, for any feature, the componentId list is missing or empty, we add all the
 * components to that feature. Similarly, if the list of features in the solution is empty or missing, a
 * feature is automatically created for all solutions.
 */
function normalizeSolutionDefinition(terminal, options, manifests) {
    if (options.solution.includeClientSideAssets) {
        manifests.forEach((manifest) => {
            manifest.loaderConfig.internalModuleBaseUrls = [clientSideAssetLibraryPseudoUrl];
        });
    }
    const componentMap = createComponentMapFromManifests(terminal, manifests);
    const numManifests = componentMap.size;
    if (numManifests === 0) {
        throw new Error('Could not find any valid manifests. Please double check paths.manifestsMatch in the task config.');
    }
    // Then, replace the guids in the solution definition with the component definition
    if (options.solution && options.solution.features) {
        const { features } = options.solution;
        // sort the array to have features without componentIds last
        if (features.length > 1) {
            features.sort((a, b) => {
                if (a.componentIds && !b.componentIds) {
                    return -1;
                }
                else if (!a.componentIds && b.componentIds) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
        }
        // set of componentIds that have already been added to features
        const assignedComponentIds = new Set();
        for (const feature of options.solution.features) {
            if (feature.componentIds && feature.componentIds.length > 0) {
                feature.components = feature.componentIds.map((componentId) => {
                    const manifest = componentMap.get(componentId);
                    if (!manifest) {
                        throw new Error(`Component {${componentId}} does not exist in feature '${feature.title}'. ` +
                            'Please update your configuration.');
                    }
                    assignedComponentIds.add(componentId);
                    return manifest;
                });
            }
            else {
                terminal.writeLine('feature.componentIds not set! ' +
                    `Adding ${numManifests - assignedComponentIds.size} components to feature { ${feature.title} }.`);
                feature.components = [];
                componentMap.forEach((component) => {
                    if (!assignedComponentIds.has(component.id)) {
                        feature.components.push(component);
                    }
                });
            }
            if (!feature.assets) {
                feature.assets = {
                    elementFiles: [],
                    elementManifests: [],
                    upgradeActions: []
                };
            }
            feature.assets.elementFiles = resolveFeatureFiles(feature.assets.elementFiles, options.paths.sharepointAssetDir);
            feature.assets.elementManifests = resolveFeatureFiles(feature.assets.elementManifests, options.paths.sharepointAssetDir);
            feature.assets.upgradeActions = resolveFeatureFiles(feature.assets.upgradeActions, options.paths.sharepointAssetDir);
        }
    }
    else {
        terminal.writeLine('config.solution.features not set! Instead generating a feature for each component.');
        options.solution.features = [];
        componentMap.forEach((component) => {
            terminal.writeLine(`Creating feature for ${component.name}...`);
            options.solution.features.push(createFeatureFromComponent(component));
        });
    }
}
exports.default = normalizeSolutionDefinition;
function resolveFeatureFiles(files, basePath) {
    if (files) {
        return files.map((filename) => resolveFeatureFile(filename, basePath));
    }
    else {
        return [];
    }
}
function resolveFeatureFile(filename, basePath) {
    let modulePath = filename;
    if (!node_core_library_1.FileSystem.exists(basePath)) {
        //
        // Import.resolveModule fails if the baseFolderPath doesn't exist.
        // But it will not if the modulePath is an absolute path
        //
        modulePath = path.join(basePath, filename);
    }
    try {
        return node_core_library_1.Import.resolveModule({ modulePath: modulePath, baseFolderPath: basePath });
    }
    catch (e) {
        // the previous call will fail if the filename is actual file name or relative path starting with folder name (e.g. 'schema.xml' or 'subfolder/schema.xml')
        if (!path.isAbsolute(modulePath) && !modulePath.startsWith('.')) {
            return node_core_library_1.Import.resolveModule({ modulePath: `./${modulePath}`, baseFolderPath: basePath });
        }
        throw e;
    }
}
//# sourceMappingURL=normalizeSolutionDefinition.js.map