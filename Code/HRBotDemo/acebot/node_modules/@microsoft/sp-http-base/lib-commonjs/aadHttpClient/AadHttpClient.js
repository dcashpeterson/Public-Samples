"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var FetchProvider_1 = require("../httpClient/FetchProvider");
var AadHttpClientResponse_1 = tslib_1.__importDefault(require("./AadHttpClientResponse"));
var AadTokenProviders_1 = tslib_1.__importDefault(require("../oauthTokenProvider/AadTokenProviders"));
var HttpClientHelper_1 = tslib_1.__importDefault(require("../httpClient/HttpClientHelper"));
var AadHttpClientConfiguration_1 = require("./AadHttpClientConfiguration");
var ICacheDataProvider_1 = require("../caching/ICacheDataProvider");
var CacheDataProviderService_1 = require("../caching/CacheDataProviderService");
var CacheManager_1 = require("../caching/CacheManager");
var AadFlights_1 = require("../oauthTokenProvider/AadFlights");
/**
 * AadHttpClient is used to perform REST calls against an Azure AD Application.
 *
 * @remarks
 * For communicating with SharePoint, use the {@link SPHttpClient} class instead.
 * For communicating with Microsoft Graph, use the {@link @microsoft/sp-http-msgraph#MSGraphClient} class.
 *
 * @public
 * @sealed
 */
var AadHttpClient = /** @class */ (function () {
    /**
     *
     * @param serviceScope - The service scope is needed to retrieve some of the class's internal components.
     * @param resourceEndpoint - The resource for which the token should be obtained.
     * @param options - Configuration options for the request to get an access token.
     *
     */
    function AadHttpClient(serviceScope, resourceEndpoint, options) {
        var _this = this;
        //Constants
        this._ERROR_REGEX = /error="([^"]*)"/;
        sp_core_library_1.Validate.isNotNullOrUndefined(serviceScope, 'serviceScope');
        sp_core_library_1.Validate.isNotNullOrUndefined(resourceEndpoint, 'resourceUrl');
        this._resourceUrl = resourceEndpoint;
        this._serviceScope = serviceScope;
        this._aadTokenProvider = (options && options.tokenProvider) || AadTokenProviders_1.default.configurable;
        this._aadTokenConfiguration = options && options.configuration;
        this._useCachedToken = options && options.useCachedToken !== undefined ? options.useCachedToken : true;
        serviceScope.whenFinished(function () {
            _this._fetchProvider = serviceScope.consume(FetchProvider_1.fetchProviderServiceKey);
        });
    }
    AadHttpClient.prototype.fetch = function (url, configuration, options, cacheConfiguration) {
        var _this = this;
        // Default fetch behavior - No caching
        // If no caching options are provided, or If Cache Provider is not present continue to API call
        if (!cacheConfiguration || !this._cacheDataProvider) {
            return this._fetch(url, configuration, options, this._useCachedToken).then(function (originalResponse) {
                if (originalResponse.status === 403) {
                    return _this._fetch(url, configuration, options, false);
                }
                else {
                    return originalResponse;
                }
            });
        }
        var cacheKey = this._cacheDataProvider.getCacheKey(ICacheDataProvider_1.CacheKeyType.HttpGenerated, url, configuration, options);
        // Fetch data and cache according to the cacheConfiguration
        return CacheManager_1.CacheManager.fetchAndCache(cacheKey, this._cacheDataProvider, cacheConfiguration, function () {
            return _this._fetch(url, configuration, options, _this._useCachedToken);
        });
    };
    AadHttpClient.prototype.get = function (url, configuration, options, cacheConfiguration) {
        var forcedGetOptions = HttpClientHelper_1.default.overrideHttpMethod(options, 'GET');
        if (cacheConfiguration) {
            return this.fetch(url, configuration, forcedGetOptions, cacheConfiguration);
        }
        else {
            return this.fetch(url, configuration, forcedGetOptions);
        }
    };
    /**
     * Calls fetch(), but sets the method to "POST".
     *
     * @param url - The endpoint URL that fetch will be called on.
     * @param configuration - Determines the default behavior of HttpClient; normally this should
     *   be the latest version number from HttpClientConfigurations.
     * @param options - Additional options that affect the request.
     * @returns A promise that will return the result.
     */
    AadHttpClient.prototype.post = function (url, configuration, options) {
        return this.fetch(url, configuration, HttpClientHelper_1.default.overrideHttpMethod(options, 'POST'));
    };
    Object.defineProperty(AadHttpClient.prototype, "_cacheDataProvider", {
        /**
         * Gets the cache data provider
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        get: function () {
            if (!this._cacheProvider) {
                this._cacheProvider = this._serviceScope.consume((0, CacheDataProviderService_1.getCacheDataProviderServiceKey)())._provider;
            }
            return this._cacheProvider;
        },
        enumerable: false,
        configurable: true
    });
    /*
     * We provide one retry in case the request at the resource fails due to either 'nonce_expired' or 'shr_expired'.
     *
     * For 'nonce_expired', we send a retry request to the resource server with the newly acquired token.
     * When fetching the token, we set the 'UseCachedToken' parameter to 'false'.
     * This means that the token will not reuse the existing nonce from the cache but instead request a new nonce from the server.
     *
     * Since PoP is a very short-lived token, we offer one retry from our side in case the request fails due to a 'shr_expired' error.
     * This retry will provide a new SHR, with the same nonce('UseCachedToken' is set to 'true')
     */
    AadHttpClient.prototype._fetch = function (url, configuration, options, useCachedToken) {
        var _this = this;
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)()) {
            var startTimer_1 = performance.now();
            var tokenFetchPromise_1 = this._getTokenFetchPromise(options, useCachedToken);
            return tokenFetchPromise_1.then(function (token) {
                var endTimer = performance.now();
                return _this._getFetchCorePromise(url, configuration, options, token).then(function (response) {
                    var wwwAuthenticateHeader = response.headers.get('WWW-Authenticate');
                    if (response.status === 401 && wwwAuthenticateHeader) {
                        var error = wwwAuthenticateHeader.match(_this._ERROR_REGEX);
                        var retryTokenStartTime_1;
                        if ((error === null || error === void 0 ? void 0 : error.length) === 2 && (error[1] === 'nonce_expired' || error[1] === 'shr_expired')) {
                            retryTokenStartTime_1 = performance.now();
                            tokenFetchPromise_1 = _this._getTokenFetchPromise(options, error[1] === 'shr_expired');
                        }
                        return tokenFetchPromise_1.then(function (retryToken) {
                            var retryTokenEndTimer = performance.now();
                            return _this._getFetchCorePromise(url, configuration, options, retryToken).then(function (retryResponse) {
                                return new AadHttpClientResponse_1.default(retryResponse, retryTokenEndTimer - retryTokenStartTime_1);
                            });
                        });
                    }
                    else {
                        return new AadHttpClientResponse_1.default(response, endTimer - startTimer_1);
                    }
                });
            });
        }
        else {
            var startTimer_2 = performance.now();
            // We can only use a custom configuration for the original AADTokenProvider right now.
            // We don't want to support this customization long term.
            var tokenFetchPromise = void 0;
            if (this._aadTokenConfiguration && this._aadTokenProvider._getTokenInternal) {
                tokenFetchPromise = this._aadTokenProvider._getTokenInternal(this._resourceUrl, this._aadTokenConfiguration, useCachedToken);
            }
            else {
                tokenFetchPromise = this._aadTokenProvider.getToken(this._resourceUrl, useCachedToken);
            }
            return tokenFetchPromise.then(function (token) {
                var endTimer = performance.now();
                // Constructing a Headers object with undefined throws an exception in IE/Edge
                options.headers = options.headers ? new Headers(options.headers) : new Headers();
                options.headers.set('Authorization', 'Bearer ' + token);
                return HttpClientHelper_1.default.fetchCore(configuration, new Request(url, options), _this._serviceScope, _this._fetchProvider, AadHttpClient._className).then(function (response) {
                    return new AadHttpClientResponse_1.default(response, endTimer - startTimer_2);
                });
            });
        }
    };
    AadHttpClient.prototype._getTokenFetchPromise = function (options, useCachedToken) {
        // We can only use a custom configuration for the original AADTokenProvider right now.
        // We don't want to support this customization long term.
        var tokenFetchPromise;
        var tokenOption = {
            useCachedToken: useCachedToken,
            authenticationScheme: options._authenticationScheme,
            resourceRequestMethod: options._resourceRequestMethod,
            shrClaims: options._shrClaims
        };
        if (this._aadTokenConfiguration && this._aadTokenProvider._getTokenInternal) {
            tokenFetchPromise = this._aadTokenProvider._getTokenInternal(this._resourceUrl, this._aadTokenConfiguration, tokenOption);
        }
        else {
            tokenFetchPromise = this._aadTokenProvider.getToken(this._resourceUrl, tokenOption);
        }
        return tokenFetchPromise;
    };
    AadHttpClient.prototype._getFetchCorePromise = function (url, configuration, options, token) {
        // Constructing a Headers object with undefined throws an exception in IE/Edge
        options.headers = options.headers ? new Headers(options.headers) : new Headers();
        if (options._authenticationScheme) {
            options.headers.set('Authorization', options._authenticationScheme + ' ' + token);
        }
        else {
            options.headers.set('Authorization', 'Bearer ' + token);
        }
        return HttpClientHelper_1.default.fetchCore(configuration, new Request(url, options), this._serviceScope, this._fetchProvider, AadHttpClient._className);
    };
    /**
     * The standard predefined AadHttpClientConfiguration objects for use with
     * the AadHttpClient class.
     */
    AadHttpClient.configurations = AadHttpClientConfiguration_1.predefinedConfigurations;
    AadHttpClient._className = 'AadHttpClient';
    return AadHttpClient;
}());
exports.default = AadHttpClient;
//# sourceMappingURL=AadHttpClient.js.map