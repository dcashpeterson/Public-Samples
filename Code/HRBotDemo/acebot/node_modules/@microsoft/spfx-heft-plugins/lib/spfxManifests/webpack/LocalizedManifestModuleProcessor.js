"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalizedManifestModuleProcessor = void 0;
const normalizeLocaleName_1 = require("../../utilities/normalizeLocaleName");
const ManifestPlugin_1 = require("./ManifestPlugin");
const DEFAULT_LOCALES = [/default/i, /en-us/i, /en/i];
function _getManifestPathOrIntegrityPath(localizedPath, bundleName, assets) {
    if (typeof localizedPath !== 'string') {
        throw new Error(`The "${bundleName}" bundle is generating integrity paths, but appears to already have an integrity path. ` +
            'This is not supported.');
    }
    const asset = assets[localizedPath];
    if (!asset) {
        throw new Error(`Unable to find the "${localizedPath}" asset for the "${bundleName}" bundle.`);
    }
    const integrity = (0, ManifestPlugin_1.computeIntegrity)(asset.source());
    return {
        path: localizedPath,
        integrity
    };
}
/**
 * @internal
 */
class LocalizedManifestModuleProcessor {
    static generateLocalizedManifestModule({ bundleName, localizedPaths, firstPassLocaleRemapping, production, selectedLocales, assets, generateIntegrity }) {
        const localeNames = Object.keys(localizedPaths);
        if (localeNames.length === 1) {
            let defaultPath = localizedPaths[localeNames[0]];
            if (generateIntegrity) {
                defaultPath = _getManifestPathOrIntegrityPath(defaultPath, bundleName, assets);
            }
            return {
                type: 'localizedPath',
                defaultPath
            };
        }
        else {
            let defaultPath = LocalizedManifestModuleProcessor.findDefaultString(localizedPaths);
            if (!defaultPath) {
                throw new Error(`Unable to find a default localized entry for the "${bundleName}" bundle. Tried to match ` +
                    `${JSON.stringify(DEFAULT_LOCALES)}.`);
            }
            else if (generateIntegrity) {
                defaultPath = _getManifestPathOrIntegrityPath(defaultPath, bundleName, assets);
            }
            const manifestLocalizedPaths = {};
            for (const [localeName, localizedPath] of Object.entries(localizedPaths)) {
                const normalizedLocaleName = (0, normalizeLocaleName_1.normalizeLocaleName)(localeName);
                const path = generateIntegrity
                    ? _getManifestPathOrIntegrityPath(localizedPath, bundleName, assets)
                    : localizedPath;
                manifestLocalizedPaths[normalizedLocaleName] = path;
            }
            if (firstPassLocaleRemapping) {
                LocalizedManifestModuleProcessor.applyLocaleRemapping(manifestLocalizedPaths, firstPassLocaleRemapping);
            }
            if (production || (selectedLocales === null || selectedLocales === void 0 ? void 0 : selectedLocales.size)) {
                LocalizedManifestModuleProcessor.applyLocaleRemapping(manifestLocalizedPaths, LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                // Do this twice because some locales (like en-gb) appear both as values and as keys
                LocalizedManifestModuleProcessor.applyLocaleRemapping(manifestLocalizedPaths, LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                // Only filter if not a production build, since selectedLocales is always set
                if ((selectedLocales === null || selectedLocales === void 0 ? void 0 : selectedLocales.size) && !production) {
                    const localeFilter = new Set([
                        // Default dev locales
                        'default',
                        'en-us',
                        'qps-ploc',
                        'qps-ploca'
                    ]);
                    // Include all requested locales
                    for (const locale of selectedLocales) {
                        localeFilter.add(locale.toLowerCase());
                    }
                    const filteredLocalizedPaths = {};
                    for (const [localeName, localizedPath] of Object.entries(manifestLocalizedPaths)) {
                        if (localeFilter.has(localeName.toLowerCase())) {
                            filteredLocalizedPaths[localeName] = localizedPath;
                        }
                    }
                    return {
                        type: 'localizedPath',
                        paths: filteredLocalizedPaths,
                        defaultPath: defaultPath
                    };
                }
            }
            return {
                type: 'localizedPath',
                paths: manifestLocalizedPaths,
                defaultPath: defaultPath
            };
        }
    }
    static findDefaultString(localizedPaths) {
        const localizedPathsEntries = Object.entries(localizedPaths);
        if (localizedPathsEntries.length === 1) {
            return localizedPathsEntries[0][1];
        }
        else {
            for (const defaultLocale of DEFAULT_LOCALES) {
                for (const [localeName, localizedPath] of localizedPathsEntries) {
                    if (defaultLocale.test(localeName)) {
                        return localizedPath;
                    }
                }
            }
            return undefined;
        }
    }
    static applyLocaleRemapping(manifestLocalizedPaths, localeRemapping) {
        for (const [localeName, localizedPath] of Object.entries(manifestLocalizedPaths)) {
            const lowercaseLocaleName = localeName.toLowerCase();
            const localeRemappingArray = localeRemapping.get(lowercaseLocaleName);
            if (localeRemappingArray) {
                for (const alternativeLocaleName of localeRemappingArray) {
                    if (!manifestLocalizedPaths.hasOwnProperty(alternativeLocaleName)) {
                        manifestLocalizedPaths[alternativeLocaleName] = localizedPath;
                    }
                }
            }
        }
    }
}
exports.LocalizedManifestModuleProcessor = LocalizedManifestModuleProcessor;
LocalizedManifestModuleProcessor.LOCALE_MAPPING = new Map([
    ['ar-sa', ['ar', 'tzm-Latn', 'ku', 'syr']],
    ['cy-gb', ['cy']],
    ['da-dk', ['fo', 'kl']],
    ['de-de', ['de', 'dsb', 'rm', 'hsb']],
    ['el-gr', ['el']],
    ['en-au', ['en-SG', 'en-HK', 'en-MY', 'en-PH', 'en-TT', 'en-AZ', 'en-BH', 'en-BN', 'en-ID', 'mi']],
    [
        'en-gb',
        [
            'sq',
            'am',
            'hy',
            'mk',
            'bs',
            'my',
            'dz',
            'en-CY',
            'en-EG',
            'en-IL',
            'en-IS',
            'en-JO',
            'en-KE',
            'en-KW',
            'en-MK',
            'en-MT',
            'en-PK',
            'en-QA',
            'en-SA',
            'en-LK',
            'en-AE',
            'en-VN',
            'is',
            'km',
            'kh',
            'mt',
            'fa',
            'gd',
            'sr-Cyrl-BA',
            'sr-Latn-BA',
            'sd',
            'si',
            'so',
            'ti-ET',
            'uz'
        ]
    ],
    ['en-in', ['as', 'gu', 'kn', 'kok', 'ml', 'mr', 'ne', 'or', 'pa', 'sa', 'ta', 'te', 'ur']],
    [
        'en-us',
        ['en-GB', 'en-NZ', 'en-IE', 'en-AU', 'bn', 'chr', 'dv', 'div', 'en', 'fil', 'haw', 'iu', 'lo', 'moh']
    ],
    [
        'en-za',
        [
            'af',
            'en-ZW',
            'en-ZM',
            'en-NG',
            'en-OM',
            'ha',
            'ig',
            'xh',
            'zu',
            'nqo',
            'om',
            'nso',
            'st',
            'tn',
            'sn',
            'ts',
            've',
            'yo'
        ]
    ],
    ['es-es', ['gn', 'quz', 'es', 'ca-ES-valencia']],
    ['fi-fi', ['sms', 'se-FI', 'se-Latn-FI']],
    ['fr-fr', ['gsw', 'br', 'tzm-Tfng', 'co', 'fr', 'ff', 'lb', 'mg', 'oc', 'zgh']],
    ['hi-in', ['hi']],
    ['id-id', ['jv']],
    ['it-it', ['it']],
    ['ms-my', ['ms']],
    ['nb-no', ['no', 'nb', 'nn', 'smj-NO', 'smj-Latn-NO', 'se-NO', 'se-Latn-NO', 'sma-Latn', 'sma-NO']],
    ['nl-nl', ['nl', 'fy']],
    ['pt-pt', ['pt']],
    ['ro-ro', ['ro']],
    ['ru-ru', ['ru', 'ba', 'sah', 'tt', 'tk']],
    ['sk-sk', ['sk']],
    ['sl-si', ['sl']],
    ['sr-cyrl-RS', ['sr-Cyrl']],
    ['sr-latn-RS', ['sr']],
    ['sv-se', ['smj', 'se', 'sv', 'sma-SE', 'sma-Latn-SE']],
    ['th-th', ['th']],
    ['tr-tr', ['tr']],
    ['vi-vn', ['vi']],
    ['zh-cn', ['zh', 'mn-Mong', 'bo', 'ug', 'ii']],
    ['zh-tw', ['zh-HK', 'zh-CHT', 'zh-Hant', 'zh-MO']]
]);
LocalizedManifestModuleProcessor.LOCALE_FALLBACK = new Map();
// initialize the static LOCALE_FALLBACK map
for (const [primary, aliases] of LocalizedManifestModuleProcessor.LOCALE_MAPPING) {
    for (const alias of aliases) {
        const key = alias.toLowerCase();
        if (key !== primary) {
            LocalizedManifestModuleProcessor.LOCALE_FALLBACK.set(key, primary);
        }
    }
}
//# sourceMappingURL=LocalizedManifestModuleProcessor.js.map