"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.runParallel = void 0;
const os_1 = require("os");
const path_1 = require("path");
const module_minifier_1 = require("@rushstack/module-minifier");
const worker_pool_1 = require("@rushstack/worker-pool");
const ZERO = BigInt(0);
const THOUSAND = BigInt(1e3);
/**
 * Formats a delta of `process.hrtime.bigint()` values as a string
 * @param timeNs
 */
function formatTime(timeNs) {
    let unit = 'ns';
    let fraction = ZERO;
    if (timeNs > THOUSAND) {
        unit = 'us';
        fraction = timeNs % THOUSAND;
        timeNs /= THOUSAND;
    }
    if (timeNs > THOUSAND) {
        unit = 'ms';
        fraction = timeNs % THOUSAND;
        timeNs /= THOUSAND;
    }
    if (timeNs > THOUSAND) {
        unit = 's';
        fraction = timeNs % THOUSAND;
        timeNs /= THOUSAND;
    }
    return `${timeNs}.${('000' + fraction).slice(-3, -1)} ${unit}`;
}
async function runParallel(options) {
    const resolvedPath = (0, path_1.resolve)(options.configFilePath);
    const rawConfig = require(resolvedPath); // eslint-disable-line @typescript-eslint/no-var-requires
    const configArray = Array.isArray(rawConfig) ? rawConfig : [rawConfig];
    const configCount = configArray.length;
    const totalCpus = (0, os_1.cpus)().length;
    // TODO: Use all cores if not minifying
    const { maxCompilationThreads: maxConfiguredCompilationThreads = Math.max(totalCpus > 8 ? (totalCpus * 3) >> 2 : totalCpus >> 1, 1), sourceMap, usePortableModules } = options;
    const maxCompilationThreads = Math.min(configCount, maxConfiguredCompilationThreads);
    const maxCompressionThreads = Math.max(1, totalCpus - maxCompilationThreads);
    const minifier = new module_minifier_1.WorkerPoolMinifier({
        terserOptions: options.terserOptions,
        maxThreads: maxCompressionThreads
    });
    const minifierConnection = await minifier.connect();
    const webpackPool = new worker_pool_1.WorkerPool({
        id: 'Webpack',
        maxWorkers: maxCompilationThreads,
        onWorkerDestroyed: () => {
            // Allocate the webpack worker to terser
            minifier.maxThreads++;
        },
        workerScriptPath: require.resolve('./workerPool/WebpackWorker'),
        workerData: {
            configFilePath: resolvedPath,
            sourceMap,
            usePortableModules
        }
    });
    let processed = 0;
    const startTime = process.hrtime.bigint();
    for (let i = 0; i < configCount; i++) {
        const webpackWorker = await webpackPool.checkoutWorkerAsync(true);
        const sendMinifierResult = (result) => {
            webpackWorker.postMessage(result);
        };
        const workerOnMessage = (message) => {
            if (message === 'getConfigHash') {
                webpackWorker.postMessage(minifierConnection.configHash);
                return;
            }
            if (typeof message === 'object') {
                return minifier.minify(message, sendMinifierResult);
            }
            ++processed;
            // eslint-disable-next-line no-console
            console.log(`${processed}/${configCount} complete (${formatTime(process.hrtime.bigint() - startTime)})`);
            webpackWorker.off('message', workerOnMessage);
            webpackPool.checkinWorker(webpackWorker);
        };
        webpackWorker.on('message', workerOnMessage);
        webpackWorker.postMessage(i);
    }
    await webpackPool.finishAsync();
    await minifierConnection.disconnect();
}
exports.runParallel = runParallel;
//# sourceMappingURL=ParallelCompiler.js.map