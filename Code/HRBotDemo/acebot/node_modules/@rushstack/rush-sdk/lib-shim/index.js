"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports._rushSdk_loadInternalModule = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const helpers_1 = require("./helpers");
const verboseEnabled = typeof process !== 'undefined' && process.env.RUSH_SDK_DEBUG === '1';
const terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider({
    verboseEnabled
}));
let errorMessage = '';
// SCENARIO 1:  Rush's PluginManager has initialized "rush-sdk" with Rush's own instance of rush-lib.
// The Rush host process will assign "global.___rush___rushLibModule" before loading the plugin.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    helpers_1.sdkContext.rushLibModule =
        global.___rush___rushLibModule ||
            global.___rush___rushLibModuleFromEnvironment ||
            global.___rush___rushLibModuleFromInstallAndRunRush;
}
// SCENARIO 2:  The project importing "rush-sdk" has installed its own instance of "rush-lib"
// as a package.json dependency.  For example, this is used by the Jest tests for Rush plugins.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    const importingPath = (_a = module === null || module === void 0 ? void 0 : module.parent) === null || _a === void 0 ? void 0 : _a.filename;
    if (importingPath) {
        const callerPackageFolder = node_core_library_1.PackageJsonLookup.instance.tryGetPackageFolderFor(importingPath);
        if (callerPackageFolder !== undefined) {
            const callerPackageJson = (0, helpers_1._require)(path.join(callerPackageFolder, 'package.json'));
            // Does the caller properly declare a dependency on rush-lib?
            if ((callerPackageJson.dependencies && callerPackageJson.dependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||
                (callerPackageJson.devDependencies &&
                    callerPackageJson.devDependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||
                (callerPackageJson.peerDependencies &&
                    callerPackageJson.peerDependencies[helpers_1.RUSH_LIB_NAME] !== undefined)) {
                // Try to resolve rush-lib from the caller's folder
                terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from caller package`);
                try {
                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(callerPackageFolder);
                }
                catch (error) {
                    // If we fail to resolve it, ignore the error
                    terminal.writeVerboseLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} from caller package`);
                }
                // If two different libraries invoke `rush-sdk`, and one of them provides "rush-lib"
                // then the first version to be loaded wins.  We do not support side-by-side instances of "rush-lib".
                if (helpers_1.sdkContext.rushLibModule !== undefined) {
                    // to track which scenario is active and how it got initialized.
                    global.___rush___rushLibModule = helpers_1.sdkContext.rushLibModule;
                    terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from caller`);
                }
            }
        }
    }
}
// SCENARIO 3: A tool or script has been invoked as a child process by an instance of "rush-lib" and can use the
// version that invoked it. In this case, use process.env._RUSH_LIB_PATH to find "rush-lib".
if (helpers_1.sdkContext.rushLibModule === undefined) {
    const rushLibPath = process.env[helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME];
    if (rushLibPath) {
        terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME} from caller package`);
        try {
            helpers_1.sdkContext.rushLibModule = (0, helpers_1._require)(rushLibPath);
        }
        catch (error) {
            // Log this as a warning, since it is unexpected to define an incorrect value of the variable.
            terminal.writeWarningLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} via process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);
        }
        if (helpers_1.sdkContext.rushLibModule !== undefined) {
            // to track which scenario is active and how it got initialized.
            global.___rush___rushLibModuleFromEnvironment = helpers_1.sdkContext.rushLibModule;
            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);
        }
    }
}
// SCENARIO 4:  A standalone tool or script depends on "rush-sdk", and is meant to be used inside a monorepo folder.
// In this case, we can use install-run-rush.js to obtain the appropriate rush-lib version for the monorepo.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    try {
        const rushJsonPath = (0, helpers_1.tryFindRushJsonLocation)(process.cwd());
        if (!rushJsonPath) {
            throw new Error('Unable to find rush.json in the current folder or its parent folders.\n' +
                'This tool is meant to be invoked from a working directory inside a Rush repository.');
        }
        const monorepoRoot = path.dirname(rushJsonPath);
        const rushJson = node_core_library_1.JsonFile.load(rushJsonPath);
        const { rushVersion } = rushJson;
        const installRunNodeModuleFolder = path.join(monorepoRoot, `common/temp/install-run/@microsoft+rush@${rushVersion}`);
        try {
            // First, try to load the version of "rush-lib" that was installed by install-run-rush.js
            terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);
            helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
        }
        catch (e1) {
            let installAndRunRushStderrContent = '';
            try {
                const installAndRunRushJSPath = path.join(monorepoRoot, 'common/scripts/install-run-rush.js');
                terminal.writeLine('The Rush engine has not been installed yet. Invoking install-run-rush.js...');
                const installAndRunRushProcess = node_core_library_1.Executable.spawnSync('node', [installAndRunRushJSPath, '--help'], {
                    stdio: 'pipe'
                });
                installAndRunRushStderrContent = installAndRunRushProcess.stderr;
                if (installAndRunRushProcess.status !== 0) {
                    throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to install`);
                }
                // Retry to load "rush-lib" after install-run-rush run
                terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush a second time`);
                helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
            }
            catch (e2) {
                // eslint-disable-next-line no-console
                console.error(`${installAndRunRushStderrContent}`);
                throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to load`);
            }
        }
        if (helpers_1.sdkContext.rushLibModule !== undefined) {
            // to track which scenario is active and how it got initialized.
            global.___rush___rushLibModuleFromInstallAndRunRush = helpers_1.sdkContext.rushLibModule;
            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);
        }
    }
    catch (e) {
        // no-catch
        errorMessage = e.message;
    }
}
if (helpers_1.sdkContext.rushLibModule === undefined) {
    // This error indicates that a project is trying to import "@rushstack/rush-sdk", but the Rush engine
    // instance cannot be found.  If you are writing Jest tests for a Rush plugin, add "@microsoft/rush-lib"
    // to the devDependencies for your project.
    // eslint-disable-next-line no-console
    console.error(`Error: The @rushstack/rush-sdk package was not able to load the Rush engine:
${errorMessage}
`);
    process.exit(1);
}
// Based on TypeScript's __exportStar()
for (const property in helpers_1.sdkContext.rushLibModule) {
    if (property !== 'default' && !exports.hasOwnProperty(property)) {
        const rushLibModuleForClosure = helpers_1.sdkContext.rushLibModule;
        // Based on TypeScript's __createBinding()
        Object.defineProperty(exports, property, {
            enumerable: true,
            get: function () {
                return rushLibModuleForClosure[property];
            }
        });
    }
}
/**
 * Used by the .js stubs for path-based imports of `@microsoft/rush-lib` internal APIs.
 */
function _rushSdk_loadInternalModule(srcImportPath) {
    if (!exports._RushInternals) {
        throw new Error(`Rush version ${exports.Rush.version} does not support internal API imports via rush-sdk`);
    }
    return exports._RushInternals.loadModule(srcImportPath);
}
exports._rushSdk_loadInternalModule = _rushSdk_loadInternalModule;
//# sourceMappingURL=index.js.map